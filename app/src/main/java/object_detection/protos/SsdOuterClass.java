/*
 * Copyright (c) 2020. Kin-Hong Wong. All Rights Reserved.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

// Generated by the protocol buffer compiler.  DO NOT EDIT!
// source: object_detection/protos/ssd.proto

package object_detection.protos;

public final class SsdOuterClass {
  private SsdOuterClass() {}
  public static void registerAllExtensions(
      com.google.protobuf.ExtensionRegistryLite registry) {
  }

  public static void registerAllExtensions(
      com.google.protobuf.ExtensionRegistry registry) {
    registerAllExtensions(
        (com.google.protobuf.ExtensionRegistryLite) registry);
  }
  public interface SsdOrBuilder extends
      // @@protoc_insertion_point(interface_extends:object_detection.protos.Ssd)
      com.google.protobuf.MessageOrBuilder {

    /**
     * <pre>
     * Number of classes to predict.
     * </pre>
     *
     * <code>optional int32 num_classes = 1;</code>
     * @return Whether the numClasses field is set.
     */
    boolean hasNumClasses();
    /**
     * <pre>
     * Number of classes to predict.
     * </pre>
     *
     * <code>optional int32 num_classes = 1;</code>
     * @return The numClasses.
     */
    int getNumClasses();

    /**
     * <pre>
     * Image resizer for preprocessing the input image.
     * </pre>
     *
     * <code>optional .object_detection.protos.ImageResizer image_resizer = 2;</code>
     * @return Whether the imageResizer field is set.
     */
    boolean hasImageResizer();
    /**
     * <pre>
     * Image resizer for preprocessing the input image.
     * </pre>
     *
     * <code>optional .object_detection.protos.ImageResizer image_resizer = 2;</code>
     * @return The imageResizer.
     */
    object_detection.protos.ImageResizerOuterClass.ImageResizer getImageResizer();
    /**
     * <pre>
     * Image resizer for preprocessing the input image.
     * </pre>
     *
     * <code>optional .object_detection.protos.ImageResizer image_resizer = 2;</code>
     */
    object_detection.protos.ImageResizerOuterClass.ImageResizerOrBuilder getImageResizerOrBuilder();

    /**
     * <pre>
     * Feature extractor config.
     * </pre>
     *
     * <code>optional .object_detection.protos.SsdFeatureExtractor feature_extractor = 3;</code>
     * @return Whether the featureExtractor field is set.
     */
    boolean hasFeatureExtractor();
    /**
     * <pre>
     * Feature extractor config.
     * </pre>
     *
     * <code>optional .object_detection.protos.SsdFeatureExtractor feature_extractor = 3;</code>
     * @return The featureExtractor.
     */
    object_detection.protos.SsdOuterClass.SsdFeatureExtractor getFeatureExtractor();
    /**
     * <pre>
     * Feature extractor config.
     * </pre>
     *
     * <code>optional .object_detection.protos.SsdFeatureExtractor feature_extractor = 3;</code>
     */
    object_detection.protos.SsdOuterClass.SsdFeatureExtractorOrBuilder getFeatureExtractorOrBuilder();

    /**
     * <pre>
     * Box coder to encode the boxes.
     * </pre>
     *
     * <code>optional .object_detection.protos.BoxCoder box_coder = 4;</code>
     * @return Whether the boxCoder field is set.
     */
    boolean hasBoxCoder();
    /**
     * <pre>
     * Box coder to encode the boxes.
     * </pre>
     *
     * <code>optional .object_detection.protos.BoxCoder box_coder = 4;</code>
     * @return The boxCoder.
     */
    object_detection.protos.BoxCoderOuterClass.BoxCoder getBoxCoder();
    /**
     * <pre>
     * Box coder to encode the boxes.
     * </pre>
     *
     * <code>optional .object_detection.protos.BoxCoder box_coder = 4;</code>
     */
    object_detection.protos.BoxCoderOuterClass.BoxCoderOrBuilder getBoxCoderOrBuilder();

    /**
     * <pre>
     * Matcher to match groundtruth with anchors.
     * </pre>
     *
     * <code>optional .object_detection.protos.Matcher matcher = 5;</code>
     * @return Whether the matcher field is set.
     */
    boolean hasMatcher();
    /**
     * <pre>
     * Matcher to match groundtruth with anchors.
     * </pre>
     *
     * <code>optional .object_detection.protos.Matcher matcher = 5;</code>
     * @return The matcher.
     */
    object_detection.protos.MatcherOuterClass.Matcher getMatcher();
    /**
     * <pre>
     * Matcher to match groundtruth with anchors.
     * </pre>
     *
     * <code>optional .object_detection.protos.Matcher matcher = 5;</code>
     */
    object_detection.protos.MatcherOuterClass.MatcherOrBuilder getMatcherOrBuilder();

    /**
     * <pre>
     * Region similarity calculator to compute similarity of boxes.
     * </pre>
     *
     * <code>optional .object_detection.protos.RegionSimilarityCalculator similarity_calculator = 6;</code>
     * @return Whether the similarityCalculator field is set.
     */
    boolean hasSimilarityCalculator();
    /**
     * <pre>
     * Region similarity calculator to compute similarity of boxes.
     * </pre>
     *
     * <code>optional .object_detection.protos.RegionSimilarityCalculator similarity_calculator = 6;</code>
     * @return The similarityCalculator.
     */
    object_detection.protos.RegionSimilarityCalculatorOuterClass.RegionSimilarityCalculator getSimilarityCalculator();
    /**
     * <pre>
     * Region similarity calculator to compute similarity of boxes.
     * </pre>
     *
     * <code>optional .object_detection.protos.RegionSimilarityCalculator similarity_calculator = 6;</code>
     */
    object_detection.protos.RegionSimilarityCalculatorOuterClass.RegionSimilarityCalculatorOrBuilder getSimilarityCalculatorOrBuilder();

    /**
     * <pre>
     * Whether background targets are to be encoded as an all
     * zeros vector or a one-hot vector (where background is the 0th class).
     * </pre>
     *
     * <code>optional bool encode_background_as_zeros = 12 [default = false];</code>
     * @return Whether the encodeBackgroundAsZeros field is set.
     */
    boolean hasEncodeBackgroundAsZeros();
    /**
     * <pre>
     * Whether background targets are to be encoded as an all
     * zeros vector or a one-hot vector (where background is the 0th class).
     * </pre>
     *
     * <code>optional bool encode_background_as_zeros = 12 [default = false];</code>
     * @return The encodeBackgroundAsZeros.
     */
    boolean getEncodeBackgroundAsZeros();

    /**
     * <pre>
     * classification weight to be associated to negative
     * anchors (default: 1.0). The weight must be in [0., 1.].
     * </pre>
     *
     * <code>optional float negative_class_weight = 13 [default = 1];</code>
     * @return Whether the negativeClassWeight field is set.
     */
    boolean hasNegativeClassWeight();
    /**
     * <pre>
     * classification weight to be associated to negative
     * anchors (default: 1.0). The weight must be in [0., 1.].
     * </pre>
     *
     * <code>optional float negative_class_weight = 13 [default = 1];</code>
     * @return The negativeClassWeight.
     */
    float getNegativeClassWeight();

    /**
     * <pre>
     * Box predictor to attach to the features.
     * </pre>
     *
     * <code>optional .object_detection.protos.BoxPredictor box_predictor = 7;</code>
     * @return Whether the boxPredictor field is set.
     */
    boolean hasBoxPredictor();
    /**
     * <pre>
     * Box predictor to attach to the features.
     * </pre>
     *
     * <code>optional .object_detection.protos.BoxPredictor box_predictor = 7;</code>
     * @return The boxPredictor.
     */
    object_detection.protos.BoxPredictorOuterClass.BoxPredictor getBoxPredictor();
    /**
     * <pre>
     * Box predictor to attach to the features.
     * </pre>
     *
     * <code>optional .object_detection.protos.BoxPredictor box_predictor = 7;</code>
     */
    object_detection.protos.BoxPredictorOuterClass.BoxPredictorOrBuilder getBoxPredictorOrBuilder();

    /**
     * <pre>
     * Anchor generator to compute anchors.
     * </pre>
     *
     * <code>optional .object_detection.protos.AnchorGenerator anchor_generator = 8;</code>
     * @return Whether the anchorGenerator field is set.
     */
    boolean hasAnchorGenerator();
    /**
     * <pre>
     * Anchor generator to compute anchors.
     * </pre>
     *
     * <code>optional .object_detection.protos.AnchorGenerator anchor_generator = 8;</code>
     * @return The anchorGenerator.
     */
    object_detection.protos.AnchorGeneratorOuterClass.AnchorGenerator getAnchorGenerator();
    /**
     * <pre>
     * Anchor generator to compute anchors.
     * </pre>
     *
     * <code>optional .object_detection.protos.AnchorGenerator anchor_generator = 8;</code>
     */
    object_detection.protos.AnchorGeneratorOuterClass.AnchorGeneratorOrBuilder getAnchorGeneratorOrBuilder();

    /**
     * <pre>
     * Post processing to apply on the predictions.
     * </pre>
     *
     * <code>optional .object_detection.protos.PostProcessing post_processing = 9;</code>
     * @return Whether the postProcessing field is set.
     */
    boolean hasPostProcessing();
    /**
     * <pre>
     * Post processing to apply on the predictions.
     * </pre>
     *
     * <code>optional .object_detection.protos.PostProcessing post_processing = 9;</code>
     * @return The postProcessing.
     */
    object_detection.protos.PostProcessingOuterClass.PostProcessing getPostProcessing();
    /**
     * <pre>
     * Post processing to apply on the predictions.
     * </pre>
     *
     * <code>optional .object_detection.protos.PostProcessing post_processing = 9;</code>
     */
    object_detection.protos.PostProcessingOuterClass.PostProcessingOrBuilder getPostProcessingOrBuilder();

    /**
     * <pre>
     * Whether to normalize the loss by number of groundtruth boxes that match to
     * the anchors.
     * </pre>
     *
     * <code>optional bool normalize_loss_by_num_matches = 10 [default = true];</code>
     * @return Whether the normalizeLossByNumMatches field is set.
     */
    boolean hasNormalizeLossByNumMatches();
    /**
     * <pre>
     * Whether to normalize the loss by number of groundtruth boxes that match to
     * the anchors.
     * </pre>
     *
     * <code>optional bool normalize_loss_by_num_matches = 10 [default = true];</code>
     * @return The normalizeLossByNumMatches.
     */
    boolean getNormalizeLossByNumMatches();

    /**
     * <pre>
     * Whether to normalize the localization loss by the code size of the box
     * encodings. This is applied along with other normalization factors.
     * </pre>
     *
     * <code>optional bool normalize_loc_loss_by_codesize = 14 [default = false];</code>
     * @return Whether the normalizeLocLossByCodesize field is set.
     */
    boolean hasNormalizeLocLossByCodesize();
    /**
     * <pre>
     * Whether to normalize the localization loss by the code size of the box
     * encodings. This is applied along with other normalization factors.
     * </pre>
     *
     * <code>optional bool normalize_loc_loss_by_codesize = 14 [default = false];</code>
     * @return The normalizeLocLossByCodesize.
     */
    boolean getNormalizeLocLossByCodesize();

    /**
     * <pre>
     * Loss configuration for training.
     * </pre>
     *
     * <code>optional .object_detection.protos.Loss loss = 11;</code>
     * @return Whether the loss field is set.
     */
    boolean hasLoss();
    /**
     * <pre>
     * Loss configuration for training.
     * </pre>
     *
     * <code>optional .object_detection.protos.Loss loss = 11;</code>
     * @return The loss.
     */
    object_detection.protos.Losses.Loss getLoss();
    /**
     * <pre>
     * Loss configuration for training.
     * </pre>
     *
     * <code>optional .object_detection.protos.Loss loss = 11;</code>
     */
    object_detection.protos.Losses.LossOrBuilder getLossOrBuilder();

    /**
     * <pre>
     * Whether to update batch norm parameters during training or not.
     * When training with a relative small batch size (e.g. 1), it is
     * desirable to disable batch norm update and use pretrained batch norm
     * params.
     * Note: Some feature extractors are used with canned arg_scopes
     * (e.g resnet arg scopes).  In these cases training behavior of batch norm
     * variables may depend on both values of `batch_norm_trainable` and
     * `is_training`.
     * When canned arg_scopes are used with feature extractors `conv_hyperparams`
     * will apply only to the additional layers that are added and are outside the
     * canned arg_scope.
     * </pre>
     *
     * <code>optional bool freeze_batchnorm = 16 [default = false];</code>
     * @return Whether the freezeBatchnorm field is set.
     */
    boolean hasFreezeBatchnorm();
    /**
     * <pre>
     * Whether to update batch norm parameters during training or not.
     * When training with a relative small batch size (e.g. 1), it is
     * desirable to disable batch norm update and use pretrained batch norm
     * params.
     * Note: Some feature extractors are used with canned arg_scopes
     * (e.g resnet arg scopes).  In these cases training behavior of batch norm
     * variables may depend on both values of `batch_norm_trainable` and
     * `is_training`.
     * When canned arg_scopes are used with feature extractors `conv_hyperparams`
     * will apply only to the additional layers that are added and are outside the
     * canned arg_scope.
     * </pre>
     *
     * <code>optional bool freeze_batchnorm = 16 [default = false];</code>
     * @return The freezeBatchnorm.
     */
    boolean getFreezeBatchnorm();

    /**
     * <pre>
     * Whether to update batch_norm inplace during training. This is required
     * for batch norm to work correctly on TPUs. When this is false, user must add
     * a control dependency on tf.GraphKeys.UPDATE_OPS for train/loss op in order
     * to update the batch norm moving average parameters.
     * </pre>
     *
     * <code>optional bool inplace_batchnorm_update = 15 [default = false];</code>
     * @return Whether the inplaceBatchnormUpdate field is set.
     */
    boolean hasInplaceBatchnormUpdate();
    /**
     * <pre>
     * Whether to update batch_norm inplace during training. This is required
     * for batch norm to work correctly on TPUs. When this is false, user must add
     * a control dependency on tf.GraphKeys.UPDATE_OPS for train/loss op in order
     * to update the batch norm moving average parameters.
     * </pre>
     *
     * <code>optional bool inplace_batchnorm_update = 15 [default = false];</code>
     * @return The inplaceBatchnormUpdate.
     */
    boolean getInplaceBatchnormUpdate();

    /**
     * <pre>
     * Whether to add an implicit background class to one-hot encodings of
     * groundtruth labels. Set to false if training a single
     * class model or using an explicit background class.
     * </pre>
     *
     * <code>optional bool add_background_class = 21 [default = true];</code>
     * @return Whether the addBackgroundClass field is set.
     */
    boolean hasAddBackgroundClass();
    /**
     * <pre>
     * Whether to add an implicit background class to one-hot encodings of
     * groundtruth labels. Set to false if training a single
     * class model or using an explicit background class.
     * </pre>
     *
     * <code>optional bool add_background_class = 21 [default = true];</code>
     * @return The addBackgroundClass.
     */
    boolean getAddBackgroundClass();

    /**
     * <pre>
     * Whether to use an explicit background class. Set to true if using
     * groundtruth labels with an explicit background class, as in multiclass
     * scores.
     * </pre>
     *
     * <code>optional bool explicit_background_class = 24 [default = false];</code>
     * @return Whether the explicitBackgroundClass field is set.
     */
    boolean hasExplicitBackgroundClass();
    /**
     * <pre>
     * Whether to use an explicit background class. Set to true if using
     * groundtruth labels with an explicit background class, as in multiclass
     * scores.
     * </pre>
     *
     * <code>optional bool explicit_background_class = 24 [default = false];</code>
     * @return The explicitBackgroundClass.
     */
    boolean getExplicitBackgroundClass();

    /**
     * <code>optional bool use_confidences_as_targets = 22 [default = false];</code>
     * @return Whether the useConfidencesAsTargets field is set.
     */
    boolean hasUseConfidencesAsTargets();
    /**
     * <code>optional bool use_confidences_as_targets = 22 [default = false];</code>
     * @return The useConfidencesAsTargets.
     */
    boolean getUseConfidencesAsTargets();

    /**
     * <code>optional float implicit_example_weight = 23 [default = 1];</code>
     * @return Whether the implicitExampleWeight field is set.
     */
    boolean hasImplicitExampleWeight();
    /**
     * <code>optional float implicit_example_weight = 23 [default = 1];</code>
     * @return The implicitExampleWeight.
     */
    float getImplicitExampleWeight();

    /**
     * <code>optional bool return_raw_detections_during_predict = 26 [default = false];</code>
     * @return Whether the returnRawDetectionsDuringPredict field is set.
     */
    boolean hasReturnRawDetectionsDuringPredict();
    /**
     * <code>optional bool return_raw_detections_during_predict = 26 [default = false];</code>
     * @return The returnRawDetectionsDuringPredict.
     */
    boolean getReturnRawDetectionsDuringPredict();

    /**
     * <pre>
     * Configs for mask head.
     * </pre>
     *
     * <code>optional .object_detection.protos.Ssd.MaskHead mask_head_config = 25;</code>
     * @return Whether the maskHeadConfig field is set.
     */
    boolean hasMaskHeadConfig();
    /**
     * <pre>
     * Configs for mask head.
     * </pre>
     *
     * <code>optional .object_detection.protos.Ssd.MaskHead mask_head_config = 25;</code>
     * @return The maskHeadConfig.
     */
    object_detection.protos.SsdOuterClass.Ssd.MaskHead getMaskHeadConfig();
    /**
     * <pre>
     * Configs for mask head.
     * </pre>
     *
     * <code>optional .object_detection.protos.Ssd.MaskHead mask_head_config = 25;</code>
     */
    object_detection.protos.SsdOuterClass.Ssd.MaskHeadOrBuilder getMaskHeadConfigOrBuilder();
  }
  /**
   * <pre>
   * Configuration for Single Shot Detection (SSD) models.
   * Next id: 27
   * </pre>
   *
   * Protobuf type {@code object_detection.protos.Ssd}
   */
  public static final class Ssd extends
      com.google.protobuf.GeneratedMessageV3 implements
      // @@protoc_insertion_point(message_implements:object_detection.protos.Ssd)
      SsdOrBuilder {
  private static final long serialVersionUID = 0L;
    // Use Ssd.newBuilder() to construct.
    private Ssd(com.google.protobuf.GeneratedMessageV3.Builder<?> builder) {
      super(builder);
    }
    private Ssd() {
      negativeClassWeight_ = 1F;
      normalizeLossByNumMatches_ = true;
      addBackgroundClass_ = true;
      implicitExampleWeight_ = 1F;
    }

    @java.lang.Override
    @SuppressWarnings({"unused"})
    protected java.lang.Object newInstance(
        UnusedPrivateParameter unused) {
      return new Ssd();
    }

    @java.lang.Override
    public final com.google.protobuf.UnknownFieldSet
    getUnknownFields() {
      return this.unknownFields;
    }
    private Ssd(
        com.google.protobuf.CodedInputStream input,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws com.google.protobuf.InvalidProtocolBufferException {
      this();
      if (extensionRegistry == null) {
        throw new java.lang.NullPointerException();
      }
      int mutable_bitField0_ = 0;
      com.google.protobuf.UnknownFieldSet.Builder unknownFields =
          com.google.protobuf.UnknownFieldSet.newBuilder();
      try {
        boolean done = false;
        while (!done) {
          int tag = input.readTag();
          switch (tag) {
            case 0:
              done = true;
              break;
            case 8: {
              bitField0_ |= 0x00000001;
              numClasses_ = input.readInt32();
              break;
            }
            case 18: {
              object_detection.protos.ImageResizerOuterClass.ImageResizer.Builder subBuilder = null;
              if (((bitField0_ & 0x00000002) != 0)) {
                subBuilder = imageResizer_.toBuilder();
              }
              imageResizer_ = input.readMessage(object_detection.protos.ImageResizerOuterClass.ImageResizer.PARSER, extensionRegistry);
              if (subBuilder != null) {
                subBuilder.mergeFrom(imageResizer_);
                imageResizer_ = subBuilder.buildPartial();
              }
              bitField0_ |= 0x00000002;
              break;
            }
            case 26: {
              object_detection.protos.SsdOuterClass.SsdFeatureExtractor.Builder subBuilder = null;
              if (((bitField0_ & 0x00000004) != 0)) {
                subBuilder = featureExtractor_.toBuilder();
              }
              featureExtractor_ = input.readMessage(object_detection.protos.SsdOuterClass.SsdFeatureExtractor.PARSER, extensionRegistry);
              if (subBuilder != null) {
                subBuilder.mergeFrom(featureExtractor_);
                featureExtractor_ = subBuilder.buildPartial();
              }
              bitField0_ |= 0x00000004;
              break;
            }
            case 34: {
              object_detection.protos.BoxCoderOuterClass.BoxCoder.Builder subBuilder = null;
              if (((bitField0_ & 0x00000008) != 0)) {
                subBuilder = boxCoder_.toBuilder();
              }
              boxCoder_ = input.readMessage(object_detection.protos.BoxCoderOuterClass.BoxCoder.PARSER, extensionRegistry);
              if (subBuilder != null) {
                subBuilder.mergeFrom(boxCoder_);
                boxCoder_ = subBuilder.buildPartial();
              }
              bitField0_ |= 0x00000008;
              break;
            }
            case 42: {
              object_detection.protos.MatcherOuterClass.Matcher.Builder subBuilder = null;
              if (((bitField0_ & 0x00000010) != 0)) {
                subBuilder = matcher_.toBuilder();
              }
              matcher_ = input.readMessage(object_detection.protos.MatcherOuterClass.Matcher.PARSER, extensionRegistry);
              if (subBuilder != null) {
                subBuilder.mergeFrom(matcher_);
                matcher_ = subBuilder.buildPartial();
              }
              bitField0_ |= 0x00000010;
              break;
            }
            case 50: {
              object_detection.protos.RegionSimilarityCalculatorOuterClass.RegionSimilarityCalculator.Builder subBuilder = null;
              if (((bitField0_ & 0x00000020) != 0)) {
                subBuilder = similarityCalculator_.toBuilder();
              }
              similarityCalculator_ = input.readMessage(object_detection.protos.RegionSimilarityCalculatorOuterClass.RegionSimilarityCalculator.PARSER, extensionRegistry);
              if (subBuilder != null) {
                subBuilder.mergeFrom(similarityCalculator_);
                similarityCalculator_ = subBuilder.buildPartial();
              }
              bitField0_ |= 0x00000020;
              break;
            }
            case 58: {
              object_detection.protos.BoxPredictorOuterClass.BoxPredictor.Builder subBuilder = null;
              if (((bitField0_ & 0x00000100) != 0)) {
                subBuilder = boxPredictor_.toBuilder();
              }
              boxPredictor_ = input.readMessage(object_detection.protos.BoxPredictorOuterClass.BoxPredictor.PARSER, extensionRegistry);
              if (subBuilder != null) {
                subBuilder.mergeFrom(boxPredictor_);
                boxPredictor_ = subBuilder.buildPartial();
              }
              bitField0_ |= 0x00000100;
              break;
            }
            case 66: {
              object_detection.protos.AnchorGeneratorOuterClass.AnchorGenerator.Builder subBuilder = null;
              if (((bitField0_ & 0x00000200) != 0)) {
                subBuilder = anchorGenerator_.toBuilder();
              }
              anchorGenerator_ = input.readMessage(object_detection.protos.AnchorGeneratorOuterClass.AnchorGenerator.PARSER, extensionRegistry);
              if (subBuilder != null) {
                subBuilder.mergeFrom(anchorGenerator_);
                anchorGenerator_ = subBuilder.buildPartial();
              }
              bitField0_ |= 0x00000200;
              break;
            }
            case 74: {
              object_detection.protos.PostProcessingOuterClass.PostProcessing.Builder subBuilder = null;
              if (((bitField0_ & 0x00000400) != 0)) {
                subBuilder = postProcessing_.toBuilder();
              }
              postProcessing_ = input.readMessage(object_detection.protos.PostProcessingOuterClass.PostProcessing.PARSER, extensionRegistry);
              if (subBuilder != null) {
                subBuilder.mergeFrom(postProcessing_);
                postProcessing_ = subBuilder.buildPartial();
              }
              bitField0_ |= 0x00000400;
              break;
            }
            case 80: {
              bitField0_ |= 0x00000800;
              normalizeLossByNumMatches_ = input.readBool();
              break;
            }
            case 90: {
              object_detection.protos.Losses.Loss.Builder subBuilder = null;
              if (((bitField0_ & 0x00002000) != 0)) {
                subBuilder = loss_.toBuilder();
              }
              loss_ = input.readMessage(object_detection.protos.Losses.Loss.PARSER, extensionRegistry);
              if (subBuilder != null) {
                subBuilder.mergeFrom(loss_);
                loss_ = subBuilder.buildPartial();
              }
              bitField0_ |= 0x00002000;
              break;
            }
            case 96: {
              bitField0_ |= 0x00000040;
              encodeBackgroundAsZeros_ = input.readBool();
              break;
            }
            case 109: {
              bitField0_ |= 0x00000080;
              negativeClassWeight_ = input.readFloat();
              break;
            }
            case 112: {
              bitField0_ |= 0x00001000;
              normalizeLocLossByCodesize_ = input.readBool();
              break;
            }
            case 120: {
              bitField0_ |= 0x00008000;
              inplaceBatchnormUpdate_ = input.readBool();
              break;
            }
            case 128: {
              bitField0_ |= 0x00004000;
              freezeBatchnorm_ = input.readBool();
              break;
            }
            case 168: {
              bitField0_ |= 0x00010000;
              addBackgroundClass_ = input.readBool();
              break;
            }
            case 176: {
              bitField0_ |= 0x00040000;
              useConfidencesAsTargets_ = input.readBool();
              break;
            }
            case 189: {
              bitField0_ |= 0x00080000;
              implicitExampleWeight_ = input.readFloat();
              break;
            }
            case 192: {
              bitField0_ |= 0x00020000;
              explicitBackgroundClass_ = input.readBool();
              break;
            }
            case 202: {
              object_detection.protos.SsdOuterClass.Ssd.MaskHead.Builder subBuilder = null;
              if (((bitField0_ & 0x00200000) != 0)) {
                subBuilder = maskHeadConfig_.toBuilder();
              }
              maskHeadConfig_ = input.readMessage(object_detection.protos.SsdOuterClass.Ssd.MaskHead.PARSER, extensionRegistry);
              if (subBuilder != null) {
                subBuilder.mergeFrom(maskHeadConfig_);
                maskHeadConfig_ = subBuilder.buildPartial();
              }
              bitField0_ |= 0x00200000;
              break;
            }
            case 208: {
              bitField0_ |= 0x00100000;
              returnRawDetectionsDuringPredict_ = input.readBool();
              break;
            }
            default: {
              if (!parseUnknownField(
                  input, unknownFields, extensionRegistry, tag)) {
                done = true;
              }
              break;
            }
          }
        }
      } catch (com.google.protobuf.InvalidProtocolBufferException e) {
        throw e.setUnfinishedMessage(this);
      } catch (java.io.IOException e) {
        throw new com.google.protobuf.InvalidProtocolBufferException(
            e).setUnfinishedMessage(this);
      } finally {
        this.unknownFields = unknownFields.build();
        makeExtensionsImmutable();
      }
    }
    public static final com.google.protobuf.Descriptors.Descriptor
        getDescriptor() {
      return object_detection.protos.SsdOuterClass.internal_static_object_detection_protos_Ssd_descriptor;
    }

    @java.lang.Override
    protected com.google.protobuf.GeneratedMessageV3.FieldAccessorTable
        internalGetFieldAccessorTable() {
      return object_detection.protos.SsdOuterClass.internal_static_object_detection_protos_Ssd_fieldAccessorTable
          .ensureFieldAccessorsInitialized(
              object_detection.protos.SsdOuterClass.Ssd.class, object_detection.protos.SsdOuterClass.Ssd.Builder.class);
    }

    public interface MaskHeadOrBuilder extends
        // @@protoc_insertion_point(interface_extends:object_detection.protos.Ssd.MaskHead)
        com.google.protobuf.MessageOrBuilder {

      /**
       * <pre>
       * The height and the width of the predicted mask. Only used when
       * predict_instance_masks is true.
       * </pre>
       *
       * <code>optional int32 mask_height = 1 [default = 15];</code>
       * @return Whether the maskHeight field is set.
       */
      boolean hasMaskHeight();
      /**
       * <pre>
       * The height and the width of the predicted mask. Only used when
       * predict_instance_masks is true.
       * </pre>
       *
       * <code>optional int32 mask_height = 1 [default = 15];</code>
       * @return The maskHeight.
       */
      int getMaskHeight();

      /**
       * <code>optional int32 mask_width = 2 [default = 15];</code>
       * @return Whether the maskWidth field is set.
       */
      boolean hasMaskWidth();
      /**
       * <code>optional int32 mask_width = 2 [default = 15];</code>
       * @return The maskWidth.
       */
      int getMaskWidth();

      /**
       * <pre>
       * Whether to predict class agnostic masks. Only used when
       * predict_instance_masks is true.
       * </pre>
       *
       * <code>optional bool masks_are_class_agnostic = 3 [default = true];</code>
       * @return Whether the masksAreClassAgnostic field is set.
       */
      boolean hasMasksAreClassAgnostic();
      /**
       * <pre>
       * Whether to predict class agnostic masks. Only used when
       * predict_instance_masks is true.
       * </pre>
       *
       * <code>optional bool masks_are_class_agnostic = 3 [default = true];</code>
       * @return The masksAreClassAgnostic.
       */
      boolean getMasksAreClassAgnostic();

      /**
       * <pre>
       * The depth for the first conv2d_transpose op applied to the
       * image_features in the mask prediction branch. If set to 0, the value
       * will be set automatically based on the number of channels in the image
       * features and the number of classes.
       * </pre>
       *
       * <code>optional int32 mask_prediction_conv_depth = 4 [default = 256];</code>
       * @return Whether the maskPredictionConvDepth field is set.
       */
      boolean hasMaskPredictionConvDepth();
      /**
       * <pre>
       * The depth for the first conv2d_transpose op applied to the
       * image_features in the mask prediction branch. If set to 0, the value
       * will be set automatically based on the number of channels in the image
       * features and the number of classes.
       * </pre>
       *
       * <code>optional int32 mask_prediction_conv_depth = 4 [default = 256];</code>
       * @return The maskPredictionConvDepth.
       */
      int getMaskPredictionConvDepth();

      /**
       * <pre>
       * The number of convolutions applied to image_features in the mask
       * prediction branch.
       * </pre>
       *
       * <code>optional int32 mask_prediction_num_conv_layers = 5 [default = 2];</code>
       * @return Whether the maskPredictionNumConvLayers field is set.
       */
      boolean hasMaskPredictionNumConvLayers();
      /**
       * <pre>
       * The number of convolutions applied to image_features in the mask
       * prediction branch.
       * </pre>
       *
       * <code>optional int32 mask_prediction_num_conv_layers = 5 [default = 2];</code>
       * @return The maskPredictionNumConvLayers.
       */
      int getMaskPredictionNumConvLayers();

      /**
       * <pre>
       * Whether to apply convolutions on mask features before upsampling using
       * nearest neighbor resizing.
       * By default, mask features are resized to [`mask_height`, `mask_width`]
       * before applying convolutions and predicting masks.
       * </pre>
       *
       * <code>optional bool convolve_then_upsample_masks = 6 [default = false];</code>
       * @return Whether the convolveThenUpsampleMasks field is set.
       */
      boolean hasConvolveThenUpsampleMasks();
      /**
       * <pre>
       * Whether to apply convolutions on mask features before upsampling using
       * nearest neighbor resizing.
       * By default, mask features are resized to [`mask_height`, `mask_width`]
       * before applying convolutions and predicting masks.
       * </pre>
       *
       * <code>optional bool convolve_then_upsample_masks = 6 [default = false];</code>
       * @return The convolveThenUpsampleMasks.
       */
      boolean getConvolveThenUpsampleMasks();

      /**
       * <pre>
       * Mask loss weight.
       * </pre>
       *
       * <code>optional float mask_loss_weight = 7 [default = 5];</code>
       * @return Whether the maskLossWeight field is set.
       */
      boolean hasMaskLossWeight();
      /**
       * <pre>
       * Mask loss weight.
       * </pre>
       *
       * <code>optional float mask_loss_weight = 7 [default = 5];</code>
       * @return The maskLossWeight.
       */
      float getMaskLossWeight();

      /**
       * <pre>
       * Number of boxes to be generated at training time for computing mask loss.
       * </pre>
       *
       * <code>optional int32 mask_loss_sample_size = 8 [default = 16];</code>
       * @return Whether the maskLossSampleSize field is set.
       */
      boolean hasMaskLossSampleSize();
      /**
       * <pre>
       * Number of boxes to be generated at training time for computing mask loss.
       * </pre>
       *
       * <code>optional int32 mask_loss_sample_size = 8 [default = 16];</code>
       * @return The maskLossSampleSize.
       */
      int getMaskLossSampleSize();

      /**
       * <pre>
       * Hyperparameters for convolution ops used in the box predictor.
       * </pre>
       *
       * <code>optional .object_detection.protos.Hyperparams conv_hyperparams = 9;</code>
       * @return Whether the convHyperparams field is set.
       */
      boolean hasConvHyperparams();
      /**
       * <pre>
       * Hyperparameters for convolution ops used in the box predictor.
       * </pre>
       *
       * <code>optional .object_detection.protos.Hyperparams conv_hyperparams = 9;</code>
       * @return The convHyperparams.
       */
      object_detection.protos.HyperparamsOuterClass.Hyperparams getConvHyperparams();
      /**
       * <pre>
       * Hyperparameters for convolution ops used in the box predictor.
       * </pre>
       *
       * <code>optional .object_detection.protos.Hyperparams conv_hyperparams = 9;</code>
       */
      object_detection.protos.HyperparamsOuterClass.HyperparamsOrBuilder getConvHyperparamsOrBuilder();

      /**
       * <pre>
       * Output size (width and height are set to be the same) of the initial
       * bilinear interpolation based cropping during ROI pooling. Only used when
       * we have second stage prediction head enabled (e.g. mask head).
       * </pre>
       *
       * <code>optional int32 initial_crop_size = 10 [default = 15];</code>
       * @return Whether the initialCropSize field is set.
       */
      boolean hasInitialCropSize();
      /**
       * <pre>
       * Output size (width and height are set to be the same) of the initial
       * bilinear interpolation based cropping during ROI pooling. Only used when
       * we have second stage prediction head enabled (e.g. mask head).
       * </pre>
       *
       * <code>optional int32 initial_crop_size = 10 [default = 15];</code>
       * @return The initialCropSize.
       */
      int getInitialCropSize();
    }
    /**
     * <pre>
     * Configuration proto for MaskHead.
     * Next id: 11
     * </pre>
     *
     * Protobuf type {@code object_detection.protos.Ssd.MaskHead}
     */
    public static final class MaskHead extends
        com.google.protobuf.GeneratedMessageV3 implements
        // @@protoc_insertion_point(message_implements:object_detection.protos.Ssd.MaskHead)
        MaskHeadOrBuilder {
    private static final long serialVersionUID = 0L;
      // Use MaskHead.newBuilder() to construct.
      private MaskHead(com.google.protobuf.GeneratedMessageV3.Builder<?> builder) {
        super(builder);
      }
      private MaskHead() {
        maskHeight_ = 15;
        maskWidth_ = 15;
        masksAreClassAgnostic_ = true;
        maskPredictionConvDepth_ = 256;
        maskPredictionNumConvLayers_ = 2;
        maskLossWeight_ = 5F;
        maskLossSampleSize_ = 16;
        initialCropSize_ = 15;
      }

      @java.lang.Override
      @SuppressWarnings({"unused"})
      protected java.lang.Object newInstance(
          UnusedPrivateParameter unused) {
        return new MaskHead();
      }

      @java.lang.Override
      public final com.google.protobuf.UnknownFieldSet
      getUnknownFields() {
        return this.unknownFields;
      }
      private MaskHead(
          com.google.protobuf.CodedInputStream input,
          com.google.protobuf.ExtensionRegistryLite extensionRegistry)
          throws com.google.protobuf.InvalidProtocolBufferException {
        this();
        if (extensionRegistry == null) {
          throw new java.lang.NullPointerException();
        }
        int mutable_bitField0_ = 0;
        com.google.protobuf.UnknownFieldSet.Builder unknownFields =
            com.google.protobuf.UnknownFieldSet.newBuilder();
        try {
          boolean done = false;
          while (!done) {
            int tag = input.readTag();
            switch (tag) {
              case 0:
                done = true;
                break;
              case 8: {
                bitField0_ |= 0x00000001;
                maskHeight_ = input.readInt32();
                break;
              }
              case 16: {
                bitField0_ |= 0x00000002;
                maskWidth_ = input.readInt32();
                break;
              }
              case 24: {
                bitField0_ |= 0x00000004;
                masksAreClassAgnostic_ = input.readBool();
                break;
              }
              case 32: {
                bitField0_ |= 0x00000008;
                maskPredictionConvDepth_ = input.readInt32();
                break;
              }
              case 40: {
                bitField0_ |= 0x00000010;
                maskPredictionNumConvLayers_ = input.readInt32();
                break;
              }
              case 48: {
                bitField0_ |= 0x00000020;
                convolveThenUpsampleMasks_ = input.readBool();
                break;
              }
              case 61: {
                bitField0_ |= 0x00000040;
                maskLossWeight_ = input.readFloat();
                break;
              }
              case 64: {
                bitField0_ |= 0x00000080;
                maskLossSampleSize_ = input.readInt32();
                break;
              }
              case 74: {
                object_detection.protos.HyperparamsOuterClass.Hyperparams.Builder subBuilder = null;
                if (((bitField0_ & 0x00000100) != 0)) {
                  subBuilder = convHyperparams_.toBuilder();
                }
                convHyperparams_ = input.readMessage(object_detection.protos.HyperparamsOuterClass.Hyperparams.PARSER, extensionRegistry);
                if (subBuilder != null) {
                  subBuilder.mergeFrom(convHyperparams_);
                  convHyperparams_ = subBuilder.buildPartial();
                }
                bitField0_ |= 0x00000100;
                break;
              }
              case 80: {
                bitField0_ |= 0x00000200;
                initialCropSize_ = input.readInt32();
                break;
              }
              default: {
                if (!parseUnknownField(
                    input, unknownFields, extensionRegistry, tag)) {
                  done = true;
                }
                break;
              }
            }
          }
        } catch (com.google.protobuf.InvalidProtocolBufferException e) {
          throw e.setUnfinishedMessage(this);
        } catch (java.io.IOException e) {
          throw new com.google.protobuf.InvalidProtocolBufferException(
              e).setUnfinishedMessage(this);
        } finally {
          this.unknownFields = unknownFields.build();
          makeExtensionsImmutable();
        }
      }
      public static final com.google.protobuf.Descriptors.Descriptor
          getDescriptor() {
        return object_detection.protos.SsdOuterClass.internal_static_object_detection_protos_Ssd_MaskHead_descriptor;
      }

      @java.lang.Override
      protected com.google.protobuf.GeneratedMessageV3.FieldAccessorTable
          internalGetFieldAccessorTable() {
        return object_detection.protos.SsdOuterClass.internal_static_object_detection_protos_Ssd_MaskHead_fieldAccessorTable
            .ensureFieldAccessorsInitialized(
                object_detection.protos.SsdOuterClass.Ssd.MaskHead.class, object_detection.protos.SsdOuterClass.Ssd.MaskHead.Builder.class);
      }

      private int bitField0_;
      public static final int MASK_HEIGHT_FIELD_NUMBER = 1;
      private int maskHeight_;
      /**
       * <pre>
       * The height and the width of the predicted mask. Only used when
       * predict_instance_masks is true.
       * </pre>
       *
       * <code>optional int32 mask_height = 1 [default = 15];</code>
       * @return Whether the maskHeight field is set.
       */
      @java.lang.Override
      public boolean hasMaskHeight() {
        return ((bitField0_ & 0x00000001) != 0);
      }
      /**
       * <pre>
       * The height and the width of the predicted mask. Only used when
       * predict_instance_masks is true.
       * </pre>
       *
       * <code>optional int32 mask_height = 1 [default = 15];</code>
       * @return The maskHeight.
       */
      @java.lang.Override
      public int getMaskHeight() {
        return maskHeight_;
      }

      public static final int MASK_WIDTH_FIELD_NUMBER = 2;
      private int maskWidth_;
      /**
       * <code>optional int32 mask_width = 2 [default = 15];</code>
       * @return Whether the maskWidth field is set.
       */
      @java.lang.Override
      public boolean hasMaskWidth() {
        return ((bitField0_ & 0x00000002) != 0);
      }
      /**
       * <code>optional int32 mask_width = 2 [default = 15];</code>
       * @return The maskWidth.
       */
      @java.lang.Override
      public int getMaskWidth() {
        return maskWidth_;
      }

      public static final int MASKS_ARE_CLASS_AGNOSTIC_FIELD_NUMBER = 3;
      private boolean masksAreClassAgnostic_;
      /**
       * <pre>
       * Whether to predict class agnostic masks. Only used when
       * predict_instance_masks is true.
       * </pre>
       *
       * <code>optional bool masks_are_class_agnostic = 3 [default = true];</code>
       * @return Whether the masksAreClassAgnostic field is set.
       */
      @java.lang.Override
      public boolean hasMasksAreClassAgnostic() {
        return ((bitField0_ & 0x00000004) != 0);
      }
      /**
       * <pre>
       * Whether to predict class agnostic masks. Only used when
       * predict_instance_masks is true.
       * </pre>
       *
       * <code>optional bool masks_are_class_agnostic = 3 [default = true];</code>
       * @return The masksAreClassAgnostic.
       */
      @java.lang.Override
      public boolean getMasksAreClassAgnostic() {
        return masksAreClassAgnostic_;
      }

      public static final int MASK_PREDICTION_CONV_DEPTH_FIELD_NUMBER = 4;
      private int maskPredictionConvDepth_;
      /**
       * <pre>
       * The depth for the first conv2d_transpose op applied to the
       * image_features in the mask prediction branch. If set to 0, the value
       * will be set automatically based on the number of channels in the image
       * features and the number of classes.
       * </pre>
       *
       * <code>optional int32 mask_prediction_conv_depth = 4 [default = 256];</code>
       * @return Whether the maskPredictionConvDepth field is set.
       */
      @java.lang.Override
      public boolean hasMaskPredictionConvDepth() {
        return ((bitField0_ & 0x00000008) != 0);
      }
      /**
       * <pre>
       * The depth for the first conv2d_transpose op applied to the
       * image_features in the mask prediction branch. If set to 0, the value
       * will be set automatically based on the number of channels in the image
       * features and the number of classes.
       * </pre>
       *
       * <code>optional int32 mask_prediction_conv_depth = 4 [default = 256];</code>
       * @return The maskPredictionConvDepth.
       */
      @java.lang.Override
      public int getMaskPredictionConvDepth() {
        return maskPredictionConvDepth_;
      }

      public static final int MASK_PREDICTION_NUM_CONV_LAYERS_FIELD_NUMBER = 5;
      private int maskPredictionNumConvLayers_;
      /**
       * <pre>
       * The number of convolutions applied to image_features in the mask
       * prediction branch.
       * </pre>
       *
       * <code>optional int32 mask_prediction_num_conv_layers = 5 [default = 2];</code>
       * @return Whether the maskPredictionNumConvLayers field is set.
       */
      @java.lang.Override
      public boolean hasMaskPredictionNumConvLayers() {
        return ((bitField0_ & 0x00000010) != 0);
      }
      /**
       * <pre>
       * The number of convolutions applied to image_features in the mask
       * prediction branch.
       * </pre>
       *
       * <code>optional int32 mask_prediction_num_conv_layers = 5 [default = 2];</code>
       * @return The maskPredictionNumConvLayers.
       */
      @java.lang.Override
      public int getMaskPredictionNumConvLayers() {
        return maskPredictionNumConvLayers_;
      }

      public static final int CONVOLVE_THEN_UPSAMPLE_MASKS_FIELD_NUMBER = 6;
      private boolean convolveThenUpsampleMasks_;
      /**
       * <pre>
       * Whether to apply convolutions on mask features before upsampling using
       * nearest neighbor resizing.
       * By default, mask features are resized to [`mask_height`, `mask_width`]
       * before applying convolutions and predicting masks.
       * </pre>
       *
       * <code>optional bool convolve_then_upsample_masks = 6 [default = false];</code>
       * @return Whether the convolveThenUpsampleMasks field is set.
       */
      @java.lang.Override
      public boolean hasConvolveThenUpsampleMasks() {
        return ((bitField0_ & 0x00000020) != 0);
      }
      /**
       * <pre>
       * Whether to apply convolutions on mask features before upsampling using
       * nearest neighbor resizing.
       * By default, mask features are resized to [`mask_height`, `mask_width`]
       * before applying convolutions and predicting masks.
       * </pre>
       *
       * <code>optional bool convolve_then_upsample_masks = 6 [default = false];</code>
       * @return The convolveThenUpsampleMasks.
       */
      @java.lang.Override
      public boolean getConvolveThenUpsampleMasks() {
        return convolveThenUpsampleMasks_;
      }

      public static final int MASK_LOSS_WEIGHT_FIELD_NUMBER = 7;
      private float maskLossWeight_;
      /**
       * <pre>
       * Mask loss weight.
       * </pre>
       *
       * <code>optional float mask_loss_weight = 7 [default = 5];</code>
       * @return Whether the maskLossWeight field is set.
       */
      @java.lang.Override
      public boolean hasMaskLossWeight() {
        return ((bitField0_ & 0x00000040) != 0);
      }
      /**
       * <pre>
       * Mask loss weight.
       * </pre>
       *
       * <code>optional float mask_loss_weight = 7 [default = 5];</code>
       * @return The maskLossWeight.
       */
      @java.lang.Override
      public float getMaskLossWeight() {
        return maskLossWeight_;
      }

      public static final int MASK_LOSS_SAMPLE_SIZE_FIELD_NUMBER = 8;
      private int maskLossSampleSize_;
      /**
       * <pre>
       * Number of boxes to be generated at training time for computing mask loss.
       * </pre>
       *
       * <code>optional int32 mask_loss_sample_size = 8 [default = 16];</code>
       * @return Whether the maskLossSampleSize field is set.
       */
      @java.lang.Override
      public boolean hasMaskLossSampleSize() {
        return ((bitField0_ & 0x00000080) != 0);
      }
      /**
       * <pre>
       * Number of boxes to be generated at training time for computing mask loss.
       * </pre>
       *
       * <code>optional int32 mask_loss_sample_size = 8 [default = 16];</code>
       * @return The maskLossSampleSize.
       */
      @java.lang.Override
      public int getMaskLossSampleSize() {
        return maskLossSampleSize_;
      }

      public static final int CONV_HYPERPARAMS_FIELD_NUMBER = 9;
      private object_detection.protos.HyperparamsOuterClass.Hyperparams convHyperparams_;
      /**
       * <pre>
       * Hyperparameters for convolution ops used in the box predictor.
       * </pre>
       *
       * <code>optional .object_detection.protos.Hyperparams conv_hyperparams = 9;</code>
       * @return Whether the convHyperparams field is set.
       */
      @java.lang.Override
      public boolean hasConvHyperparams() {
        return ((bitField0_ & 0x00000100) != 0);
      }
      /**
       * <pre>
       * Hyperparameters for convolution ops used in the box predictor.
       * </pre>
       *
       * <code>optional .object_detection.protos.Hyperparams conv_hyperparams = 9;</code>
       * @return The convHyperparams.
       */
      @java.lang.Override
      public object_detection.protos.HyperparamsOuterClass.Hyperparams getConvHyperparams() {
        return convHyperparams_ == null ? object_detection.protos.HyperparamsOuterClass.Hyperparams.getDefaultInstance() : convHyperparams_;
      }
      /**
       * <pre>
       * Hyperparameters for convolution ops used in the box predictor.
       * </pre>
       *
       * <code>optional .object_detection.protos.Hyperparams conv_hyperparams = 9;</code>
       */
      @java.lang.Override
      public object_detection.protos.HyperparamsOuterClass.HyperparamsOrBuilder getConvHyperparamsOrBuilder() {
        return convHyperparams_ == null ? object_detection.protos.HyperparamsOuterClass.Hyperparams.getDefaultInstance() : convHyperparams_;
      }

      public static final int INITIAL_CROP_SIZE_FIELD_NUMBER = 10;
      private int initialCropSize_;
      /**
       * <pre>
       * Output size (width and height are set to be the same) of the initial
       * bilinear interpolation based cropping during ROI pooling. Only used when
       * we have second stage prediction head enabled (e.g. mask head).
       * </pre>
       *
       * <code>optional int32 initial_crop_size = 10 [default = 15];</code>
       * @return Whether the initialCropSize field is set.
       */
      @java.lang.Override
      public boolean hasInitialCropSize() {
        return ((bitField0_ & 0x00000200) != 0);
      }
      /**
       * <pre>
       * Output size (width and height are set to be the same) of the initial
       * bilinear interpolation based cropping during ROI pooling. Only used when
       * we have second stage prediction head enabled (e.g. mask head).
       * </pre>
       *
       * <code>optional int32 initial_crop_size = 10 [default = 15];</code>
       * @return The initialCropSize.
       */
      @java.lang.Override
      public int getInitialCropSize() {
        return initialCropSize_;
      }

      private byte memoizedIsInitialized = -1;
      @java.lang.Override
      public final boolean isInitialized() {
        byte isInitialized = memoizedIsInitialized;
        if (isInitialized == 1) return true;
        if (isInitialized == 0) return false;

        memoizedIsInitialized = 1;
        return true;
      }

      @java.lang.Override
      public void writeTo(com.google.protobuf.CodedOutputStream output)
                          throws java.io.IOException {
        if (((bitField0_ & 0x00000001) != 0)) {
          output.writeInt32(1, maskHeight_);
        }
        if (((bitField0_ & 0x00000002) != 0)) {
          output.writeInt32(2, maskWidth_);
        }
        if (((bitField0_ & 0x00000004) != 0)) {
          output.writeBool(3, masksAreClassAgnostic_);
        }
        if (((bitField0_ & 0x00000008) != 0)) {
          output.writeInt32(4, maskPredictionConvDepth_);
        }
        if (((bitField0_ & 0x00000010) != 0)) {
          output.writeInt32(5, maskPredictionNumConvLayers_);
        }
        if (((bitField0_ & 0x00000020) != 0)) {
          output.writeBool(6, convolveThenUpsampleMasks_);
        }
        if (((bitField0_ & 0x00000040) != 0)) {
          output.writeFloat(7, maskLossWeight_);
        }
        if (((bitField0_ & 0x00000080) != 0)) {
          output.writeInt32(8, maskLossSampleSize_);
        }
        if (((bitField0_ & 0x00000100) != 0)) {
          output.writeMessage(9, getConvHyperparams());
        }
        if (((bitField0_ & 0x00000200) != 0)) {
          output.writeInt32(10, initialCropSize_);
        }
        unknownFields.writeTo(output);
      }

      @java.lang.Override
      public int getSerializedSize() {
        int size = memoizedSize;
        if (size != -1) return size;

        size = 0;
        if (((bitField0_ & 0x00000001) != 0)) {
          size += com.google.protobuf.CodedOutputStream
            .computeInt32Size(1, maskHeight_);
        }
        if (((bitField0_ & 0x00000002) != 0)) {
          size += com.google.protobuf.CodedOutputStream
            .computeInt32Size(2, maskWidth_);
        }
        if (((bitField0_ & 0x00000004) != 0)) {
          size += com.google.protobuf.CodedOutputStream
            .computeBoolSize(3, masksAreClassAgnostic_);
        }
        if (((bitField0_ & 0x00000008) != 0)) {
          size += com.google.protobuf.CodedOutputStream
            .computeInt32Size(4, maskPredictionConvDepth_);
        }
        if (((bitField0_ & 0x00000010) != 0)) {
          size += com.google.protobuf.CodedOutputStream
            .computeInt32Size(5, maskPredictionNumConvLayers_);
        }
        if (((bitField0_ & 0x00000020) != 0)) {
          size += com.google.protobuf.CodedOutputStream
            .computeBoolSize(6, convolveThenUpsampleMasks_);
        }
        if (((bitField0_ & 0x00000040) != 0)) {
          size += com.google.protobuf.CodedOutputStream
            .computeFloatSize(7, maskLossWeight_);
        }
        if (((bitField0_ & 0x00000080) != 0)) {
          size += com.google.protobuf.CodedOutputStream
            .computeInt32Size(8, maskLossSampleSize_);
        }
        if (((bitField0_ & 0x00000100) != 0)) {
          size += com.google.protobuf.CodedOutputStream
            .computeMessageSize(9, getConvHyperparams());
        }
        if (((bitField0_ & 0x00000200) != 0)) {
          size += com.google.protobuf.CodedOutputStream
            .computeInt32Size(10, initialCropSize_);
        }
        size += unknownFields.getSerializedSize();
        memoizedSize = size;
        return size;
      }

      @java.lang.Override
      public boolean equals(final java.lang.Object obj) {
        if (obj == this) {
         return true;
        }
        if (!(obj instanceof object_detection.protos.SsdOuterClass.Ssd.MaskHead)) {
          return super.equals(obj);
        }
        object_detection.protos.SsdOuterClass.Ssd.MaskHead other = (object_detection.protos.SsdOuterClass.Ssd.MaskHead) obj;

        if (hasMaskHeight() != other.hasMaskHeight()) return false;
        if (hasMaskHeight()) {
          if (getMaskHeight()
              != other.getMaskHeight()) return false;
        }
        if (hasMaskWidth() != other.hasMaskWidth()) return false;
        if (hasMaskWidth()) {
          if (getMaskWidth()
              != other.getMaskWidth()) return false;
        }
        if (hasMasksAreClassAgnostic() != other.hasMasksAreClassAgnostic()) return false;
        if (hasMasksAreClassAgnostic()) {
          if (getMasksAreClassAgnostic()
              != other.getMasksAreClassAgnostic()) return false;
        }
        if (hasMaskPredictionConvDepth() != other.hasMaskPredictionConvDepth()) return false;
        if (hasMaskPredictionConvDepth()) {
          if (getMaskPredictionConvDepth()
              != other.getMaskPredictionConvDepth()) return false;
        }
        if (hasMaskPredictionNumConvLayers() != other.hasMaskPredictionNumConvLayers()) return false;
        if (hasMaskPredictionNumConvLayers()) {
          if (getMaskPredictionNumConvLayers()
              != other.getMaskPredictionNumConvLayers()) return false;
        }
        if (hasConvolveThenUpsampleMasks() != other.hasConvolveThenUpsampleMasks()) return false;
        if (hasConvolveThenUpsampleMasks()) {
          if (getConvolveThenUpsampleMasks()
              != other.getConvolveThenUpsampleMasks()) return false;
        }
        if (hasMaskLossWeight() != other.hasMaskLossWeight()) return false;
        if (hasMaskLossWeight()) {
          if (java.lang.Float.floatToIntBits(getMaskLossWeight())
              != java.lang.Float.floatToIntBits(
                  other.getMaskLossWeight())) return false;
        }
        if (hasMaskLossSampleSize() != other.hasMaskLossSampleSize()) return false;
        if (hasMaskLossSampleSize()) {
          if (getMaskLossSampleSize()
              != other.getMaskLossSampleSize()) return false;
        }
        if (hasConvHyperparams() != other.hasConvHyperparams()) return false;
        if (hasConvHyperparams()) {
          if (!getConvHyperparams()
              .equals(other.getConvHyperparams())) return false;
        }
        if (hasInitialCropSize() != other.hasInitialCropSize()) return false;
        if (hasInitialCropSize()) {
          if (getInitialCropSize()
              != other.getInitialCropSize()) return false;
        }
        if (!unknownFields.equals(other.unknownFields)) return false;
        return true;
      }

      @java.lang.Override
      public int hashCode() {
        if (memoizedHashCode != 0) {
          return memoizedHashCode;
        }
        int hash = 41;
        hash = (19 * hash) + getDescriptor().hashCode();
        if (hasMaskHeight()) {
          hash = (37 * hash) + MASK_HEIGHT_FIELD_NUMBER;
          hash = (53 * hash) + getMaskHeight();
        }
        if (hasMaskWidth()) {
          hash = (37 * hash) + MASK_WIDTH_FIELD_NUMBER;
          hash = (53 * hash) + getMaskWidth();
        }
        if (hasMasksAreClassAgnostic()) {
          hash = (37 * hash) + MASKS_ARE_CLASS_AGNOSTIC_FIELD_NUMBER;
          hash = (53 * hash) + com.google.protobuf.Internal.hashBoolean(
              getMasksAreClassAgnostic());
        }
        if (hasMaskPredictionConvDepth()) {
          hash = (37 * hash) + MASK_PREDICTION_CONV_DEPTH_FIELD_NUMBER;
          hash = (53 * hash) + getMaskPredictionConvDepth();
        }
        if (hasMaskPredictionNumConvLayers()) {
          hash = (37 * hash) + MASK_PREDICTION_NUM_CONV_LAYERS_FIELD_NUMBER;
          hash = (53 * hash) + getMaskPredictionNumConvLayers();
        }
        if (hasConvolveThenUpsampleMasks()) {
          hash = (37 * hash) + CONVOLVE_THEN_UPSAMPLE_MASKS_FIELD_NUMBER;
          hash = (53 * hash) + com.google.protobuf.Internal.hashBoolean(
              getConvolveThenUpsampleMasks());
        }
        if (hasMaskLossWeight()) {
          hash = (37 * hash) + MASK_LOSS_WEIGHT_FIELD_NUMBER;
          hash = (53 * hash) + java.lang.Float.floatToIntBits(
              getMaskLossWeight());
        }
        if (hasMaskLossSampleSize()) {
          hash = (37 * hash) + MASK_LOSS_SAMPLE_SIZE_FIELD_NUMBER;
          hash = (53 * hash) + getMaskLossSampleSize();
        }
        if (hasConvHyperparams()) {
          hash = (37 * hash) + CONV_HYPERPARAMS_FIELD_NUMBER;
          hash = (53 * hash) + getConvHyperparams().hashCode();
        }
        if (hasInitialCropSize()) {
          hash = (37 * hash) + INITIAL_CROP_SIZE_FIELD_NUMBER;
          hash = (53 * hash) + getInitialCropSize();
        }
        hash = (29 * hash) + unknownFields.hashCode();
        memoizedHashCode = hash;
        return hash;
      }

      public static object_detection.protos.SsdOuterClass.Ssd.MaskHead parseFrom(
          java.nio.ByteBuffer data)
          throws com.google.protobuf.InvalidProtocolBufferException {
        return PARSER.parseFrom(data);
      }
      public static object_detection.protos.SsdOuterClass.Ssd.MaskHead parseFrom(
          java.nio.ByteBuffer data,
          com.google.protobuf.ExtensionRegistryLite extensionRegistry)
          throws com.google.protobuf.InvalidProtocolBufferException {
        return PARSER.parseFrom(data, extensionRegistry);
      }
      public static object_detection.protos.SsdOuterClass.Ssd.MaskHead parseFrom(
          com.google.protobuf.ByteString data)
          throws com.google.protobuf.InvalidProtocolBufferException {
        return PARSER.parseFrom(data);
      }
      public static object_detection.protos.SsdOuterClass.Ssd.MaskHead parseFrom(
          com.google.protobuf.ByteString data,
          com.google.protobuf.ExtensionRegistryLite extensionRegistry)
          throws com.google.protobuf.InvalidProtocolBufferException {
        return PARSER.parseFrom(data, extensionRegistry);
      }
      public static object_detection.protos.SsdOuterClass.Ssd.MaskHead parseFrom(byte[] data)
          throws com.google.protobuf.InvalidProtocolBufferException {
        return PARSER.parseFrom(data);
      }
      public static object_detection.protos.SsdOuterClass.Ssd.MaskHead parseFrom(
          byte[] data,
          com.google.protobuf.ExtensionRegistryLite extensionRegistry)
          throws com.google.protobuf.InvalidProtocolBufferException {
        return PARSER.parseFrom(data, extensionRegistry);
      }
      public static object_detection.protos.SsdOuterClass.Ssd.MaskHead parseFrom(java.io.InputStream input)
          throws java.io.IOException {
        return com.google.protobuf.GeneratedMessageV3
            .parseWithIOException(PARSER, input);
      }
      public static object_detection.protos.SsdOuterClass.Ssd.MaskHead parseFrom(
          java.io.InputStream input,
          com.google.protobuf.ExtensionRegistryLite extensionRegistry)
          throws java.io.IOException {
        return com.google.protobuf.GeneratedMessageV3
            .parseWithIOException(PARSER, input, extensionRegistry);
      }
      public static object_detection.protos.SsdOuterClass.Ssd.MaskHead parseDelimitedFrom(java.io.InputStream input)
          throws java.io.IOException {
        return com.google.protobuf.GeneratedMessageV3
            .parseDelimitedWithIOException(PARSER, input);
      }
      public static object_detection.protos.SsdOuterClass.Ssd.MaskHead parseDelimitedFrom(
          java.io.InputStream input,
          com.google.protobuf.ExtensionRegistryLite extensionRegistry)
          throws java.io.IOException {
        return com.google.protobuf.GeneratedMessageV3
            .parseDelimitedWithIOException(PARSER, input, extensionRegistry);
      }
      public static object_detection.protos.SsdOuterClass.Ssd.MaskHead parseFrom(
          com.google.protobuf.CodedInputStream input)
          throws java.io.IOException {
        return com.google.protobuf.GeneratedMessageV3
            .parseWithIOException(PARSER, input);
      }
      public static object_detection.protos.SsdOuterClass.Ssd.MaskHead parseFrom(
          com.google.protobuf.CodedInputStream input,
          com.google.protobuf.ExtensionRegistryLite extensionRegistry)
          throws java.io.IOException {
        return com.google.protobuf.GeneratedMessageV3
            .parseWithIOException(PARSER, input, extensionRegistry);
      }

      @java.lang.Override
      public Builder newBuilderForType() { return newBuilder(); }
      public static Builder newBuilder() {
        return DEFAULT_INSTANCE.toBuilder();
      }
      public static Builder newBuilder(object_detection.protos.SsdOuterClass.Ssd.MaskHead prototype) {
        return DEFAULT_INSTANCE.toBuilder().mergeFrom(prototype);
      }
      @java.lang.Override
      public Builder toBuilder() {
        return this == DEFAULT_INSTANCE
            ? new Builder() : new Builder().mergeFrom(this);
      }

      @java.lang.Override
      protected Builder newBuilderForType(
          com.google.protobuf.GeneratedMessageV3.BuilderParent parent) {
        Builder builder = new Builder(parent);
        return builder;
      }
      /**
       * <pre>
       * Configuration proto for MaskHead.
       * Next id: 11
       * </pre>
       *
       * Protobuf type {@code object_detection.protos.Ssd.MaskHead}
       */
      public static final class Builder extends
          com.google.protobuf.GeneratedMessageV3.Builder<Builder> implements
          // @@protoc_insertion_point(builder_implements:object_detection.protos.Ssd.MaskHead)
          object_detection.protos.SsdOuterClass.Ssd.MaskHeadOrBuilder {
        public static final com.google.protobuf.Descriptors.Descriptor
            getDescriptor() {
          return object_detection.protos.SsdOuterClass.internal_static_object_detection_protos_Ssd_MaskHead_descriptor;
        }

        @java.lang.Override
        protected com.google.protobuf.GeneratedMessageV3.FieldAccessorTable
            internalGetFieldAccessorTable() {
          return object_detection.protos.SsdOuterClass.internal_static_object_detection_protos_Ssd_MaskHead_fieldAccessorTable
              .ensureFieldAccessorsInitialized(
                  object_detection.protos.SsdOuterClass.Ssd.MaskHead.class, object_detection.protos.SsdOuterClass.Ssd.MaskHead.Builder.class);
        }

        // Construct using object_detection.protos.SsdOuterClass.Ssd.MaskHead.newBuilder()
        private Builder() {
          maybeForceBuilderInitialization();
        }

        private Builder(
            com.google.protobuf.GeneratedMessageV3.BuilderParent parent) {
          super(parent);
          maybeForceBuilderInitialization();
        }
        private void maybeForceBuilderInitialization() {
          if (com.google.protobuf.GeneratedMessageV3
                  .alwaysUseFieldBuilders) {
            getConvHyperparamsFieldBuilder();
          }
        }
        @java.lang.Override
        public Builder clear() {
          super.clear();
          maskHeight_ = 15;
          bitField0_ = (bitField0_ & ~0x00000001);
          maskWidth_ = 15;
          bitField0_ = (bitField0_ & ~0x00000002);
          masksAreClassAgnostic_ = true;
          bitField0_ = (bitField0_ & ~0x00000004);
          maskPredictionConvDepth_ = 256;
          bitField0_ = (bitField0_ & ~0x00000008);
          maskPredictionNumConvLayers_ = 2;
          bitField0_ = (bitField0_ & ~0x00000010);
          convolveThenUpsampleMasks_ = false;
          bitField0_ = (bitField0_ & ~0x00000020);
          maskLossWeight_ = 5F;
          bitField0_ = (bitField0_ & ~0x00000040);
          maskLossSampleSize_ = 16;
          bitField0_ = (bitField0_ & ~0x00000080);
          if (convHyperparamsBuilder_ == null) {
            convHyperparams_ = null;
          } else {
            convHyperparamsBuilder_.clear();
          }
          bitField0_ = (bitField0_ & ~0x00000100);
          initialCropSize_ = 15;
          bitField0_ = (bitField0_ & ~0x00000200);
          return this;
        }

        @java.lang.Override
        public com.google.protobuf.Descriptors.Descriptor
            getDescriptorForType() {
          return object_detection.protos.SsdOuterClass.internal_static_object_detection_protos_Ssd_MaskHead_descriptor;
        }

        @java.lang.Override
        public object_detection.protos.SsdOuterClass.Ssd.MaskHead getDefaultInstanceForType() {
          return object_detection.protos.SsdOuterClass.Ssd.MaskHead.getDefaultInstance();
        }

        @java.lang.Override
        public object_detection.protos.SsdOuterClass.Ssd.MaskHead build() {
          object_detection.protos.SsdOuterClass.Ssd.MaskHead result = buildPartial();
          if (!result.isInitialized()) {
            throw newUninitializedMessageException(result);
          }
          return result;
        }

        @java.lang.Override
        public object_detection.protos.SsdOuterClass.Ssd.MaskHead buildPartial() {
          object_detection.protos.SsdOuterClass.Ssd.MaskHead result = new object_detection.protos.SsdOuterClass.Ssd.MaskHead(this);
          int from_bitField0_ = bitField0_;
          int to_bitField0_ = 0;
          if (((from_bitField0_ & 0x00000001) != 0)) {
            to_bitField0_ |= 0x00000001;
          }
          result.maskHeight_ = maskHeight_;
          if (((from_bitField0_ & 0x00000002) != 0)) {
            to_bitField0_ |= 0x00000002;
          }
          result.maskWidth_ = maskWidth_;
          if (((from_bitField0_ & 0x00000004) != 0)) {
            to_bitField0_ |= 0x00000004;
          }
          result.masksAreClassAgnostic_ = masksAreClassAgnostic_;
          if (((from_bitField0_ & 0x00000008) != 0)) {
            to_bitField0_ |= 0x00000008;
          }
          result.maskPredictionConvDepth_ = maskPredictionConvDepth_;
          if (((from_bitField0_ & 0x00000010) != 0)) {
            to_bitField0_ |= 0x00000010;
          }
          result.maskPredictionNumConvLayers_ = maskPredictionNumConvLayers_;
          if (((from_bitField0_ & 0x00000020) != 0)) {
            result.convolveThenUpsampleMasks_ = convolveThenUpsampleMasks_;
            to_bitField0_ |= 0x00000020;
          }
          if (((from_bitField0_ & 0x00000040) != 0)) {
            to_bitField0_ |= 0x00000040;
          }
          result.maskLossWeight_ = maskLossWeight_;
          if (((from_bitField0_ & 0x00000080) != 0)) {
            to_bitField0_ |= 0x00000080;
          }
          result.maskLossSampleSize_ = maskLossSampleSize_;
          if (((from_bitField0_ & 0x00000100) != 0)) {
            if (convHyperparamsBuilder_ == null) {
              result.convHyperparams_ = convHyperparams_;
            } else {
              result.convHyperparams_ = convHyperparamsBuilder_.build();
            }
            to_bitField0_ |= 0x00000100;
          }
          if (((from_bitField0_ & 0x00000200) != 0)) {
            to_bitField0_ |= 0x00000200;
          }
          result.initialCropSize_ = initialCropSize_;
          result.bitField0_ = to_bitField0_;
          onBuilt();
          return result;
        }

        @java.lang.Override
        public Builder clone() {
          return super.clone();
        }
        @java.lang.Override
        public Builder setField(
            com.google.protobuf.Descriptors.FieldDescriptor field,
            java.lang.Object value) {
          return super.setField(field, value);
        }
        @java.lang.Override
        public Builder clearField(
            com.google.protobuf.Descriptors.FieldDescriptor field) {
          return super.clearField(field);
        }
        @java.lang.Override
        public Builder clearOneof(
            com.google.protobuf.Descriptors.OneofDescriptor oneof) {
          return super.clearOneof(oneof);
        }
        @java.lang.Override
        public Builder setRepeatedField(
            com.google.protobuf.Descriptors.FieldDescriptor field,
            int index, java.lang.Object value) {
          return super.setRepeatedField(field, index, value);
        }
        @java.lang.Override
        public Builder addRepeatedField(
            com.google.protobuf.Descriptors.FieldDescriptor field,
            java.lang.Object value) {
          return super.addRepeatedField(field, value);
        }
        @java.lang.Override
        public Builder mergeFrom(com.google.protobuf.Message other) {
          if (other instanceof object_detection.protos.SsdOuterClass.Ssd.MaskHead) {
            return mergeFrom((object_detection.protos.SsdOuterClass.Ssd.MaskHead)other);
          } else {
            super.mergeFrom(other);
            return this;
          }
        }

        public Builder mergeFrom(object_detection.protos.SsdOuterClass.Ssd.MaskHead other) {
          if (other == object_detection.protos.SsdOuterClass.Ssd.MaskHead.getDefaultInstance()) return this;
          if (other.hasMaskHeight()) {
            setMaskHeight(other.getMaskHeight());
          }
          if (other.hasMaskWidth()) {
            setMaskWidth(other.getMaskWidth());
          }
          if (other.hasMasksAreClassAgnostic()) {
            setMasksAreClassAgnostic(other.getMasksAreClassAgnostic());
          }
          if (other.hasMaskPredictionConvDepth()) {
            setMaskPredictionConvDepth(other.getMaskPredictionConvDepth());
          }
          if (other.hasMaskPredictionNumConvLayers()) {
            setMaskPredictionNumConvLayers(other.getMaskPredictionNumConvLayers());
          }
          if (other.hasConvolveThenUpsampleMasks()) {
            setConvolveThenUpsampleMasks(other.getConvolveThenUpsampleMasks());
          }
          if (other.hasMaskLossWeight()) {
            setMaskLossWeight(other.getMaskLossWeight());
          }
          if (other.hasMaskLossSampleSize()) {
            setMaskLossSampleSize(other.getMaskLossSampleSize());
          }
          if (other.hasConvHyperparams()) {
            mergeConvHyperparams(other.getConvHyperparams());
          }
          if (other.hasInitialCropSize()) {
            setInitialCropSize(other.getInitialCropSize());
          }
          this.mergeUnknownFields(other.unknownFields);
          onChanged();
          return this;
        }

        @java.lang.Override
        public final boolean isInitialized() {
          return true;
        }

        @java.lang.Override
        public Builder mergeFrom(
            com.google.protobuf.CodedInputStream input,
            com.google.protobuf.ExtensionRegistryLite extensionRegistry)
            throws java.io.IOException {
          object_detection.protos.SsdOuterClass.Ssd.MaskHead parsedMessage = null;
          try {
            parsedMessage = PARSER.parsePartialFrom(input, extensionRegistry);
          } catch (com.google.protobuf.InvalidProtocolBufferException e) {
            parsedMessage = (object_detection.protos.SsdOuterClass.Ssd.MaskHead) e.getUnfinishedMessage();
            throw e.unwrapIOException();
          } finally {
            if (parsedMessage != null) {
              mergeFrom(parsedMessage);
            }
          }
          return this;
        }
        private int bitField0_;

        private int maskHeight_ = 15;
        /**
         * <pre>
         * The height and the width of the predicted mask. Only used when
         * predict_instance_masks is true.
         * </pre>
         *
         * <code>optional int32 mask_height = 1 [default = 15];</code>
         * @return Whether the maskHeight field is set.
         */
        @java.lang.Override
        public boolean hasMaskHeight() {
          return ((bitField0_ & 0x00000001) != 0);
        }
        /**
         * <pre>
         * The height and the width of the predicted mask. Only used when
         * predict_instance_masks is true.
         * </pre>
         *
         * <code>optional int32 mask_height = 1 [default = 15];</code>
         * @return The maskHeight.
         */
        @java.lang.Override
        public int getMaskHeight() {
          return maskHeight_;
        }
        /**
         * <pre>
         * The height and the width of the predicted mask. Only used when
         * predict_instance_masks is true.
         * </pre>
         *
         * <code>optional int32 mask_height = 1 [default = 15];</code>
         * @param value The maskHeight to set.
         * @return This builder for chaining.
         */
        public Builder setMaskHeight(int value) {
          bitField0_ |= 0x00000001;
          maskHeight_ = value;
          onChanged();
          return this;
        }
        /**
         * <pre>
         * The height and the width of the predicted mask. Only used when
         * predict_instance_masks is true.
         * </pre>
         *
         * <code>optional int32 mask_height = 1 [default = 15];</code>
         * @return This builder for chaining.
         */
        public Builder clearMaskHeight() {
          bitField0_ = (bitField0_ & ~0x00000001);
          maskHeight_ = 15;
          onChanged();
          return this;
        }

        private int maskWidth_ = 15;
        /**
         * <code>optional int32 mask_width = 2 [default = 15];</code>
         * @return Whether the maskWidth field is set.
         */
        @java.lang.Override
        public boolean hasMaskWidth() {
          return ((bitField0_ & 0x00000002) != 0);
        }
        /**
         * <code>optional int32 mask_width = 2 [default = 15];</code>
         * @return The maskWidth.
         */
        @java.lang.Override
        public int getMaskWidth() {
          return maskWidth_;
        }
        /**
         * <code>optional int32 mask_width = 2 [default = 15];</code>
         * @param value The maskWidth to set.
         * @return This builder for chaining.
         */
        public Builder setMaskWidth(int value) {
          bitField0_ |= 0x00000002;
          maskWidth_ = value;
          onChanged();
          return this;
        }
        /**
         * <code>optional int32 mask_width = 2 [default = 15];</code>
         * @return This builder for chaining.
         */
        public Builder clearMaskWidth() {
          bitField0_ = (bitField0_ & ~0x00000002);
          maskWidth_ = 15;
          onChanged();
          return this;
        }

        private boolean masksAreClassAgnostic_ = true;
        /**
         * <pre>
         * Whether to predict class agnostic masks. Only used when
         * predict_instance_masks is true.
         * </pre>
         *
         * <code>optional bool masks_are_class_agnostic = 3 [default = true];</code>
         * @return Whether the masksAreClassAgnostic field is set.
         */
        @java.lang.Override
        public boolean hasMasksAreClassAgnostic() {
          return ((bitField0_ & 0x00000004) != 0);
        }
        /**
         * <pre>
         * Whether to predict class agnostic masks. Only used when
         * predict_instance_masks is true.
         * </pre>
         *
         * <code>optional bool masks_are_class_agnostic = 3 [default = true];</code>
         * @return The masksAreClassAgnostic.
         */
        @java.lang.Override
        public boolean getMasksAreClassAgnostic() {
          return masksAreClassAgnostic_;
        }
        /**
         * <pre>
         * Whether to predict class agnostic masks. Only used when
         * predict_instance_masks is true.
         * </pre>
         *
         * <code>optional bool masks_are_class_agnostic = 3 [default = true];</code>
         * @param value The masksAreClassAgnostic to set.
         * @return This builder for chaining.
         */
        public Builder setMasksAreClassAgnostic(boolean value) {
          bitField0_ |= 0x00000004;
          masksAreClassAgnostic_ = value;
          onChanged();
          return this;
        }
        /**
         * <pre>
         * Whether to predict class agnostic masks. Only used when
         * predict_instance_masks is true.
         * </pre>
         *
         * <code>optional bool masks_are_class_agnostic = 3 [default = true];</code>
         * @return This builder for chaining.
         */
        public Builder clearMasksAreClassAgnostic() {
          bitField0_ = (bitField0_ & ~0x00000004);
          masksAreClassAgnostic_ = true;
          onChanged();
          return this;
        }

        private int maskPredictionConvDepth_ = 256;
        /**
         * <pre>
         * The depth for the first conv2d_transpose op applied to the
         * image_features in the mask prediction branch. If set to 0, the value
         * will be set automatically based on the number of channels in the image
         * features and the number of classes.
         * </pre>
         *
         * <code>optional int32 mask_prediction_conv_depth = 4 [default = 256];</code>
         * @return Whether the maskPredictionConvDepth field is set.
         */
        @java.lang.Override
        public boolean hasMaskPredictionConvDepth() {
          return ((bitField0_ & 0x00000008) != 0);
        }
        /**
         * <pre>
         * The depth for the first conv2d_transpose op applied to the
         * image_features in the mask prediction branch. If set to 0, the value
         * will be set automatically based on the number of channels in the image
         * features and the number of classes.
         * </pre>
         *
         * <code>optional int32 mask_prediction_conv_depth = 4 [default = 256];</code>
         * @return The maskPredictionConvDepth.
         */
        @java.lang.Override
        public int getMaskPredictionConvDepth() {
          return maskPredictionConvDepth_;
        }
        /**
         * <pre>
         * The depth for the first conv2d_transpose op applied to the
         * image_features in the mask prediction branch. If set to 0, the value
         * will be set automatically based on the number of channels in the image
         * features and the number of classes.
         * </pre>
         *
         * <code>optional int32 mask_prediction_conv_depth = 4 [default = 256];</code>
         * @param value The maskPredictionConvDepth to set.
         * @return This builder for chaining.
         */
        public Builder setMaskPredictionConvDepth(int value) {
          bitField0_ |= 0x00000008;
          maskPredictionConvDepth_ = value;
          onChanged();
          return this;
        }
        /**
         * <pre>
         * The depth for the first conv2d_transpose op applied to the
         * image_features in the mask prediction branch. If set to 0, the value
         * will be set automatically based on the number of channels in the image
         * features and the number of classes.
         * </pre>
         *
         * <code>optional int32 mask_prediction_conv_depth = 4 [default = 256];</code>
         * @return This builder for chaining.
         */
        public Builder clearMaskPredictionConvDepth() {
          bitField0_ = (bitField0_ & ~0x00000008);
          maskPredictionConvDepth_ = 256;
          onChanged();
          return this;
        }

        private int maskPredictionNumConvLayers_ = 2;
        /**
         * <pre>
         * The number of convolutions applied to image_features in the mask
         * prediction branch.
         * </pre>
         *
         * <code>optional int32 mask_prediction_num_conv_layers = 5 [default = 2];</code>
         * @return Whether the maskPredictionNumConvLayers field is set.
         */
        @java.lang.Override
        public boolean hasMaskPredictionNumConvLayers() {
          return ((bitField0_ & 0x00000010) != 0);
        }
        /**
         * <pre>
         * The number of convolutions applied to image_features in the mask
         * prediction branch.
         * </pre>
         *
         * <code>optional int32 mask_prediction_num_conv_layers = 5 [default = 2];</code>
         * @return The maskPredictionNumConvLayers.
         */
        @java.lang.Override
        public int getMaskPredictionNumConvLayers() {
          return maskPredictionNumConvLayers_;
        }
        /**
         * <pre>
         * The number of convolutions applied to image_features in the mask
         * prediction branch.
         * </pre>
         *
         * <code>optional int32 mask_prediction_num_conv_layers = 5 [default = 2];</code>
         * @param value The maskPredictionNumConvLayers to set.
         * @return This builder for chaining.
         */
        public Builder setMaskPredictionNumConvLayers(int value) {
          bitField0_ |= 0x00000010;
          maskPredictionNumConvLayers_ = value;
          onChanged();
          return this;
        }
        /**
         * <pre>
         * The number of convolutions applied to image_features in the mask
         * prediction branch.
         * </pre>
         *
         * <code>optional int32 mask_prediction_num_conv_layers = 5 [default = 2];</code>
         * @return This builder for chaining.
         */
        public Builder clearMaskPredictionNumConvLayers() {
          bitField0_ = (bitField0_ & ~0x00000010);
          maskPredictionNumConvLayers_ = 2;
          onChanged();
          return this;
        }

        private boolean convolveThenUpsampleMasks_ ;
        /**
         * <pre>
         * Whether to apply convolutions on mask features before upsampling using
         * nearest neighbor resizing.
         * By default, mask features are resized to [`mask_height`, `mask_width`]
         * before applying convolutions and predicting masks.
         * </pre>
         *
         * <code>optional bool convolve_then_upsample_masks = 6 [default = false];</code>
         * @return Whether the convolveThenUpsampleMasks field is set.
         */
        @java.lang.Override
        public boolean hasConvolveThenUpsampleMasks() {
          return ((bitField0_ & 0x00000020) != 0);
        }
        /**
         * <pre>
         * Whether to apply convolutions on mask features before upsampling using
         * nearest neighbor resizing.
         * By default, mask features are resized to [`mask_height`, `mask_width`]
         * before applying convolutions and predicting masks.
         * </pre>
         *
         * <code>optional bool convolve_then_upsample_masks = 6 [default = false];</code>
         * @return The convolveThenUpsampleMasks.
         */
        @java.lang.Override
        public boolean getConvolveThenUpsampleMasks() {
          return convolveThenUpsampleMasks_;
        }
        /**
         * <pre>
         * Whether to apply convolutions on mask features before upsampling using
         * nearest neighbor resizing.
         * By default, mask features are resized to [`mask_height`, `mask_width`]
         * before applying convolutions and predicting masks.
         * </pre>
         *
         * <code>optional bool convolve_then_upsample_masks = 6 [default = false];</code>
         * @param value The convolveThenUpsampleMasks to set.
         * @return This builder for chaining.
         */
        public Builder setConvolveThenUpsampleMasks(boolean value) {
          bitField0_ |= 0x00000020;
          convolveThenUpsampleMasks_ = value;
          onChanged();
          return this;
        }
        /**
         * <pre>
         * Whether to apply convolutions on mask features before upsampling using
         * nearest neighbor resizing.
         * By default, mask features are resized to [`mask_height`, `mask_width`]
         * before applying convolutions and predicting masks.
         * </pre>
         *
         * <code>optional bool convolve_then_upsample_masks = 6 [default = false];</code>
         * @return This builder for chaining.
         */
        public Builder clearConvolveThenUpsampleMasks() {
          bitField0_ = (bitField0_ & ~0x00000020);
          convolveThenUpsampleMasks_ = false;
          onChanged();
          return this;
        }

        private float maskLossWeight_ = 5F;
        /**
         * <pre>
         * Mask loss weight.
         * </pre>
         *
         * <code>optional float mask_loss_weight = 7 [default = 5];</code>
         * @return Whether the maskLossWeight field is set.
         */
        @java.lang.Override
        public boolean hasMaskLossWeight() {
          return ((bitField0_ & 0x00000040) != 0);
        }
        /**
         * <pre>
         * Mask loss weight.
         * </pre>
         *
         * <code>optional float mask_loss_weight = 7 [default = 5];</code>
         * @return The maskLossWeight.
         */
        @java.lang.Override
        public float getMaskLossWeight() {
          return maskLossWeight_;
        }
        /**
         * <pre>
         * Mask loss weight.
         * </pre>
         *
         * <code>optional float mask_loss_weight = 7 [default = 5];</code>
         * @param value The maskLossWeight to set.
         * @return This builder for chaining.
         */
        public Builder setMaskLossWeight(float value) {
          bitField0_ |= 0x00000040;
          maskLossWeight_ = value;
          onChanged();
          return this;
        }
        /**
         * <pre>
         * Mask loss weight.
         * </pre>
         *
         * <code>optional float mask_loss_weight = 7 [default = 5];</code>
         * @return This builder for chaining.
         */
        public Builder clearMaskLossWeight() {
          bitField0_ = (bitField0_ & ~0x00000040);
          maskLossWeight_ = 5F;
          onChanged();
          return this;
        }

        private int maskLossSampleSize_ = 16;
        /**
         * <pre>
         * Number of boxes to be generated at training time for computing mask loss.
         * </pre>
         *
         * <code>optional int32 mask_loss_sample_size = 8 [default = 16];</code>
         * @return Whether the maskLossSampleSize field is set.
         */
        @java.lang.Override
        public boolean hasMaskLossSampleSize() {
          return ((bitField0_ & 0x00000080) != 0);
        }
        /**
         * <pre>
         * Number of boxes to be generated at training time for computing mask loss.
         * </pre>
         *
         * <code>optional int32 mask_loss_sample_size = 8 [default = 16];</code>
         * @return The maskLossSampleSize.
         */
        @java.lang.Override
        public int getMaskLossSampleSize() {
          return maskLossSampleSize_;
        }
        /**
         * <pre>
         * Number of boxes to be generated at training time for computing mask loss.
         * </pre>
         *
         * <code>optional int32 mask_loss_sample_size = 8 [default = 16];</code>
         * @param value The maskLossSampleSize to set.
         * @return This builder for chaining.
         */
        public Builder setMaskLossSampleSize(int value) {
          bitField0_ |= 0x00000080;
          maskLossSampleSize_ = value;
          onChanged();
          return this;
        }
        /**
         * <pre>
         * Number of boxes to be generated at training time for computing mask loss.
         * </pre>
         *
         * <code>optional int32 mask_loss_sample_size = 8 [default = 16];</code>
         * @return This builder for chaining.
         */
        public Builder clearMaskLossSampleSize() {
          bitField0_ = (bitField0_ & ~0x00000080);
          maskLossSampleSize_ = 16;
          onChanged();
          return this;
        }

        private object_detection.protos.HyperparamsOuterClass.Hyperparams convHyperparams_;
        private com.google.protobuf.SingleFieldBuilderV3<
            object_detection.protos.HyperparamsOuterClass.Hyperparams, object_detection.protos.HyperparamsOuterClass.Hyperparams.Builder, object_detection.protos.HyperparamsOuterClass.HyperparamsOrBuilder> convHyperparamsBuilder_;
        /**
         * <pre>
         * Hyperparameters for convolution ops used in the box predictor.
         * </pre>
         *
         * <code>optional .object_detection.protos.Hyperparams conv_hyperparams = 9;</code>
         * @return Whether the convHyperparams field is set.
         */
        public boolean hasConvHyperparams() {
          return ((bitField0_ & 0x00000100) != 0);
        }
        /**
         * <pre>
         * Hyperparameters for convolution ops used in the box predictor.
         * </pre>
         *
         * <code>optional .object_detection.protos.Hyperparams conv_hyperparams = 9;</code>
         * @return The convHyperparams.
         */
        public object_detection.protos.HyperparamsOuterClass.Hyperparams getConvHyperparams() {
          if (convHyperparamsBuilder_ == null) {
            return convHyperparams_ == null ? object_detection.protos.HyperparamsOuterClass.Hyperparams.getDefaultInstance() : convHyperparams_;
          } else {
            return convHyperparamsBuilder_.getMessage();
          }
        }
        /**
         * <pre>
         * Hyperparameters for convolution ops used in the box predictor.
         * </pre>
         *
         * <code>optional .object_detection.protos.Hyperparams conv_hyperparams = 9;</code>
         */
        public Builder setConvHyperparams(object_detection.protos.HyperparamsOuterClass.Hyperparams value) {
          if (convHyperparamsBuilder_ == null) {
            if (value == null) {
              throw new NullPointerException();
            }
            convHyperparams_ = value;
            onChanged();
          } else {
            convHyperparamsBuilder_.setMessage(value);
          }
          bitField0_ |= 0x00000100;
          return this;
        }
        /**
         * <pre>
         * Hyperparameters for convolution ops used in the box predictor.
         * </pre>
         *
         * <code>optional .object_detection.protos.Hyperparams conv_hyperparams = 9;</code>
         */
        public Builder setConvHyperparams(
            object_detection.protos.HyperparamsOuterClass.Hyperparams.Builder builderForValue) {
          if (convHyperparamsBuilder_ == null) {
            convHyperparams_ = builderForValue.build();
            onChanged();
          } else {
            convHyperparamsBuilder_.setMessage(builderForValue.build());
          }
          bitField0_ |= 0x00000100;
          return this;
        }
        /**
         * <pre>
         * Hyperparameters for convolution ops used in the box predictor.
         * </pre>
         *
         * <code>optional .object_detection.protos.Hyperparams conv_hyperparams = 9;</code>
         */
        public Builder mergeConvHyperparams(object_detection.protos.HyperparamsOuterClass.Hyperparams value) {
          if (convHyperparamsBuilder_ == null) {
            if (((bitField0_ & 0x00000100) != 0) &&
                convHyperparams_ != null &&
                convHyperparams_ != object_detection.protos.HyperparamsOuterClass.Hyperparams.getDefaultInstance()) {
              convHyperparams_ =
                object_detection.protos.HyperparamsOuterClass.Hyperparams.newBuilder(convHyperparams_).mergeFrom(value).buildPartial();
            } else {
              convHyperparams_ = value;
            }
            onChanged();
          } else {
            convHyperparamsBuilder_.mergeFrom(value);
          }
          bitField0_ |= 0x00000100;
          return this;
        }
        /**
         * <pre>
         * Hyperparameters for convolution ops used in the box predictor.
         * </pre>
         *
         * <code>optional .object_detection.protos.Hyperparams conv_hyperparams = 9;</code>
         */
        public Builder clearConvHyperparams() {
          if (convHyperparamsBuilder_ == null) {
            convHyperparams_ = null;
            onChanged();
          } else {
            convHyperparamsBuilder_.clear();
          }
          bitField0_ = (bitField0_ & ~0x00000100);
          return this;
        }
        /**
         * <pre>
         * Hyperparameters for convolution ops used in the box predictor.
         * </pre>
         *
         * <code>optional .object_detection.protos.Hyperparams conv_hyperparams = 9;</code>
         */
        public object_detection.protos.HyperparamsOuterClass.Hyperparams.Builder getConvHyperparamsBuilder() {
          bitField0_ |= 0x00000100;
          onChanged();
          return getConvHyperparamsFieldBuilder().getBuilder();
        }
        /**
         * <pre>
         * Hyperparameters for convolution ops used in the box predictor.
         * </pre>
         *
         * <code>optional .object_detection.protos.Hyperparams conv_hyperparams = 9;</code>
         */
        public object_detection.protos.HyperparamsOuterClass.HyperparamsOrBuilder getConvHyperparamsOrBuilder() {
          if (convHyperparamsBuilder_ != null) {
            return convHyperparamsBuilder_.getMessageOrBuilder();
          } else {
            return convHyperparams_ == null ?
                object_detection.protos.HyperparamsOuterClass.Hyperparams.getDefaultInstance() : convHyperparams_;
          }
        }
        /**
         * <pre>
         * Hyperparameters for convolution ops used in the box predictor.
         * </pre>
         *
         * <code>optional .object_detection.protos.Hyperparams conv_hyperparams = 9;</code>
         */
        private com.google.protobuf.SingleFieldBuilderV3<
            object_detection.protos.HyperparamsOuterClass.Hyperparams, object_detection.protos.HyperparamsOuterClass.Hyperparams.Builder, object_detection.protos.HyperparamsOuterClass.HyperparamsOrBuilder>
            getConvHyperparamsFieldBuilder() {
          if (convHyperparamsBuilder_ == null) {
            convHyperparamsBuilder_ = new com.google.protobuf.SingleFieldBuilderV3<
                object_detection.protos.HyperparamsOuterClass.Hyperparams, object_detection.protos.HyperparamsOuterClass.Hyperparams.Builder, object_detection.protos.HyperparamsOuterClass.HyperparamsOrBuilder>(
                    getConvHyperparams(),
                    getParentForChildren(),
                    isClean());
            convHyperparams_ = null;
          }
          return convHyperparamsBuilder_;
        }

        private int initialCropSize_ = 15;
        /**
         * <pre>
         * Output size (width and height are set to be the same) of the initial
         * bilinear interpolation based cropping during ROI pooling. Only used when
         * we have second stage prediction head enabled (e.g. mask head).
         * </pre>
         *
         * <code>optional int32 initial_crop_size = 10 [default = 15];</code>
         * @return Whether the initialCropSize field is set.
         */
        @java.lang.Override
        public boolean hasInitialCropSize() {
          return ((bitField0_ & 0x00000200) != 0);
        }
        /**
         * <pre>
         * Output size (width and height are set to be the same) of the initial
         * bilinear interpolation based cropping during ROI pooling. Only used when
         * we have second stage prediction head enabled (e.g. mask head).
         * </pre>
         *
         * <code>optional int32 initial_crop_size = 10 [default = 15];</code>
         * @return The initialCropSize.
         */
        @java.lang.Override
        public int getInitialCropSize() {
          return initialCropSize_;
        }
        /**
         * <pre>
         * Output size (width and height are set to be the same) of the initial
         * bilinear interpolation based cropping during ROI pooling. Only used when
         * we have second stage prediction head enabled (e.g. mask head).
         * </pre>
         *
         * <code>optional int32 initial_crop_size = 10 [default = 15];</code>
         * @param value The initialCropSize to set.
         * @return This builder for chaining.
         */
        public Builder setInitialCropSize(int value) {
          bitField0_ |= 0x00000200;
          initialCropSize_ = value;
          onChanged();
          return this;
        }
        /**
         * <pre>
         * Output size (width and height are set to be the same) of the initial
         * bilinear interpolation based cropping during ROI pooling. Only used when
         * we have second stage prediction head enabled (e.g. mask head).
         * </pre>
         *
         * <code>optional int32 initial_crop_size = 10 [default = 15];</code>
         * @return This builder for chaining.
         */
        public Builder clearInitialCropSize() {
          bitField0_ = (bitField0_ & ~0x00000200);
          initialCropSize_ = 15;
          onChanged();
          return this;
        }
        @java.lang.Override
        public final Builder setUnknownFields(
            final com.google.protobuf.UnknownFieldSet unknownFields) {
          return super.setUnknownFields(unknownFields);
        }

        @java.lang.Override
        public final Builder mergeUnknownFields(
            final com.google.protobuf.UnknownFieldSet unknownFields) {
          return super.mergeUnknownFields(unknownFields);
        }


        // @@protoc_insertion_point(builder_scope:object_detection.protos.Ssd.MaskHead)
      }

      // @@protoc_insertion_point(class_scope:object_detection.protos.Ssd.MaskHead)
      private static final object_detection.protos.SsdOuterClass.Ssd.MaskHead DEFAULT_INSTANCE;
      static {
        DEFAULT_INSTANCE = new object_detection.protos.SsdOuterClass.Ssd.MaskHead();
      }

      public static object_detection.protos.SsdOuterClass.Ssd.MaskHead getDefaultInstance() {
        return DEFAULT_INSTANCE;
      }

      @java.lang.Deprecated public static final com.google.protobuf.Parser<MaskHead>
          PARSER = new com.google.protobuf.AbstractParser<MaskHead>() {
        @java.lang.Override
        public MaskHead parsePartialFrom(
            com.google.protobuf.CodedInputStream input,
            com.google.protobuf.ExtensionRegistryLite extensionRegistry)
            throws com.google.protobuf.InvalidProtocolBufferException {
          return new MaskHead(input, extensionRegistry);
        }
      };

      public static com.google.protobuf.Parser<MaskHead> parser() {
        return PARSER;
      }

      @java.lang.Override
      public com.google.protobuf.Parser<MaskHead> getParserForType() {
        return PARSER;
      }

      @java.lang.Override
      public object_detection.protos.SsdOuterClass.Ssd.MaskHead getDefaultInstanceForType() {
        return DEFAULT_INSTANCE;
      }

    }

    private int bitField0_;
    public static final int NUM_CLASSES_FIELD_NUMBER = 1;
    private int numClasses_;
    /**
     * <pre>
     * Number of classes to predict.
     * </pre>
     *
     * <code>optional int32 num_classes = 1;</code>
     * @return Whether the numClasses field is set.
     */
    @java.lang.Override
    public boolean hasNumClasses() {
      return ((bitField0_ & 0x00000001) != 0);
    }
    /**
     * <pre>
     * Number of classes to predict.
     * </pre>
     *
     * <code>optional int32 num_classes = 1;</code>
     * @return The numClasses.
     */
    @java.lang.Override
    public int getNumClasses() {
      return numClasses_;
    }

    public static final int IMAGE_RESIZER_FIELD_NUMBER = 2;
    private object_detection.protos.ImageResizerOuterClass.ImageResizer imageResizer_;
    /**
     * <pre>
     * Image resizer for preprocessing the input image.
     * </pre>
     *
     * <code>optional .object_detection.protos.ImageResizer image_resizer = 2;</code>
     * @return Whether the imageResizer field is set.
     */
    @java.lang.Override
    public boolean hasImageResizer() {
      return ((bitField0_ & 0x00000002) != 0);
    }
    /**
     * <pre>
     * Image resizer for preprocessing the input image.
     * </pre>
     *
     * <code>optional .object_detection.protos.ImageResizer image_resizer = 2;</code>
     * @return The imageResizer.
     */
    @java.lang.Override
    public object_detection.protos.ImageResizerOuterClass.ImageResizer getImageResizer() {
      return imageResizer_ == null ? object_detection.protos.ImageResizerOuterClass.ImageResizer.getDefaultInstance() : imageResizer_;
    }
    /**
     * <pre>
     * Image resizer for preprocessing the input image.
     * </pre>
     *
     * <code>optional .object_detection.protos.ImageResizer image_resizer = 2;</code>
     */
    @java.lang.Override
    public object_detection.protos.ImageResizerOuterClass.ImageResizerOrBuilder getImageResizerOrBuilder() {
      return imageResizer_ == null ? object_detection.protos.ImageResizerOuterClass.ImageResizer.getDefaultInstance() : imageResizer_;
    }

    public static final int FEATURE_EXTRACTOR_FIELD_NUMBER = 3;
    private object_detection.protos.SsdOuterClass.SsdFeatureExtractor featureExtractor_;
    /**
     * <pre>
     * Feature extractor config.
     * </pre>
     *
     * <code>optional .object_detection.protos.SsdFeatureExtractor feature_extractor = 3;</code>
     * @return Whether the featureExtractor field is set.
     */
    @java.lang.Override
    public boolean hasFeatureExtractor() {
      return ((bitField0_ & 0x00000004) != 0);
    }
    /**
     * <pre>
     * Feature extractor config.
     * </pre>
     *
     * <code>optional .object_detection.protos.SsdFeatureExtractor feature_extractor = 3;</code>
     * @return The featureExtractor.
     */
    @java.lang.Override
    public object_detection.protos.SsdOuterClass.SsdFeatureExtractor getFeatureExtractor() {
      return featureExtractor_ == null ? object_detection.protos.SsdOuterClass.SsdFeatureExtractor.getDefaultInstance() : featureExtractor_;
    }
    /**
     * <pre>
     * Feature extractor config.
     * </pre>
     *
     * <code>optional .object_detection.protos.SsdFeatureExtractor feature_extractor = 3;</code>
     */
    @java.lang.Override
    public object_detection.protos.SsdOuterClass.SsdFeatureExtractorOrBuilder getFeatureExtractorOrBuilder() {
      return featureExtractor_ == null ? object_detection.protos.SsdOuterClass.SsdFeatureExtractor.getDefaultInstance() : featureExtractor_;
    }

    public static final int BOX_CODER_FIELD_NUMBER = 4;
    private object_detection.protos.BoxCoderOuterClass.BoxCoder boxCoder_;
    /**
     * <pre>
     * Box coder to encode the boxes.
     * </pre>
     *
     * <code>optional .object_detection.protos.BoxCoder box_coder = 4;</code>
     * @return Whether the boxCoder field is set.
     */
    @java.lang.Override
    public boolean hasBoxCoder() {
      return ((bitField0_ & 0x00000008) != 0);
    }
    /**
     * <pre>
     * Box coder to encode the boxes.
     * </pre>
     *
     * <code>optional .object_detection.protos.BoxCoder box_coder = 4;</code>
     * @return The boxCoder.
     */
    @java.lang.Override
    public object_detection.protos.BoxCoderOuterClass.BoxCoder getBoxCoder() {
      return boxCoder_ == null ? object_detection.protos.BoxCoderOuterClass.BoxCoder.getDefaultInstance() : boxCoder_;
    }
    /**
     * <pre>
     * Box coder to encode the boxes.
     * </pre>
     *
     * <code>optional .object_detection.protos.BoxCoder box_coder = 4;</code>
     */
    @java.lang.Override
    public object_detection.protos.BoxCoderOuterClass.BoxCoderOrBuilder getBoxCoderOrBuilder() {
      return boxCoder_ == null ? object_detection.protos.BoxCoderOuterClass.BoxCoder.getDefaultInstance() : boxCoder_;
    }

    public static final int MATCHER_FIELD_NUMBER = 5;
    private object_detection.protos.MatcherOuterClass.Matcher matcher_;
    /**
     * <pre>
     * Matcher to match groundtruth with anchors.
     * </pre>
     *
     * <code>optional .object_detection.protos.Matcher matcher = 5;</code>
     * @return Whether the matcher field is set.
     */
    @java.lang.Override
    public boolean hasMatcher() {
      return ((bitField0_ & 0x00000010) != 0);
    }
    /**
     * <pre>
     * Matcher to match groundtruth with anchors.
     * </pre>
     *
     * <code>optional .object_detection.protos.Matcher matcher = 5;</code>
     * @return The matcher.
     */
    @java.lang.Override
    public object_detection.protos.MatcherOuterClass.Matcher getMatcher() {
      return matcher_ == null ? object_detection.protos.MatcherOuterClass.Matcher.getDefaultInstance() : matcher_;
    }
    /**
     * <pre>
     * Matcher to match groundtruth with anchors.
     * </pre>
     *
     * <code>optional .object_detection.protos.Matcher matcher = 5;</code>
     */
    @java.lang.Override
    public object_detection.protos.MatcherOuterClass.MatcherOrBuilder getMatcherOrBuilder() {
      return matcher_ == null ? object_detection.protos.MatcherOuterClass.Matcher.getDefaultInstance() : matcher_;
    }

    public static final int SIMILARITY_CALCULATOR_FIELD_NUMBER = 6;
    private object_detection.protos.RegionSimilarityCalculatorOuterClass.RegionSimilarityCalculator similarityCalculator_;
    /**
     * <pre>
     * Region similarity calculator to compute similarity of boxes.
     * </pre>
     *
     * <code>optional .object_detection.protos.RegionSimilarityCalculator similarity_calculator = 6;</code>
     * @return Whether the similarityCalculator field is set.
     */
    @java.lang.Override
    public boolean hasSimilarityCalculator() {
      return ((bitField0_ & 0x00000020) != 0);
    }
    /**
     * <pre>
     * Region similarity calculator to compute similarity of boxes.
     * </pre>
     *
     * <code>optional .object_detection.protos.RegionSimilarityCalculator similarity_calculator = 6;</code>
     * @return The similarityCalculator.
     */
    @java.lang.Override
    public object_detection.protos.RegionSimilarityCalculatorOuterClass.RegionSimilarityCalculator getSimilarityCalculator() {
      return similarityCalculator_ == null ? object_detection.protos.RegionSimilarityCalculatorOuterClass.RegionSimilarityCalculator.getDefaultInstance() : similarityCalculator_;
    }
    /**
     * <pre>
     * Region similarity calculator to compute similarity of boxes.
     * </pre>
     *
     * <code>optional .object_detection.protos.RegionSimilarityCalculator similarity_calculator = 6;</code>
     */
    @java.lang.Override
    public object_detection.protos.RegionSimilarityCalculatorOuterClass.RegionSimilarityCalculatorOrBuilder getSimilarityCalculatorOrBuilder() {
      return similarityCalculator_ == null ? object_detection.protos.RegionSimilarityCalculatorOuterClass.RegionSimilarityCalculator.getDefaultInstance() : similarityCalculator_;
    }

    public static final int ENCODE_BACKGROUND_AS_ZEROS_FIELD_NUMBER = 12;
    private boolean encodeBackgroundAsZeros_;
    /**
     * <pre>
     * Whether background targets are to be encoded as an all
     * zeros vector or a one-hot vector (where background is the 0th class).
     * </pre>
     *
     * <code>optional bool encode_background_as_zeros = 12 [default = false];</code>
     * @return Whether the encodeBackgroundAsZeros field is set.
     */
    @java.lang.Override
    public boolean hasEncodeBackgroundAsZeros() {
      return ((bitField0_ & 0x00000040) != 0);
    }
    /**
     * <pre>
     * Whether background targets are to be encoded as an all
     * zeros vector or a one-hot vector (where background is the 0th class).
     * </pre>
     *
     * <code>optional bool encode_background_as_zeros = 12 [default = false];</code>
     * @return The encodeBackgroundAsZeros.
     */
    @java.lang.Override
    public boolean getEncodeBackgroundAsZeros() {
      return encodeBackgroundAsZeros_;
    }

    public static final int NEGATIVE_CLASS_WEIGHT_FIELD_NUMBER = 13;
    private float negativeClassWeight_;
    /**
     * <pre>
     * classification weight to be associated to negative
     * anchors (default: 1.0). The weight must be in [0., 1.].
     * </pre>
     *
     * <code>optional float negative_class_weight = 13 [default = 1];</code>
     * @return Whether the negativeClassWeight field is set.
     */
    @java.lang.Override
    public boolean hasNegativeClassWeight() {
      return ((bitField0_ & 0x00000080) != 0);
    }
    /**
     * <pre>
     * classification weight to be associated to negative
     * anchors (default: 1.0). The weight must be in [0., 1.].
     * </pre>
     *
     * <code>optional float negative_class_weight = 13 [default = 1];</code>
     * @return The negativeClassWeight.
     */
    @java.lang.Override
    public float getNegativeClassWeight() {
      return negativeClassWeight_;
    }

    public static final int BOX_PREDICTOR_FIELD_NUMBER = 7;
    private object_detection.protos.BoxPredictorOuterClass.BoxPredictor boxPredictor_;
    /**
     * <pre>
     * Box predictor to attach to the features.
     * </pre>
     *
     * <code>optional .object_detection.protos.BoxPredictor box_predictor = 7;</code>
     * @return Whether the boxPredictor field is set.
     */
    @java.lang.Override
    public boolean hasBoxPredictor() {
      return ((bitField0_ & 0x00000100) != 0);
    }
    /**
     * <pre>
     * Box predictor to attach to the features.
     * </pre>
     *
     * <code>optional .object_detection.protos.BoxPredictor box_predictor = 7;</code>
     * @return The boxPredictor.
     */
    @java.lang.Override
    public object_detection.protos.BoxPredictorOuterClass.BoxPredictor getBoxPredictor() {
      return boxPredictor_ == null ? object_detection.protos.BoxPredictorOuterClass.BoxPredictor.getDefaultInstance() : boxPredictor_;
    }
    /**
     * <pre>
     * Box predictor to attach to the features.
     * </pre>
     *
     * <code>optional .object_detection.protos.BoxPredictor box_predictor = 7;</code>
     */
    @java.lang.Override
    public object_detection.protos.BoxPredictorOuterClass.BoxPredictorOrBuilder getBoxPredictorOrBuilder() {
      return boxPredictor_ == null ? object_detection.protos.BoxPredictorOuterClass.BoxPredictor.getDefaultInstance() : boxPredictor_;
    }

    public static final int ANCHOR_GENERATOR_FIELD_NUMBER = 8;
    private object_detection.protos.AnchorGeneratorOuterClass.AnchorGenerator anchorGenerator_;
    /**
     * <pre>
     * Anchor generator to compute anchors.
     * </pre>
     *
     * <code>optional .object_detection.protos.AnchorGenerator anchor_generator = 8;</code>
     * @return Whether the anchorGenerator field is set.
     */
    @java.lang.Override
    public boolean hasAnchorGenerator() {
      return ((bitField0_ & 0x00000200) != 0);
    }
    /**
     * <pre>
     * Anchor generator to compute anchors.
     * </pre>
     *
     * <code>optional .object_detection.protos.AnchorGenerator anchor_generator = 8;</code>
     * @return The anchorGenerator.
     */
    @java.lang.Override
    public object_detection.protos.AnchorGeneratorOuterClass.AnchorGenerator getAnchorGenerator() {
      return anchorGenerator_ == null ? object_detection.protos.AnchorGeneratorOuterClass.AnchorGenerator.getDefaultInstance() : anchorGenerator_;
    }
    /**
     * <pre>
     * Anchor generator to compute anchors.
     * </pre>
     *
     * <code>optional .object_detection.protos.AnchorGenerator anchor_generator = 8;</code>
     */
    @java.lang.Override
    public object_detection.protos.AnchorGeneratorOuterClass.AnchorGeneratorOrBuilder getAnchorGeneratorOrBuilder() {
      return anchorGenerator_ == null ? object_detection.protos.AnchorGeneratorOuterClass.AnchorGenerator.getDefaultInstance() : anchorGenerator_;
    }

    public static final int POST_PROCESSING_FIELD_NUMBER = 9;
    private object_detection.protos.PostProcessingOuterClass.PostProcessing postProcessing_;
    /**
     * <pre>
     * Post processing to apply on the predictions.
     * </pre>
     *
     * <code>optional .object_detection.protos.PostProcessing post_processing = 9;</code>
     * @return Whether the postProcessing field is set.
     */
    @java.lang.Override
    public boolean hasPostProcessing() {
      return ((bitField0_ & 0x00000400) != 0);
    }
    /**
     * <pre>
     * Post processing to apply on the predictions.
     * </pre>
     *
     * <code>optional .object_detection.protos.PostProcessing post_processing = 9;</code>
     * @return The postProcessing.
     */
    @java.lang.Override
    public object_detection.protos.PostProcessingOuterClass.PostProcessing getPostProcessing() {
      return postProcessing_ == null ? object_detection.protos.PostProcessingOuterClass.PostProcessing.getDefaultInstance() : postProcessing_;
    }
    /**
     * <pre>
     * Post processing to apply on the predictions.
     * </pre>
     *
     * <code>optional .object_detection.protos.PostProcessing post_processing = 9;</code>
     */
    @java.lang.Override
    public object_detection.protos.PostProcessingOuterClass.PostProcessingOrBuilder getPostProcessingOrBuilder() {
      return postProcessing_ == null ? object_detection.protos.PostProcessingOuterClass.PostProcessing.getDefaultInstance() : postProcessing_;
    }

    public static final int NORMALIZE_LOSS_BY_NUM_MATCHES_FIELD_NUMBER = 10;
    private boolean normalizeLossByNumMatches_;
    /**
     * <pre>
     * Whether to normalize the loss by number of groundtruth boxes that match to
     * the anchors.
     * </pre>
     *
     * <code>optional bool normalize_loss_by_num_matches = 10 [default = true];</code>
     * @return Whether the normalizeLossByNumMatches field is set.
     */
    @java.lang.Override
    public boolean hasNormalizeLossByNumMatches() {
      return ((bitField0_ & 0x00000800) != 0);
    }
    /**
     * <pre>
     * Whether to normalize the loss by number of groundtruth boxes that match to
     * the anchors.
     * </pre>
     *
     * <code>optional bool normalize_loss_by_num_matches = 10 [default = true];</code>
     * @return The normalizeLossByNumMatches.
     */
    @java.lang.Override
    public boolean getNormalizeLossByNumMatches() {
      return normalizeLossByNumMatches_;
    }

    public static final int NORMALIZE_LOC_LOSS_BY_CODESIZE_FIELD_NUMBER = 14;
    private boolean normalizeLocLossByCodesize_;
    /**
     * <pre>
     * Whether to normalize the localization loss by the code size of the box
     * encodings. This is applied along with other normalization factors.
     * </pre>
     *
     * <code>optional bool normalize_loc_loss_by_codesize = 14 [default = false];</code>
     * @return Whether the normalizeLocLossByCodesize field is set.
     */
    @java.lang.Override
    public boolean hasNormalizeLocLossByCodesize() {
      return ((bitField0_ & 0x00001000) != 0);
    }
    /**
     * <pre>
     * Whether to normalize the localization loss by the code size of the box
     * encodings. This is applied along with other normalization factors.
     * </pre>
     *
     * <code>optional bool normalize_loc_loss_by_codesize = 14 [default = false];</code>
     * @return The normalizeLocLossByCodesize.
     */
    @java.lang.Override
    public boolean getNormalizeLocLossByCodesize() {
      return normalizeLocLossByCodesize_;
    }

    public static final int LOSS_FIELD_NUMBER = 11;
    private object_detection.protos.Losses.Loss loss_;
    /**
     * <pre>
     * Loss configuration for training.
     * </pre>
     *
     * <code>optional .object_detection.protos.Loss loss = 11;</code>
     * @return Whether the loss field is set.
     */
    @java.lang.Override
    public boolean hasLoss() {
      return ((bitField0_ & 0x00002000) != 0);
    }
    /**
     * <pre>
     * Loss configuration for training.
     * </pre>
     *
     * <code>optional .object_detection.protos.Loss loss = 11;</code>
     * @return The loss.
     */
    @java.lang.Override
    public object_detection.protos.Losses.Loss getLoss() {
      return loss_ == null ? object_detection.protos.Losses.Loss.getDefaultInstance() : loss_;
    }
    /**
     * <pre>
     * Loss configuration for training.
     * </pre>
     *
     * <code>optional .object_detection.protos.Loss loss = 11;</code>
     */
    @java.lang.Override
    public object_detection.protos.Losses.LossOrBuilder getLossOrBuilder() {
      return loss_ == null ? object_detection.protos.Losses.Loss.getDefaultInstance() : loss_;
    }

    public static final int FREEZE_BATCHNORM_FIELD_NUMBER = 16;
    private boolean freezeBatchnorm_;
    /**
     * <pre>
     * Whether to update batch norm parameters during training or not.
     * When training with a relative small batch size (e.g. 1), it is
     * desirable to disable batch norm update and use pretrained batch norm
     * params.
     * Note: Some feature extractors are used with canned arg_scopes
     * (e.g resnet arg scopes).  In these cases training behavior of batch norm
     * variables may depend on both values of `batch_norm_trainable` and
     * `is_training`.
     * When canned arg_scopes are used with feature extractors `conv_hyperparams`
     * will apply only to the additional layers that are added and are outside the
     * canned arg_scope.
     * </pre>
     *
     * <code>optional bool freeze_batchnorm = 16 [default = false];</code>
     * @return Whether the freezeBatchnorm field is set.
     */
    @java.lang.Override
    public boolean hasFreezeBatchnorm() {
      return ((bitField0_ & 0x00004000) != 0);
    }
    /**
     * <pre>
     * Whether to update batch norm parameters during training or not.
     * When training with a relative small batch size (e.g. 1), it is
     * desirable to disable batch norm update and use pretrained batch norm
     * params.
     * Note: Some feature extractors are used with canned arg_scopes
     * (e.g resnet arg scopes).  In these cases training behavior of batch norm
     * variables may depend on both values of `batch_norm_trainable` and
     * `is_training`.
     * When canned arg_scopes are used with feature extractors `conv_hyperparams`
     * will apply only to the additional layers that are added and are outside the
     * canned arg_scope.
     * </pre>
     *
     * <code>optional bool freeze_batchnorm = 16 [default = false];</code>
     * @return The freezeBatchnorm.
     */
    @java.lang.Override
    public boolean getFreezeBatchnorm() {
      return freezeBatchnorm_;
    }

    public static final int INPLACE_BATCHNORM_UPDATE_FIELD_NUMBER = 15;
    private boolean inplaceBatchnormUpdate_;
    /**
     * <pre>
     * Whether to update batch_norm inplace during training. This is required
     * for batch norm to work correctly on TPUs. When this is false, user must add
     * a control dependency on tf.GraphKeys.UPDATE_OPS for train/loss op in order
     * to update the batch norm moving average parameters.
     * </pre>
     *
     * <code>optional bool inplace_batchnorm_update = 15 [default = false];</code>
     * @return Whether the inplaceBatchnormUpdate field is set.
     */
    @java.lang.Override
    public boolean hasInplaceBatchnormUpdate() {
      return ((bitField0_ & 0x00008000) != 0);
    }
    /**
     * <pre>
     * Whether to update batch_norm inplace during training. This is required
     * for batch norm to work correctly on TPUs. When this is false, user must add
     * a control dependency on tf.GraphKeys.UPDATE_OPS for train/loss op in order
     * to update the batch norm moving average parameters.
     * </pre>
     *
     * <code>optional bool inplace_batchnorm_update = 15 [default = false];</code>
     * @return The inplaceBatchnormUpdate.
     */
    @java.lang.Override
    public boolean getInplaceBatchnormUpdate() {
      return inplaceBatchnormUpdate_;
    }

    public static final int ADD_BACKGROUND_CLASS_FIELD_NUMBER = 21;
    private boolean addBackgroundClass_;
    /**
     * <pre>
     * Whether to add an implicit background class to one-hot encodings of
     * groundtruth labels. Set to false if training a single
     * class model or using an explicit background class.
     * </pre>
     *
     * <code>optional bool add_background_class = 21 [default = true];</code>
     * @return Whether the addBackgroundClass field is set.
     */
    @java.lang.Override
    public boolean hasAddBackgroundClass() {
      return ((bitField0_ & 0x00010000) != 0);
    }
    /**
     * <pre>
     * Whether to add an implicit background class to one-hot encodings of
     * groundtruth labels. Set to false if training a single
     * class model or using an explicit background class.
     * </pre>
     *
     * <code>optional bool add_background_class = 21 [default = true];</code>
     * @return The addBackgroundClass.
     */
    @java.lang.Override
    public boolean getAddBackgroundClass() {
      return addBackgroundClass_;
    }

    public static final int EXPLICIT_BACKGROUND_CLASS_FIELD_NUMBER = 24;
    private boolean explicitBackgroundClass_;
    /**
     * <pre>
     * Whether to use an explicit background class. Set to true if using
     * groundtruth labels with an explicit background class, as in multiclass
     * scores.
     * </pre>
     *
     * <code>optional bool explicit_background_class = 24 [default = false];</code>
     * @return Whether the explicitBackgroundClass field is set.
     */
    @java.lang.Override
    public boolean hasExplicitBackgroundClass() {
      return ((bitField0_ & 0x00020000) != 0);
    }
    /**
     * <pre>
     * Whether to use an explicit background class. Set to true if using
     * groundtruth labels with an explicit background class, as in multiclass
     * scores.
     * </pre>
     *
     * <code>optional bool explicit_background_class = 24 [default = false];</code>
     * @return The explicitBackgroundClass.
     */
    @java.lang.Override
    public boolean getExplicitBackgroundClass() {
      return explicitBackgroundClass_;
    }

    public static final int USE_CONFIDENCES_AS_TARGETS_FIELD_NUMBER = 22;
    private boolean useConfidencesAsTargets_;
    /**
     * <code>optional bool use_confidences_as_targets = 22 [default = false];</code>
     * @return Whether the useConfidencesAsTargets field is set.
     */
    @java.lang.Override
    public boolean hasUseConfidencesAsTargets() {
      return ((bitField0_ & 0x00040000) != 0);
    }
    /**
     * <code>optional bool use_confidences_as_targets = 22 [default = false];</code>
     * @return The useConfidencesAsTargets.
     */
    @java.lang.Override
    public boolean getUseConfidencesAsTargets() {
      return useConfidencesAsTargets_;
    }

    public static final int IMPLICIT_EXAMPLE_WEIGHT_FIELD_NUMBER = 23;
    private float implicitExampleWeight_;
    /**
     * <code>optional float implicit_example_weight = 23 [default = 1];</code>
     * @return Whether the implicitExampleWeight field is set.
     */
    @java.lang.Override
    public boolean hasImplicitExampleWeight() {
      return ((bitField0_ & 0x00080000) != 0);
    }
    /**
     * <code>optional float implicit_example_weight = 23 [default = 1];</code>
     * @return The implicitExampleWeight.
     */
    @java.lang.Override
    public float getImplicitExampleWeight() {
      return implicitExampleWeight_;
    }

    public static final int RETURN_RAW_DETECTIONS_DURING_PREDICT_FIELD_NUMBER = 26;
    private boolean returnRawDetectionsDuringPredict_;
    /**
     * <code>optional bool return_raw_detections_during_predict = 26 [default = false];</code>
     * @return Whether the returnRawDetectionsDuringPredict field is set.
     */
    @java.lang.Override
    public boolean hasReturnRawDetectionsDuringPredict() {
      return ((bitField0_ & 0x00100000) != 0);
    }
    /**
     * <code>optional bool return_raw_detections_during_predict = 26 [default = false];</code>
     * @return The returnRawDetectionsDuringPredict.
     */
    @java.lang.Override
    public boolean getReturnRawDetectionsDuringPredict() {
      return returnRawDetectionsDuringPredict_;
    }

    public static final int MASK_HEAD_CONFIG_FIELD_NUMBER = 25;
    private object_detection.protos.SsdOuterClass.Ssd.MaskHead maskHeadConfig_;
    /**
     * <pre>
     * Configs for mask head.
     * </pre>
     *
     * <code>optional .object_detection.protos.Ssd.MaskHead mask_head_config = 25;</code>
     * @return Whether the maskHeadConfig field is set.
     */
    @java.lang.Override
    public boolean hasMaskHeadConfig() {
      return ((bitField0_ & 0x00200000) != 0);
    }
    /**
     * <pre>
     * Configs for mask head.
     * </pre>
     *
     * <code>optional .object_detection.protos.Ssd.MaskHead mask_head_config = 25;</code>
     * @return The maskHeadConfig.
     */
    @java.lang.Override
    public object_detection.protos.SsdOuterClass.Ssd.MaskHead getMaskHeadConfig() {
      return maskHeadConfig_ == null ? object_detection.protos.SsdOuterClass.Ssd.MaskHead.getDefaultInstance() : maskHeadConfig_;
    }
    /**
     * <pre>
     * Configs for mask head.
     * </pre>
     *
     * <code>optional .object_detection.protos.Ssd.MaskHead mask_head_config = 25;</code>
     */
    @java.lang.Override
    public object_detection.protos.SsdOuterClass.Ssd.MaskHeadOrBuilder getMaskHeadConfigOrBuilder() {
      return maskHeadConfig_ == null ? object_detection.protos.SsdOuterClass.Ssd.MaskHead.getDefaultInstance() : maskHeadConfig_;
    }

    private byte memoizedIsInitialized = -1;
    @java.lang.Override
    public final boolean isInitialized() {
      byte isInitialized = memoizedIsInitialized;
      if (isInitialized == 1) return true;
      if (isInitialized == 0) return false;

      memoizedIsInitialized = 1;
      return true;
    }

    @java.lang.Override
    public void writeTo(com.google.protobuf.CodedOutputStream output)
                        throws java.io.IOException {
      if (((bitField0_ & 0x00000001) != 0)) {
        output.writeInt32(1, numClasses_);
      }
      if (((bitField0_ & 0x00000002) != 0)) {
        output.writeMessage(2, getImageResizer());
      }
      if (((bitField0_ & 0x00000004) != 0)) {
        output.writeMessage(3, getFeatureExtractor());
      }
      if (((bitField0_ & 0x00000008) != 0)) {
        output.writeMessage(4, getBoxCoder());
      }
      if (((bitField0_ & 0x00000010) != 0)) {
        output.writeMessage(5, getMatcher());
      }
      if (((bitField0_ & 0x00000020) != 0)) {
        output.writeMessage(6, getSimilarityCalculator());
      }
      if (((bitField0_ & 0x00000100) != 0)) {
        output.writeMessage(7, getBoxPredictor());
      }
      if (((bitField0_ & 0x00000200) != 0)) {
        output.writeMessage(8, getAnchorGenerator());
      }
      if (((bitField0_ & 0x00000400) != 0)) {
        output.writeMessage(9, getPostProcessing());
      }
      if (((bitField0_ & 0x00000800) != 0)) {
        output.writeBool(10, normalizeLossByNumMatches_);
      }
      if (((bitField0_ & 0x00002000) != 0)) {
        output.writeMessage(11, getLoss());
      }
      if (((bitField0_ & 0x00000040) != 0)) {
        output.writeBool(12, encodeBackgroundAsZeros_);
      }
      if (((bitField0_ & 0x00000080) != 0)) {
        output.writeFloat(13, negativeClassWeight_);
      }
      if (((bitField0_ & 0x00001000) != 0)) {
        output.writeBool(14, normalizeLocLossByCodesize_);
      }
      if (((bitField0_ & 0x00008000) != 0)) {
        output.writeBool(15, inplaceBatchnormUpdate_);
      }
      if (((bitField0_ & 0x00004000) != 0)) {
        output.writeBool(16, freezeBatchnorm_);
      }
      if (((bitField0_ & 0x00010000) != 0)) {
        output.writeBool(21, addBackgroundClass_);
      }
      if (((bitField0_ & 0x00040000) != 0)) {
        output.writeBool(22, useConfidencesAsTargets_);
      }
      if (((bitField0_ & 0x00080000) != 0)) {
        output.writeFloat(23, implicitExampleWeight_);
      }
      if (((bitField0_ & 0x00020000) != 0)) {
        output.writeBool(24, explicitBackgroundClass_);
      }
      if (((bitField0_ & 0x00200000) != 0)) {
        output.writeMessage(25, getMaskHeadConfig());
      }
      if (((bitField0_ & 0x00100000) != 0)) {
        output.writeBool(26, returnRawDetectionsDuringPredict_);
      }
      unknownFields.writeTo(output);
    }

    @java.lang.Override
    public int getSerializedSize() {
      int size = memoizedSize;
      if (size != -1) return size;

      size = 0;
      if (((bitField0_ & 0x00000001) != 0)) {
        size += com.google.protobuf.CodedOutputStream
          .computeInt32Size(1, numClasses_);
      }
      if (((bitField0_ & 0x00000002) != 0)) {
        size += com.google.protobuf.CodedOutputStream
          .computeMessageSize(2, getImageResizer());
      }
      if (((bitField0_ & 0x00000004) != 0)) {
        size += com.google.protobuf.CodedOutputStream
          .computeMessageSize(3, getFeatureExtractor());
      }
      if (((bitField0_ & 0x00000008) != 0)) {
        size += com.google.protobuf.CodedOutputStream
          .computeMessageSize(4, getBoxCoder());
      }
      if (((bitField0_ & 0x00000010) != 0)) {
        size += com.google.protobuf.CodedOutputStream
          .computeMessageSize(5, getMatcher());
      }
      if (((bitField0_ & 0x00000020) != 0)) {
        size += com.google.protobuf.CodedOutputStream
          .computeMessageSize(6, getSimilarityCalculator());
      }
      if (((bitField0_ & 0x00000100) != 0)) {
        size += com.google.protobuf.CodedOutputStream
          .computeMessageSize(7, getBoxPredictor());
      }
      if (((bitField0_ & 0x00000200) != 0)) {
        size += com.google.protobuf.CodedOutputStream
          .computeMessageSize(8, getAnchorGenerator());
      }
      if (((bitField0_ & 0x00000400) != 0)) {
        size += com.google.protobuf.CodedOutputStream
          .computeMessageSize(9, getPostProcessing());
      }
      if (((bitField0_ & 0x00000800) != 0)) {
        size += com.google.protobuf.CodedOutputStream
          .computeBoolSize(10, normalizeLossByNumMatches_);
      }
      if (((bitField0_ & 0x00002000) != 0)) {
        size += com.google.protobuf.CodedOutputStream
          .computeMessageSize(11, getLoss());
      }
      if (((bitField0_ & 0x00000040) != 0)) {
        size += com.google.protobuf.CodedOutputStream
          .computeBoolSize(12, encodeBackgroundAsZeros_);
      }
      if (((bitField0_ & 0x00000080) != 0)) {
        size += com.google.protobuf.CodedOutputStream
          .computeFloatSize(13, negativeClassWeight_);
      }
      if (((bitField0_ & 0x00001000) != 0)) {
        size += com.google.protobuf.CodedOutputStream
          .computeBoolSize(14, normalizeLocLossByCodesize_);
      }
      if (((bitField0_ & 0x00008000) != 0)) {
        size += com.google.protobuf.CodedOutputStream
          .computeBoolSize(15, inplaceBatchnormUpdate_);
      }
      if (((bitField0_ & 0x00004000) != 0)) {
        size += com.google.protobuf.CodedOutputStream
          .computeBoolSize(16, freezeBatchnorm_);
      }
      if (((bitField0_ & 0x00010000) != 0)) {
        size += com.google.protobuf.CodedOutputStream
          .computeBoolSize(21, addBackgroundClass_);
      }
      if (((bitField0_ & 0x00040000) != 0)) {
        size += com.google.protobuf.CodedOutputStream
          .computeBoolSize(22, useConfidencesAsTargets_);
      }
      if (((bitField0_ & 0x00080000) != 0)) {
        size += com.google.protobuf.CodedOutputStream
          .computeFloatSize(23, implicitExampleWeight_);
      }
      if (((bitField0_ & 0x00020000) != 0)) {
        size += com.google.protobuf.CodedOutputStream
          .computeBoolSize(24, explicitBackgroundClass_);
      }
      if (((bitField0_ & 0x00200000) != 0)) {
        size += com.google.protobuf.CodedOutputStream
          .computeMessageSize(25, getMaskHeadConfig());
      }
      if (((bitField0_ & 0x00100000) != 0)) {
        size += com.google.protobuf.CodedOutputStream
          .computeBoolSize(26, returnRawDetectionsDuringPredict_);
      }
      size += unknownFields.getSerializedSize();
      memoizedSize = size;
      return size;
    }

    @java.lang.Override
    public boolean equals(final java.lang.Object obj) {
      if (obj == this) {
       return true;
      }
      if (!(obj instanceof object_detection.protos.SsdOuterClass.Ssd)) {
        return super.equals(obj);
      }
      object_detection.protos.SsdOuterClass.Ssd other = (object_detection.protos.SsdOuterClass.Ssd) obj;

      if (hasNumClasses() != other.hasNumClasses()) return false;
      if (hasNumClasses()) {
        if (getNumClasses()
            != other.getNumClasses()) return false;
      }
      if (hasImageResizer() != other.hasImageResizer()) return false;
      if (hasImageResizer()) {
        if (!getImageResizer()
            .equals(other.getImageResizer())) return false;
      }
      if (hasFeatureExtractor() != other.hasFeatureExtractor()) return false;
      if (hasFeatureExtractor()) {
        if (!getFeatureExtractor()
            .equals(other.getFeatureExtractor())) return false;
      }
      if (hasBoxCoder() != other.hasBoxCoder()) return false;
      if (hasBoxCoder()) {
        if (!getBoxCoder()
            .equals(other.getBoxCoder())) return false;
      }
      if (hasMatcher() != other.hasMatcher()) return false;
      if (hasMatcher()) {
        if (!getMatcher()
            .equals(other.getMatcher())) return false;
      }
      if (hasSimilarityCalculator() != other.hasSimilarityCalculator()) return false;
      if (hasSimilarityCalculator()) {
        if (!getSimilarityCalculator()
            .equals(other.getSimilarityCalculator())) return false;
      }
      if (hasEncodeBackgroundAsZeros() != other.hasEncodeBackgroundAsZeros()) return false;
      if (hasEncodeBackgroundAsZeros()) {
        if (getEncodeBackgroundAsZeros()
            != other.getEncodeBackgroundAsZeros()) return false;
      }
      if (hasNegativeClassWeight() != other.hasNegativeClassWeight()) return false;
      if (hasNegativeClassWeight()) {
        if (java.lang.Float.floatToIntBits(getNegativeClassWeight())
            != java.lang.Float.floatToIntBits(
                other.getNegativeClassWeight())) return false;
      }
      if (hasBoxPredictor() != other.hasBoxPredictor()) return false;
      if (hasBoxPredictor()) {
        if (!getBoxPredictor()
            .equals(other.getBoxPredictor())) return false;
      }
      if (hasAnchorGenerator() != other.hasAnchorGenerator()) return false;
      if (hasAnchorGenerator()) {
        if (!getAnchorGenerator()
            .equals(other.getAnchorGenerator())) return false;
      }
      if (hasPostProcessing() != other.hasPostProcessing()) return false;
      if (hasPostProcessing()) {
        if (!getPostProcessing()
            .equals(other.getPostProcessing())) return false;
      }
      if (hasNormalizeLossByNumMatches() != other.hasNormalizeLossByNumMatches()) return false;
      if (hasNormalizeLossByNumMatches()) {
        if (getNormalizeLossByNumMatches()
            != other.getNormalizeLossByNumMatches()) return false;
      }
      if (hasNormalizeLocLossByCodesize() != other.hasNormalizeLocLossByCodesize()) return false;
      if (hasNormalizeLocLossByCodesize()) {
        if (getNormalizeLocLossByCodesize()
            != other.getNormalizeLocLossByCodesize()) return false;
      }
      if (hasLoss() != other.hasLoss()) return false;
      if (hasLoss()) {
        if (!getLoss()
            .equals(other.getLoss())) return false;
      }
      if (hasFreezeBatchnorm() != other.hasFreezeBatchnorm()) return false;
      if (hasFreezeBatchnorm()) {
        if (getFreezeBatchnorm()
            != other.getFreezeBatchnorm()) return false;
      }
      if (hasInplaceBatchnormUpdate() != other.hasInplaceBatchnormUpdate()) return false;
      if (hasInplaceBatchnormUpdate()) {
        if (getInplaceBatchnormUpdate()
            != other.getInplaceBatchnormUpdate()) return false;
      }
      if (hasAddBackgroundClass() != other.hasAddBackgroundClass()) return false;
      if (hasAddBackgroundClass()) {
        if (getAddBackgroundClass()
            != other.getAddBackgroundClass()) return false;
      }
      if (hasExplicitBackgroundClass() != other.hasExplicitBackgroundClass()) return false;
      if (hasExplicitBackgroundClass()) {
        if (getExplicitBackgroundClass()
            != other.getExplicitBackgroundClass()) return false;
      }
      if (hasUseConfidencesAsTargets() != other.hasUseConfidencesAsTargets()) return false;
      if (hasUseConfidencesAsTargets()) {
        if (getUseConfidencesAsTargets()
            != other.getUseConfidencesAsTargets()) return false;
      }
      if (hasImplicitExampleWeight() != other.hasImplicitExampleWeight()) return false;
      if (hasImplicitExampleWeight()) {
        if (java.lang.Float.floatToIntBits(getImplicitExampleWeight())
            != java.lang.Float.floatToIntBits(
                other.getImplicitExampleWeight())) return false;
      }
      if (hasReturnRawDetectionsDuringPredict() != other.hasReturnRawDetectionsDuringPredict()) return false;
      if (hasReturnRawDetectionsDuringPredict()) {
        if (getReturnRawDetectionsDuringPredict()
            != other.getReturnRawDetectionsDuringPredict()) return false;
      }
      if (hasMaskHeadConfig() != other.hasMaskHeadConfig()) return false;
      if (hasMaskHeadConfig()) {
        if (!getMaskHeadConfig()
            .equals(other.getMaskHeadConfig())) return false;
      }
      if (!unknownFields.equals(other.unknownFields)) return false;
      return true;
    }

    @java.lang.Override
    public int hashCode() {
      if (memoizedHashCode != 0) {
        return memoizedHashCode;
      }
      int hash = 41;
      hash = (19 * hash) + getDescriptor().hashCode();
      if (hasNumClasses()) {
        hash = (37 * hash) + NUM_CLASSES_FIELD_NUMBER;
        hash = (53 * hash) + getNumClasses();
      }
      if (hasImageResizer()) {
        hash = (37 * hash) + IMAGE_RESIZER_FIELD_NUMBER;
        hash = (53 * hash) + getImageResizer().hashCode();
      }
      if (hasFeatureExtractor()) {
        hash = (37 * hash) + FEATURE_EXTRACTOR_FIELD_NUMBER;
        hash = (53 * hash) + getFeatureExtractor().hashCode();
      }
      if (hasBoxCoder()) {
        hash = (37 * hash) + BOX_CODER_FIELD_NUMBER;
        hash = (53 * hash) + getBoxCoder().hashCode();
      }
      if (hasMatcher()) {
        hash = (37 * hash) + MATCHER_FIELD_NUMBER;
        hash = (53 * hash) + getMatcher().hashCode();
      }
      if (hasSimilarityCalculator()) {
        hash = (37 * hash) + SIMILARITY_CALCULATOR_FIELD_NUMBER;
        hash = (53 * hash) + getSimilarityCalculator().hashCode();
      }
      if (hasEncodeBackgroundAsZeros()) {
        hash = (37 * hash) + ENCODE_BACKGROUND_AS_ZEROS_FIELD_NUMBER;
        hash = (53 * hash) + com.google.protobuf.Internal.hashBoolean(
            getEncodeBackgroundAsZeros());
      }
      if (hasNegativeClassWeight()) {
        hash = (37 * hash) + NEGATIVE_CLASS_WEIGHT_FIELD_NUMBER;
        hash = (53 * hash) + java.lang.Float.floatToIntBits(
            getNegativeClassWeight());
      }
      if (hasBoxPredictor()) {
        hash = (37 * hash) + BOX_PREDICTOR_FIELD_NUMBER;
        hash = (53 * hash) + getBoxPredictor().hashCode();
      }
      if (hasAnchorGenerator()) {
        hash = (37 * hash) + ANCHOR_GENERATOR_FIELD_NUMBER;
        hash = (53 * hash) + getAnchorGenerator().hashCode();
      }
      if (hasPostProcessing()) {
        hash = (37 * hash) + POST_PROCESSING_FIELD_NUMBER;
        hash = (53 * hash) + getPostProcessing().hashCode();
      }
      if (hasNormalizeLossByNumMatches()) {
        hash = (37 * hash) + NORMALIZE_LOSS_BY_NUM_MATCHES_FIELD_NUMBER;
        hash = (53 * hash) + com.google.protobuf.Internal.hashBoolean(
            getNormalizeLossByNumMatches());
      }
      if (hasNormalizeLocLossByCodesize()) {
        hash = (37 * hash) + NORMALIZE_LOC_LOSS_BY_CODESIZE_FIELD_NUMBER;
        hash = (53 * hash) + com.google.protobuf.Internal.hashBoolean(
            getNormalizeLocLossByCodesize());
      }
      if (hasLoss()) {
        hash = (37 * hash) + LOSS_FIELD_NUMBER;
        hash = (53 * hash) + getLoss().hashCode();
      }
      if (hasFreezeBatchnorm()) {
        hash = (37 * hash) + FREEZE_BATCHNORM_FIELD_NUMBER;
        hash = (53 * hash) + com.google.protobuf.Internal.hashBoolean(
            getFreezeBatchnorm());
      }
      if (hasInplaceBatchnormUpdate()) {
        hash = (37 * hash) + INPLACE_BATCHNORM_UPDATE_FIELD_NUMBER;
        hash = (53 * hash) + com.google.protobuf.Internal.hashBoolean(
            getInplaceBatchnormUpdate());
      }
      if (hasAddBackgroundClass()) {
        hash = (37 * hash) + ADD_BACKGROUND_CLASS_FIELD_NUMBER;
        hash = (53 * hash) + com.google.protobuf.Internal.hashBoolean(
            getAddBackgroundClass());
      }
      if (hasExplicitBackgroundClass()) {
        hash = (37 * hash) + EXPLICIT_BACKGROUND_CLASS_FIELD_NUMBER;
        hash = (53 * hash) + com.google.protobuf.Internal.hashBoolean(
            getExplicitBackgroundClass());
      }
      if (hasUseConfidencesAsTargets()) {
        hash = (37 * hash) + USE_CONFIDENCES_AS_TARGETS_FIELD_NUMBER;
        hash = (53 * hash) + com.google.protobuf.Internal.hashBoolean(
            getUseConfidencesAsTargets());
      }
      if (hasImplicitExampleWeight()) {
        hash = (37 * hash) + IMPLICIT_EXAMPLE_WEIGHT_FIELD_NUMBER;
        hash = (53 * hash) + java.lang.Float.floatToIntBits(
            getImplicitExampleWeight());
      }
      if (hasReturnRawDetectionsDuringPredict()) {
        hash = (37 * hash) + RETURN_RAW_DETECTIONS_DURING_PREDICT_FIELD_NUMBER;
        hash = (53 * hash) + com.google.protobuf.Internal.hashBoolean(
            getReturnRawDetectionsDuringPredict());
      }
      if (hasMaskHeadConfig()) {
        hash = (37 * hash) + MASK_HEAD_CONFIG_FIELD_NUMBER;
        hash = (53 * hash) + getMaskHeadConfig().hashCode();
      }
      hash = (29 * hash) + unknownFields.hashCode();
      memoizedHashCode = hash;
      return hash;
    }

    public static object_detection.protos.SsdOuterClass.Ssd parseFrom(
        java.nio.ByteBuffer data)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return PARSER.parseFrom(data);
    }
    public static object_detection.protos.SsdOuterClass.Ssd parseFrom(
        java.nio.ByteBuffer data,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return PARSER.parseFrom(data, extensionRegistry);
    }
    public static object_detection.protos.SsdOuterClass.Ssd parseFrom(
        com.google.protobuf.ByteString data)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return PARSER.parseFrom(data);
    }
    public static object_detection.protos.SsdOuterClass.Ssd parseFrom(
        com.google.protobuf.ByteString data,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return PARSER.parseFrom(data, extensionRegistry);
    }
    public static object_detection.protos.SsdOuterClass.Ssd parseFrom(byte[] data)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return PARSER.parseFrom(data);
    }
    public static object_detection.protos.SsdOuterClass.Ssd parseFrom(
        byte[] data,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return PARSER.parseFrom(data, extensionRegistry);
    }
    public static object_detection.protos.SsdOuterClass.Ssd parseFrom(java.io.InputStream input)
        throws java.io.IOException {
      return com.google.protobuf.GeneratedMessageV3
          .parseWithIOException(PARSER, input);
    }
    public static object_detection.protos.SsdOuterClass.Ssd parseFrom(
        java.io.InputStream input,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws java.io.IOException {
      return com.google.protobuf.GeneratedMessageV3
          .parseWithIOException(PARSER, input, extensionRegistry);
    }
    public static object_detection.protos.SsdOuterClass.Ssd parseDelimitedFrom(java.io.InputStream input)
        throws java.io.IOException {
      return com.google.protobuf.GeneratedMessageV3
          .parseDelimitedWithIOException(PARSER, input);
    }
    public static object_detection.protos.SsdOuterClass.Ssd parseDelimitedFrom(
        java.io.InputStream input,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws java.io.IOException {
      return com.google.protobuf.GeneratedMessageV3
          .parseDelimitedWithIOException(PARSER, input, extensionRegistry);
    }
    public static object_detection.protos.SsdOuterClass.Ssd parseFrom(
        com.google.protobuf.CodedInputStream input)
        throws java.io.IOException {
      return com.google.protobuf.GeneratedMessageV3
          .parseWithIOException(PARSER, input);
    }
    public static object_detection.protos.SsdOuterClass.Ssd parseFrom(
        com.google.protobuf.CodedInputStream input,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws java.io.IOException {
      return com.google.protobuf.GeneratedMessageV3
          .parseWithIOException(PARSER, input, extensionRegistry);
    }

    @java.lang.Override
    public Builder newBuilderForType() { return newBuilder(); }
    public static Builder newBuilder() {
      return DEFAULT_INSTANCE.toBuilder();
    }
    public static Builder newBuilder(object_detection.protos.SsdOuterClass.Ssd prototype) {
      return DEFAULT_INSTANCE.toBuilder().mergeFrom(prototype);
    }
    @java.lang.Override
    public Builder toBuilder() {
      return this == DEFAULT_INSTANCE
          ? new Builder() : new Builder().mergeFrom(this);
    }

    @java.lang.Override
    protected Builder newBuilderForType(
        com.google.protobuf.GeneratedMessageV3.BuilderParent parent) {
      Builder builder = new Builder(parent);
      return builder;
    }
    /**
     * <pre>
     * Configuration for Single Shot Detection (SSD) models.
     * Next id: 27
     * </pre>
     *
     * Protobuf type {@code object_detection.protos.Ssd}
     */
    public static final class Builder extends
        com.google.protobuf.GeneratedMessageV3.Builder<Builder> implements
        // @@protoc_insertion_point(builder_implements:object_detection.protos.Ssd)
        object_detection.protos.SsdOuterClass.SsdOrBuilder {
      public static final com.google.protobuf.Descriptors.Descriptor
          getDescriptor() {
        return object_detection.protos.SsdOuterClass.internal_static_object_detection_protos_Ssd_descriptor;
      }

      @java.lang.Override
      protected com.google.protobuf.GeneratedMessageV3.FieldAccessorTable
          internalGetFieldAccessorTable() {
        return object_detection.protos.SsdOuterClass.internal_static_object_detection_protos_Ssd_fieldAccessorTable
            .ensureFieldAccessorsInitialized(
                object_detection.protos.SsdOuterClass.Ssd.class, object_detection.protos.SsdOuterClass.Ssd.Builder.class);
      }

      // Construct using object_detection.protos.SsdOuterClass.Ssd.newBuilder()
      private Builder() {
        maybeForceBuilderInitialization();
      }

      private Builder(
          com.google.protobuf.GeneratedMessageV3.BuilderParent parent) {
        super(parent);
        maybeForceBuilderInitialization();
      }
      private void maybeForceBuilderInitialization() {
        if (com.google.protobuf.GeneratedMessageV3
                .alwaysUseFieldBuilders) {
          getImageResizerFieldBuilder();
          getFeatureExtractorFieldBuilder();
          getBoxCoderFieldBuilder();
          getMatcherFieldBuilder();
          getSimilarityCalculatorFieldBuilder();
          getBoxPredictorFieldBuilder();
          getAnchorGeneratorFieldBuilder();
          getPostProcessingFieldBuilder();
          getLossFieldBuilder();
          getMaskHeadConfigFieldBuilder();
        }
      }
      @java.lang.Override
      public Builder clear() {
        super.clear();
        numClasses_ = 0;
        bitField0_ = (bitField0_ & ~0x00000001);
        if (imageResizerBuilder_ == null) {
          imageResizer_ = null;
        } else {
          imageResizerBuilder_.clear();
        }
        bitField0_ = (bitField0_ & ~0x00000002);
        if (featureExtractorBuilder_ == null) {
          featureExtractor_ = null;
        } else {
          featureExtractorBuilder_.clear();
        }
        bitField0_ = (bitField0_ & ~0x00000004);
        if (boxCoderBuilder_ == null) {
          boxCoder_ = null;
        } else {
          boxCoderBuilder_.clear();
        }
        bitField0_ = (bitField0_ & ~0x00000008);
        if (matcherBuilder_ == null) {
          matcher_ = null;
        } else {
          matcherBuilder_.clear();
        }
        bitField0_ = (bitField0_ & ~0x00000010);
        if (similarityCalculatorBuilder_ == null) {
          similarityCalculator_ = null;
        } else {
          similarityCalculatorBuilder_.clear();
        }
        bitField0_ = (bitField0_ & ~0x00000020);
        encodeBackgroundAsZeros_ = false;
        bitField0_ = (bitField0_ & ~0x00000040);
        negativeClassWeight_ = 1F;
        bitField0_ = (bitField0_ & ~0x00000080);
        if (boxPredictorBuilder_ == null) {
          boxPredictor_ = null;
        } else {
          boxPredictorBuilder_.clear();
        }
        bitField0_ = (bitField0_ & ~0x00000100);
        if (anchorGeneratorBuilder_ == null) {
          anchorGenerator_ = null;
        } else {
          anchorGeneratorBuilder_.clear();
        }
        bitField0_ = (bitField0_ & ~0x00000200);
        if (postProcessingBuilder_ == null) {
          postProcessing_ = null;
        } else {
          postProcessingBuilder_.clear();
        }
        bitField0_ = (bitField0_ & ~0x00000400);
        normalizeLossByNumMatches_ = true;
        bitField0_ = (bitField0_ & ~0x00000800);
        normalizeLocLossByCodesize_ = false;
        bitField0_ = (bitField0_ & ~0x00001000);
        if (lossBuilder_ == null) {
          loss_ = null;
        } else {
          lossBuilder_.clear();
        }
        bitField0_ = (bitField0_ & ~0x00002000);
        freezeBatchnorm_ = false;
        bitField0_ = (bitField0_ & ~0x00004000);
        inplaceBatchnormUpdate_ = false;
        bitField0_ = (bitField0_ & ~0x00008000);
        addBackgroundClass_ = true;
        bitField0_ = (bitField0_ & ~0x00010000);
        explicitBackgroundClass_ = false;
        bitField0_ = (bitField0_ & ~0x00020000);
        useConfidencesAsTargets_ = false;
        bitField0_ = (bitField0_ & ~0x00040000);
        implicitExampleWeight_ = 1F;
        bitField0_ = (bitField0_ & ~0x00080000);
        returnRawDetectionsDuringPredict_ = false;
        bitField0_ = (bitField0_ & ~0x00100000);
        if (maskHeadConfigBuilder_ == null) {
          maskHeadConfig_ = null;
        } else {
          maskHeadConfigBuilder_.clear();
        }
        bitField0_ = (bitField0_ & ~0x00200000);
        return this;
      }

      @java.lang.Override
      public com.google.protobuf.Descriptors.Descriptor
          getDescriptorForType() {
        return object_detection.protos.SsdOuterClass.internal_static_object_detection_protos_Ssd_descriptor;
      }

      @java.lang.Override
      public object_detection.protos.SsdOuterClass.Ssd getDefaultInstanceForType() {
        return object_detection.protos.SsdOuterClass.Ssd.getDefaultInstance();
      }

      @java.lang.Override
      public object_detection.protos.SsdOuterClass.Ssd build() {
        object_detection.protos.SsdOuterClass.Ssd result = buildPartial();
        if (!result.isInitialized()) {
          throw newUninitializedMessageException(result);
        }
        return result;
      }

      @java.lang.Override
      public object_detection.protos.SsdOuterClass.Ssd buildPartial() {
        object_detection.protos.SsdOuterClass.Ssd result = new object_detection.protos.SsdOuterClass.Ssd(this);
        int from_bitField0_ = bitField0_;
        int to_bitField0_ = 0;
        if (((from_bitField0_ & 0x00000001) != 0)) {
          result.numClasses_ = numClasses_;
          to_bitField0_ |= 0x00000001;
        }
        if (((from_bitField0_ & 0x00000002) != 0)) {
          if (imageResizerBuilder_ == null) {
            result.imageResizer_ = imageResizer_;
          } else {
            result.imageResizer_ = imageResizerBuilder_.build();
          }
          to_bitField0_ |= 0x00000002;
        }
        if (((from_bitField0_ & 0x00000004) != 0)) {
          if (featureExtractorBuilder_ == null) {
            result.featureExtractor_ = featureExtractor_;
          } else {
            result.featureExtractor_ = featureExtractorBuilder_.build();
          }
          to_bitField0_ |= 0x00000004;
        }
        if (((from_bitField0_ & 0x00000008) != 0)) {
          if (boxCoderBuilder_ == null) {
            result.boxCoder_ = boxCoder_;
          } else {
            result.boxCoder_ = boxCoderBuilder_.build();
          }
          to_bitField0_ |= 0x00000008;
        }
        if (((from_bitField0_ & 0x00000010) != 0)) {
          if (matcherBuilder_ == null) {
            result.matcher_ = matcher_;
          } else {
            result.matcher_ = matcherBuilder_.build();
          }
          to_bitField0_ |= 0x00000010;
        }
        if (((from_bitField0_ & 0x00000020) != 0)) {
          if (similarityCalculatorBuilder_ == null) {
            result.similarityCalculator_ = similarityCalculator_;
          } else {
            result.similarityCalculator_ = similarityCalculatorBuilder_.build();
          }
          to_bitField0_ |= 0x00000020;
        }
        if (((from_bitField0_ & 0x00000040) != 0)) {
          result.encodeBackgroundAsZeros_ = encodeBackgroundAsZeros_;
          to_bitField0_ |= 0x00000040;
        }
        if (((from_bitField0_ & 0x00000080) != 0)) {
          to_bitField0_ |= 0x00000080;
        }
        result.negativeClassWeight_ = negativeClassWeight_;
        if (((from_bitField0_ & 0x00000100) != 0)) {
          if (boxPredictorBuilder_ == null) {
            result.boxPredictor_ = boxPredictor_;
          } else {
            result.boxPredictor_ = boxPredictorBuilder_.build();
          }
          to_bitField0_ |= 0x00000100;
        }
        if (((from_bitField0_ & 0x00000200) != 0)) {
          if (anchorGeneratorBuilder_ == null) {
            result.anchorGenerator_ = anchorGenerator_;
          } else {
            result.anchorGenerator_ = anchorGeneratorBuilder_.build();
          }
          to_bitField0_ |= 0x00000200;
        }
        if (((from_bitField0_ & 0x00000400) != 0)) {
          if (postProcessingBuilder_ == null) {
            result.postProcessing_ = postProcessing_;
          } else {
            result.postProcessing_ = postProcessingBuilder_.build();
          }
          to_bitField0_ |= 0x00000400;
        }
        if (((from_bitField0_ & 0x00000800) != 0)) {
          to_bitField0_ |= 0x00000800;
        }
        result.normalizeLossByNumMatches_ = normalizeLossByNumMatches_;
        if (((from_bitField0_ & 0x00001000) != 0)) {
          result.normalizeLocLossByCodesize_ = normalizeLocLossByCodesize_;
          to_bitField0_ |= 0x00001000;
        }
        if (((from_bitField0_ & 0x00002000) != 0)) {
          if (lossBuilder_ == null) {
            result.loss_ = loss_;
          } else {
            result.loss_ = lossBuilder_.build();
          }
          to_bitField0_ |= 0x00002000;
        }
        if (((from_bitField0_ & 0x00004000) != 0)) {
          result.freezeBatchnorm_ = freezeBatchnorm_;
          to_bitField0_ |= 0x00004000;
        }
        if (((from_bitField0_ & 0x00008000) != 0)) {
          result.inplaceBatchnormUpdate_ = inplaceBatchnormUpdate_;
          to_bitField0_ |= 0x00008000;
        }
        if (((from_bitField0_ & 0x00010000) != 0)) {
          to_bitField0_ |= 0x00010000;
        }
        result.addBackgroundClass_ = addBackgroundClass_;
        if (((from_bitField0_ & 0x00020000) != 0)) {
          result.explicitBackgroundClass_ = explicitBackgroundClass_;
          to_bitField0_ |= 0x00020000;
        }
        if (((from_bitField0_ & 0x00040000) != 0)) {
          result.useConfidencesAsTargets_ = useConfidencesAsTargets_;
          to_bitField0_ |= 0x00040000;
        }
        if (((from_bitField0_ & 0x00080000) != 0)) {
          to_bitField0_ |= 0x00080000;
        }
        result.implicitExampleWeight_ = implicitExampleWeight_;
        if (((from_bitField0_ & 0x00100000) != 0)) {
          result.returnRawDetectionsDuringPredict_ = returnRawDetectionsDuringPredict_;
          to_bitField0_ |= 0x00100000;
        }
        if (((from_bitField0_ & 0x00200000) != 0)) {
          if (maskHeadConfigBuilder_ == null) {
            result.maskHeadConfig_ = maskHeadConfig_;
          } else {
            result.maskHeadConfig_ = maskHeadConfigBuilder_.build();
          }
          to_bitField0_ |= 0x00200000;
        }
        result.bitField0_ = to_bitField0_;
        onBuilt();
        return result;
      }

      @java.lang.Override
      public Builder clone() {
        return super.clone();
      }
      @java.lang.Override
      public Builder setField(
          com.google.protobuf.Descriptors.FieldDescriptor field,
          java.lang.Object value) {
        return super.setField(field, value);
      }
      @java.lang.Override
      public Builder clearField(
          com.google.protobuf.Descriptors.FieldDescriptor field) {
        return super.clearField(field);
      }
      @java.lang.Override
      public Builder clearOneof(
          com.google.protobuf.Descriptors.OneofDescriptor oneof) {
        return super.clearOneof(oneof);
      }
      @java.lang.Override
      public Builder setRepeatedField(
          com.google.protobuf.Descriptors.FieldDescriptor field,
          int index, java.lang.Object value) {
        return super.setRepeatedField(field, index, value);
      }
      @java.lang.Override
      public Builder addRepeatedField(
          com.google.protobuf.Descriptors.FieldDescriptor field,
          java.lang.Object value) {
        return super.addRepeatedField(field, value);
      }
      @java.lang.Override
      public Builder mergeFrom(com.google.protobuf.Message other) {
        if (other instanceof object_detection.protos.SsdOuterClass.Ssd) {
          return mergeFrom((object_detection.protos.SsdOuterClass.Ssd)other);
        } else {
          super.mergeFrom(other);
          return this;
        }
      }

      public Builder mergeFrom(object_detection.protos.SsdOuterClass.Ssd other) {
        if (other == object_detection.protos.SsdOuterClass.Ssd.getDefaultInstance()) return this;
        if (other.hasNumClasses()) {
          setNumClasses(other.getNumClasses());
        }
        if (other.hasImageResizer()) {
          mergeImageResizer(other.getImageResizer());
        }
        if (other.hasFeatureExtractor()) {
          mergeFeatureExtractor(other.getFeatureExtractor());
        }
        if (other.hasBoxCoder()) {
          mergeBoxCoder(other.getBoxCoder());
        }
        if (other.hasMatcher()) {
          mergeMatcher(other.getMatcher());
        }
        if (other.hasSimilarityCalculator()) {
          mergeSimilarityCalculator(other.getSimilarityCalculator());
        }
        if (other.hasEncodeBackgroundAsZeros()) {
          setEncodeBackgroundAsZeros(other.getEncodeBackgroundAsZeros());
        }
        if (other.hasNegativeClassWeight()) {
          setNegativeClassWeight(other.getNegativeClassWeight());
        }
        if (other.hasBoxPredictor()) {
          mergeBoxPredictor(other.getBoxPredictor());
        }
        if (other.hasAnchorGenerator()) {
          mergeAnchorGenerator(other.getAnchorGenerator());
        }
        if (other.hasPostProcessing()) {
          mergePostProcessing(other.getPostProcessing());
        }
        if (other.hasNormalizeLossByNumMatches()) {
          setNormalizeLossByNumMatches(other.getNormalizeLossByNumMatches());
        }
        if (other.hasNormalizeLocLossByCodesize()) {
          setNormalizeLocLossByCodesize(other.getNormalizeLocLossByCodesize());
        }
        if (other.hasLoss()) {
          mergeLoss(other.getLoss());
        }
        if (other.hasFreezeBatchnorm()) {
          setFreezeBatchnorm(other.getFreezeBatchnorm());
        }
        if (other.hasInplaceBatchnormUpdate()) {
          setInplaceBatchnormUpdate(other.getInplaceBatchnormUpdate());
        }
        if (other.hasAddBackgroundClass()) {
          setAddBackgroundClass(other.getAddBackgroundClass());
        }
        if (other.hasExplicitBackgroundClass()) {
          setExplicitBackgroundClass(other.getExplicitBackgroundClass());
        }
        if (other.hasUseConfidencesAsTargets()) {
          setUseConfidencesAsTargets(other.getUseConfidencesAsTargets());
        }
        if (other.hasImplicitExampleWeight()) {
          setImplicitExampleWeight(other.getImplicitExampleWeight());
        }
        if (other.hasReturnRawDetectionsDuringPredict()) {
          setReturnRawDetectionsDuringPredict(other.getReturnRawDetectionsDuringPredict());
        }
        if (other.hasMaskHeadConfig()) {
          mergeMaskHeadConfig(other.getMaskHeadConfig());
        }
        this.mergeUnknownFields(other.unknownFields);
        onChanged();
        return this;
      }

      @java.lang.Override
      public final boolean isInitialized() {
        return true;
      }

      @java.lang.Override
      public Builder mergeFrom(
          com.google.protobuf.CodedInputStream input,
          com.google.protobuf.ExtensionRegistryLite extensionRegistry)
          throws java.io.IOException {
        object_detection.protos.SsdOuterClass.Ssd parsedMessage = null;
        try {
          parsedMessage = PARSER.parsePartialFrom(input, extensionRegistry);
        } catch (com.google.protobuf.InvalidProtocolBufferException e) {
          parsedMessage = (object_detection.protos.SsdOuterClass.Ssd) e.getUnfinishedMessage();
          throw e.unwrapIOException();
        } finally {
          if (parsedMessage != null) {
            mergeFrom(parsedMessage);
          }
        }
        return this;
      }
      private int bitField0_;

      private int numClasses_ ;
      /**
       * <pre>
       * Number of classes to predict.
       * </pre>
       *
       * <code>optional int32 num_classes = 1;</code>
       * @return Whether the numClasses field is set.
       */
      @java.lang.Override
      public boolean hasNumClasses() {
        return ((bitField0_ & 0x00000001) != 0);
      }
      /**
       * <pre>
       * Number of classes to predict.
       * </pre>
       *
       * <code>optional int32 num_classes = 1;</code>
       * @return The numClasses.
       */
      @java.lang.Override
      public int getNumClasses() {
        return numClasses_;
      }
      /**
       * <pre>
       * Number of classes to predict.
       * </pre>
       *
       * <code>optional int32 num_classes = 1;</code>
       * @param value The numClasses to set.
       * @return This builder for chaining.
       */
      public Builder setNumClasses(int value) {
        bitField0_ |= 0x00000001;
        numClasses_ = value;
        onChanged();
        return this;
      }
      /**
       * <pre>
       * Number of classes to predict.
       * </pre>
       *
       * <code>optional int32 num_classes = 1;</code>
       * @return This builder for chaining.
       */
      public Builder clearNumClasses() {
        bitField0_ = (bitField0_ & ~0x00000001);
        numClasses_ = 0;
        onChanged();
        return this;
      }

      private object_detection.protos.ImageResizerOuterClass.ImageResizer imageResizer_;
      private com.google.protobuf.SingleFieldBuilderV3<
          object_detection.protos.ImageResizerOuterClass.ImageResizer, object_detection.protos.ImageResizerOuterClass.ImageResizer.Builder, object_detection.protos.ImageResizerOuterClass.ImageResizerOrBuilder> imageResizerBuilder_;
      /**
       * <pre>
       * Image resizer for preprocessing the input image.
       * </pre>
       *
       * <code>optional .object_detection.protos.ImageResizer image_resizer = 2;</code>
       * @return Whether the imageResizer field is set.
       */
      public boolean hasImageResizer() {
        return ((bitField0_ & 0x00000002) != 0);
      }
      /**
       * <pre>
       * Image resizer for preprocessing the input image.
       * </pre>
       *
       * <code>optional .object_detection.protos.ImageResizer image_resizer = 2;</code>
       * @return The imageResizer.
       */
      public object_detection.protos.ImageResizerOuterClass.ImageResizer getImageResizer() {
        if (imageResizerBuilder_ == null) {
          return imageResizer_ == null ? object_detection.protos.ImageResizerOuterClass.ImageResizer.getDefaultInstance() : imageResizer_;
        } else {
          return imageResizerBuilder_.getMessage();
        }
      }
      /**
       * <pre>
       * Image resizer for preprocessing the input image.
       * </pre>
       *
       * <code>optional .object_detection.protos.ImageResizer image_resizer = 2;</code>
       */
      public Builder setImageResizer(object_detection.protos.ImageResizerOuterClass.ImageResizer value) {
        if (imageResizerBuilder_ == null) {
          if (value == null) {
            throw new NullPointerException();
          }
          imageResizer_ = value;
          onChanged();
        } else {
          imageResizerBuilder_.setMessage(value);
        }
        bitField0_ |= 0x00000002;
        return this;
      }
      /**
       * <pre>
       * Image resizer for preprocessing the input image.
       * </pre>
       *
       * <code>optional .object_detection.protos.ImageResizer image_resizer = 2;</code>
       */
      public Builder setImageResizer(
          object_detection.protos.ImageResizerOuterClass.ImageResizer.Builder builderForValue) {
        if (imageResizerBuilder_ == null) {
          imageResizer_ = builderForValue.build();
          onChanged();
        } else {
          imageResizerBuilder_.setMessage(builderForValue.build());
        }
        bitField0_ |= 0x00000002;
        return this;
      }
      /**
       * <pre>
       * Image resizer for preprocessing the input image.
       * </pre>
       *
       * <code>optional .object_detection.protos.ImageResizer image_resizer = 2;</code>
       */
      public Builder mergeImageResizer(object_detection.protos.ImageResizerOuterClass.ImageResizer value) {
        if (imageResizerBuilder_ == null) {
          if (((bitField0_ & 0x00000002) != 0) &&
              imageResizer_ != null &&
              imageResizer_ != object_detection.protos.ImageResizerOuterClass.ImageResizer.getDefaultInstance()) {
            imageResizer_ =
              object_detection.protos.ImageResizerOuterClass.ImageResizer.newBuilder(imageResizer_).mergeFrom(value).buildPartial();
          } else {
            imageResizer_ = value;
          }
          onChanged();
        } else {
          imageResizerBuilder_.mergeFrom(value);
        }
        bitField0_ |= 0x00000002;
        return this;
      }
      /**
       * <pre>
       * Image resizer for preprocessing the input image.
       * </pre>
       *
       * <code>optional .object_detection.protos.ImageResizer image_resizer = 2;</code>
       */
      public Builder clearImageResizer() {
        if (imageResizerBuilder_ == null) {
          imageResizer_ = null;
          onChanged();
        } else {
          imageResizerBuilder_.clear();
        }
        bitField0_ = (bitField0_ & ~0x00000002);
        return this;
      }
      /**
       * <pre>
       * Image resizer for preprocessing the input image.
       * </pre>
       *
       * <code>optional .object_detection.protos.ImageResizer image_resizer = 2;</code>
       */
      public object_detection.protos.ImageResizerOuterClass.ImageResizer.Builder getImageResizerBuilder() {
        bitField0_ |= 0x00000002;
        onChanged();
        return getImageResizerFieldBuilder().getBuilder();
      }
      /**
       * <pre>
       * Image resizer for preprocessing the input image.
       * </pre>
       *
       * <code>optional .object_detection.protos.ImageResizer image_resizer = 2;</code>
       */
      public object_detection.protos.ImageResizerOuterClass.ImageResizerOrBuilder getImageResizerOrBuilder() {
        if (imageResizerBuilder_ != null) {
          return imageResizerBuilder_.getMessageOrBuilder();
        } else {
          return imageResizer_ == null ?
              object_detection.protos.ImageResizerOuterClass.ImageResizer.getDefaultInstance() : imageResizer_;
        }
      }
      /**
       * <pre>
       * Image resizer for preprocessing the input image.
       * </pre>
       *
       * <code>optional .object_detection.protos.ImageResizer image_resizer = 2;</code>
       */
      private com.google.protobuf.SingleFieldBuilderV3<
          object_detection.protos.ImageResizerOuterClass.ImageResizer, object_detection.protos.ImageResizerOuterClass.ImageResizer.Builder, object_detection.protos.ImageResizerOuterClass.ImageResizerOrBuilder>
          getImageResizerFieldBuilder() {
        if (imageResizerBuilder_ == null) {
          imageResizerBuilder_ = new com.google.protobuf.SingleFieldBuilderV3<
              object_detection.protos.ImageResizerOuterClass.ImageResizer, object_detection.protos.ImageResizerOuterClass.ImageResizer.Builder, object_detection.protos.ImageResizerOuterClass.ImageResizerOrBuilder>(
                  getImageResizer(),
                  getParentForChildren(),
                  isClean());
          imageResizer_ = null;
        }
        return imageResizerBuilder_;
      }

      private object_detection.protos.SsdOuterClass.SsdFeatureExtractor featureExtractor_;
      private com.google.protobuf.SingleFieldBuilderV3<
          object_detection.protos.SsdOuterClass.SsdFeatureExtractor, object_detection.protos.SsdOuterClass.SsdFeatureExtractor.Builder, object_detection.protos.SsdOuterClass.SsdFeatureExtractorOrBuilder> featureExtractorBuilder_;
      /**
       * <pre>
       * Feature extractor config.
       * </pre>
       *
       * <code>optional .object_detection.protos.SsdFeatureExtractor feature_extractor = 3;</code>
       * @return Whether the featureExtractor field is set.
       */
      public boolean hasFeatureExtractor() {
        return ((bitField0_ & 0x00000004) != 0);
      }
      /**
       * <pre>
       * Feature extractor config.
       * </pre>
       *
       * <code>optional .object_detection.protos.SsdFeatureExtractor feature_extractor = 3;</code>
       * @return The featureExtractor.
       */
      public object_detection.protos.SsdOuterClass.SsdFeatureExtractor getFeatureExtractor() {
        if (featureExtractorBuilder_ == null) {
          return featureExtractor_ == null ? object_detection.protos.SsdOuterClass.SsdFeatureExtractor.getDefaultInstance() : featureExtractor_;
        } else {
          return featureExtractorBuilder_.getMessage();
        }
      }
      /**
       * <pre>
       * Feature extractor config.
       * </pre>
       *
       * <code>optional .object_detection.protos.SsdFeatureExtractor feature_extractor = 3;</code>
       */
      public Builder setFeatureExtractor(object_detection.protos.SsdOuterClass.SsdFeatureExtractor value) {
        if (featureExtractorBuilder_ == null) {
          if (value == null) {
            throw new NullPointerException();
          }
          featureExtractor_ = value;
          onChanged();
        } else {
          featureExtractorBuilder_.setMessage(value);
        }
        bitField0_ |= 0x00000004;
        return this;
      }
      /**
       * <pre>
       * Feature extractor config.
       * </pre>
       *
       * <code>optional .object_detection.protos.SsdFeatureExtractor feature_extractor = 3;</code>
       */
      public Builder setFeatureExtractor(
          object_detection.protos.SsdOuterClass.SsdFeatureExtractor.Builder builderForValue) {
        if (featureExtractorBuilder_ == null) {
          featureExtractor_ = builderForValue.build();
          onChanged();
        } else {
          featureExtractorBuilder_.setMessage(builderForValue.build());
        }
        bitField0_ |= 0x00000004;
        return this;
      }
      /**
       * <pre>
       * Feature extractor config.
       * </pre>
       *
       * <code>optional .object_detection.protos.SsdFeatureExtractor feature_extractor = 3;</code>
       */
      public Builder mergeFeatureExtractor(object_detection.protos.SsdOuterClass.SsdFeatureExtractor value) {
        if (featureExtractorBuilder_ == null) {
          if (((bitField0_ & 0x00000004) != 0) &&
              featureExtractor_ != null &&
              featureExtractor_ != object_detection.protos.SsdOuterClass.SsdFeatureExtractor.getDefaultInstance()) {
            featureExtractor_ =
              object_detection.protos.SsdOuterClass.SsdFeatureExtractor.newBuilder(featureExtractor_).mergeFrom(value).buildPartial();
          } else {
            featureExtractor_ = value;
          }
          onChanged();
        } else {
          featureExtractorBuilder_.mergeFrom(value);
        }
        bitField0_ |= 0x00000004;
        return this;
      }
      /**
       * <pre>
       * Feature extractor config.
       * </pre>
       *
       * <code>optional .object_detection.protos.SsdFeatureExtractor feature_extractor = 3;</code>
       */
      public Builder clearFeatureExtractor() {
        if (featureExtractorBuilder_ == null) {
          featureExtractor_ = null;
          onChanged();
        } else {
          featureExtractorBuilder_.clear();
        }
        bitField0_ = (bitField0_ & ~0x00000004);
        return this;
      }
      /**
       * <pre>
       * Feature extractor config.
       * </pre>
       *
       * <code>optional .object_detection.protos.SsdFeatureExtractor feature_extractor = 3;</code>
       */
      public object_detection.protos.SsdOuterClass.SsdFeatureExtractor.Builder getFeatureExtractorBuilder() {
        bitField0_ |= 0x00000004;
        onChanged();
        return getFeatureExtractorFieldBuilder().getBuilder();
      }
      /**
       * <pre>
       * Feature extractor config.
       * </pre>
       *
       * <code>optional .object_detection.protos.SsdFeatureExtractor feature_extractor = 3;</code>
       */
      public object_detection.protos.SsdOuterClass.SsdFeatureExtractorOrBuilder getFeatureExtractorOrBuilder() {
        if (featureExtractorBuilder_ != null) {
          return featureExtractorBuilder_.getMessageOrBuilder();
        } else {
          return featureExtractor_ == null ?
              object_detection.protos.SsdOuterClass.SsdFeatureExtractor.getDefaultInstance() : featureExtractor_;
        }
      }
      /**
       * <pre>
       * Feature extractor config.
       * </pre>
       *
       * <code>optional .object_detection.protos.SsdFeatureExtractor feature_extractor = 3;</code>
       */
      private com.google.protobuf.SingleFieldBuilderV3<
          object_detection.protos.SsdOuterClass.SsdFeatureExtractor, object_detection.protos.SsdOuterClass.SsdFeatureExtractor.Builder, object_detection.protos.SsdOuterClass.SsdFeatureExtractorOrBuilder>
          getFeatureExtractorFieldBuilder() {
        if (featureExtractorBuilder_ == null) {
          featureExtractorBuilder_ = new com.google.protobuf.SingleFieldBuilderV3<
              object_detection.protos.SsdOuterClass.SsdFeatureExtractor, object_detection.protos.SsdOuterClass.SsdFeatureExtractor.Builder, object_detection.protos.SsdOuterClass.SsdFeatureExtractorOrBuilder>(
                  getFeatureExtractor(),
                  getParentForChildren(),
                  isClean());
          featureExtractor_ = null;
        }
        return featureExtractorBuilder_;
      }

      private object_detection.protos.BoxCoderOuterClass.BoxCoder boxCoder_;
      private com.google.protobuf.SingleFieldBuilderV3<
          object_detection.protos.BoxCoderOuterClass.BoxCoder, object_detection.protos.BoxCoderOuterClass.BoxCoder.Builder, object_detection.protos.BoxCoderOuterClass.BoxCoderOrBuilder> boxCoderBuilder_;
      /**
       * <pre>
       * Box coder to encode the boxes.
       * </pre>
       *
       * <code>optional .object_detection.protos.BoxCoder box_coder = 4;</code>
       * @return Whether the boxCoder field is set.
       */
      public boolean hasBoxCoder() {
        return ((bitField0_ & 0x00000008) != 0);
      }
      /**
       * <pre>
       * Box coder to encode the boxes.
       * </pre>
       *
       * <code>optional .object_detection.protos.BoxCoder box_coder = 4;</code>
       * @return The boxCoder.
       */
      public object_detection.protos.BoxCoderOuterClass.BoxCoder getBoxCoder() {
        if (boxCoderBuilder_ == null) {
          return boxCoder_ == null ? object_detection.protos.BoxCoderOuterClass.BoxCoder.getDefaultInstance() : boxCoder_;
        } else {
          return boxCoderBuilder_.getMessage();
        }
      }
      /**
       * <pre>
       * Box coder to encode the boxes.
       * </pre>
       *
       * <code>optional .object_detection.protos.BoxCoder box_coder = 4;</code>
       */
      public Builder setBoxCoder(object_detection.protos.BoxCoderOuterClass.BoxCoder value) {
        if (boxCoderBuilder_ == null) {
          if (value == null) {
            throw new NullPointerException();
          }
          boxCoder_ = value;
          onChanged();
        } else {
          boxCoderBuilder_.setMessage(value);
        }
        bitField0_ |= 0x00000008;
        return this;
      }
      /**
       * <pre>
       * Box coder to encode the boxes.
       * </pre>
       *
       * <code>optional .object_detection.protos.BoxCoder box_coder = 4;</code>
       */
      public Builder setBoxCoder(
          object_detection.protos.BoxCoderOuterClass.BoxCoder.Builder builderForValue) {
        if (boxCoderBuilder_ == null) {
          boxCoder_ = builderForValue.build();
          onChanged();
        } else {
          boxCoderBuilder_.setMessage(builderForValue.build());
        }
        bitField0_ |= 0x00000008;
        return this;
      }
      /**
       * <pre>
       * Box coder to encode the boxes.
       * </pre>
       *
       * <code>optional .object_detection.protos.BoxCoder box_coder = 4;</code>
       */
      public Builder mergeBoxCoder(object_detection.protos.BoxCoderOuterClass.BoxCoder value) {
        if (boxCoderBuilder_ == null) {
          if (((bitField0_ & 0x00000008) != 0) &&
              boxCoder_ != null &&
              boxCoder_ != object_detection.protos.BoxCoderOuterClass.BoxCoder.getDefaultInstance()) {
            boxCoder_ =
              object_detection.protos.BoxCoderOuterClass.BoxCoder.newBuilder(boxCoder_).mergeFrom(value).buildPartial();
          } else {
            boxCoder_ = value;
          }
          onChanged();
        } else {
          boxCoderBuilder_.mergeFrom(value);
        }
        bitField0_ |= 0x00000008;
        return this;
      }
      /**
       * <pre>
       * Box coder to encode the boxes.
       * </pre>
       *
       * <code>optional .object_detection.protos.BoxCoder box_coder = 4;</code>
       */
      public Builder clearBoxCoder() {
        if (boxCoderBuilder_ == null) {
          boxCoder_ = null;
          onChanged();
        } else {
          boxCoderBuilder_.clear();
        }
        bitField0_ = (bitField0_ & ~0x00000008);
        return this;
      }
      /**
       * <pre>
       * Box coder to encode the boxes.
       * </pre>
       *
       * <code>optional .object_detection.protos.BoxCoder box_coder = 4;</code>
       */
      public object_detection.protos.BoxCoderOuterClass.BoxCoder.Builder getBoxCoderBuilder() {
        bitField0_ |= 0x00000008;
        onChanged();
        return getBoxCoderFieldBuilder().getBuilder();
      }
      /**
       * <pre>
       * Box coder to encode the boxes.
       * </pre>
       *
       * <code>optional .object_detection.protos.BoxCoder box_coder = 4;</code>
       */
      public object_detection.protos.BoxCoderOuterClass.BoxCoderOrBuilder getBoxCoderOrBuilder() {
        if (boxCoderBuilder_ != null) {
          return boxCoderBuilder_.getMessageOrBuilder();
        } else {
          return boxCoder_ == null ?
              object_detection.protos.BoxCoderOuterClass.BoxCoder.getDefaultInstance() : boxCoder_;
        }
      }
      /**
       * <pre>
       * Box coder to encode the boxes.
       * </pre>
       *
       * <code>optional .object_detection.protos.BoxCoder box_coder = 4;</code>
       */
      private com.google.protobuf.SingleFieldBuilderV3<
          object_detection.protos.BoxCoderOuterClass.BoxCoder, object_detection.protos.BoxCoderOuterClass.BoxCoder.Builder, object_detection.protos.BoxCoderOuterClass.BoxCoderOrBuilder>
          getBoxCoderFieldBuilder() {
        if (boxCoderBuilder_ == null) {
          boxCoderBuilder_ = new com.google.protobuf.SingleFieldBuilderV3<
              object_detection.protos.BoxCoderOuterClass.BoxCoder, object_detection.protos.BoxCoderOuterClass.BoxCoder.Builder, object_detection.protos.BoxCoderOuterClass.BoxCoderOrBuilder>(
                  getBoxCoder(),
                  getParentForChildren(),
                  isClean());
          boxCoder_ = null;
        }
        return boxCoderBuilder_;
      }

      private object_detection.protos.MatcherOuterClass.Matcher matcher_;
      private com.google.protobuf.SingleFieldBuilderV3<
          object_detection.protos.MatcherOuterClass.Matcher, object_detection.protos.MatcherOuterClass.Matcher.Builder, object_detection.protos.MatcherOuterClass.MatcherOrBuilder> matcherBuilder_;
      /**
       * <pre>
       * Matcher to match groundtruth with anchors.
       * </pre>
       *
       * <code>optional .object_detection.protos.Matcher matcher = 5;</code>
       * @return Whether the matcher field is set.
       */
      public boolean hasMatcher() {
        return ((bitField0_ & 0x00000010) != 0);
      }
      /**
       * <pre>
       * Matcher to match groundtruth with anchors.
       * </pre>
       *
       * <code>optional .object_detection.protos.Matcher matcher = 5;</code>
       * @return The matcher.
       */
      public object_detection.protos.MatcherOuterClass.Matcher getMatcher() {
        if (matcherBuilder_ == null) {
          return matcher_ == null ? object_detection.protos.MatcherOuterClass.Matcher.getDefaultInstance() : matcher_;
        } else {
          return matcherBuilder_.getMessage();
        }
      }
      /**
       * <pre>
       * Matcher to match groundtruth with anchors.
       * </pre>
       *
       * <code>optional .object_detection.protos.Matcher matcher = 5;</code>
       */
      public Builder setMatcher(object_detection.protos.MatcherOuterClass.Matcher value) {
        if (matcherBuilder_ == null) {
          if (value == null) {
            throw new NullPointerException();
          }
          matcher_ = value;
          onChanged();
        } else {
          matcherBuilder_.setMessage(value);
        }
        bitField0_ |= 0x00000010;
        return this;
      }
      /**
       * <pre>
       * Matcher to match groundtruth with anchors.
       * </pre>
       *
       * <code>optional .object_detection.protos.Matcher matcher = 5;</code>
       */
      public Builder setMatcher(
          object_detection.protos.MatcherOuterClass.Matcher.Builder builderForValue) {
        if (matcherBuilder_ == null) {
          matcher_ = builderForValue.build();
          onChanged();
        } else {
          matcherBuilder_.setMessage(builderForValue.build());
        }
        bitField0_ |= 0x00000010;
        return this;
      }
      /**
       * <pre>
       * Matcher to match groundtruth with anchors.
       * </pre>
       *
       * <code>optional .object_detection.protos.Matcher matcher = 5;</code>
       */
      public Builder mergeMatcher(object_detection.protos.MatcherOuterClass.Matcher value) {
        if (matcherBuilder_ == null) {
          if (((bitField0_ & 0x00000010) != 0) &&
              matcher_ != null &&
              matcher_ != object_detection.protos.MatcherOuterClass.Matcher.getDefaultInstance()) {
            matcher_ =
              object_detection.protos.MatcherOuterClass.Matcher.newBuilder(matcher_).mergeFrom(value).buildPartial();
          } else {
            matcher_ = value;
          }
          onChanged();
        } else {
          matcherBuilder_.mergeFrom(value);
        }
        bitField0_ |= 0x00000010;
        return this;
      }
      /**
       * <pre>
       * Matcher to match groundtruth with anchors.
       * </pre>
       *
       * <code>optional .object_detection.protos.Matcher matcher = 5;</code>
       */
      public Builder clearMatcher() {
        if (matcherBuilder_ == null) {
          matcher_ = null;
          onChanged();
        } else {
          matcherBuilder_.clear();
        }
        bitField0_ = (bitField0_ & ~0x00000010);
        return this;
      }
      /**
       * <pre>
       * Matcher to match groundtruth with anchors.
       * </pre>
       *
       * <code>optional .object_detection.protos.Matcher matcher = 5;</code>
       */
      public object_detection.protos.MatcherOuterClass.Matcher.Builder getMatcherBuilder() {
        bitField0_ |= 0x00000010;
        onChanged();
        return getMatcherFieldBuilder().getBuilder();
      }
      /**
       * <pre>
       * Matcher to match groundtruth with anchors.
       * </pre>
       *
       * <code>optional .object_detection.protos.Matcher matcher = 5;</code>
       */
      public object_detection.protos.MatcherOuterClass.MatcherOrBuilder getMatcherOrBuilder() {
        if (matcherBuilder_ != null) {
          return matcherBuilder_.getMessageOrBuilder();
        } else {
          return matcher_ == null ?
              object_detection.protos.MatcherOuterClass.Matcher.getDefaultInstance() : matcher_;
        }
      }
      /**
       * <pre>
       * Matcher to match groundtruth with anchors.
       * </pre>
       *
       * <code>optional .object_detection.protos.Matcher matcher = 5;</code>
       */
      private com.google.protobuf.SingleFieldBuilderV3<
          object_detection.protos.MatcherOuterClass.Matcher, object_detection.protos.MatcherOuterClass.Matcher.Builder, object_detection.protos.MatcherOuterClass.MatcherOrBuilder>
          getMatcherFieldBuilder() {
        if (matcherBuilder_ == null) {
          matcherBuilder_ = new com.google.protobuf.SingleFieldBuilderV3<
              object_detection.protos.MatcherOuterClass.Matcher, object_detection.protos.MatcherOuterClass.Matcher.Builder, object_detection.protos.MatcherOuterClass.MatcherOrBuilder>(
                  getMatcher(),
                  getParentForChildren(),
                  isClean());
          matcher_ = null;
        }
        return matcherBuilder_;
      }

      private object_detection.protos.RegionSimilarityCalculatorOuterClass.RegionSimilarityCalculator similarityCalculator_;
      private com.google.protobuf.SingleFieldBuilderV3<
          object_detection.protos.RegionSimilarityCalculatorOuterClass.RegionSimilarityCalculator, object_detection.protos.RegionSimilarityCalculatorOuterClass.RegionSimilarityCalculator.Builder, object_detection.protos.RegionSimilarityCalculatorOuterClass.RegionSimilarityCalculatorOrBuilder> similarityCalculatorBuilder_;
      /**
       * <pre>
       * Region similarity calculator to compute similarity of boxes.
       * </pre>
       *
       * <code>optional .object_detection.protos.RegionSimilarityCalculator similarity_calculator = 6;</code>
       * @return Whether the similarityCalculator field is set.
       */
      public boolean hasSimilarityCalculator() {
        return ((bitField0_ & 0x00000020) != 0);
      }
      /**
       * <pre>
       * Region similarity calculator to compute similarity of boxes.
       * </pre>
       *
       * <code>optional .object_detection.protos.RegionSimilarityCalculator similarity_calculator = 6;</code>
       * @return The similarityCalculator.
       */
      public object_detection.protos.RegionSimilarityCalculatorOuterClass.RegionSimilarityCalculator getSimilarityCalculator() {
        if (similarityCalculatorBuilder_ == null) {
          return similarityCalculator_ == null ? object_detection.protos.RegionSimilarityCalculatorOuterClass.RegionSimilarityCalculator.getDefaultInstance() : similarityCalculator_;
        } else {
          return similarityCalculatorBuilder_.getMessage();
        }
      }
      /**
       * <pre>
       * Region similarity calculator to compute similarity of boxes.
       * </pre>
       *
       * <code>optional .object_detection.protos.RegionSimilarityCalculator similarity_calculator = 6;</code>
       */
      public Builder setSimilarityCalculator(object_detection.protos.RegionSimilarityCalculatorOuterClass.RegionSimilarityCalculator value) {
        if (similarityCalculatorBuilder_ == null) {
          if (value == null) {
            throw new NullPointerException();
          }
          similarityCalculator_ = value;
          onChanged();
        } else {
          similarityCalculatorBuilder_.setMessage(value);
        }
        bitField0_ |= 0x00000020;
        return this;
      }
      /**
       * <pre>
       * Region similarity calculator to compute similarity of boxes.
       * </pre>
       *
       * <code>optional .object_detection.protos.RegionSimilarityCalculator similarity_calculator = 6;</code>
       */
      public Builder setSimilarityCalculator(
          object_detection.protos.RegionSimilarityCalculatorOuterClass.RegionSimilarityCalculator.Builder builderForValue) {
        if (similarityCalculatorBuilder_ == null) {
          similarityCalculator_ = builderForValue.build();
          onChanged();
        } else {
          similarityCalculatorBuilder_.setMessage(builderForValue.build());
        }
        bitField0_ |= 0x00000020;
        return this;
      }
      /**
       * <pre>
       * Region similarity calculator to compute similarity of boxes.
       * </pre>
       *
       * <code>optional .object_detection.protos.RegionSimilarityCalculator similarity_calculator = 6;</code>
       */
      public Builder mergeSimilarityCalculator(object_detection.protos.RegionSimilarityCalculatorOuterClass.RegionSimilarityCalculator value) {
        if (similarityCalculatorBuilder_ == null) {
          if (((bitField0_ & 0x00000020) != 0) &&
              similarityCalculator_ != null &&
              similarityCalculator_ != object_detection.protos.RegionSimilarityCalculatorOuterClass.RegionSimilarityCalculator.getDefaultInstance()) {
            similarityCalculator_ =
              object_detection.protos.RegionSimilarityCalculatorOuterClass.RegionSimilarityCalculator.newBuilder(similarityCalculator_).mergeFrom(value).buildPartial();
          } else {
            similarityCalculator_ = value;
          }
          onChanged();
        } else {
          similarityCalculatorBuilder_.mergeFrom(value);
        }
        bitField0_ |= 0x00000020;
        return this;
      }
      /**
       * <pre>
       * Region similarity calculator to compute similarity of boxes.
       * </pre>
       *
       * <code>optional .object_detection.protos.RegionSimilarityCalculator similarity_calculator = 6;</code>
       */
      public Builder clearSimilarityCalculator() {
        if (similarityCalculatorBuilder_ == null) {
          similarityCalculator_ = null;
          onChanged();
        } else {
          similarityCalculatorBuilder_.clear();
        }
        bitField0_ = (bitField0_ & ~0x00000020);
        return this;
      }
      /**
       * <pre>
       * Region similarity calculator to compute similarity of boxes.
       * </pre>
       *
       * <code>optional .object_detection.protos.RegionSimilarityCalculator similarity_calculator = 6;</code>
       */
      public object_detection.protos.RegionSimilarityCalculatorOuterClass.RegionSimilarityCalculator.Builder getSimilarityCalculatorBuilder() {
        bitField0_ |= 0x00000020;
        onChanged();
        return getSimilarityCalculatorFieldBuilder().getBuilder();
      }
      /**
       * <pre>
       * Region similarity calculator to compute similarity of boxes.
       * </pre>
       *
       * <code>optional .object_detection.protos.RegionSimilarityCalculator similarity_calculator = 6;</code>
       */
      public object_detection.protos.RegionSimilarityCalculatorOuterClass.RegionSimilarityCalculatorOrBuilder getSimilarityCalculatorOrBuilder() {
        if (similarityCalculatorBuilder_ != null) {
          return similarityCalculatorBuilder_.getMessageOrBuilder();
        } else {
          return similarityCalculator_ == null ?
              object_detection.protos.RegionSimilarityCalculatorOuterClass.RegionSimilarityCalculator.getDefaultInstance() : similarityCalculator_;
        }
      }
      /**
       * <pre>
       * Region similarity calculator to compute similarity of boxes.
       * </pre>
       *
       * <code>optional .object_detection.protos.RegionSimilarityCalculator similarity_calculator = 6;</code>
       */
      private com.google.protobuf.SingleFieldBuilderV3<
          object_detection.protos.RegionSimilarityCalculatorOuterClass.RegionSimilarityCalculator, object_detection.protos.RegionSimilarityCalculatorOuterClass.RegionSimilarityCalculator.Builder, object_detection.protos.RegionSimilarityCalculatorOuterClass.RegionSimilarityCalculatorOrBuilder>
          getSimilarityCalculatorFieldBuilder() {
        if (similarityCalculatorBuilder_ == null) {
          similarityCalculatorBuilder_ = new com.google.protobuf.SingleFieldBuilderV3<
              object_detection.protos.RegionSimilarityCalculatorOuterClass.RegionSimilarityCalculator, object_detection.protos.RegionSimilarityCalculatorOuterClass.RegionSimilarityCalculator.Builder, object_detection.protos.RegionSimilarityCalculatorOuterClass.RegionSimilarityCalculatorOrBuilder>(
                  getSimilarityCalculator(),
                  getParentForChildren(),
                  isClean());
          similarityCalculator_ = null;
        }
        return similarityCalculatorBuilder_;
      }

      private boolean encodeBackgroundAsZeros_ ;
      /**
       * <pre>
       * Whether background targets are to be encoded as an all
       * zeros vector or a one-hot vector (where background is the 0th class).
       * </pre>
       *
       * <code>optional bool encode_background_as_zeros = 12 [default = false];</code>
       * @return Whether the encodeBackgroundAsZeros field is set.
       */
      @java.lang.Override
      public boolean hasEncodeBackgroundAsZeros() {
        return ((bitField0_ & 0x00000040) != 0);
      }
      /**
       * <pre>
       * Whether background targets are to be encoded as an all
       * zeros vector or a one-hot vector (where background is the 0th class).
       * </pre>
       *
       * <code>optional bool encode_background_as_zeros = 12 [default = false];</code>
       * @return The encodeBackgroundAsZeros.
       */
      @java.lang.Override
      public boolean getEncodeBackgroundAsZeros() {
        return encodeBackgroundAsZeros_;
      }
      /**
       * <pre>
       * Whether background targets are to be encoded as an all
       * zeros vector or a one-hot vector (where background is the 0th class).
       * </pre>
       *
       * <code>optional bool encode_background_as_zeros = 12 [default = false];</code>
       * @param value The encodeBackgroundAsZeros to set.
       * @return This builder for chaining.
       */
      public Builder setEncodeBackgroundAsZeros(boolean value) {
        bitField0_ |= 0x00000040;
        encodeBackgroundAsZeros_ = value;
        onChanged();
        return this;
      }
      /**
       * <pre>
       * Whether background targets are to be encoded as an all
       * zeros vector or a one-hot vector (where background is the 0th class).
       * </pre>
       *
       * <code>optional bool encode_background_as_zeros = 12 [default = false];</code>
       * @return This builder for chaining.
       */
      public Builder clearEncodeBackgroundAsZeros() {
        bitField0_ = (bitField0_ & ~0x00000040);
        encodeBackgroundAsZeros_ = false;
        onChanged();
        return this;
      }

      private float negativeClassWeight_ = 1F;
      /**
       * <pre>
       * classification weight to be associated to negative
       * anchors (default: 1.0). The weight must be in [0., 1.].
       * </pre>
       *
       * <code>optional float negative_class_weight = 13 [default = 1];</code>
       * @return Whether the negativeClassWeight field is set.
       */
      @java.lang.Override
      public boolean hasNegativeClassWeight() {
        return ((bitField0_ & 0x00000080) != 0);
      }
      /**
       * <pre>
       * classification weight to be associated to negative
       * anchors (default: 1.0). The weight must be in [0., 1.].
       * </pre>
       *
       * <code>optional float negative_class_weight = 13 [default = 1];</code>
       * @return The negativeClassWeight.
       */
      @java.lang.Override
      public float getNegativeClassWeight() {
        return negativeClassWeight_;
      }
      /**
       * <pre>
       * classification weight to be associated to negative
       * anchors (default: 1.0). The weight must be in [0., 1.].
       * </pre>
       *
       * <code>optional float negative_class_weight = 13 [default = 1];</code>
       * @param value The negativeClassWeight to set.
       * @return This builder for chaining.
       */
      public Builder setNegativeClassWeight(float value) {
        bitField0_ |= 0x00000080;
        negativeClassWeight_ = value;
        onChanged();
        return this;
      }
      /**
       * <pre>
       * classification weight to be associated to negative
       * anchors (default: 1.0). The weight must be in [0., 1.].
       * </pre>
       *
       * <code>optional float negative_class_weight = 13 [default = 1];</code>
       * @return This builder for chaining.
       */
      public Builder clearNegativeClassWeight() {
        bitField0_ = (bitField0_ & ~0x00000080);
        negativeClassWeight_ = 1F;
        onChanged();
        return this;
      }

      private object_detection.protos.BoxPredictorOuterClass.BoxPredictor boxPredictor_;
      private com.google.protobuf.SingleFieldBuilderV3<
          object_detection.protos.BoxPredictorOuterClass.BoxPredictor, object_detection.protos.BoxPredictorOuterClass.BoxPredictor.Builder, object_detection.protos.BoxPredictorOuterClass.BoxPredictorOrBuilder> boxPredictorBuilder_;
      /**
       * <pre>
       * Box predictor to attach to the features.
       * </pre>
       *
       * <code>optional .object_detection.protos.BoxPredictor box_predictor = 7;</code>
       * @return Whether the boxPredictor field is set.
       */
      public boolean hasBoxPredictor() {
        return ((bitField0_ & 0x00000100) != 0);
      }
      /**
       * <pre>
       * Box predictor to attach to the features.
       * </pre>
       *
       * <code>optional .object_detection.protos.BoxPredictor box_predictor = 7;</code>
       * @return The boxPredictor.
       */
      public object_detection.protos.BoxPredictorOuterClass.BoxPredictor getBoxPredictor() {
        if (boxPredictorBuilder_ == null) {
          return boxPredictor_ == null ? object_detection.protos.BoxPredictorOuterClass.BoxPredictor.getDefaultInstance() : boxPredictor_;
        } else {
          return boxPredictorBuilder_.getMessage();
        }
      }
      /**
       * <pre>
       * Box predictor to attach to the features.
       * </pre>
       *
       * <code>optional .object_detection.protos.BoxPredictor box_predictor = 7;</code>
       */
      public Builder setBoxPredictor(object_detection.protos.BoxPredictorOuterClass.BoxPredictor value) {
        if (boxPredictorBuilder_ == null) {
          if (value == null) {
            throw new NullPointerException();
          }
          boxPredictor_ = value;
          onChanged();
        } else {
          boxPredictorBuilder_.setMessage(value);
        }
        bitField0_ |= 0x00000100;
        return this;
      }
      /**
       * <pre>
       * Box predictor to attach to the features.
       * </pre>
       *
       * <code>optional .object_detection.protos.BoxPredictor box_predictor = 7;</code>
       */
      public Builder setBoxPredictor(
          object_detection.protos.BoxPredictorOuterClass.BoxPredictor.Builder builderForValue) {
        if (boxPredictorBuilder_ == null) {
          boxPredictor_ = builderForValue.build();
          onChanged();
        } else {
          boxPredictorBuilder_.setMessage(builderForValue.build());
        }
        bitField0_ |= 0x00000100;
        return this;
      }
      /**
       * <pre>
       * Box predictor to attach to the features.
       * </pre>
       *
       * <code>optional .object_detection.protos.BoxPredictor box_predictor = 7;</code>
       */
      public Builder mergeBoxPredictor(object_detection.protos.BoxPredictorOuterClass.BoxPredictor value) {
        if (boxPredictorBuilder_ == null) {
          if (((bitField0_ & 0x00000100) != 0) &&
              boxPredictor_ != null &&
              boxPredictor_ != object_detection.protos.BoxPredictorOuterClass.BoxPredictor.getDefaultInstance()) {
            boxPredictor_ =
              object_detection.protos.BoxPredictorOuterClass.BoxPredictor.newBuilder(boxPredictor_).mergeFrom(value).buildPartial();
          } else {
            boxPredictor_ = value;
          }
          onChanged();
        } else {
          boxPredictorBuilder_.mergeFrom(value);
        }
        bitField0_ |= 0x00000100;
        return this;
      }
      /**
       * <pre>
       * Box predictor to attach to the features.
       * </pre>
       *
       * <code>optional .object_detection.protos.BoxPredictor box_predictor = 7;</code>
       */
      public Builder clearBoxPredictor() {
        if (boxPredictorBuilder_ == null) {
          boxPredictor_ = null;
          onChanged();
        } else {
          boxPredictorBuilder_.clear();
        }
        bitField0_ = (bitField0_ & ~0x00000100);
        return this;
      }
      /**
       * <pre>
       * Box predictor to attach to the features.
       * </pre>
       *
       * <code>optional .object_detection.protos.BoxPredictor box_predictor = 7;</code>
       */
      public object_detection.protos.BoxPredictorOuterClass.BoxPredictor.Builder getBoxPredictorBuilder() {
        bitField0_ |= 0x00000100;
        onChanged();
        return getBoxPredictorFieldBuilder().getBuilder();
      }
      /**
       * <pre>
       * Box predictor to attach to the features.
       * </pre>
       *
       * <code>optional .object_detection.protos.BoxPredictor box_predictor = 7;</code>
       */
      public object_detection.protos.BoxPredictorOuterClass.BoxPredictorOrBuilder getBoxPredictorOrBuilder() {
        if (boxPredictorBuilder_ != null) {
          return boxPredictorBuilder_.getMessageOrBuilder();
        } else {
          return boxPredictor_ == null ?
              object_detection.protos.BoxPredictorOuterClass.BoxPredictor.getDefaultInstance() : boxPredictor_;
        }
      }
      /**
       * <pre>
       * Box predictor to attach to the features.
       * </pre>
       *
       * <code>optional .object_detection.protos.BoxPredictor box_predictor = 7;</code>
       */
      private com.google.protobuf.SingleFieldBuilderV3<
          object_detection.protos.BoxPredictorOuterClass.BoxPredictor, object_detection.protos.BoxPredictorOuterClass.BoxPredictor.Builder, object_detection.protos.BoxPredictorOuterClass.BoxPredictorOrBuilder>
          getBoxPredictorFieldBuilder() {
        if (boxPredictorBuilder_ == null) {
          boxPredictorBuilder_ = new com.google.protobuf.SingleFieldBuilderV3<
              object_detection.protos.BoxPredictorOuterClass.BoxPredictor, object_detection.protos.BoxPredictorOuterClass.BoxPredictor.Builder, object_detection.protos.BoxPredictorOuterClass.BoxPredictorOrBuilder>(
                  getBoxPredictor(),
                  getParentForChildren(),
                  isClean());
          boxPredictor_ = null;
        }
        return boxPredictorBuilder_;
      }

      private object_detection.protos.AnchorGeneratorOuterClass.AnchorGenerator anchorGenerator_;
      private com.google.protobuf.SingleFieldBuilderV3<
          object_detection.protos.AnchorGeneratorOuterClass.AnchorGenerator, object_detection.protos.AnchorGeneratorOuterClass.AnchorGenerator.Builder, object_detection.protos.AnchorGeneratorOuterClass.AnchorGeneratorOrBuilder> anchorGeneratorBuilder_;
      /**
       * <pre>
       * Anchor generator to compute anchors.
       * </pre>
       *
       * <code>optional .object_detection.protos.AnchorGenerator anchor_generator = 8;</code>
       * @return Whether the anchorGenerator field is set.
       */
      public boolean hasAnchorGenerator() {
        return ((bitField0_ & 0x00000200) != 0);
      }
      /**
       * <pre>
       * Anchor generator to compute anchors.
       * </pre>
       *
       * <code>optional .object_detection.protos.AnchorGenerator anchor_generator = 8;</code>
       * @return The anchorGenerator.
       */
      public object_detection.protos.AnchorGeneratorOuterClass.AnchorGenerator getAnchorGenerator() {
        if (anchorGeneratorBuilder_ == null) {
          return anchorGenerator_ == null ? object_detection.protos.AnchorGeneratorOuterClass.AnchorGenerator.getDefaultInstance() : anchorGenerator_;
        } else {
          return anchorGeneratorBuilder_.getMessage();
        }
      }
      /**
       * <pre>
       * Anchor generator to compute anchors.
       * </pre>
       *
       * <code>optional .object_detection.protos.AnchorGenerator anchor_generator = 8;</code>
       */
      public Builder setAnchorGenerator(object_detection.protos.AnchorGeneratorOuterClass.AnchorGenerator value) {
        if (anchorGeneratorBuilder_ == null) {
          if (value == null) {
            throw new NullPointerException();
          }
          anchorGenerator_ = value;
          onChanged();
        } else {
          anchorGeneratorBuilder_.setMessage(value);
        }
        bitField0_ |= 0x00000200;
        return this;
      }
      /**
       * <pre>
       * Anchor generator to compute anchors.
       * </pre>
       *
       * <code>optional .object_detection.protos.AnchorGenerator anchor_generator = 8;</code>
       */
      public Builder setAnchorGenerator(
          object_detection.protos.AnchorGeneratorOuterClass.AnchorGenerator.Builder builderForValue) {
        if (anchorGeneratorBuilder_ == null) {
          anchorGenerator_ = builderForValue.build();
          onChanged();
        } else {
          anchorGeneratorBuilder_.setMessage(builderForValue.build());
        }
        bitField0_ |= 0x00000200;
        return this;
      }
      /**
       * <pre>
       * Anchor generator to compute anchors.
       * </pre>
       *
       * <code>optional .object_detection.protos.AnchorGenerator anchor_generator = 8;</code>
       */
      public Builder mergeAnchorGenerator(object_detection.protos.AnchorGeneratorOuterClass.AnchorGenerator value) {
        if (anchorGeneratorBuilder_ == null) {
          if (((bitField0_ & 0x00000200) != 0) &&
              anchorGenerator_ != null &&
              anchorGenerator_ != object_detection.protos.AnchorGeneratorOuterClass.AnchorGenerator.getDefaultInstance()) {
            anchorGenerator_ =
              object_detection.protos.AnchorGeneratorOuterClass.AnchorGenerator.newBuilder(anchorGenerator_).mergeFrom(value).buildPartial();
          } else {
            anchorGenerator_ = value;
          }
          onChanged();
        } else {
          anchorGeneratorBuilder_.mergeFrom(value);
        }
        bitField0_ |= 0x00000200;
        return this;
      }
      /**
       * <pre>
       * Anchor generator to compute anchors.
       * </pre>
       *
       * <code>optional .object_detection.protos.AnchorGenerator anchor_generator = 8;</code>
       */
      public Builder clearAnchorGenerator() {
        if (anchorGeneratorBuilder_ == null) {
          anchorGenerator_ = null;
          onChanged();
        } else {
          anchorGeneratorBuilder_.clear();
        }
        bitField0_ = (bitField0_ & ~0x00000200);
        return this;
      }
      /**
       * <pre>
       * Anchor generator to compute anchors.
       * </pre>
       *
       * <code>optional .object_detection.protos.AnchorGenerator anchor_generator = 8;</code>
       */
      public object_detection.protos.AnchorGeneratorOuterClass.AnchorGenerator.Builder getAnchorGeneratorBuilder() {
        bitField0_ |= 0x00000200;
        onChanged();
        return getAnchorGeneratorFieldBuilder().getBuilder();
      }
      /**
       * <pre>
       * Anchor generator to compute anchors.
       * </pre>
       *
       * <code>optional .object_detection.protos.AnchorGenerator anchor_generator = 8;</code>
       */
      public object_detection.protos.AnchorGeneratorOuterClass.AnchorGeneratorOrBuilder getAnchorGeneratorOrBuilder() {
        if (anchorGeneratorBuilder_ != null) {
          return anchorGeneratorBuilder_.getMessageOrBuilder();
        } else {
          return anchorGenerator_ == null ?
              object_detection.protos.AnchorGeneratorOuterClass.AnchorGenerator.getDefaultInstance() : anchorGenerator_;
        }
      }
      /**
       * <pre>
       * Anchor generator to compute anchors.
       * </pre>
       *
       * <code>optional .object_detection.protos.AnchorGenerator anchor_generator = 8;</code>
       */
      private com.google.protobuf.SingleFieldBuilderV3<
          object_detection.protos.AnchorGeneratorOuterClass.AnchorGenerator, object_detection.protos.AnchorGeneratorOuterClass.AnchorGenerator.Builder, object_detection.protos.AnchorGeneratorOuterClass.AnchorGeneratorOrBuilder>
          getAnchorGeneratorFieldBuilder() {
        if (anchorGeneratorBuilder_ == null) {
          anchorGeneratorBuilder_ = new com.google.protobuf.SingleFieldBuilderV3<
              object_detection.protos.AnchorGeneratorOuterClass.AnchorGenerator, object_detection.protos.AnchorGeneratorOuterClass.AnchorGenerator.Builder, object_detection.protos.AnchorGeneratorOuterClass.AnchorGeneratorOrBuilder>(
                  getAnchorGenerator(),
                  getParentForChildren(),
                  isClean());
          anchorGenerator_ = null;
        }
        return anchorGeneratorBuilder_;
      }

      private object_detection.protos.PostProcessingOuterClass.PostProcessing postProcessing_;
      private com.google.protobuf.SingleFieldBuilderV3<
          object_detection.protos.PostProcessingOuterClass.PostProcessing, object_detection.protos.PostProcessingOuterClass.PostProcessing.Builder, object_detection.protos.PostProcessingOuterClass.PostProcessingOrBuilder> postProcessingBuilder_;
      /**
       * <pre>
       * Post processing to apply on the predictions.
       * </pre>
       *
       * <code>optional .object_detection.protos.PostProcessing post_processing = 9;</code>
       * @return Whether the postProcessing field is set.
       */
      public boolean hasPostProcessing() {
        return ((bitField0_ & 0x00000400) != 0);
      }
      /**
       * <pre>
       * Post processing to apply on the predictions.
       * </pre>
       *
       * <code>optional .object_detection.protos.PostProcessing post_processing = 9;</code>
       * @return The postProcessing.
       */
      public object_detection.protos.PostProcessingOuterClass.PostProcessing getPostProcessing() {
        if (postProcessingBuilder_ == null) {
          return postProcessing_ == null ? object_detection.protos.PostProcessingOuterClass.PostProcessing.getDefaultInstance() : postProcessing_;
        } else {
          return postProcessingBuilder_.getMessage();
        }
      }
      /**
       * <pre>
       * Post processing to apply on the predictions.
       * </pre>
       *
       * <code>optional .object_detection.protos.PostProcessing post_processing = 9;</code>
       */
      public Builder setPostProcessing(object_detection.protos.PostProcessingOuterClass.PostProcessing value) {
        if (postProcessingBuilder_ == null) {
          if (value == null) {
            throw new NullPointerException();
          }
          postProcessing_ = value;
          onChanged();
        } else {
          postProcessingBuilder_.setMessage(value);
        }
        bitField0_ |= 0x00000400;
        return this;
      }
      /**
       * <pre>
       * Post processing to apply on the predictions.
       * </pre>
       *
       * <code>optional .object_detection.protos.PostProcessing post_processing = 9;</code>
       */
      public Builder setPostProcessing(
          object_detection.protos.PostProcessingOuterClass.PostProcessing.Builder builderForValue) {
        if (postProcessingBuilder_ == null) {
          postProcessing_ = builderForValue.build();
          onChanged();
        } else {
          postProcessingBuilder_.setMessage(builderForValue.build());
        }
        bitField0_ |= 0x00000400;
        return this;
      }
      /**
       * <pre>
       * Post processing to apply on the predictions.
       * </pre>
       *
       * <code>optional .object_detection.protos.PostProcessing post_processing = 9;</code>
       */
      public Builder mergePostProcessing(object_detection.protos.PostProcessingOuterClass.PostProcessing value) {
        if (postProcessingBuilder_ == null) {
          if (((bitField0_ & 0x00000400) != 0) &&
              postProcessing_ != null &&
              postProcessing_ != object_detection.protos.PostProcessingOuterClass.PostProcessing.getDefaultInstance()) {
            postProcessing_ =
              object_detection.protos.PostProcessingOuterClass.PostProcessing.newBuilder(postProcessing_).mergeFrom(value).buildPartial();
          } else {
            postProcessing_ = value;
          }
          onChanged();
        } else {
          postProcessingBuilder_.mergeFrom(value);
        }
        bitField0_ |= 0x00000400;
        return this;
      }
      /**
       * <pre>
       * Post processing to apply on the predictions.
       * </pre>
       *
       * <code>optional .object_detection.protos.PostProcessing post_processing = 9;</code>
       */
      public Builder clearPostProcessing() {
        if (postProcessingBuilder_ == null) {
          postProcessing_ = null;
          onChanged();
        } else {
          postProcessingBuilder_.clear();
        }
        bitField0_ = (bitField0_ & ~0x00000400);
        return this;
      }
      /**
       * <pre>
       * Post processing to apply on the predictions.
       * </pre>
       *
       * <code>optional .object_detection.protos.PostProcessing post_processing = 9;</code>
       */
      public object_detection.protos.PostProcessingOuterClass.PostProcessing.Builder getPostProcessingBuilder() {
        bitField0_ |= 0x00000400;
        onChanged();
        return getPostProcessingFieldBuilder().getBuilder();
      }
      /**
       * <pre>
       * Post processing to apply on the predictions.
       * </pre>
       *
       * <code>optional .object_detection.protos.PostProcessing post_processing = 9;</code>
       */
      public object_detection.protos.PostProcessingOuterClass.PostProcessingOrBuilder getPostProcessingOrBuilder() {
        if (postProcessingBuilder_ != null) {
          return postProcessingBuilder_.getMessageOrBuilder();
        } else {
          return postProcessing_ == null ?
              object_detection.protos.PostProcessingOuterClass.PostProcessing.getDefaultInstance() : postProcessing_;
        }
      }
      /**
       * <pre>
       * Post processing to apply on the predictions.
       * </pre>
       *
       * <code>optional .object_detection.protos.PostProcessing post_processing = 9;</code>
       */
      private com.google.protobuf.SingleFieldBuilderV3<
          object_detection.protos.PostProcessingOuterClass.PostProcessing, object_detection.protos.PostProcessingOuterClass.PostProcessing.Builder, object_detection.protos.PostProcessingOuterClass.PostProcessingOrBuilder>
          getPostProcessingFieldBuilder() {
        if (postProcessingBuilder_ == null) {
          postProcessingBuilder_ = new com.google.protobuf.SingleFieldBuilderV3<
              object_detection.protos.PostProcessingOuterClass.PostProcessing, object_detection.protos.PostProcessingOuterClass.PostProcessing.Builder, object_detection.protos.PostProcessingOuterClass.PostProcessingOrBuilder>(
                  getPostProcessing(),
                  getParentForChildren(),
                  isClean());
          postProcessing_ = null;
        }
        return postProcessingBuilder_;
      }

      private boolean normalizeLossByNumMatches_ = true;
      /**
       * <pre>
       * Whether to normalize the loss by number of groundtruth boxes that match to
       * the anchors.
       * </pre>
       *
       * <code>optional bool normalize_loss_by_num_matches = 10 [default = true];</code>
       * @return Whether the normalizeLossByNumMatches field is set.
       */
      @java.lang.Override
      public boolean hasNormalizeLossByNumMatches() {
        return ((bitField0_ & 0x00000800) != 0);
      }
      /**
       * <pre>
       * Whether to normalize the loss by number of groundtruth boxes that match to
       * the anchors.
       * </pre>
       *
       * <code>optional bool normalize_loss_by_num_matches = 10 [default = true];</code>
       * @return The normalizeLossByNumMatches.
       */
      @java.lang.Override
      public boolean getNormalizeLossByNumMatches() {
        return normalizeLossByNumMatches_;
      }
      /**
       * <pre>
       * Whether to normalize the loss by number of groundtruth boxes that match to
       * the anchors.
       * </pre>
       *
       * <code>optional bool normalize_loss_by_num_matches = 10 [default = true];</code>
       * @param value The normalizeLossByNumMatches to set.
       * @return This builder for chaining.
       */
      public Builder setNormalizeLossByNumMatches(boolean value) {
        bitField0_ |= 0x00000800;
        normalizeLossByNumMatches_ = value;
        onChanged();
        return this;
      }
      /**
       * <pre>
       * Whether to normalize the loss by number of groundtruth boxes that match to
       * the anchors.
       * </pre>
       *
       * <code>optional bool normalize_loss_by_num_matches = 10 [default = true];</code>
       * @return This builder for chaining.
       */
      public Builder clearNormalizeLossByNumMatches() {
        bitField0_ = (bitField0_ & ~0x00000800);
        normalizeLossByNumMatches_ = true;
        onChanged();
        return this;
      }

      private boolean normalizeLocLossByCodesize_ ;
      /**
       * <pre>
       * Whether to normalize the localization loss by the code size of the box
       * encodings. This is applied along with other normalization factors.
       * </pre>
       *
       * <code>optional bool normalize_loc_loss_by_codesize = 14 [default = false];</code>
       * @return Whether the normalizeLocLossByCodesize field is set.
       */
      @java.lang.Override
      public boolean hasNormalizeLocLossByCodesize() {
        return ((bitField0_ & 0x00001000) != 0);
      }
      /**
       * <pre>
       * Whether to normalize the localization loss by the code size of the box
       * encodings. This is applied along with other normalization factors.
       * </pre>
       *
       * <code>optional bool normalize_loc_loss_by_codesize = 14 [default = false];</code>
       * @return The normalizeLocLossByCodesize.
       */
      @java.lang.Override
      public boolean getNormalizeLocLossByCodesize() {
        return normalizeLocLossByCodesize_;
      }
      /**
       * <pre>
       * Whether to normalize the localization loss by the code size of the box
       * encodings. This is applied along with other normalization factors.
       * </pre>
       *
       * <code>optional bool normalize_loc_loss_by_codesize = 14 [default = false];</code>
       * @param value The normalizeLocLossByCodesize to set.
       * @return This builder for chaining.
       */
      public Builder setNormalizeLocLossByCodesize(boolean value) {
        bitField0_ |= 0x00001000;
        normalizeLocLossByCodesize_ = value;
        onChanged();
        return this;
      }
      /**
       * <pre>
       * Whether to normalize the localization loss by the code size of the box
       * encodings. This is applied along with other normalization factors.
       * </pre>
       *
       * <code>optional bool normalize_loc_loss_by_codesize = 14 [default = false];</code>
       * @return This builder for chaining.
       */
      public Builder clearNormalizeLocLossByCodesize() {
        bitField0_ = (bitField0_ & ~0x00001000);
        normalizeLocLossByCodesize_ = false;
        onChanged();
        return this;
      }

      private object_detection.protos.Losses.Loss loss_;
      private com.google.protobuf.SingleFieldBuilderV3<
          object_detection.protos.Losses.Loss, object_detection.protos.Losses.Loss.Builder, object_detection.protos.Losses.LossOrBuilder> lossBuilder_;
      /**
       * <pre>
       * Loss configuration for training.
       * </pre>
       *
       * <code>optional .object_detection.protos.Loss loss = 11;</code>
       * @return Whether the loss field is set.
       */
      public boolean hasLoss() {
        return ((bitField0_ & 0x00002000) != 0);
      }
      /**
       * <pre>
       * Loss configuration for training.
       * </pre>
       *
       * <code>optional .object_detection.protos.Loss loss = 11;</code>
       * @return The loss.
       */
      public object_detection.protos.Losses.Loss getLoss() {
        if (lossBuilder_ == null) {
          return loss_ == null ? object_detection.protos.Losses.Loss.getDefaultInstance() : loss_;
        } else {
          return lossBuilder_.getMessage();
        }
      }
      /**
       * <pre>
       * Loss configuration for training.
       * </pre>
       *
       * <code>optional .object_detection.protos.Loss loss = 11;</code>
       */
      public Builder setLoss(object_detection.protos.Losses.Loss value) {
        if (lossBuilder_ == null) {
          if (value == null) {
            throw new NullPointerException();
          }
          loss_ = value;
          onChanged();
        } else {
          lossBuilder_.setMessage(value);
        }
        bitField0_ |= 0x00002000;
        return this;
      }
      /**
       * <pre>
       * Loss configuration for training.
       * </pre>
       *
       * <code>optional .object_detection.protos.Loss loss = 11;</code>
       */
      public Builder setLoss(
          object_detection.protos.Losses.Loss.Builder builderForValue) {
        if (lossBuilder_ == null) {
          loss_ = builderForValue.build();
          onChanged();
        } else {
          lossBuilder_.setMessage(builderForValue.build());
        }
        bitField0_ |= 0x00002000;
        return this;
      }
      /**
       * <pre>
       * Loss configuration for training.
       * </pre>
       *
       * <code>optional .object_detection.protos.Loss loss = 11;</code>
       */
      public Builder mergeLoss(object_detection.protos.Losses.Loss value) {
        if (lossBuilder_ == null) {
          if (((bitField0_ & 0x00002000) != 0) &&
              loss_ != null &&
              loss_ != object_detection.protos.Losses.Loss.getDefaultInstance()) {
            loss_ =
              object_detection.protos.Losses.Loss.newBuilder(loss_).mergeFrom(value).buildPartial();
          } else {
            loss_ = value;
          }
          onChanged();
        } else {
          lossBuilder_.mergeFrom(value);
        }
        bitField0_ |= 0x00002000;
        return this;
      }
      /**
       * <pre>
       * Loss configuration for training.
       * </pre>
       *
       * <code>optional .object_detection.protos.Loss loss = 11;</code>
       */
      public Builder clearLoss() {
        if (lossBuilder_ == null) {
          loss_ = null;
          onChanged();
        } else {
          lossBuilder_.clear();
        }
        bitField0_ = (bitField0_ & ~0x00002000);
        return this;
      }
      /**
       * <pre>
       * Loss configuration for training.
       * </pre>
       *
       * <code>optional .object_detection.protos.Loss loss = 11;</code>
       */
      public object_detection.protos.Losses.Loss.Builder getLossBuilder() {
        bitField0_ |= 0x00002000;
        onChanged();
        return getLossFieldBuilder().getBuilder();
      }
      /**
       * <pre>
       * Loss configuration for training.
       * </pre>
       *
       * <code>optional .object_detection.protos.Loss loss = 11;</code>
       */
      public object_detection.protos.Losses.LossOrBuilder getLossOrBuilder() {
        if (lossBuilder_ != null) {
          return lossBuilder_.getMessageOrBuilder();
        } else {
          return loss_ == null ?
              object_detection.protos.Losses.Loss.getDefaultInstance() : loss_;
        }
      }
      /**
       * <pre>
       * Loss configuration for training.
       * </pre>
       *
       * <code>optional .object_detection.protos.Loss loss = 11;</code>
       */
      private com.google.protobuf.SingleFieldBuilderV3<
          object_detection.protos.Losses.Loss, object_detection.protos.Losses.Loss.Builder, object_detection.protos.Losses.LossOrBuilder>
          getLossFieldBuilder() {
        if (lossBuilder_ == null) {
          lossBuilder_ = new com.google.protobuf.SingleFieldBuilderV3<
              object_detection.protos.Losses.Loss, object_detection.protos.Losses.Loss.Builder, object_detection.protos.Losses.LossOrBuilder>(
                  getLoss(),
                  getParentForChildren(),
                  isClean());
          loss_ = null;
        }
        return lossBuilder_;
      }

      private boolean freezeBatchnorm_ ;
      /**
       * <pre>
       * Whether to update batch norm parameters during training or not.
       * When training with a relative small batch size (e.g. 1), it is
       * desirable to disable batch norm update and use pretrained batch norm
       * params.
       * Note: Some feature extractors are used with canned arg_scopes
       * (e.g resnet arg scopes).  In these cases training behavior of batch norm
       * variables may depend on both values of `batch_norm_trainable` and
       * `is_training`.
       * When canned arg_scopes are used with feature extractors `conv_hyperparams`
       * will apply only to the additional layers that are added and are outside the
       * canned arg_scope.
       * </pre>
       *
       * <code>optional bool freeze_batchnorm = 16 [default = false];</code>
       * @return Whether the freezeBatchnorm field is set.
       */
      @java.lang.Override
      public boolean hasFreezeBatchnorm() {
        return ((bitField0_ & 0x00004000) != 0);
      }
      /**
       * <pre>
       * Whether to update batch norm parameters during training or not.
       * When training with a relative small batch size (e.g. 1), it is
       * desirable to disable batch norm update and use pretrained batch norm
       * params.
       * Note: Some feature extractors are used with canned arg_scopes
       * (e.g resnet arg scopes).  In these cases training behavior of batch norm
       * variables may depend on both values of `batch_norm_trainable` and
       * `is_training`.
       * When canned arg_scopes are used with feature extractors `conv_hyperparams`
       * will apply only to the additional layers that are added and are outside the
       * canned arg_scope.
       * </pre>
       *
       * <code>optional bool freeze_batchnorm = 16 [default = false];</code>
       * @return The freezeBatchnorm.
       */
      @java.lang.Override
      public boolean getFreezeBatchnorm() {
        return freezeBatchnorm_;
      }
      /**
       * <pre>
       * Whether to update batch norm parameters during training or not.
       * When training with a relative small batch size (e.g. 1), it is
       * desirable to disable batch norm update and use pretrained batch norm
       * params.
       * Note: Some feature extractors are used with canned arg_scopes
       * (e.g resnet arg scopes).  In these cases training behavior of batch norm
       * variables may depend on both values of `batch_norm_trainable` and
       * `is_training`.
       * When canned arg_scopes are used with feature extractors `conv_hyperparams`
       * will apply only to the additional layers that are added and are outside the
       * canned arg_scope.
       * </pre>
       *
       * <code>optional bool freeze_batchnorm = 16 [default = false];</code>
       * @param value The freezeBatchnorm to set.
       * @return This builder for chaining.
       */
      public Builder setFreezeBatchnorm(boolean value) {
        bitField0_ |= 0x00004000;
        freezeBatchnorm_ = value;
        onChanged();
        return this;
      }
      /**
       * <pre>
       * Whether to update batch norm parameters during training or not.
       * When training with a relative small batch size (e.g. 1), it is
       * desirable to disable batch norm update and use pretrained batch norm
       * params.
       * Note: Some feature extractors are used with canned arg_scopes
       * (e.g resnet arg scopes).  In these cases training behavior of batch norm
       * variables may depend on both values of `batch_norm_trainable` and
       * `is_training`.
       * When canned arg_scopes are used with feature extractors `conv_hyperparams`
       * will apply only to the additional layers that are added and are outside the
       * canned arg_scope.
       * </pre>
       *
       * <code>optional bool freeze_batchnorm = 16 [default = false];</code>
       * @return This builder for chaining.
       */
      public Builder clearFreezeBatchnorm() {
        bitField0_ = (bitField0_ & ~0x00004000);
        freezeBatchnorm_ = false;
        onChanged();
        return this;
      }

      private boolean inplaceBatchnormUpdate_ ;
      /**
       * <pre>
       * Whether to update batch_norm inplace during training. This is required
       * for batch norm to work correctly on TPUs. When this is false, user must add
       * a control dependency on tf.GraphKeys.UPDATE_OPS for train/loss op in order
       * to update the batch norm moving average parameters.
       * </pre>
       *
       * <code>optional bool inplace_batchnorm_update = 15 [default = false];</code>
       * @return Whether the inplaceBatchnormUpdate field is set.
       */
      @java.lang.Override
      public boolean hasInplaceBatchnormUpdate() {
        return ((bitField0_ & 0x00008000) != 0);
      }
      /**
       * <pre>
       * Whether to update batch_norm inplace during training. This is required
       * for batch norm to work correctly on TPUs. When this is false, user must add
       * a control dependency on tf.GraphKeys.UPDATE_OPS for train/loss op in order
       * to update the batch norm moving average parameters.
       * </pre>
       *
       * <code>optional bool inplace_batchnorm_update = 15 [default = false];</code>
       * @return The inplaceBatchnormUpdate.
       */
      @java.lang.Override
      public boolean getInplaceBatchnormUpdate() {
        return inplaceBatchnormUpdate_;
      }
      /**
       * <pre>
       * Whether to update batch_norm inplace during training. This is required
       * for batch norm to work correctly on TPUs. When this is false, user must add
       * a control dependency on tf.GraphKeys.UPDATE_OPS for train/loss op in order
       * to update the batch norm moving average parameters.
       * </pre>
       *
       * <code>optional bool inplace_batchnorm_update = 15 [default = false];</code>
       * @param value The inplaceBatchnormUpdate to set.
       * @return This builder for chaining.
       */
      public Builder setInplaceBatchnormUpdate(boolean value) {
        bitField0_ |= 0x00008000;
        inplaceBatchnormUpdate_ = value;
        onChanged();
        return this;
      }
      /**
       * <pre>
       * Whether to update batch_norm inplace during training. This is required
       * for batch norm to work correctly on TPUs. When this is false, user must add
       * a control dependency on tf.GraphKeys.UPDATE_OPS for train/loss op in order
       * to update the batch norm moving average parameters.
       * </pre>
       *
       * <code>optional bool inplace_batchnorm_update = 15 [default = false];</code>
       * @return This builder for chaining.
       */
      public Builder clearInplaceBatchnormUpdate() {
        bitField0_ = (bitField0_ & ~0x00008000);
        inplaceBatchnormUpdate_ = false;
        onChanged();
        return this;
      }

      private boolean addBackgroundClass_ = true;
      /**
       * <pre>
       * Whether to add an implicit background class to one-hot encodings of
       * groundtruth labels. Set to false if training a single
       * class model or using an explicit background class.
       * </pre>
       *
       * <code>optional bool add_background_class = 21 [default = true];</code>
       * @return Whether the addBackgroundClass field is set.
       */
      @java.lang.Override
      public boolean hasAddBackgroundClass() {
        return ((bitField0_ & 0x00010000) != 0);
      }
      /**
       * <pre>
       * Whether to add an implicit background class to one-hot encodings of
       * groundtruth labels. Set to false if training a single
       * class model or using an explicit background class.
       * </pre>
       *
       * <code>optional bool add_background_class = 21 [default = true];</code>
       * @return The addBackgroundClass.
       */
      @java.lang.Override
      public boolean getAddBackgroundClass() {
        return addBackgroundClass_;
      }
      /**
       * <pre>
       * Whether to add an implicit background class to one-hot encodings of
       * groundtruth labels. Set to false if training a single
       * class model or using an explicit background class.
       * </pre>
       *
       * <code>optional bool add_background_class = 21 [default = true];</code>
       * @param value The addBackgroundClass to set.
       * @return This builder for chaining.
       */
      public Builder setAddBackgroundClass(boolean value) {
        bitField0_ |= 0x00010000;
        addBackgroundClass_ = value;
        onChanged();
        return this;
      }
      /**
       * <pre>
       * Whether to add an implicit background class to one-hot encodings of
       * groundtruth labels. Set to false if training a single
       * class model or using an explicit background class.
       * </pre>
       *
       * <code>optional bool add_background_class = 21 [default = true];</code>
       * @return This builder for chaining.
       */
      public Builder clearAddBackgroundClass() {
        bitField0_ = (bitField0_ & ~0x00010000);
        addBackgroundClass_ = true;
        onChanged();
        return this;
      }

      private boolean explicitBackgroundClass_ ;
      /**
       * <pre>
       * Whether to use an explicit background class. Set to true if using
       * groundtruth labels with an explicit background class, as in multiclass
       * scores.
       * </pre>
       *
       * <code>optional bool explicit_background_class = 24 [default = false];</code>
       * @return Whether the explicitBackgroundClass field is set.
       */
      @java.lang.Override
      public boolean hasExplicitBackgroundClass() {
        return ((bitField0_ & 0x00020000) != 0);
      }
      /**
       * <pre>
       * Whether to use an explicit background class. Set to true if using
       * groundtruth labels with an explicit background class, as in multiclass
       * scores.
       * </pre>
       *
       * <code>optional bool explicit_background_class = 24 [default = false];</code>
       * @return The explicitBackgroundClass.
       */
      @java.lang.Override
      public boolean getExplicitBackgroundClass() {
        return explicitBackgroundClass_;
      }
      /**
       * <pre>
       * Whether to use an explicit background class. Set to true if using
       * groundtruth labels with an explicit background class, as in multiclass
       * scores.
       * </pre>
       *
       * <code>optional bool explicit_background_class = 24 [default = false];</code>
       * @param value The explicitBackgroundClass to set.
       * @return This builder for chaining.
       */
      public Builder setExplicitBackgroundClass(boolean value) {
        bitField0_ |= 0x00020000;
        explicitBackgroundClass_ = value;
        onChanged();
        return this;
      }
      /**
       * <pre>
       * Whether to use an explicit background class. Set to true if using
       * groundtruth labels with an explicit background class, as in multiclass
       * scores.
       * </pre>
       *
       * <code>optional bool explicit_background_class = 24 [default = false];</code>
       * @return This builder for chaining.
       */
      public Builder clearExplicitBackgroundClass() {
        bitField0_ = (bitField0_ & ~0x00020000);
        explicitBackgroundClass_ = false;
        onChanged();
        return this;
      }

      private boolean useConfidencesAsTargets_ ;
      /**
       * <code>optional bool use_confidences_as_targets = 22 [default = false];</code>
       * @return Whether the useConfidencesAsTargets field is set.
       */
      @java.lang.Override
      public boolean hasUseConfidencesAsTargets() {
        return ((bitField0_ & 0x00040000) != 0);
      }
      /**
       * <code>optional bool use_confidences_as_targets = 22 [default = false];</code>
       * @return The useConfidencesAsTargets.
       */
      @java.lang.Override
      public boolean getUseConfidencesAsTargets() {
        return useConfidencesAsTargets_;
      }
      /**
       * <code>optional bool use_confidences_as_targets = 22 [default = false];</code>
       * @param value The useConfidencesAsTargets to set.
       * @return This builder for chaining.
       */
      public Builder setUseConfidencesAsTargets(boolean value) {
        bitField0_ |= 0x00040000;
        useConfidencesAsTargets_ = value;
        onChanged();
        return this;
      }
      /**
       * <code>optional bool use_confidences_as_targets = 22 [default = false];</code>
       * @return This builder for chaining.
       */
      public Builder clearUseConfidencesAsTargets() {
        bitField0_ = (bitField0_ & ~0x00040000);
        useConfidencesAsTargets_ = false;
        onChanged();
        return this;
      }

      private float implicitExampleWeight_ = 1F;
      /**
       * <code>optional float implicit_example_weight = 23 [default = 1];</code>
       * @return Whether the implicitExampleWeight field is set.
       */
      @java.lang.Override
      public boolean hasImplicitExampleWeight() {
        return ((bitField0_ & 0x00080000) != 0);
      }
      /**
       * <code>optional float implicit_example_weight = 23 [default = 1];</code>
       * @return The implicitExampleWeight.
       */
      @java.lang.Override
      public float getImplicitExampleWeight() {
        return implicitExampleWeight_;
      }
      /**
       * <code>optional float implicit_example_weight = 23 [default = 1];</code>
       * @param value The implicitExampleWeight to set.
       * @return This builder for chaining.
       */
      public Builder setImplicitExampleWeight(float value) {
        bitField0_ |= 0x00080000;
        implicitExampleWeight_ = value;
        onChanged();
        return this;
      }
      /**
       * <code>optional float implicit_example_weight = 23 [default = 1];</code>
       * @return This builder for chaining.
       */
      public Builder clearImplicitExampleWeight() {
        bitField0_ = (bitField0_ & ~0x00080000);
        implicitExampleWeight_ = 1F;
        onChanged();
        return this;
      }

      private boolean returnRawDetectionsDuringPredict_ ;
      /**
       * <code>optional bool return_raw_detections_during_predict = 26 [default = false];</code>
       * @return Whether the returnRawDetectionsDuringPredict field is set.
       */
      @java.lang.Override
      public boolean hasReturnRawDetectionsDuringPredict() {
        return ((bitField0_ & 0x00100000) != 0);
      }
      /**
       * <code>optional bool return_raw_detections_during_predict = 26 [default = false];</code>
       * @return The returnRawDetectionsDuringPredict.
       */
      @java.lang.Override
      public boolean getReturnRawDetectionsDuringPredict() {
        return returnRawDetectionsDuringPredict_;
      }
      /**
       * <code>optional bool return_raw_detections_during_predict = 26 [default = false];</code>
       * @param value The returnRawDetectionsDuringPredict to set.
       * @return This builder for chaining.
       */
      public Builder setReturnRawDetectionsDuringPredict(boolean value) {
        bitField0_ |= 0x00100000;
        returnRawDetectionsDuringPredict_ = value;
        onChanged();
        return this;
      }
      /**
       * <code>optional bool return_raw_detections_during_predict = 26 [default = false];</code>
       * @return This builder for chaining.
       */
      public Builder clearReturnRawDetectionsDuringPredict() {
        bitField0_ = (bitField0_ & ~0x00100000);
        returnRawDetectionsDuringPredict_ = false;
        onChanged();
        return this;
      }

      private object_detection.protos.SsdOuterClass.Ssd.MaskHead maskHeadConfig_;
      private com.google.protobuf.SingleFieldBuilderV3<
          object_detection.protos.SsdOuterClass.Ssd.MaskHead, object_detection.protos.SsdOuterClass.Ssd.MaskHead.Builder, object_detection.protos.SsdOuterClass.Ssd.MaskHeadOrBuilder> maskHeadConfigBuilder_;
      /**
       * <pre>
       * Configs for mask head.
       * </pre>
       *
       * <code>optional .object_detection.protos.Ssd.MaskHead mask_head_config = 25;</code>
       * @return Whether the maskHeadConfig field is set.
       */
      public boolean hasMaskHeadConfig() {
        return ((bitField0_ & 0x00200000) != 0);
      }
      /**
       * <pre>
       * Configs for mask head.
       * </pre>
       *
       * <code>optional .object_detection.protos.Ssd.MaskHead mask_head_config = 25;</code>
       * @return The maskHeadConfig.
       */
      public object_detection.protos.SsdOuterClass.Ssd.MaskHead getMaskHeadConfig() {
        if (maskHeadConfigBuilder_ == null) {
          return maskHeadConfig_ == null ? object_detection.protos.SsdOuterClass.Ssd.MaskHead.getDefaultInstance() : maskHeadConfig_;
        } else {
          return maskHeadConfigBuilder_.getMessage();
        }
      }
      /**
       * <pre>
       * Configs for mask head.
       * </pre>
       *
       * <code>optional .object_detection.protos.Ssd.MaskHead mask_head_config = 25;</code>
       */
      public Builder setMaskHeadConfig(object_detection.protos.SsdOuterClass.Ssd.MaskHead value) {
        if (maskHeadConfigBuilder_ == null) {
          if (value == null) {
            throw new NullPointerException();
          }
          maskHeadConfig_ = value;
          onChanged();
        } else {
          maskHeadConfigBuilder_.setMessage(value);
        }
        bitField0_ |= 0x00200000;
        return this;
      }
      /**
       * <pre>
       * Configs for mask head.
       * </pre>
       *
       * <code>optional .object_detection.protos.Ssd.MaskHead mask_head_config = 25;</code>
       */
      public Builder setMaskHeadConfig(
          object_detection.protos.SsdOuterClass.Ssd.MaskHead.Builder builderForValue) {
        if (maskHeadConfigBuilder_ == null) {
          maskHeadConfig_ = builderForValue.build();
          onChanged();
        } else {
          maskHeadConfigBuilder_.setMessage(builderForValue.build());
        }
        bitField0_ |= 0x00200000;
        return this;
      }
      /**
       * <pre>
       * Configs for mask head.
       * </pre>
       *
       * <code>optional .object_detection.protos.Ssd.MaskHead mask_head_config = 25;</code>
       */
      public Builder mergeMaskHeadConfig(object_detection.protos.SsdOuterClass.Ssd.MaskHead value) {
        if (maskHeadConfigBuilder_ == null) {
          if (((bitField0_ & 0x00200000) != 0) &&
              maskHeadConfig_ != null &&
              maskHeadConfig_ != object_detection.protos.SsdOuterClass.Ssd.MaskHead.getDefaultInstance()) {
            maskHeadConfig_ =
              object_detection.protos.SsdOuterClass.Ssd.MaskHead.newBuilder(maskHeadConfig_).mergeFrom(value).buildPartial();
          } else {
            maskHeadConfig_ = value;
          }
          onChanged();
        } else {
          maskHeadConfigBuilder_.mergeFrom(value);
        }
        bitField0_ |= 0x00200000;
        return this;
      }
      /**
       * <pre>
       * Configs for mask head.
       * </pre>
       *
       * <code>optional .object_detection.protos.Ssd.MaskHead mask_head_config = 25;</code>
       */
      public Builder clearMaskHeadConfig() {
        if (maskHeadConfigBuilder_ == null) {
          maskHeadConfig_ = null;
          onChanged();
        } else {
          maskHeadConfigBuilder_.clear();
        }
        bitField0_ = (bitField0_ & ~0x00200000);
        return this;
      }
      /**
       * <pre>
       * Configs for mask head.
       * </pre>
       *
       * <code>optional .object_detection.protos.Ssd.MaskHead mask_head_config = 25;</code>
       */
      public object_detection.protos.SsdOuterClass.Ssd.MaskHead.Builder getMaskHeadConfigBuilder() {
        bitField0_ |= 0x00200000;
        onChanged();
        return getMaskHeadConfigFieldBuilder().getBuilder();
      }
      /**
       * <pre>
       * Configs for mask head.
       * </pre>
       *
       * <code>optional .object_detection.protos.Ssd.MaskHead mask_head_config = 25;</code>
       */
      public object_detection.protos.SsdOuterClass.Ssd.MaskHeadOrBuilder getMaskHeadConfigOrBuilder() {
        if (maskHeadConfigBuilder_ != null) {
          return maskHeadConfigBuilder_.getMessageOrBuilder();
        } else {
          return maskHeadConfig_ == null ?
              object_detection.protos.SsdOuterClass.Ssd.MaskHead.getDefaultInstance() : maskHeadConfig_;
        }
      }
      /**
       * <pre>
       * Configs for mask head.
       * </pre>
       *
       * <code>optional .object_detection.protos.Ssd.MaskHead mask_head_config = 25;</code>
       */
      private com.google.protobuf.SingleFieldBuilderV3<
          object_detection.protos.SsdOuterClass.Ssd.MaskHead, object_detection.protos.SsdOuterClass.Ssd.MaskHead.Builder, object_detection.protos.SsdOuterClass.Ssd.MaskHeadOrBuilder>
          getMaskHeadConfigFieldBuilder() {
        if (maskHeadConfigBuilder_ == null) {
          maskHeadConfigBuilder_ = new com.google.protobuf.SingleFieldBuilderV3<
              object_detection.protos.SsdOuterClass.Ssd.MaskHead, object_detection.protos.SsdOuterClass.Ssd.MaskHead.Builder, object_detection.protos.SsdOuterClass.Ssd.MaskHeadOrBuilder>(
                  getMaskHeadConfig(),
                  getParentForChildren(),
                  isClean());
          maskHeadConfig_ = null;
        }
        return maskHeadConfigBuilder_;
      }
      @java.lang.Override
      public final Builder setUnknownFields(
          final com.google.protobuf.UnknownFieldSet unknownFields) {
        return super.setUnknownFields(unknownFields);
      }

      @java.lang.Override
      public final Builder mergeUnknownFields(
          final com.google.protobuf.UnknownFieldSet unknownFields) {
        return super.mergeUnknownFields(unknownFields);
      }


      // @@protoc_insertion_point(builder_scope:object_detection.protos.Ssd)
    }

    // @@protoc_insertion_point(class_scope:object_detection.protos.Ssd)
    private static final object_detection.protos.SsdOuterClass.Ssd DEFAULT_INSTANCE;
    static {
      DEFAULT_INSTANCE = new object_detection.protos.SsdOuterClass.Ssd();
    }

    public static object_detection.protos.SsdOuterClass.Ssd getDefaultInstance() {
      return DEFAULT_INSTANCE;
    }

    @java.lang.Deprecated public static final com.google.protobuf.Parser<Ssd>
        PARSER = new com.google.protobuf.AbstractParser<Ssd>() {
      @java.lang.Override
      public Ssd parsePartialFrom(
          com.google.protobuf.CodedInputStream input,
          com.google.protobuf.ExtensionRegistryLite extensionRegistry)
          throws com.google.protobuf.InvalidProtocolBufferException {
        return new Ssd(input, extensionRegistry);
      }
    };

    public static com.google.protobuf.Parser<Ssd> parser() {
      return PARSER;
    }

    @java.lang.Override
    public com.google.protobuf.Parser<Ssd> getParserForType() {
      return PARSER;
    }

    @java.lang.Override
    public object_detection.protos.SsdOuterClass.Ssd getDefaultInstanceForType() {
      return DEFAULT_INSTANCE;
    }

  }

  public interface SsdFeatureExtractorOrBuilder extends
      // @@protoc_insertion_point(interface_extends:object_detection.protos.SsdFeatureExtractor)
      com.google.protobuf.MessageOrBuilder {

    /**
     * <pre>
     * Type of ssd feature extractor.
     * </pre>
     *
     * <code>optional string type = 1;</code>
     * @return Whether the type field is set.
     */
    boolean hasType();
    /**
     * <pre>
     * Type of ssd feature extractor.
     * </pre>
     *
     * <code>optional string type = 1;</code>
     * @return The type.
     */
    java.lang.String getType();
    /**
     * <pre>
     * Type of ssd feature extractor.
     * </pre>
     *
     * <code>optional string type = 1;</code>
     * @return The bytes for type.
     */
    com.google.protobuf.ByteString
        getTypeBytes();

    /**
     * <pre>
     * The factor to alter the depth of the channels in the feature extractor.
     * </pre>
     *
     * <code>optional float depth_multiplier = 2 [default = 1];</code>
     * @return Whether the depthMultiplier field is set.
     */
    boolean hasDepthMultiplier();
    /**
     * <pre>
     * The factor to alter the depth of the channels in the feature extractor.
     * </pre>
     *
     * <code>optional float depth_multiplier = 2 [default = 1];</code>
     * @return The depthMultiplier.
     */
    float getDepthMultiplier();

    /**
     * <pre>
     * Minimum number of the channels in the feature extractor.
     * </pre>
     *
     * <code>optional int32 min_depth = 3 [default = 16];</code>
     * @return Whether the minDepth field is set.
     */
    boolean hasMinDepth();
    /**
     * <pre>
     * Minimum number of the channels in the feature extractor.
     * </pre>
     *
     * <code>optional int32 min_depth = 3 [default = 16];</code>
     * @return The minDepth.
     */
    int getMinDepth();

    /**
     * <pre>
     * Hyperparameters that affect the layers of feature extractor added on top
     * of the base feature extractor.
     * </pre>
     *
     * <code>optional .object_detection.protos.Hyperparams conv_hyperparams = 4;</code>
     * @return Whether the convHyperparams field is set.
     */
    boolean hasConvHyperparams();
    /**
     * <pre>
     * Hyperparameters that affect the layers of feature extractor added on top
     * of the base feature extractor.
     * </pre>
     *
     * <code>optional .object_detection.protos.Hyperparams conv_hyperparams = 4;</code>
     * @return The convHyperparams.
     */
    object_detection.protos.HyperparamsOuterClass.Hyperparams getConvHyperparams();
    /**
     * <pre>
     * Hyperparameters that affect the layers of feature extractor added on top
     * of the base feature extractor.
     * </pre>
     *
     * <code>optional .object_detection.protos.Hyperparams conv_hyperparams = 4;</code>
     */
    object_detection.protos.HyperparamsOuterClass.HyperparamsOrBuilder getConvHyperparamsOrBuilder();

    /**
     * <pre>
     * Normally, SSD feature extractors are constructed by reusing an existing
     * base feature extractor (that has its own hyperparams) and adding new layers
     * on top of it. `conv_hyperparams` above normally applies only to the new
     * layers while base feature extractor uses its own default hyperparams. If
     * this value is set to true, the base feature extractor's hyperparams will be
     * overridden with the `conv_hyperparams`.
     * </pre>
     *
     * <code>optional bool override_base_feature_extractor_hyperparams = 9 [default = false];</code>
     * @return Whether the overrideBaseFeatureExtractorHyperparams field is set.
     */
    boolean hasOverrideBaseFeatureExtractorHyperparams();
    /**
     * <pre>
     * Normally, SSD feature extractors are constructed by reusing an existing
     * base feature extractor (that has its own hyperparams) and adding new layers
     * on top of it. `conv_hyperparams` above normally applies only to the new
     * layers while base feature extractor uses its own default hyperparams. If
     * this value is set to true, the base feature extractor's hyperparams will be
     * overridden with the `conv_hyperparams`.
     * </pre>
     *
     * <code>optional bool override_base_feature_extractor_hyperparams = 9 [default = false];</code>
     * @return The overrideBaseFeatureExtractorHyperparams.
     */
    boolean getOverrideBaseFeatureExtractorHyperparams();

    /**
     * <pre>
     * The nearest multiple to zero-pad the input height and width dimensions to.
     * For example, if pad_to_multiple = 2, input dimensions are zero-padded
     * until the resulting dimensions are even.
     * </pre>
     *
     * <code>optional int32 pad_to_multiple = 5 [default = 1];</code>
     * @return Whether the padToMultiple field is set.
     */
    boolean hasPadToMultiple();
    /**
     * <pre>
     * The nearest multiple to zero-pad the input height and width dimensions to.
     * For example, if pad_to_multiple = 2, input dimensions are zero-padded
     * until the resulting dimensions are even.
     * </pre>
     *
     * <code>optional int32 pad_to_multiple = 5 [default = 1];</code>
     * @return The padToMultiple.
     */
    int getPadToMultiple();

    /**
     * <pre>
     * Whether to use explicit padding when extracting SSD multiresolution
     * features. This will also apply to the base feature extractor if a MobileNet
     * architecture is used.
     * </pre>
     *
     * <code>optional bool use_explicit_padding = 7 [default = false];</code>
     * @return Whether the useExplicitPadding field is set.
     */
    boolean hasUseExplicitPadding();
    /**
     * <pre>
     * Whether to use explicit padding when extracting SSD multiresolution
     * features. This will also apply to the base feature extractor if a MobileNet
     * architecture is used.
     * </pre>
     *
     * <code>optional bool use_explicit_padding = 7 [default = false];</code>
     * @return The useExplicitPadding.
     */
    boolean getUseExplicitPadding();

    /**
     * <pre>
     * Whether to use depthwise separable convolutions for to extract additional
     * feature maps added by SSD.
     * </pre>
     *
     * <code>optional bool use_depthwise = 8 [default = false];</code>
     * @return Whether the useDepthwise field is set.
     */
    boolean hasUseDepthwise();
    /**
     * <pre>
     * Whether to use depthwise separable convolutions for to extract additional
     * feature maps added by SSD.
     * </pre>
     *
     * <code>optional bool use_depthwise = 8 [default = false];</code>
     * @return The useDepthwise.
     */
    boolean getUseDepthwise();

    /**
     * <pre>
     * Feature Pyramid Networks config.
     * </pre>
     *
     * <code>.object_detection.protos.FeaturePyramidNetworks fpn = 10;</code>
     * @return Whether the fpn field is set.
     */
    boolean hasFpn();
    /**
     * <pre>
     * Feature Pyramid Networks config.
     * </pre>
     *
     * <code>.object_detection.protos.FeaturePyramidNetworks fpn = 10;</code>
     * @return The fpn.
     */
    object_detection.protos.Fpn.FeaturePyramidNetworks getFpn();
    /**
     * <pre>
     * Feature Pyramid Networks config.
     * </pre>
     *
     * <code>.object_detection.protos.FeaturePyramidNetworks fpn = 10;</code>
     */
    object_detection.protos.Fpn.FeaturePyramidNetworksOrBuilder getFpnOrBuilder();

    /**
     * <pre>
     * Bidirectional Feature Pyramid Networks config.
     * </pre>
     *
     * <code>.object_detection.protos.BidirectionalFeaturePyramidNetworks bifpn = 19;</code>
     * @return Whether the bifpn field is set.
     */
    boolean hasBifpn();
    /**
     * <pre>
     * Bidirectional Feature Pyramid Networks config.
     * </pre>
     *
     * <code>.object_detection.protos.BidirectionalFeaturePyramidNetworks bifpn = 19;</code>
     * @return The bifpn.
     */
    object_detection.protos.Fpn.BidirectionalFeaturePyramidNetworks getBifpn();
    /**
     * <pre>
     * Bidirectional Feature Pyramid Networks config.
     * </pre>
     *
     * <code>.object_detection.protos.BidirectionalFeaturePyramidNetworks bifpn = 19;</code>
     */
    object_detection.protos.Fpn.BidirectionalFeaturePyramidNetworksOrBuilder getBifpnOrBuilder();

    /**
     * <pre>
     * If true, replace preprocess function of feature extractor with a
     * placeholder. This should only be used if all the image preprocessing steps
     * happen outside the graph.
     * </pre>
     *
     * <code>optional bool replace_preprocessor_with_placeholder = 11 [default = false];</code>
     * @return Whether the replacePreprocessorWithPlaceholder field is set.
     */
    boolean hasReplacePreprocessorWithPlaceholder();
    /**
     * <pre>
     * If true, replace preprocess function of feature extractor with a
     * placeholder. This should only be used if all the image preprocessing steps
     * happen outside the graph.
     * </pre>
     *
     * <code>optional bool replace_preprocessor_with_placeholder = 11 [default = false];</code>
     * @return The replacePreprocessorWithPlaceholder.
     */
    boolean getReplacePreprocessorWithPlaceholder();

    /**
     * <pre>
     * The number of SSD layers.
     * </pre>
     *
     * <code>optional int32 num_layers = 12 [default = 6];</code>
     * @return Whether the numLayers field is set.
     */
    boolean hasNumLayers();
    /**
     * <pre>
     * The number of SSD layers.
     * </pre>
     *
     * <code>optional int32 num_layers = 12 [default = 6];</code>
     * @return The numLayers.
     */
    int getNumLayers();

    public object_detection.protos.SsdOuterClass.SsdFeatureExtractor.FeaturePyramidOneofCase getFeaturePyramidOneofCase();
  }
  /**
   * <pre>
   * Next id: 20.
   * </pre>
   *
   * Protobuf type {@code object_detection.protos.SsdFeatureExtractor}
   */
  public static final class SsdFeatureExtractor extends
      com.google.protobuf.GeneratedMessageV3 implements
      // @@protoc_insertion_point(message_implements:object_detection.protos.SsdFeatureExtractor)
      SsdFeatureExtractorOrBuilder {
  private static final long serialVersionUID = 0L;
    // Use SsdFeatureExtractor.newBuilder() to construct.
    private SsdFeatureExtractor(com.google.protobuf.GeneratedMessageV3.Builder<?> builder) {
      super(builder);
    }
    private SsdFeatureExtractor() {
      type_ = "";
      depthMultiplier_ = 1F;
      minDepth_ = 16;
      padToMultiple_ = 1;
      numLayers_ = 6;
    }

    @java.lang.Override
    @SuppressWarnings({"unused"})
    protected java.lang.Object newInstance(
        UnusedPrivateParameter unused) {
      return new SsdFeatureExtractor();
    }

    @java.lang.Override
    public final com.google.protobuf.UnknownFieldSet
    getUnknownFields() {
      return this.unknownFields;
    }
    private SsdFeatureExtractor(
        com.google.protobuf.CodedInputStream input,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws com.google.protobuf.InvalidProtocolBufferException {
      this();
      if (extensionRegistry == null) {
        throw new java.lang.NullPointerException();
      }
      int mutable_bitField0_ = 0;
      com.google.protobuf.UnknownFieldSet.Builder unknownFields =
          com.google.protobuf.UnknownFieldSet.newBuilder();
      try {
        boolean done = false;
        while (!done) {
          int tag = input.readTag();
          switch (tag) {
            case 0:
              done = true;
              break;
            case 10: {
              com.google.protobuf.ByteString bs = input.readBytes();
              bitField0_ |= 0x00000001;
              type_ = bs;
              break;
            }
            case 21: {
              bitField0_ |= 0x00000002;
              depthMultiplier_ = input.readFloat();
              break;
            }
            case 24: {
              bitField0_ |= 0x00000004;
              minDepth_ = input.readInt32();
              break;
            }
            case 34: {
              object_detection.protos.HyperparamsOuterClass.Hyperparams.Builder subBuilder = null;
              if (((bitField0_ & 0x00000008) != 0)) {
                subBuilder = convHyperparams_.toBuilder();
              }
              convHyperparams_ = input.readMessage(object_detection.protos.HyperparamsOuterClass.Hyperparams.PARSER, extensionRegistry);
              if (subBuilder != null) {
                subBuilder.mergeFrom(convHyperparams_);
                convHyperparams_ = subBuilder.buildPartial();
              }
              bitField0_ |= 0x00000008;
              break;
            }
            case 40: {
              bitField0_ |= 0x00000020;
              padToMultiple_ = input.readInt32();
              break;
            }
            case 56: {
              bitField0_ |= 0x00000040;
              useExplicitPadding_ = input.readBool();
              break;
            }
            case 64: {
              bitField0_ |= 0x00000080;
              useDepthwise_ = input.readBool();
              break;
            }
            case 72: {
              bitField0_ |= 0x00000010;
              overrideBaseFeatureExtractorHyperparams_ = input.readBool();
              break;
            }
            case 82: {
              object_detection.protos.Fpn.FeaturePyramidNetworks.Builder subBuilder = null;
              if (featurePyramidOneofCase_ == 10) {
                subBuilder = ((object_detection.protos.Fpn.FeaturePyramidNetworks) featurePyramidOneof_).toBuilder();
              }
              featurePyramidOneof_ =
                  input.readMessage(object_detection.protos.Fpn.FeaturePyramidNetworks.PARSER, extensionRegistry);
              if (subBuilder != null) {
                subBuilder.mergeFrom((object_detection.protos.Fpn.FeaturePyramidNetworks) featurePyramidOneof_);
                featurePyramidOneof_ = subBuilder.buildPartial();
              }
              featurePyramidOneofCase_ = 10;
              break;
            }
            case 88: {
              bitField0_ |= 0x00000400;
              replacePreprocessorWithPlaceholder_ = input.readBool();
              break;
            }
            case 96: {
              bitField0_ |= 0x00000800;
              numLayers_ = input.readInt32();
              break;
            }
            case 154: {
              object_detection.protos.Fpn.BidirectionalFeaturePyramidNetworks.Builder subBuilder = null;
              if (featurePyramidOneofCase_ == 19) {
                subBuilder = ((object_detection.protos.Fpn.BidirectionalFeaturePyramidNetworks) featurePyramidOneof_).toBuilder();
              }
              featurePyramidOneof_ =
                  input.readMessage(object_detection.protos.Fpn.BidirectionalFeaturePyramidNetworks.PARSER, extensionRegistry);
              if (subBuilder != null) {
                subBuilder.mergeFrom((object_detection.protos.Fpn.BidirectionalFeaturePyramidNetworks) featurePyramidOneof_);
                featurePyramidOneof_ = subBuilder.buildPartial();
              }
              featurePyramidOneofCase_ = 19;
              break;
            }
            default: {
              if (!parseUnknownField(
                  input, unknownFields, extensionRegistry, tag)) {
                done = true;
              }
              break;
            }
          }
        }
      } catch (com.google.protobuf.InvalidProtocolBufferException e) {
        throw e.setUnfinishedMessage(this);
      } catch (java.io.IOException e) {
        throw new com.google.protobuf.InvalidProtocolBufferException(
            e).setUnfinishedMessage(this);
      } finally {
        this.unknownFields = unknownFields.build();
        makeExtensionsImmutable();
      }
    }
    public static final com.google.protobuf.Descriptors.Descriptor
        getDescriptor() {
      return object_detection.protos.SsdOuterClass.internal_static_object_detection_protos_SsdFeatureExtractor_descriptor;
    }

    @java.lang.Override
    protected com.google.protobuf.GeneratedMessageV3.FieldAccessorTable
        internalGetFieldAccessorTable() {
      return object_detection.protos.SsdOuterClass.internal_static_object_detection_protos_SsdFeatureExtractor_fieldAccessorTable
          .ensureFieldAccessorsInitialized(
              object_detection.protos.SsdOuterClass.SsdFeatureExtractor.class, object_detection.protos.SsdOuterClass.SsdFeatureExtractor.Builder.class);
    }

    private int bitField0_;
    private int featurePyramidOneofCase_ = 0;
    private java.lang.Object featurePyramidOneof_;
    public enum FeaturePyramidOneofCase
        implements com.google.protobuf.Internal.EnumLite,
            com.google.protobuf.AbstractMessage.InternalOneOfEnum {
      FPN(10),
      BIFPN(19),
      FEATUREPYRAMIDONEOF_NOT_SET(0);
      private final int value;
      private FeaturePyramidOneofCase(int value) {
        this.value = value;
      }
      /**
       * @param value The number of the enum to look for.
       * @return The enum associated with the given number.
       * @deprecated Use {@link #forNumber(int)} instead.
       */
      @java.lang.Deprecated
      public static FeaturePyramidOneofCase valueOf(int value) {
        return forNumber(value);
      }

      public static FeaturePyramidOneofCase forNumber(int value) {
        switch (value) {
          case 10: return FPN;
          case 19: return BIFPN;
          case 0: return FEATUREPYRAMIDONEOF_NOT_SET;
          default: return null;
        }
      }
      public int getNumber() {
        return this.value;
      }
    };

    public FeaturePyramidOneofCase
    getFeaturePyramidOneofCase() {
      return FeaturePyramidOneofCase.forNumber(
          featurePyramidOneofCase_);
    }

    public static final int TYPE_FIELD_NUMBER = 1;
    private volatile java.lang.Object type_;
    /**
     * <pre>
     * Type of ssd feature extractor.
     * </pre>
     *
     * <code>optional string type = 1;</code>
     * @return Whether the type field is set.
     */
    @java.lang.Override
    public boolean hasType() {
      return ((bitField0_ & 0x00000001) != 0);
    }
    /**
     * <pre>
     * Type of ssd feature extractor.
     * </pre>
     *
     * <code>optional string type = 1;</code>
     * @return The type.
     */
    @java.lang.Override
    public java.lang.String getType() {
      java.lang.Object ref = type_;
      if (ref instanceof java.lang.String) {
        return (java.lang.String) ref;
      } else {
        com.google.protobuf.ByteString bs =
            (com.google.protobuf.ByteString) ref;
        java.lang.String s = bs.toStringUtf8();
        if (bs.isValidUtf8()) {
          type_ = s;
        }
        return s;
      }
    }
    /**
     * <pre>
     * Type of ssd feature extractor.
     * </pre>
     *
     * <code>optional string type = 1;</code>
     * @return The bytes for type.
     */
    @java.lang.Override
    public com.google.protobuf.ByteString
        getTypeBytes() {
      java.lang.Object ref = type_;
      if (ref instanceof java.lang.String) {
        com.google.protobuf.ByteString b =
            com.google.protobuf.ByteString.copyFromUtf8(
                (java.lang.String) ref);
        type_ = b;
        return b;
      } else {
        return (com.google.protobuf.ByteString) ref;
      }
    }

    public static final int DEPTH_MULTIPLIER_FIELD_NUMBER = 2;
    private float depthMultiplier_;
    /**
     * <pre>
     * The factor to alter the depth of the channels in the feature extractor.
     * </pre>
     *
     * <code>optional float depth_multiplier = 2 [default = 1];</code>
     * @return Whether the depthMultiplier field is set.
     */
    @java.lang.Override
    public boolean hasDepthMultiplier() {
      return ((bitField0_ & 0x00000002) != 0);
    }
    /**
     * <pre>
     * The factor to alter the depth of the channels in the feature extractor.
     * </pre>
     *
     * <code>optional float depth_multiplier = 2 [default = 1];</code>
     * @return The depthMultiplier.
     */
    @java.lang.Override
    public float getDepthMultiplier() {
      return depthMultiplier_;
    }

    public static final int MIN_DEPTH_FIELD_NUMBER = 3;
    private int minDepth_;
    /**
     * <pre>
     * Minimum number of the channels in the feature extractor.
     * </pre>
     *
     * <code>optional int32 min_depth = 3 [default = 16];</code>
     * @return Whether the minDepth field is set.
     */
    @java.lang.Override
    public boolean hasMinDepth() {
      return ((bitField0_ & 0x00000004) != 0);
    }
    /**
     * <pre>
     * Minimum number of the channels in the feature extractor.
     * </pre>
     *
     * <code>optional int32 min_depth = 3 [default = 16];</code>
     * @return The minDepth.
     */
    @java.lang.Override
    public int getMinDepth() {
      return minDepth_;
    }

    public static final int CONV_HYPERPARAMS_FIELD_NUMBER = 4;
    private object_detection.protos.HyperparamsOuterClass.Hyperparams convHyperparams_;
    /**
     * <pre>
     * Hyperparameters that affect the layers of feature extractor added on top
     * of the base feature extractor.
     * </pre>
     *
     * <code>optional .object_detection.protos.Hyperparams conv_hyperparams = 4;</code>
     * @return Whether the convHyperparams field is set.
     */
    @java.lang.Override
    public boolean hasConvHyperparams() {
      return ((bitField0_ & 0x00000008) != 0);
    }
    /**
     * <pre>
     * Hyperparameters that affect the layers of feature extractor added on top
     * of the base feature extractor.
     * </pre>
     *
     * <code>optional .object_detection.protos.Hyperparams conv_hyperparams = 4;</code>
     * @return The convHyperparams.
     */
    @java.lang.Override
    public object_detection.protos.HyperparamsOuterClass.Hyperparams getConvHyperparams() {
      return convHyperparams_ == null ? object_detection.protos.HyperparamsOuterClass.Hyperparams.getDefaultInstance() : convHyperparams_;
    }
    /**
     * <pre>
     * Hyperparameters that affect the layers of feature extractor added on top
     * of the base feature extractor.
     * </pre>
     *
     * <code>optional .object_detection.protos.Hyperparams conv_hyperparams = 4;</code>
     */
    @java.lang.Override
    public object_detection.protos.HyperparamsOuterClass.HyperparamsOrBuilder getConvHyperparamsOrBuilder() {
      return convHyperparams_ == null ? object_detection.protos.HyperparamsOuterClass.Hyperparams.getDefaultInstance() : convHyperparams_;
    }

    public static final int OVERRIDE_BASE_FEATURE_EXTRACTOR_HYPERPARAMS_FIELD_NUMBER = 9;
    private boolean overrideBaseFeatureExtractorHyperparams_;
    /**
     * <pre>
     * Normally, SSD feature extractors are constructed by reusing an existing
     * base feature extractor (that has its own hyperparams) and adding new layers
     * on top of it. `conv_hyperparams` above normally applies only to the new
     * layers while base feature extractor uses its own default hyperparams. If
     * this value is set to true, the base feature extractor's hyperparams will be
     * overridden with the `conv_hyperparams`.
     * </pre>
     *
     * <code>optional bool override_base_feature_extractor_hyperparams = 9 [default = false];</code>
     * @return Whether the overrideBaseFeatureExtractorHyperparams field is set.
     */
    @java.lang.Override
    public boolean hasOverrideBaseFeatureExtractorHyperparams() {
      return ((bitField0_ & 0x00000010) != 0);
    }
    /**
     * <pre>
     * Normally, SSD feature extractors are constructed by reusing an existing
     * base feature extractor (that has its own hyperparams) and adding new layers
     * on top of it. `conv_hyperparams` above normally applies only to the new
     * layers while base feature extractor uses its own default hyperparams. If
     * this value is set to true, the base feature extractor's hyperparams will be
     * overridden with the `conv_hyperparams`.
     * </pre>
     *
     * <code>optional bool override_base_feature_extractor_hyperparams = 9 [default = false];</code>
     * @return The overrideBaseFeatureExtractorHyperparams.
     */
    @java.lang.Override
    public boolean getOverrideBaseFeatureExtractorHyperparams() {
      return overrideBaseFeatureExtractorHyperparams_;
    }

    public static final int PAD_TO_MULTIPLE_FIELD_NUMBER = 5;
    private int padToMultiple_;
    /**
     * <pre>
     * The nearest multiple to zero-pad the input height and width dimensions to.
     * For example, if pad_to_multiple = 2, input dimensions are zero-padded
     * until the resulting dimensions are even.
     * </pre>
     *
     * <code>optional int32 pad_to_multiple = 5 [default = 1];</code>
     * @return Whether the padToMultiple field is set.
     */
    @java.lang.Override
    public boolean hasPadToMultiple() {
      return ((bitField0_ & 0x00000020) != 0);
    }
    /**
     * <pre>
     * The nearest multiple to zero-pad the input height and width dimensions to.
     * For example, if pad_to_multiple = 2, input dimensions are zero-padded
     * until the resulting dimensions are even.
     * </pre>
     *
     * <code>optional int32 pad_to_multiple = 5 [default = 1];</code>
     * @return The padToMultiple.
     */
    @java.lang.Override
    public int getPadToMultiple() {
      return padToMultiple_;
    }

    public static final int USE_EXPLICIT_PADDING_FIELD_NUMBER = 7;
    private boolean useExplicitPadding_;
    /**
     * <pre>
     * Whether to use explicit padding when extracting SSD multiresolution
     * features. This will also apply to the base feature extractor if a MobileNet
     * architecture is used.
     * </pre>
     *
     * <code>optional bool use_explicit_padding = 7 [default = false];</code>
     * @return Whether the useExplicitPadding field is set.
     */
    @java.lang.Override
    public boolean hasUseExplicitPadding() {
      return ((bitField0_ & 0x00000040) != 0);
    }
    /**
     * <pre>
     * Whether to use explicit padding when extracting SSD multiresolution
     * features. This will also apply to the base feature extractor if a MobileNet
     * architecture is used.
     * </pre>
     *
     * <code>optional bool use_explicit_padding = 7 [default = false];</code>
     * @return The useExplicitPadding.
     */
    @java.lang.Override
    public boolean getUseExplicitPadding() {
      return useExplicitPadding_;
    }

    public static final int USE_DEPTHWISE_FIELD_NUMBER = 8;
    private boolean useDepthwise_;
    /**
     * <pre>
     * Whether to use depthwise separable convolutions for to extract additional
     * feature maps added by SSD.
     * </pre>
     *
     * <code>optional bool use_depthwise = 8 [default = false];</code>
     * @return Whether the useDepthwise field is set.
     */
    @java.lang.Override
    public boolean hasUseDepthwise() {
      return ((bitField0_ & 0x00000080) != 0);
    }
    /**
     * <pre>
     * Whether to use depthwise separable convolutions for to extract additional
     * feature maps added by SSD.
     * </pre>
     *
     * <code>optional bool use_depthwise = 8 [default = false];</code>
     * @return The useDepthwise.
     */
    @java.lang.Override
    public boolean getUseDepthwise() {
      return useDepthwise_;
    }

    public static final int FPN_FIELD_NUMBER = 10;
    /**
     * <pre>
     * Feature Pyramid Networks config.
     * </pre>
     *
     * <code>.object_detection.protos.FeaturePyramidNetworks fpn = 10;</code>
     * @return Whether the fpn field is set.
     */
    @java.lang.Override
    public boolean hasFpn() {
      return featurePyramidOneofCase_ == 10;
    }
    /**
     * <pre>
     * Feature Pyramid Networks config.
     * </pre>
     *
     * <code>.object_detection.protos.FeaturePyramidNetworks fpn = 10;</code>
     * @return The fpn.
     */
    @java.lang.Override
    public object_detection.protos.Fpn.FeaturePyramidNetworks getFpn() {
      if (featurePyramidOneofCase_ == 10) {
         return (object_detection.protos.Fpn.FeaturePyramidNetworks) featurePyramidOneof_;
      }
      return object_detection.protos.Fpn.FeaturePyramidNetworks.getDefaultInstance();
    }
    /**
     * <pre>
     * Feature Pyramid Networks config.
     * </pre>
     *
     * <code>.object_detection.protos.FeaturePyramidNetworks fpn = 10;</code>
     */
    @java.lang.Override
    public object_detection.protos.Fpn.FeaturePyramidNetworksOrBuilder getFpnOrBuilder() {
      if (featurePyramidOneofCase_ == 10) {
         return (object_detection.protos.Fpn.FeaturePyramidNetworks) featurePyramidOneof_;
      }
      return object_detection.protos.Fpn.FeaturePyramidNetworks.getDefaultInstance();
    }

    public static final int BIFPN_FIELD_NUMBER = 19;
    /**
     * <pre>
     * Bidirectional Feature Pyramid Networks config.
     * </pre>
     *
     * <code>.object_detection.protos.BidirectionalFeaturePyramidNetworks bifpn = 19;</code>
     * @return Whether the bifpn field is set.
     */
    @java.lang.Override
    public boolean hasBifpn() {
      return featurePyramidOneofCase_ == 19;
    }
    /**
     * <pre>
     * Bidirectional Feature Pyramid Networks config.
     * </pre>
     *
     * <code>.object_detection.protos.BidirectionalFeaturePyramidNetworks bifpn = 19;</code>
     * @return The bifpn.
     */
    @java.lang.Override
    public object_detection.protos.Fpn.BidirectionalFeaturePyramidNetworks getBifpn() {
      if (featurePyramidOneofCase_ == 19) {
         return (object_detection.protos.Fpn.BidirectionalFeaturePyramidNetworks) featurePyramidOneof_;
      }
      return object_detection.protos.Fpn.BidirectionalFeaturePyramidNetworks.getDefaultInstance();
    }
    /**
     * <pre>
     * Bidirectional Feature Pyramid Networks config.
     * </pre>
     *
     * <code>.object_detection.protos.BidirectionalFeaturePyramidNetworks bifpn = 19;</code>
     */
    @java.lang.Override
    public object_detection.protos.Fpn.BidirectionalFeaturePyramidNetworksOrBuilder getBifpnOrBuilder() {
      if (featurePyramidOneofCase_ == 19) {
         return (object_detection.protos.Fpn.BidirectionalFeaturePyramidNetworks) featurePyramidOneof_;
      }
      return object_detection.protos.Fpn.BidirectionalFeaturePyramidNetworks.getDefaultInstance();
    }

    public static final int REPLACE_PREPROCESSOR_WITH_PLACEHOLDER_FIELD_NUMBER = 11;
    private boolean replacePreprocessorWithPlaceholder_;
    /**
     * <pre>
     * If true, replace preprocess function of feature extractor with a
     * placeholder. This should only be used if all the image preprocessing steps
     * happen outside the graph.
     * </pre>
     *
     * <code>optional bool replace_preprocessor_with_placeholder = 11 [default = false];</code>
     * @return Whether the replacePreprocessorWithPlaceholder field is set.
     */
    @java.lang.Override
    public boolean hasReplacePreprocessorWithPlaceholder() {
      return ((bitField0_ & 0x00000400) != 0);
    }
    /**
     * <pre>
     * If true, replace preprocess function of feature extractor with a
     * placeholder. This should only be used if all the image preprocessing steps
     * happen outside the graph.
     * </pre>
     *
     * <code>optional bool replace_preprocessor_with_placeholder = 11 [default = false];</code>
     * @return The replacePreprocessorWithPlaceholder.
     */
    @java.lang.Override
    public boolean getReplacePreprocessorWithPlaceholder() {
      return replacePreprocessorWithPlaceholder_;
    }

    public static final int NUM_LAYERS_FIELD_NUMBER = 12;
    private int numLayers_;
    /**
     * <pre>
     * The number of SSD layers.
     * </pre>
     *
     * <code>optional int32 num_layers = 12 [default = 6];</code>
     * @return Whether the numLayers field is set.
     */
    @java.lang.Override
    public boolean hasNumLayers() {
      return ((bitField0_ & 0x00000800) != 0);
    }
    /**
     * <pre>
     * The number of SSD layers.
     * </pre>
     *
     * <code>optional int32 num_layers = 12 [default = 6];</code>
     * @return The numLayers.
     */
    @java.lang.Override
    public int getNumLayers() {
      return numLayers_;
    }

    private byte memoizedIsInitialized = -1;
    @java.lang.Override
    public final boolean isInitialized() {
      byte isInitialized = memoizedIsInitialized;
      if (isInitialized == 1) return true;
      if (isInitialized == 0) return false;

      memoizedIsInitialized = 1;
      return true;
    }

    @java.lang.Override
    public void writeTo(com.google.protobuf.CodedOutputStream output)
                        throws java.io.IOException {
      if (((bitField0_ & 0x00000001) != 0)) {
        com.google.protobuf.GeneratedMessageV3.writeString(output, 1, type_);
      }
      if (((bitField0_ & 0x00000002) != 0)) {
        output.writeFloat(2, depthMultiplier_);
      }
      if (((bitField0_ & 0x00000004) != 0)) {
        output.writeInt32(3, minDepth_);
      }
      if (((bitField0_ & 0x00000008) != 0)) {
        output.writeMessage(4, getConvHyperparams());
      }
      if (((bitField0_ & 0x00000020) != 0)) {
        output.writeInt32(5, padToMultiple_);
      }
      if (((bitField0_ & 0x00000040) != 0)) {
        output.writeBool(7, useExplicitPadding_);
      }
      if (((bitField0_ & 0x00000080) != 0)) {
        output.writeBool(8, useDepthwise_);
      }
      if (((bitField0_ & 0x00000010) != 0)) {
        output.writeBool(9, overrideBaseFeatureExtractorHyperparams_);
      }
      if (featurePyramidOneofCase_ == 10) {
        output.writeMessage(10, (object_detection.protos.Fpn.FeaturePyramidNetworks) featurePyramidOneof_);
      }
      if (((bitField0_ & 0x00000400) != 0)) {
        output.writeBool(11, replacePreprocessorWithPlaceholder_);
      }
      if (((bitField0_ & 0x00000800) != 0)) {
        output.writeInt32(12, numLayers_);
      }
      if (featurePyramidOneofCase_ == 19) {
        output.writeMessage(19, (object_detection.protos.Fpn.BidirectionalFeaturePyramidNetworks) featurePyramidOneof_);
      }
      unknownFields.writeTo(output);
    }

    @java.lang.Override
    public int getSerializedSize() {
      int size = memoizedSize;
      if (size != -1) return size;

      size = 0;
      if (((bitField0_ & 0x00000001) != 0)) {
        size += com.google.protobuf.GeneratedMessageV3.computeStringSize(1, type_);
      }
      if (((bitField0_ & 0x00000002) != 0)) {
        size += com.google.protobuf.CodedOutputStream
          .computeFloatSize(2, depthMultiplier_);
      }
      if (((bitField0_ & 0x00000004) != 0)) {
        size += com.google.protobuf.CodedOutputStream
          .computeInt32Size(3, minDepth_);
      }
      if (((bitField0_ & 0x00000008) != 0)) {
        size += com.google.protobuf.CodedOutputStream
          .computeMessageSize(4, getConvHyperparams());
      }
      if (((bitField0_ & 0x00000020) != 0)) {
        size += com.google.protobuf.CodedOutputStream
          .computeInt32Size(5, padToMultiple_);
      }
      if (((bitField0_ & 0x00000040) != 0)) {
        size += com.google.protobuf.CodedOutputStream
          .computeBoolSize(7, useExplicitPadding_);
      }
      if (((bitField0_ & 0x00000080) != 0)) {
        size += com.google.protobuf.CodedOutputStream
          .computeBoolSize(8, useDepthwise_);
      }
      if (((bitField0_ & 0x00000010) != 0)) {
        size += com.google.protobuf.CodedOutputStream
          .computeBoolSize(9, overrideBaseFeatureExtractorHyperparams_);
      }
      if (featurePyramidOneofCase_ == 10) {
        size += com.google.protobuf.CodedOutputStream
          .computeMessageSize(10, (object_detection.protos.Fpn.FeaturePyramidNetworks) featurePyramidOneof_);
      }
      if (((bitField0_ & 0x00000400) != 0)) {
        size += com.google.protobuf.CodedOutputStream
          .computeBoolSize(11, replacePreprocessorWithPlaceholder_);
      }
      if (((bitField0_ & 0x00000800) != 0)) {
        size += com.google.protobuf.CodedOutputStream
          .computeInt32Size(12, numLayers_);
      }
      if (featurePyramidOneofCase_ == 19) {
        size += com.google.protobuf.CodedOutputStream
          .computeMessageSize(19, (object_detection.protos.Fpn.BidirectionalFeaturePyramidNetworks) featurePyramidOneof_);
      }
      size += unknownFields.getSerializedSize();
      memoizedSize = size;
      return size;
    }

    @java.lang.Override
    public boolean equals(final java.lang.Object obj) {
      if (obj == this) {
       return true;
      }
      if (!(obj instanceof object_detection.protos.SsdOuterClass.SsdFeatureExtractor)) {
        return super.equals(obj);
      }
      object_detection.protos.SsdOuterClass.SsdFeatureExtractor other = (object_detection.protos.SsdOuterClass.SsdFeatureExtractor) obj;

      if (hasType() != other.hasType()) return false;
      if (hasType()) {
        if (!getType()
            .equals(other.getType())) return false;
      }
      if (hasDepthMultiplier() != other.hasDepthMultiplier()) return false;
      if (hasDepthMultiplier()) {
        if (java.lang.Float.floatToIntBits(getDepthMultiplier())
            != java.lang.Float.floatToIntBits(
                other.getDepthMultiplier())) return false;
      }
      if (hasMinDepth() != other.hasMinDepth()) return false;
      if (hasMinDepth()) {
        if (getMinDepth()
            != other.getMinDepth()) return false;
      }
      if (hasConvHyperparams() != other.hasConvHyperparams()) return false;
      if (hasConvHyperparams()) {
        if (!getConvHyperparams()
            .equals(other.getConvHyperparams())) return false;
      }
      if (hasOverrideBaseFeatureExtractorHyperparams() != other.hasOverrideBaseFeatureExtractorHyperparams()) return false;
      if (hasOverrideBaseFeatureExtractorHyperparams()) {
        if (getOverrideBaseFeatureExtractorHyperparams()
            != other.getOverrideBaseFeatureExtractorHyperparams()) return false;
      }
      if (hasPadToMultiple() != other.hasPadToMultiple()) return false;
      if (hasPadToMultiple()) {
        if (getPadToMultiple()
            != other.getPadToMultiple()) return false;
      }
      if (hasUseExplicitPadding() != other.hasUseExplicitPadding()) return false;
      if (hasUseExplicitPadding()) {
        if (getUseExplicitPadding()
            != other.getUseExplicitPadding()) return false;
      }
      if (hasUseDepthwise() != other.hasUseDepthwise()) return false;
      if (hasUseDepthwise()) {
        if (getUseDepthwise()
            != other.getUseDepthwise()) return false;
      }
      if (hasReplacePreprocessorWithPlaceholder() != other.hasReplacePreprocessorWithPlaceholder()) return false;
      if (hasReplacePreprocessorWithPlaceholder()) {
        if (getReplacePreprocessorWithPlaceholder()
            != other.getReplacePreprocessorWithPlaceholder()) return false;
      }
      if (hasNumLayers() != other.hasNumLayers()) return false;
      if (hasNumLayers()) {
        if (getNumLayers()
            != other.getNumLayers()) return false;
      }
      if (!getFeaturePyramidOneofCase().equals(other.getFeaturePyramidOneofCase())) return false;
      switch (featurePyramidOneofCase_) {
        case 10:
          if (!getFpn()
              .equals(other.getFpn())) return false;
          break;
        case 19:
          if (!getBifpn()
              .equals(other.getBifpn())) return false;
          break;
        case 0:
        default:
      }
      if (!unknownFields.equals(other.unknownFields)) return false;
      return true;
    }

    @java.lang.Override
    public int hashCode() {
      if (memoizedHashCode != 0) {
        return memoizedHashCode;
      }
      int hash = 41;
      hash = (19 * hash) + getDescriptor().hashCode();
      if (hasType()) {
        hash = (37 * hash) + TYPE_FIELD_NUMBER;
        hash = (53 * hash) + getType().hashCode();
      }
      if (hasDepthMultiplier()) {
        hash = (37 * hash) + DEPTH_MULTIPLIER_FIELD_NUMBER;
        hash = (53 * hash) + java.lang.Float.floatToIntBits(
            getDepthMultiplier());
      }
      if (hasMinDepth()) {
        hash = (37 * hash) + MIN_DEPTH_FIELD_NUMBER;
        hash = (53 * hash) + getMinDepth();
      }
      if (hasConvHyperparams()) {
        hash = (37 * hash) + CONV_HYPERPARAMS_FIELD_NUMBER;
        hash = (53 * hash) + getConvHyperparams().hashCode();
      }
      if (hasOverrideBaseFeatureExtractorHyperparams()) {
        hash = (37 * hash) + OVERRIDE_BASE_FEATURE_EXTRACTOR_HYPERPARAMS_FIELD_NUMBER;
        hash = (53 * hash) + com.google.protobuf.Internal.hashBoolean(
            getOverrideBaseFeatureExtractorHyperparams());
      }
      if (hasPadToMultiple()) {
        hash = (37 * hash) + PAD_TO_MULTIPLE_FIELD_NUMBER;
        hash = (53 * hash) + getPadToMultiple();
      }
      if (hasUseExplicitPadding()) {
        hash = (37 * hash) + USE_EXPLICIT_PADDING_FIELD_NUMBER;
        hash = (53 * hash) + com.google.protobuf.Internal.hashBoolean(
            getUseExplicitPadding());
      }
      if (hasUseDepthwise()) {
        hash = (37 * hash) + USE_DEPTHWISE_FIELD_NUMBER;
        hash = (53 * hash) + com.google.protobuf.Internal.hashBoolean(
            getUseDepthwise());
      }
      if (hasReplacePreprocessorWithPlaceholder()) {
        hash = (37 * hash) + REPLACE_PREPROCESSOR_WITH_PLACEHOLDER_FIELD_NUMBER;
        hash = (53 * hash) + com.google.protobuf.Internal.hashBoolean(
            getReplacePreprocessorWithPlaceholder());
      }
      if (hasNumLayers()) {
        hash = (37 * hash) + NUM_LAYERS_FIELD_NUMBER;
        hash = (53 * hash) + getNumLayers();
      }
      switch (featurePyramidOneofCase_) {
        case 10:
          hash = (37 * hash) + FPN_FIELD_NUMBER;
          hash = (53 * hash) + getFpn().hashCode();
          break;
        case 19:
          hash = (37 * hash) + BIFPN_FIELD_NUMBER;
          hash = (53 * hash) + getBifpn().hashCode();
          break;
        case 0:
        default:
      }
      hash = (29 * hash) + unknownFields.hashCode();
      memoizedHashCode = hash;
      return hash;
    }

    public static object_detection.protos.SsdOuterClass.SsdFeatureExtractor parseFrom(
        java.nio.ByteBuffer data)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return PARSER.parseFrom(data);
    }
    public static object_detection.protos.SsdOuterClass.SsdFeatureExtractor parseFrom(
        java.nio.ByteBuffer data,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return PARSER.parseFrom(data, extensionRegistry);
    }
    public static object_detection.protos.SsdOuterClass.SsdFeatureExtractor parseFrom(
        com.google.protobuf.ByteString data)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return PARSER.parseFrom(data);
    }
    public static object_detection.protos.SsdOuterClass.SsdFeatureExtractor parseFrom(
        com.google.protobuf.ByteString data,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return PARSER.parseFrom(data, extensionRegistry);
    }
    public static object_detection.protos.SsdOuterClass.SsdFeatureExtractor parseFrom(byte[] data)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return PARSER.parseFrom(data);
    }
    public static object_detection.protos.SsdOuterClass.SsdFeatureExtractor parseFrom(
        byte[] data,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return PARSER.parseFrom(data, extensionRegistry);
    }
    public static object_detection.protos.SsdOuterClass.SsdFeatureExtractor parseFrom(java.io.InputStream input)
        throws java.io.IOException {
      return com.google.protobuf.GeneratedMessageV3
          .parseWithIOException(PARSER, input);
    }
    public static object_detection.protos.SsdOuterClass.SsdFeatureExtractor parseFrom(
        java.io.InputStream input,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws java.io.IOException {
      return com.google.protobuf.GeneratedMessageV3
          .parseWithIOException(PARSER, input, extensionRegistry);
    }
    public static object_detection.protos.SsdOuterClass.SsdFeatureExtractor parseDelimitedFrom(java.io.InputStream input)
        throws java.io.IOException {
      return com.google.protobuf.GeneratedMessageV3
          .parseDelimitedWithIOException(PARSER, input);
    }
    public static object_detection.protos.SsdOuterClass.SsdFeatureExtractor parseDelimitedFrom(
        java.io.InputStream input,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws java.io.IOException {
      return com.google.protobuf.GeneratedMessageV3
          .parseDelimitedWithIOException(PARSER, input, extensionRegistry);
    }
    public static object_detection.protos.SsdOuterClass.SsdFeatureExtractor parseFrom(
        com.google.protobuf.CodedInputStream input)
        throws java.io.IOException {
      return com.google.protobuf.GeneratedMessageV3
          .parseWithIOException(PARSER, input);
    }
    public static object_detection.protos.SsdOuterClass.SsdFeatureExtractor parseFrom(
        com.google.protobuf.CodedInputStream input,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws java.io.IOException {
      return com.google.protobuf.GeneratedMessageV3
          .parseWithIOException(PARSER, input, extensionRegistry);
    }

    @java.lang.Override
    public Builder newBuilderForType() { return newBuilder(); }
    public static Builder newBuilder() {
      return DEFAULT_INSTANCE.toBuilder();
    }
    public static Builder newBuilder(object_detection.protos.SsdOuterClass.SsdFeatureExtractor prototype) {
      return DEFAULT_INSTANCE.toBuilder().mergeFrom(prototype);
    }
    @java.lang.Override
    public Builder toBuilder() {
      return this == DEFAULT_INSTANCE
          ? new Builder() : new Builder().mergeFrom(this);
    }

    @java.lang.Override
    protected Builder newBuilderForType(
        com.google.protobuf.GeneratedMessageV3.BuilderParent parent) {
      Builder builder = new Builder(parent);
      return builder;
    }
    /**
     * <pre>
     * Next id: 20.
     * </pre>
     *
     * Protobuf type {@code object_detection.protos.SsdFeatureExtractor}
     */
    public static final class Builder extends
        com.google.protobuf.GeneratedMessageV3.Builder<Builder> implements
        // @@protoc_insertion_point(builder_implements:object_detection.protos.SsdFeatureExtractor)
        object_detection.protos.SsdOuterClass.SsdFeatureExtractorOrBuilder {
      public static final com.google.protobuf.Descriptors.Descriptor
          getDescriptor() {
        return object_detection.protos.SsdOuterClass.internal_static_object_detection_protos_SsdFeatureExtractor_descriptor;
      }

      @java.lang.Override
      protected com.google.protobuf.GeneratedMessageV3.FieldAccessorTable
          internalGetFieldAccessorTable() {
        return object_detection.protos.SsdOuterClass.internal_static_object_detection_protos_SsdFeatureExtractor_fieldAccessorTable
            .ensureFieldAccessorsInitialized(
                object_detection.protos.SsdOuterClass.SsdFeatureExtractor.class, object_detection.protos.SsdOuterClass.SsdFeatureExtractor.Builder.class);
      }

      // Construct using object_detection.protos.SsdOuterClass.SsdFeatureExtractor.newBuilder()
      private Builder() {
        maybeForceBuilderInitialization();
      }

      private Builder(
          com.google.protobuf.GeneratedMessageV3.BuilderParent parent) {
        super(parent);
        maybeForceBuilderInitialization();
      }
      private void maybeForceBuilderInitialization() {
        if (com.google.protobuf.GeneratedMessageV3
                .alwaysUseFieldBuilders) {
          getConvHyperparamsFieldBuilder();
        }
      }
      @java.lang.Override
      public Builder clear() {
        super.clear();
        type_ = "";
        bitField0_ = (bitField0_ & ~0x00000001);
        depthMultiplier_ = 1F;
        bitField0_ = (bitField0_ & ~0x00000002);
        minDepth_ = 16;
        bitField0_ = (bitField0_ & ~0x00000004);
        if (convHyperparamsBuilder_ == null) {
          convHyperparams_ = null;
        } else {
          convHyperparamsBuilder_.clear();
        }
        bitField0_ = (bitField0_ & ~0x00000008);
        overrideBaseFeatureExtractorHyperparams_ = false;
        bitField0_ = (bitField0_ & ~0x00000010);
        padToMultiple_ = 1;
        bitField0_ = (bitField0_ & ~0x00000020);
        useExplicitPadding_ = false;
        bitField0_ = (bitField0_ & ~0x00000040);
        useDepthwise_ = false;
        bitField0_ = (bitField0_ & ~0x00000080);
        replacePreprocessorWithPlaceholder_ = false;
        bitField0_ = (bitField0_ & ~0x00000400);
        numLayers_ = 6;
        bitField0_ = (bitField0_ & ~0x00000800);
        featurePyramidOneofCase_ = 0;
        featurePyramidOneof_ = null;
        return this;
      }

      @java.lang.Override
      public com.google.protobuf.Descriptors.Descriptor
          getDescriptorForType() {
        return object_detection.protos.SsdOuterClass.internal_static_object_detection_protos_SsdFeatureExtractor_descriptor;
      }

      @java.lang.Override
      public object_detection.protos.SsdOuterClass.SsdFeatureExtractor getDefaultInstanceForType() {
        return object_detection.protos.SsdOuterClass.SsdFeatureExtractor.getDefaultInstance();
      }

      @java.lang.Override
      public object_detection.protos.SsdOuterClass.SsdFeatureExtractor build() {
        object_detection.protos.SsdOuterClass.SsdFeatureExtractor result = buildPartial();
        if (!result.isInitialized()) {
          throw newUninitializedMessageException(result);
        }
        return result;
      }

      @java.lang.Override
      public object_detection.protos.SsdOuterClass.SsdFeatureExtractor buildPartial() {
        object_detection.protos.SsdOuterClass.SsdFeatureExtractor result = new object_detection.protos.SsdOuterClass.SsdFeatureExtractor(this);
        int from_bitField0_ = bitField0_;
        int to_bitField0_ = 0;
        if (((from_bitField0_ & 0x00000001) != 0)) {
          to_bitField0_ |= 0x00000001;
        }
        result.type_ = type_;
        if (((from_bitField0_ & 0x00000002) != 0)) {
          to_bitField0_ |= 0x00000002;
        }
        result.depthMultiplier_ = depthMultiplier_;
        if (((from_bitField0_ & 0x00000004) != 0)) {
          to_bitField0_ |= 0x00000004;
        }
        result.minDepth_ = minDepth_;
        if (((from_bitField0_ & 0x00000008) != 0)) {
          if (convHyperparamsBuilder_ == null) {
            result.convHyperparams_ = convHyperparams_;
          } else {
            result.convHyperparams_ = convHyperparamsBuilder_.build();
          }
          to_bitField0_ |= 0x00000008;
        }
        if (((from_bitField0_ & 0x00000010) != 0)) {
          result.overrideBaseFeatureExtractorHyperparams_ = overrideBaseFeatureExtractorHyperparams_;
          to_bitField0_ |= 0x00000010;
        }
        if (((from_bitField0_ & 0x00000020) != 0)) {
          to_bitField0_ |= 0x00000020;
        }
        result.padToMultiple_ = padToMultiple_;
        if (((from_bitField0_ & 0x00000040) != 0)) {
          result.useExplicitPadding_ = useExplicitPadding_;
          to_bitField0_ |= 0x00000040;
        }
        if (((from_bitField0_ & 0x00000080) != 0)) {
          result.useDepthwise_ = useDepthwise_;
          to_bitField0_ |= 0x00000080;
        }
        if (featurePyramidOneofCase_ == 10) {
          if (fpnBuilder_ == null) {
            result.featurePyramidOneof_ = featurePyramidOneof_;
          } else {
            result.featurePyramidOneof_ = fpnBuilder_.build();
          }
        }
        if (featurePyramidOneofCase_ == 19) {
          if (bifpnBuilder_ == null) {
            result.featurePyramidOneof_ = featurePyramidOneof_;
          } else {
            result.featurePyramidOneof_ = bifpnBuilder_.build();
          }
        }
        if (((from_bitField0_ & 0x00000400) != 0)) {
          result.replacePreprocessorWithPlaceholder_ = replacePreprocessorWithPlaceholder_;
          to_bitField0_ |= 0x00000400;
        }
        if (((from_bitField0_ & 0x00000800) != 0)) {
          to_bitField0_ |= 0x00000800;
        }
        result.numLayers_ = numLayers_;
        result.bitField0_ = to_bitField0_;
        result.featurePyramidOneofCase_ = featurePyramidOneofCase_;
        onBuilt();
        return result;
      }

      @java.lang.Override
      public Builder clone() {
        return super.clone();
      }
      @java.lang.Override
      public Builder setField(
          com.google.protobuf.Descriptors.FieldDescriptor field,
          java.lang.Object value) {
        return super.setField(field, value);
      }
      @java.lang.Override
      public Builder clearField(
          com.google.protobuf.Descriptors.FieldDescriptor field) {
        return super.clearField(field);
      }
      @java.lang.Override
      public Builder clearOneof(
          com.google.protobuf.Descriptors.OneofDescriptor oneof) {
        return super.clearOneof(oneof);
      }
      @java.lang.Override
      public Builder setRepeatedField(
          com.google.protobuf.Descriptors.FieldDescriptor field,
          int index, java.lang.Object value) {
        return super.setRepeatedField(field, index, value);
      }
      @java.lang.Override
      public Builder addRepeatedField(
          com.google.protobuf.Descriptors.FieldDescriptor field,
          java.lang.Object value) {
        return super.addRepeatedField(field, value);
      }
      @java.lang.Override
      public Builder mergeFrom(com.google.protobuf.Message other) {
        if (other instanceof object_detection.protos.SsdOuterClass.SsdFeatureExtractor) {
          return mergeFrom((object_detection.protos.SsdOuterClass.SsdFeatureExtractor)other);
        } else {
          super.mergeFrom(other);
          return this;
        }
      }

      public Builder mergeFrom(object_detection.protos.SsdOuterClass.SsdFeatureExtractor other) {
        if (other == object_detection.protos.SsdOuterClass.SsdFeatureExtractor.getDefaultInstance()) return this;
        if (other.hasType()) {
          bitField0_ |= 0x00000001;
          type_ = other.type_;
          onChanged();
        }
        if (other.hasDepthMultiplier()) {
          setDepthMultiplier(other.getDepthMultiplier());
        }
        if (other.hasMinDepth()) {
          setMinDepth(other.getMinDepth());
        }
        if (other.hasConvHyperparams()) {
          mergeConvHyperparams(other.getConvHyperparams());
        }
        if (other.hasOverrideBaseFeatureExtractorHyperparams()) {
          setOverrideBaseFeatureExtractorHyperparams(other.getOverrideBaseFeatureExtractorHyperparams());
        }
        if (other.hasPadToMultiple()) {
          setPadToMultiple(other.getPadToMultiple());
        }
        if (other.hasUseExplicitPadding()) {
          setUseExplicitPadding(other.getUseExplicitPadding());
        }
        if (other.hasUseDepthwise()) {
          setUseDepthwise(other.getUseDepthwise());
        }
        if (other.hasReplacePreprocessorWithPlaceholder()) {
          setReplacePreprocessorWithPlaceholder(other.getReplacePreprocessorWithPlaceholder());
        }
        if (other.hasNumLayers()) {
          setNumLayers(other.getNumLayers());
        }
        switch (other.getFeaturePyramidOneofCase()) {
          case FPN: {
            mergeFpn(other.getFpn());
            break;
          }
          case BIFPN: {
            mergeBifpn(other.getBifpn());
            break;
          }
          case FEATUREPYRAMIDONEOF_NOT_SET: {
            break;
          }
        }
        this.mergeUnknownFields(other.unknownFields);
        onChanged();
        return this;
      }

      @java.lang.Override
      public final boolean isInitialized() {
        return true;
      }

      @java.lang.Override
      public Builder mergeFrom(
          com.google.protobuf.CodedInputStream input,
          com.google.protobuf.ExtensionRegistryLite extensionRegistry)
          throws java.io.IOException {
        object_detection.protos.SsdOuterClass.SsdFeatureExtractor parsedMessage = null;
        try {
          parsedMessage = PARSER.parsePartialFrom(input, extensionRegistry);
        } catch (com.google.protobuf.InvalidProtocolBufferException e) {
          parsedMessage = (object_detection.protos.SsdOuterClass.SsdFeatureExtractor) e.getUnfinishedMessage();
          throw e.unwrapIOException();
        } finally {
          if (parsedMessage != null) {
            mergeFrom(parsedMessage);
          }
        }
        return this;
      }
      private int featurePyramidOneofCase_ = 0;
      private java.lang.Object featurePyramidOneof_;
      public FeaturePyramidOneofCase
          getFeaturePyramidOneofCase() {
        return FeaturePyramidOneofCase.forNumber(
            featurePyramidOneofCase_);
      }

      public Builder clearFeaturePyramidOneof() {
        featurePyramidOneofCase_ = 0;
        featurePyramidOneof_ = null;
        onChanged();
        return this;
      }

      private int bitField0_;

      private java.lang.Object type_ = "";
      /**
       * <pre>
       * Type of ssd feature extractor.
       * </pre>
       *
       * <code>optional string type = 1;</code>
       * @return Whether the type field is set.
       */
      public boolean hasType() {
        return ((bitField0_ & 0x00000001) != 0);
      }
      /**
       * <pre>
       * Type of ssd feature extractor.
       * </pre>
       *
       * <code>optional string type = 1;</code>
       * @return The type.
       */
      public java.lang.String getType() {
        java.lang.Object ref = type_;
        if (!(ref instanceof java.lang.String)) {
          com.google.protobuf.ByteString bs =
              (com.google.protobuf.ByteString) ref;
          java.lang.String s = bs.toStringUtf8();
          if (bs.isValidUtf8()) {
            type_ = s;
          }
          return s;
        } else {
          return (java.lang.String) ref;
        }
      }
      /**
       * <pre>
       * Type of ssd feature extractor.
       * </pre>
       *
       * <code>optional string type = 1;</code>
       * @return The bytes for type.
       */
      public com.google.protobuf.ByteString
          getTypeBytes() {
        java.lang.Object ref = type_;
        if (ref instanceof String) {
          com.google.protobuf.ByteString b =
              com.google.protobuf.ByteString.copyFromUtf8(
                  (java.lang.String) ref);
          type_ = b;
          return b;
        } else {
          return (com.google.protobuf.ByteString) ref;
        }
      }
      /**
       * <pre>
       * Type of ssd feature extractor.
       * </pre>
       *
       * <code>optional string type = 1;</code>
       * @param value The type to set.
       * @return This builder for chaining.
       */
      public Builder setType(
          java.lang.String value) {
        if (value == null) {
    throw new NullPointerException();
  }
  bitField0_ |= 0x00000001;
        type_ = value;
        onChanged();
        return this;
      }
      /**
       * <pre>
       * Type of ssd feature extractor.
       * </pre>
       *
       * <code>optional string type = 1;</code>
       * @return This builder for chaining.
       */
      public Builder clearType() {
        bitField0_ = (bitField0_ & ~0x00000001);
        type_ = getDefaultInstance().getType();
        onChanged();
        return this;
      }
      /**
       * <pre>
       * Type of ssd feature extractor.
       * </pre>
       *
       * <code>optional string type = 1;</code>
       * @param value The bytes for type to set.
       * @return This builder for chaining.
       */
      public Builder setTypeBytes(
          com.google.protobuf.ByteString value) {
        if (value == null) {
    throw new NullPointerException();
  }
  bitField0_ |= 0x00000001;
        type_ = value;
        onChanged();
        return this;
      }

      private float depthMultiplier_ = 1F;
      /**
       * <pre>
       * The factor to alter the depth of the channels in the feature extractor.
       * </pre>
       *
       * <code>optional float depth_multiplier = 2 [default = 1];</code>
       * @return Whether the depthMultiplier field is set.
       */
      @java.lang.Override
      public boolean hasDepthMultiplier() {
        return ((bitField0_ & 0x00000002) != 0);
      }
      /**
       * <pre>
       * The factor to alter the depth of the channels in the feature extractor.
       * </pre>
       *
       * <code>optional float depth_multiplier = 2 [default = 1];</code>
       * @return The depthMultiplier.
       */
      @java.lang.Override
      public float getDepthMultiplier() {
        return depthMultiplier_;
      }
      /**
       * <pre>
       * The factor to alter the depth of the channels in the feature extractor.
       * </pre>
       *
       * <code>optional float depth_multiplier = 2 [default = 1];</code>
       * @param value The depthMultiplier to set.
       * @return This builder for chaining.
       */
      public Builder setDepthMultiplier(float value) {
        bitField0_ |= 0x00000002;
        depthMultiplier_ = value;
        onChanged();
        return this;
      }
      /**
       * <pre>
       * The factor to alter the depth of the channels in the feature extractor.
       * </pre>
       *
       * <code>optional float depth_multiplier = 2 [default = 1];</code>
       * @return This builder for chaining.
       */
      public Builder clearDepthMultiplier() {
        bitField0_ = (bitField0_ & ~0x00000002);
        depthMultiplier_ = 1F;
        onChanged();
        return this;
      }

      private int minDepth_ = 16;
      /**
       * <pre>
       * Minimum number of the channels in the feature extractor.
       * </pre>
       *
       * <code>optional int32 min_depth = 3 [default = 16];</code>
       * @return Whether the minDepth field is set.
       */
      @java.lang.Override
      public boolean hasMinDepth() {
        return ((bitField0_ & 0x00000004) != 0);
      }
      /**
       * <pre>
       * Minimum number of the channels in the feature extractor.
       * </pre>
       *
       * <code>optional int32 min_depth = 3 [default = 16];</code>
       * @return The minDepth.
       */
      @java.lang.Override
      public int getMinDepth() {
        return minDepth_;
      }
      /**
       * <pre>
       * Minimum number of the channels in the feature extractor.
       * </pre>
       *
       * <code>optional int32 min_depth = 3 [default = 16];</code>
       * @param value The minDepth to set.
       * @return This builder for chaining.
       */
      public Builder setMinDepth(int value) {
        bitField0_ |= 0x00000004;
        minDepth_ = value;
        onChanged();
        return this;
      }
      /**
       * <pre>
       * Minimum number of the channels in the feature extractor.
       * </pre>
       *
       * <code>optional int32 min_depth = 3 [default = 16];</code>
       * @return This builder for chaining.
       */
      public Builder clearMinDepth() {
        bitField0_ = (bitField0_ & ~0x00000004);
        minDepth_ = 16;
        onChanged();
        return this;
      }

      private object_detection.protos.HyperparamsOuterClass.Hyperparams convHyperparams_;
      private com.google.protobuf.SingleFieldBuilderV3<
          object_detection.protos.HyperparamsOuterClass.Hyperparams, object_detection.protos.HyperparamsOuterClass.Hyperparams.Builder, object_detection.protos.HyperparamsOuterClass.HyperparamsOrBuilder> convHyperparamsBuilder_;
      /**
       * <pre>
       * Hyperparameters that affect the layers of feature extractor added on top
       * of the base feature extractor.
       * </pre>
       *
       * <code>optional .object_detection.protos.Hyperparams conv_hyperparams = 4;</code>
       * @return Whether the convHyperparams field is set.
       */
      public boolean hasConvHyperparams() {
        return ((bitField0_ & 0x00000008) != 0);
      }
      /**
       * <pre>
       * Hyperparameters that affect the layers of feature extractor added on top
       * of the base feature extractor.
       * </pre>
       *
       * <code>optional .object_detection.protos.Hyperparams conv_hyperparams = 4;</code>
       * @return The convHyperparams.
       */
      public object_detection.protos.HyperparamsOuterClass.Hyperparams getConvHyperparams() {
        if (convHyperparamsBuilder_ == null) {
          return convHyperparams_ == null ? object_detection.protos.HyperparamsOuterClass.Hyperparams.getDefaultInstance() : convHyperparams_;
        } else {
          return convHyperparamsBuilder_.getMessage();
        }
      }
      /**
       * <pre>
       * Hyperparameters that affect the layers of feature extractor added on top
       * of the base feature extractor.
       * </pre>
       *
       * <code>optional .object_detection.protos.Hyperparams conv_hyperparams = 4;</code>
       */
      public Builder setConvHyperparams(object_detection.protos.HyperparamsOuterClass.Hyperparams value) {
        if (convHyperparamsBuilder_ == null) {
          if (value == null) {
            throw new NullPointerException();
          }
          convHyperparams_ = value;
          onChanged();
        } else {
          convHyperparamsBuilder_.setMessage(value);
        }
        bitField0_ |= 0x00000008;
        return this;
      }
      /**
       * <pre>
       * Hyperparameters that affect the layers of feature extractor added on top
       * of the base feature extractor.
       * </pre>
       *
       * <code>optional .object_detection.protos.Hyperparams conv_hyperparams = 4;</code>
       */
      public Builder setConvHyperparams(
          object_detection.protos.HyperparamsOuterClass.Hyperparams.Builder builderForValue) {
        if (convHyperparamsBuilder_ == null) {
          convHyperparams_ = builderForValue.build();
          onChanged();
        } else {
          convHyperparamsBuilder_.setMessage(builderForValue.build());
        }
        bitField0_ |= 0x00000008;
        return this;
      }
      /**
       * <pre>
       * Hyperparameters that affect the layers of feature extractor added on top
       * of the base feature extractor.
       * </pre>
       *
       * <code>optional .object_detection.protos.Hyperparams conv_hyperparams = 4;</code>
       */
      public Builder mergeConvHyperparams(object_detection.protos.HyperparamsOuterClass.Hyperparams value) {
        if (convHyperparamsBuilder_ == null) {
          if (((bitField0_ & 0x00000008) != 0) &&
              convHyperparams_ != null &&
              convHyperparams_ != object_detection.protos.HyperparamsOuterClass.Hyperparams.getDefaultInstance()) {
            convHyperparams_ =
              object_detection.protos.HyperparamsOuterClass.Hyperparams.newBuilder(convHyperparams_).mergeFrom(value).buildPartial();
          } else {
            convHyperparams_ = value;
          }
          onChanged();
        } else {
          convHyperparamsBuilder_.mergeFrom(value);
        }
        bitField0_ |= 0x00000008;
        return this;
      }
      /**
       * <pre>
       * Hyperparameters that affect the layers of feature extractor added on top
       * of the base feature extractor.
       * </pre>
       *
       * <code>optional .object_detection.protos.Hyperparams conv_hyperparams = 4;</code>
       */
      public Builder clearConvHyperparams() {
        if (convHyperparamsBuilder_ == null) {
          convHyperparams_ = null;
          onChanged();
        } else {
          convHyperparamsBuilder_.clear();
        }
        bitField0_ = (bitField0_ & ~0x00000008);
        return this;
      }
      /**
       * <pre>
       * Hyperparameters that affect the layers of feature extractor added on top
       * of the base feature extractor.
       * </pre>
       *
       * <code>optional .object_detection.protos.Hyperparams conv_hyperparams = 4;</code>
       */
      public object_detection.protos.HyperparamsOuterClass.Hyperparams.Builder getConvHyperparamsBuilder() {
        bitField0_ |= 0x00000008;
        onChanged();
        return getConvHyperparamsFieldBuilder().getBuilder();
      }
      /**
       * <pre>
       * Hyperparameters that affect the layers of feature extractor added on top
       * of the base feature extractor.
       * </pre>
       *
       * <code>optional .object_detection.protos.Hyperparams conv_hyperparams = 4;</code>
       */
      public object_detection.protos.HyperparamsOuterClass.HyperparamsOrBuilder getConvHyperparamsOrBuilder() {
        if (convHyperparamsBuilder_ != null) {
          return convHyperparamsBuilder_.getMessageOrBuilder();
        } else {
          return convHyperparams_ == null ?
              object_detection.protos.HyperparamsOuterClass.Hyperparams.getDefaultInstance() : convHyperparams_;
        }
      }
      /**
       * <pre>
       * Hyperparameters that affect the layers of feature extractor added on top
       * of the base feature extractor.
       * </pre>
       *
       * <code>optional .object_detection.protos.Hyperparams conv_hyperparams = 4;</code>
       */
      private com.google.protobuf.SingleFieldBuilderV3<
          object_detection.protos.HyperparamsOuterClass.Hyperparams, object_detection.protos.HyperparamsOuterClass.Hyperparams.Builder, object_detection.protos.HyperparamsOuterClass.HyperparamsOrBuilder>
          getConvHyperparamsFieldBuilder() {
        if (convHyperparamsBuilder_ == null) {
          convHyperparamsBuilder_ = new com.google.protobuf.SingleFieldBuilderV3<
              object_detection.protos.HyperparamsOuterClass.Hyperparams, object_detection.protos.HyperparamsOuterClass.Hyperparams.Builder, object_detection.protos.HyperparamsOuterClass.HyperparamsOrBuilder>(
                  getConvHyperparams(),
                  getParentForChildren(),
                  isClean());
          convHyperparams_ = null;
        }
        return convHyperparamsBuilder_;
      }

      private boolean overrideBaseFeatureExtractorHyperparams_ ;
      /**
       * <pre>
       * Normally, SSD feature extractors are constructed by reusing an existing
       * base feature extractor (that has its own hyperparams) and adding new layers
       * on top of it. `conv_hyperparams` above normally applies only to the new
       * layers while base feature extractor uses its own default hyperparams. If
       * this value is set to true, the base feature extractor's hyperparams will be
       * overridden with the `conv_hyperparams`.
       * </pre>
       *
       * <code>optional bool override_base_feature_extractor_hyperparams = 9 [default = false];</code>
       * @return Whether the overrideBaseFeatureExtractorHyperparams field is set.
       */
      @java.lang.Override
      public boolean hasOverrideBaseFeatureExtractorHyperparams() {
        return ((bitField0_ & 0x00000010) != 0);
      }
      /**
       * <pre>
       * Normally, SSD feature extractors are constructed by reusing an existing
       * base feature extractor (that has its own hyperparams) and adding new layers
       * on top of it. `conv_hyperparams` above normally applies only to the new
       * layers while base feature extractor uses its own default hyperparams. If
       * this value is set to true, the base feature extractor's hyperparams will be
       * overridden with the `conv_hyperparams`.
       * </pre>
       *
       * <code>optional bool override_base_feature_extractor_hyperparams = 9 [default = false];</code>
       * @return The overrideBaseFeatureExtractorHyperparams.
       */
      @java.lang.Override
      public boolean getOverrideBaseFeatureExtractorHyperparams() {
        return overrideBaseFeatureExtractorHyperparams_;
      }
      /**
       * <pre>
       * Normally, SSD feature extractors are constructed by reusing an existing
       * base feature extractor (that has its own hyperparams) and adding new layers
       * on top of it. `conv_hyperparams` above normally applies only to the new
       * layers while base feature extractor uses its own default hyperparams. If
       * this value is set to true, the base feature extractor's hyperparams will be
       * overridden with the `conv_hyperparams`.
       * </pre>
       *
       * <code>optional bool override_base_feature_extractor_hyperparams = 9 [default = false];</code>
       * @param value The overrideBaseFeatureExtractorHyperparams to set.
       * @return This builder for chaining.
       */
      public Builder setOverrideBaseFeatureExtractorHyperparams(boolean value) {
        bitField0_ |= 0x00000010;
        overrideBaseFeatureExtractorHyperparams_ = value;
        onChanged();
        return this;
      }
      /**
       * <pre>
       * Normally, SSD feature extractors are constructed by reusing an existing
       * base feature extractor (that has its own hyperparams) and adding new layers
       * on top of it. `conv_hyperparams` above normally applies only to the new
       * layers while base feature extractor uses its own default hyperparams. If
       * this value is set to true, the base feature extractor's hyperparams will be
       * overridden with the `conv_hyperparams`.
       * </pre>
       *
       * <code>optional bool override_base_feature_extractor_hyperparams = 9 [default = false];</code>
       * @return This builder for chaining.
       */
      public Builder clearOverrideBaseFeatureExtractorHyperparams() {
        bitField0_ = (bitField0_ & ~0x00000010);
        overrideBaseFeatureExtractorHyperparams_ = false;
        onChanged();
        return this;
      }

      private int padToMultiple_ = 1;
      /**
       * <pre>
       * The nearest multiple to zero-pad the input height and width dimensions to.
       * For example, if pad_to_multiple = 2, input dimensions are zero-padded
       * until the resulting dimensions are even.
       * </pre>
       *
       * <code>optional int32 pad_to_multiple = 5 [default = 1];</code>
       * @return Whether the padToMultiple field is set.
       */
      @java.lang.Override
      public boolean hasPadToMultiple() {
        return ((bitField0_ & 0x00000020) != 0);
      }
      /**
       * <pre>
       * The nearest multiple to zero-pad the input height and width dimensions to.
       * For example, if pad_to_multiple = 2, input dimensions are zero-padded
       * until the resulting dimensions are even.
       * </pre>
       *
       * <code>optional int32 pad_to_multiple = 5 [default = 1];</code>
       * @return The padToMultiple.
       */
      @java.lang.Override
      public int getPadToMultiple() {
        return padToMultiple_;
      }
      /**
       * <pre>
       * The nearest multiple to zero-pad the input height and width dimensions to.
       * For example, if pad_to_multiple = 2, input dimensions are zero-padded
       * until the resulting dimensions are even.
       * </pre>
       *
       * <code>optional int32 pad_to_multiple = 5 [default = 1];</code>
       * @param value The padToMultiple to set.
       * @return This builder for chaining.
       */
      public Builder setPadToMultiple(int value) {
        bitField0_ |= 0x00000020;
        padToMultiple_ = value;
        onChanged();
        return this;
      }
      /**
       * <pre>
       * The nearest multiple to zero-pad the input height and width dimensions to.
       * For example, if pad_to_multiple = 2, input dimensions are zero-padded
       * until the resulting dimensions are even.
       * </pre>
       *
       * <code>optional int32 pad_to_multiple = 5 [default = 1];</code>
       * @return This builder for chaining.
       */
      public Builder clearPadToMultiple() {
        bitField0_ = (bitField0_ & ~0x00000020);
        padToMultiple_ = 1;
        onChanged();
        return this;
      }

      private boolean useExplicitPadding_ ;
      /**
       * <pre>
       * Whether to use explicit padding when extracting SSD multiresolution
       * features. This will also apply to the base feature extractor if a MobileNet
       * architecture is used.
       * </pre>
       *
       * <code>optional bool use_explicit_padding = 7 [default = false];</code>
       * @return Whether the useExplicitPadding field is set.
       */
      @java.lang.Override
      public boolean hasUseExplicitPadding() {
        return ((bitField0_ & 0x00000040) != 0);
      }
      /**
       * <pre>
       * Whether to use explicit padding when extracting SSD multiresolution
       * features. This will also apply to the base feature extractor if a MobileNet
       * architecture is used.
       * </pre>
       *
       * <code>optional bool use_explicit_padding = 7 [default = false];</code>
       * @return The useExplicitPadding.
       */
      @java.lang.Override
      public boolean getUseExplicitPadding() {
        return useExplicitPadding_;
      }
      /**
       * <pre>
       * Whether to use explicit padding when extracting SSD multiresolution
       * features. This will also apply to the base feature extractor if a MobileNet
       * architecture is used.
       * </pre>
       *
       * <code>optional bool use_explicit_padding = 7 [default = false];</code>
       * @param value The useExplicitPadding to set.
       * @return This builder for chaining.
       */
      public Builder setUseExplicitPadding(boolean value) {
        bitField0_ |= 0x00000040;
        useExplicitPadding_ = value;
        onChanged();
        return this;
      }
      /**
       * <pre>
       * Whether to use explicit padding when extracting SSD multiresolution
       * features. This will also apply to the base feature extractor if a MobileNet
       * architecture is used.
       * </pre>
       *
       * <code>optional bool use_explicit_padding = 7 [default = false];</code>
       * @return This builder for chaining.
       */
      public Builder clearUseExplicitPadding() {
        bitField0_ = (bitField0_ & ~0x00000040);
        useExplicitPadding_ = false;
        onChanged();
        return this;
      }

      private boolean useDepthwise_ ;
      /**
       * <pre>
       * Whether to use depthwise separable convolutions for to extract additional
       * feature maps added by SSD.
       * </pre>
       *
       * <code>optional bool use_depthwise = 8 [default = false];</code>
       * @return Whether the useDepthwise field is set.
       */
      @java.lang.Override
      public boolean hasUseDepthwise() {
        return ((bitField0_ & 0x00000080) != 0);
      }
      /**
       * <pre>
       * Whether to use depthwise separable convolutions for to extract additional
       * feature maps added by SSD.
       * </pre>
       *
       * <code>optional bool use_depthwise = 8 [default = false];</code>
       * @return The useDepthwise.
       */
      @java.lang.Override
      public boolean getUseDepthwise() {
        return useDepthwise_;
      }
      /**
       * <pre>
       * Whether to use depthwise separable convolutions for to extract additional
       * feature maps added by SSD.
       * </pre>
       *
       * <code>optional bool use_depthwise = 8 [default = false];</code>
       * @param value The useDepthwise to set.
       * @return This builder for chaining.
       */
      public Builder setUseDepthwise(boolean value) {
        bitField0_ |= 0x00000080;
        useDepthwise_ = value;
        onChanged();
        return this;
      }
      /**
       * <pre>
       * Whether to use depthwise separable convolutions for to extract additional
       * feature maps added by SSD.
       * </pre>
       *
       * <code>optional bool use_depthwise = 8 [default = false];</code>
       * @return This builder for chaining.
       */
      public Builder clearUseDepthwise() {
        bitField0_ = (bitField0_ & ~0x00000080);
        useDepthwise_ = false;
        onChanged();
        return this;
      }

      private com.google.protobuf.SingleFieldBuilderV3<
          object_detection.protos.Fpn.FeaturePyramidNetworks, object_detection.protos.Fpn.FeaturePyramidNetworks.Builder, object_detection.protos.Fpn.FeaturePyramidNetworksOrBuilder> fpnBuilder_;
      /**
       * <pre>
       * Feature Pyramid Networks config.
       * </pre>
       *
       * <code>.object_detection.protos.FeaturePyramidNetworks fpn = 10;</code>
       * @return Whether the fpn field is set.
       */
      @java.lang.Override
      public boolean hasFpn() {
        return featurePyramidOneofCase_ == 10;
      }
      /**
       * <pre>
       * Feature Pyramid Networks config.
       * </pre>
       *
       * <code>.object_detection.protos.FeaturePyramidNetworks fpn = 10;</code>
       * @return The fpn.
       */
      @java.lang.Override
      public object_detection.protos.Fpn.FeaturePyramidNetworks getFpn() {
        if (fpnBuilder_ == null) {
          if (featurePyramidOneofCase_ == 10) {
            return (object_detection.protos.Fpn.FeaturePyramidNetworks) featurePyramidOneof_;
          }
          return object_detection.protos.Fpn.FeaturePyramidNetworks.getDefaultInstance();
        } else {
          if (featurePyramidOneofCase_ == 10) {
            return fpnBuilder_.getMessage();
          }
          return object_detection.protos.Fpn.FeaturePyramidNetworks.getDefaultInstance();
        }
      }
      /**
       * <pre>
       * Feature Pyramid Networks config.
       * </pre>
       *
       * <code>.object_detection.protos.FeaturePyramidNetworks fpn = 10;</code>
       */
      public Builder setFpn(object_detection.protos.Fpn.FeaturePyramidNetworks value) {
        if (fpnBuilder_ == null) {
          if (value == null) {
            throw new NullPointerException();
          }
          featurePyramidOneof_ = value;
          onChanged();
        } else {
          fpnBuilder_.setMessage(value);
        }
        featurePyramidOneofCase_ = 10;
        return this;
      }
      /**
       * <pre>
       * Feature Pyramid Networks config.
       * </pre>
       *
       * <code>.object_detection.protos.FeaturePyramidNetworks fpn = 10;</code>
       */
      public Builder setFpn(
          object_detection.protos.Fpn.FeaturePyramidNetworks.Builder builderForValue) {
        if (fpnBuilder_ == null) {
          featurePyramidOneof_ = builderForValue.build();
          onChanged();
        } else {
          fpnBuilder_.setMessage(builderForValue.build());
        }
        featurePyramidOneofCase_ = 10;
        return this;
      }
      /**
       * <pre>
       * Feature Pyramid Networks config.
       * </pre>
       *
       * <code>.object_detection.protos.FeaturePyramidNetworks fpn = 10;</code>
       */
      public Builder mergeFpn(object_detection.protos.Fpn.FeaturePyramidNetworks value) {
        if (fpnBuilder_ == null) {
          if (featurePyramidOneofCase_ == 10 &&
              featurePyramidOneof_ != object_detection.protos.Fpn.FeaturePyramidNetworks.getDefaultInstance()) {
            featurePyramidOneof_ = object_detection.protos.Fpn.FeaturePyramidNetworks.newBuilder((object_detection.protos.Fpn.FeaturePyramidNetworks) featurePyramidOneof_)
                .mergeFrom(value).buildPartial();
          } else {
            featurePyramidOneof_ = value;
          }
          onChanged();
        } else {
          if (featurePyramidOneofCase_ == 10) {
            fpnBuilder_.mergeFrom(value);
          }
          fpnBuilder_.setMessage(value);
        }
        featurePyramidOneofCase_ = 10;
        return this;
      }
      /**
       * <pre>
       * Feature Pyramid Networks config.
       * </pre>
       *
       * <code>.object_detection.protos.FeaturePyramidNetworks fpn = 10;</code>
       */
      public Builder clearFpn() {
        if (fpnBuilder_ == null) {
          if (featurePyramidOneofCase_ == 10) {
            featurePyramidOneofCase_ = 0;
            featurePyramidOneof_ = null;
            onChanged();
          }
        } else {
          if (featurePyramidOneofCase_ == 10) {
            featurePyramidOneofCase_ = 0;
            featurePyramidOneof_ = null;
          }
          fpnBuilder_.clear();
        }
        return this;
      }
      /**
       * <pre>
       * Feature Pyramid Networks config.
       * </pre>
       *
       * <code>.object_detection.protos.FeaturePyramidNetworks fpn = 10;</code>
       */
      public object_detection.protos.Fpn.FeaturePyramidNetworks.Builder getFpnBuilder() {
        return getFpnFieldBuilder().getBuilder();
      }
      /**
       * <pre>
       * Feature Pyramid Networks config.
       * </pre>
       *
       * <code>.object_detection.protos.FeaturePyramidNetworks fpn = 10;</code>
       */
      @java.lang.Override
      public object_detection.protos.Fpn.FeaturePyramidNetworksOrBuilder getFpnOrBuilder() {
        if ((featurePyramidOneofCase_ == 10) && (fpnBuilder_ != null)) {
          return fpnBuilder_.getMessageOrBuilder();
        } else {
          if (featurePyramidOneofCase_ == 10) {
            return (object_detection.protos.Fpn.FeaturePyramidNetworks) featurePyramidOneof_;
          }
          return object_detection.protos.Fpn.FeaturePyramidNetworks.getDefaultInstance();
        }
      }
      /**
       * <pre>
       * Feature Pyramid Networks config.
       * </pre>
       *
       * <code>.object_detection.protos.FeaturePyramidNetworks fpn = 10;</code>
       */
      private com.google.protobuf.SingleFieldBuilderV3<
          object_detection.protos.Fpn.FeaturePyramidNetworks, object_detection.protos.Fpn.FeaturePyramidNetworks.Builder, object_detection.protos.Fpn.FeaturePyramidNetworksOrBuilder>
          getFpnFieldBuilder() {
        if (fpnBuilder_ == null) {
          if (!(featurePyramidOneofCase_ == 10)) {
            featurePyramidOneof_ = object_detection.protos.Fpn.FeaturePyramidNetworks.getDefaultInstance();
          }
          fpnBuilder_ = new com.google.protobuf.SingleFieldBuilderV3<
              object_detection.protos.Fpn.FeaturePyramidNetworks, object_detection.protos.Fpn.FeaturePyramidNetworks.Builder, object_detection.protos.Fpn.FeaturePyramidNetworksOrBuilder>(
                  (object_detection.protos.Fpn.FeaturePyramidNetworks) featurePyramidOneof_,
                  getParentForChildren(),
                  isClean());
          featurePyramidOneof_ = null;
        }
        featurePyramidOneofCase_ = 10;
        onChanged();;
        return fpnBuilder_;
      }

      private com.google.protobuf.SingleFieldBuilderV3<
          object_detection.protos.Fpn.BidirectionalFeaturePyramidNetworks, object_detection.protos.Fpn.BidirectionalFeaturePyramidNetworks.Builder, object_detection.protos.Fpn.BidirectionalFeaturePyramidNetworksOrBuilder> bifpnBuilder_;
      /**
       * <pre>
       * Bidirectional Feature Pyramid Networks config.
       * </pre>
       *
       * <code>.object_detection.protos.BidirectionalFeaturePyramidNetworks bifpn = 19;</code>
       * @return Whether the bifpn field is set.
       */
      @java.lang.Override
      public boolean hasBifpn() {
        return featurePyramidOneofCase_ == 19;
      }
      /**
       * <pre>
       * Bidirectional Feature Pyramid Networks config.
       * </pre>
       *
       * <code>.object_detection.protos.BidirectionalFeaturePyramidNetworks bifpn = 19;</code>
       * @return The bifpn.
       */
      @java.lang.Override
      public object_detection.protos.Fpn.BidirectionalFeaturePyramidNetworks getBifpn() {
        if (bifpnBuilder_ == null) {
          if (featurePyramidOneofCase_ == 19) {
            return (object_detection.protos.Fpn.BidirectionalFeaturePyramidNetworks) featurePyramidOneof_;
          }
          return object_detection.protos.Fpn.BidirectionalFeaturePyramidNetworks.getDefaultInstance();
        } else {
          if (featurePyramidOneofCase_ == 19) {
            return bifpnBuilder_.getMessage();
          }
          return object_detection.protos.Fpn.BidirectionalFeaturePyramidNetworks.getDefaultInstance();
        }
      }
      /**
       * <pre>
       * Bidirectional Feature Pyramid Networks config.
       * </pre>
       *
       * <code>.object_detection.protos.BidirectionalFeaturePyramidNetworks bifpn = 19;</code>
       */
      public Builder setBifpn(object_detection.protos.Fpn.BidirectionalFeaturePyramidNetworks value) {
        if (bifpnBuilder_ == null) {
          if (value == null) {
            throw new NullPointerException();
          }
          featurePyramidOneof_ = value;
          onChanged();
        } else {
          bifpnBuilder_.setMessage(value);
        }
        featurePyramidOneofCase_ = 19;
        return this;
      }
      /**
       * <pre>
       * Bidirectional Feature Pyramid Networks config.
       * </pre>
       *
       * <code>.object_detection.protos.BidirectionalFeaturePyramidNetworks bifpn = 19;</code>
       */
      public Builder setBifpn(
          object_detection.protos.Fpn.BidirectionalFeaturePyramidNetworks.Builder builderForValue) {
        if (bifpnBuilder_ == null) {
          featurePyramidOneof_ = builderForValue.build();
          onChanged();
        } else {
          bifpnBuilder_.setMessage(builderForValue.build());
        }
        featurePyramidOneofCase_ = 19;
        return this;
      }
      /**
       * <pre>
       * Bidirectional Feature Pyramid Networks config.
       * </pre>
       *
       * <code>.object_detection.protos.BidirectionalFeaturePyramidNetworks bifpn = 19;</code>
       */
      public Builder mergeBifpn(object_detection.protos.Fpn.BidirectionalFeaturePyramidNetworks value) {
        if (bifpnBuilder_ == null) {
          if (featurePyramidOneofCase_ == 19 &&
              featurePyramidOneof_ != object_detection.protos.Fpn.BidirectionalFeaturePyramidNetworks.getDefaultInstance()) {
            featurePyramidOneof_ = object_detection.protos.Fpn.BidirectionalFeaturePyramidNetworks.newBuilder((object_detection.protos.Fpn.BidirectionalFeaturePyramidNetworks) featurePyramidOneof_)
                .mergeFrom(value).buildPartial();
          } else {
            featurePyramidOneof_ = value;
          }
          onChanged();
        } else {
          if (featurePyramidOneofCase_ == 19) {
            bifpnBuilder_.mergeFrom(value);
          }
          bifpnBuilder_.setMessage(value);
        }
        featurePyramidOneofCase_ = 19;
        return this;
      }
      /**
       * <pre>
       * Bidirectional Feature Pyramid Networks config.
       * </pre>
       *
       * <code>.object_detection.protos.BidirectionalFeaturePyramidNetworks bifpn = 19;</code>
       */
      public Builder clearBifpn() {
        if (bifpnBuilder_ == null) {
          if (featurePyramidOneofCase_ == 19) {
            featurePyramidOneofCase_ = 0;
            featurePyramidOneof_ = null;
            onChanged();
          }
        } else {
          if (featurePyramidOneofCase_ == 19) {
            featurePyramidOneofCase_ = 0;
            featurePyramidOneof_ = null;
          }
          bifpnBuilder_.clear();
        }
        return this;
      }
      /**
       * <pre>
       * Bidirectional Feature Pyramid Networks config.
       * </pre>
       *
       * <code>.object_detection.protos.BidirectionalFeaturePyramidNetworks bifpn = 19;</code>
       */
      public object_detection.protos.Fpn.BidirectionalFeaturePyramidNetworks.Builder getBifpnBuilder() {
        return getBifpnFieldBuilder().getBuilder();
      }
      /**
       * <pre>
       * Bidirectional Feature Pyramid Networks config.
       * </pre>
       *
       * <code>.object_detection.protos.BidirectionalFeaturePyramidNetworks bifpn = 19;</code>
       */
      @java.lang.Override
      public object_detection.protos.Fpn.BidirectionalFeaturePyramidNetworksOrBuilder getBifpnOrBuilder() {
        if ((featurePyramidOneofCase_ == 19) && (bifpnBuilder_ != null)) {
          return bifpnBuilder_.getMessageOrBuilder();
        } else {
          if (featurePyramidOneofCase_ == 19) {
            return (object_detection.protos.Fpn.BidirectionalFeaturePyramidNetworks) featurePyramidOneof_;
          }
          return object_detection.protos.Fpn.BidirectionalFeaturePyramidNetworks.getDefaultInstance();
        }
      }
      /**
       * <pre>
       * Bidirectional Feature Pyramid Networks config.
       * </pre>
       *
       * <code>.object_detection.protos.BidirectionalFeaturePyramidNetworks bifpn = 19;</code>
       */
      private com.google.protobuf.SingleFieldBuilderV3<
          object_detection.protos.Fpn.BidirectionalFeaturePyramidNetworks, object_detection.protos.Fpn.BidirectionalFeaturePyramidNetworks.Builder, object_detection.protos.Fpn.BidirectionalFeaturePyramidNetworksOrBuilder>
          getBifpnFieldBuilder() {
        if (bifpnBuilder_ == null) {
          if (!(featurePyramidOneofCase_ == 19)) {
            featurePyramidOneof_ = object_detection.protos.Fpn.BidirectionalFeaturePyramidNetworks.getDefaultInstance();
          }
          bifpnBuilder_ = new com.google.protobuf.SingleFieldBuilderV3<
              object_detection.protos.Fpn.BidirectionalFeaturePyramidNetworks, object_detection.protos.Fpn.BidirectionalFeaturePyramidNetworks.Builder, object_detection.protos.Fpn.BidirectionalFeaturePyramidNetworksOrBuilder>(
                  (object_detection.protos.Fpn.BidirectionalFeaturePyramidNetworks) featurePyramidOneof_,
                  getParentForChildren(),
                  isClean());
          featurePyramidOneof_ = null;
        }
        featurePyramidOneofCase_ = 19;
        onChanged();;
        return bifpnBuilder_;
      }

      private boolean replacePreprocessorWithPlaceholder_ ;
      /**
       * <pre>
       * If true, replace preprocess function of feature extractor with a
       * placeholder. This should only be used if all the image preprocessing steps
       * happen outside the graph.
       * </pre>
       *
       * <code>optional bool replace_preprocessor_with_placeholder = 11 [default = false];</code>
       * @return Whether the replacePreprocessorWithPlaceholder field is set.
       */
      @java.lang.Override
      public boolean hasReplacePreprocessorWithPlaceholder() {
        return ((bitField0_ & 0x00000400) != 0);
      }
      /**
       * <pre>
       * If true, replace preprocess function of feature extractor with a
       * placeholder. This should only be used if all the image preprocessing steps
       * happen outside the graph.
       * </pre>
       *
       * <code>optional bool replace_preprocessor_with_placeholder = 11 [default = false];</code>
       * @return The replacePreprocessorWithPlaceholder.
       */
      @java.lang.Override
      public boolean getReplacePreprocessorWithPlaceholder() {
        return replacePreprocessorWithPlaceholder_;
      }
      /**
       * <pre>
       * If true, replace preprocess function of feature extractor with a
       * placeholder. This should only be used if all the image preprocessing steps
       * happen outside the graph.
       * </pre>
       *
       * <code>optional bool replace_preprocessor_with_placeholder = 11 [default = false];</code>
       * @param value The replacePreprocessorWithPlaceholder to set.
       * @return This builder for chaining.
       */
      public Builder setReplacePreprocessorWithPlaceholder(boolean value) {
        bitField0_ |= 0x00000400;
        replacePreprocessorWithPlaceholder_ = value;
        onChanged();
        return this;
      }
      /**
       * <pre>
       * If true, replace preprocess function of feature extractor with a
       * placeholder. This should only be used if all the image preprocessing steps
       * happen outside the graph.
       * </pre>
       *
       * <code>optional bool replace_preprocessor_with_placeholder = 11 [default = false];</code>
       * @return This builder for chaining.
       */
      public Builder clearReplacePreprocessorWithPlaceholder() {
        bitField0_ = (bitField0_ & ~0x00000400);
        replacePreprocessorWithPlaceholder_ = false;
        onChanged();
        return this;
      }

      private int numLayers_ = 6;
      /**
       * <pre>
       * The number of SSD layers.
       * </pre>
       *
       * <code>optional int32 num_layers = 12 [default = 6];</code>
       * @return Whether the numLayers field is set.
       */
      @java.lang.Override
      public boolean hasNumLayers() {
        return ((bitField0_ & 0x00000800) != 0);
      }
      /**
       * <pre>
       * The number of SSD layers.
       * </pre>
       *
       * <code>optional int32 num_layers = 12 [default = 6];</code>
       * @return The numLayers.
       */
      @java.lang.Override
      public int getNumLayers() {
        return numLayers_;
      }
      /**
       * <pre>
       * The number of SSD layers.
       * </pre>
       *
       * <code>optional int32 num_layers = 12 [default = 6];</code>
       * @param value The numLayers to set.
       * @return This builder for chaining.
       */
      public Builder setNumLayers(int value) {
        bitField0_ |= 0x00000800;
        numLayers_ = value;
        onChanged();
        return this;
      }
      /**
       * <pre>
       * The number of SSD layers.
       * </pre>
       *
       * <code>optional int32 num_layers = 12 [default = 6];</code>
       * @return This builder for chaining.
       */
      public Builder clearNumLayers() {
        bitField0_ = (bitField0_ & ~0x00000800);
        numLayers_ = 6;
        onChanged();
        return this;
      }
      @java.lang.Override
      public final Builder setUnknownFields(
          final com.google.protobuf.UnknownFieldSet unknownFields) {
        return super.setUnknownFields(unknownFields);
      }

      @java.lang.Override
      public final Builder mergeUnknownFields(
          final com.google.protobuf.UnknownFieldSet unknownFields) {
        return super.mergeUnknownFields(unknownFields);
      }


      // @@protoc_insertion_point(builder_scope:object_detection.protos.SsdFeatureExtractor)
    }

    // @@protoc_insertion_point(class_scope:object_detection.protos.SsdFeatureExtractor)
    private static final object_detection.protos.SsdOuterClass.SsdFeatureExtractor DEFAULT_INSTANCE;
    static {
      DEFAULT_INSTANCE = new object_detection.protos.SsdOuterClass.SsdFeatureExtractor();
    }

    public static object_detection.protos.SsdOuterClass.SsdFeatureExtractor getDefaultInstance() {
      return DEFAULT_INSTANCE;
    }

    @java.lang.Deprecated public static final com.google.protobuf.Parser<SsdFeatureExtractor>
        PARSER = new com.google.protobuf.AbstractParser<SsdFeatureExtractor>() {
      @java.lang.Override
      public SsdFeatureExtractor parsePartialFrom(
          com.google.protobuf.CodedInputStream input,
          com.google.protobuf.ExtensionRegistryLite extensionRegistry)
          throws com.google.protobuf.InvalidProtocolBufferException {
        return new SsdFeatureExtractor(input, extensionRegistry);
      }
    };

    public static com.google.protobuf.Parser<SsdFeatureExtractor> parser() {
      return PARSER;
    }

    @java.lang.Override
    public com.google.protobuf.Parser<SsdFeatureExtractor> getParserForType() {
      return PARSER;
    }

    @java.lang.Override
    public object_detection.protos.SsdOuterClass.SsdFeatureExtractor getDefaultInstanceForType() {
      return DEFAULT_INSTANCE;
    }

  }

  private static final com.google.protobuf.Descriptors.Descriptor
    internal_static_object_detection_protos_Ssd_descriptor;
  private static final
    com.google.protobuf.GeneratedMessageV3.FieldAccessorTable
      internal_static_object_detection_protos_Ssd_fieldAccessorTable;
  private static final com.google.protobuf.Descriptors.Descriptor
    internal_static_object_detection_protos_Ssd_MaskHead_descriptor;
  private static final
    com.google.protobuf.GeneratedMessageV3.FieldAccessorTable
      internal_static_object_detection_protos_Ssd_MaskHead_fieldAccessorTable;
  private static final com.google.protobuf.Descriptors.Descriptor
    internal_static_object_detection_protos_SsdFeatureExtractor_descriptor;
  private static final
    com.google.protobuf.GeneratedMessageV3.FieldAccessorTable
      internal_static_object_detection_protos_SsdFeatureExtractor_fieldAccessorTable;

  public static com.google.protobuf.Descriptors.FileDescriptor
      getDescriptor() {
    return descriptor;
  }
  private static  com.google.protobuf.Descriptors.FileDescriptor
      descriptor;
  static {
    java.lang.String[] descriptorData = {
      "\n!object_detection/protos/ssd.proto\022\027obj" +
      "ect_detection.protos\032.object_detection/p" +
      "rotos/anchor_generator.proto\032\'object_det" +
      "ection/protos/box_coder.proto\032+object_de" +
      "tection/protos/box_predictor.proto\032)obje" +
      "ct_detection/protos/hyperparams.proto\032+o" +
      "bject_detection/protos/image_resizer.pro" +
      "to\032$object_detection/protos/losses.proto" +
      "\032%object_detection/protos/matcher.proto\032" +
      "-object_detection/protos/post_processing" +
      ".proto\032:object_detection/protos/region_s" +
      "imilarity_calculator.proto\032!object_detec" +
      "tion/protos/fpn.proto\"\334\013\n\003Ssd\022\023\n\013num_cla" +
      "sses\030\001 \001(\005\022<\n\rimage_resizer\030\002 \001(\0132%.obje" +
      "ct_detection.protos.ImageResizer\022G\n\021feat" +
      "ure_extractor\030\003 \001(\0132,.object_detection.p" +
      "rotos.SsdFeatureExtractor\0224\n\tbox_coder\030\004" +
      " \001(\0132!.object_detection.protos.BoxCoder\022" +
      "1\n\007matcher\030\005 \001(\0132 .object_detection.prot" +
      "os.Matcher\022R\n\025similarity_calculator\030\006 \001(" +
      "\01323.object_detection.protos.RegionSimila" +
      "rityCalculator\022)\n\032encode_background_as_z" +
      "eros\030\014 \001(\010:\005false\022 \n\025negative_class_weig" +
      "ht\030\r \001(\002:\0011\022<\n\rbox_predictor\030\007 \001(\0132%.obj" +
      "ect_detection.protos.BoxPredictor\022B\n\020anc" +
      "hor_generator\030\010 \001(\0132(.object_detection.p" +
      "rotos.AnchorGenerator\022@\n\017post_processing" +
      "\030\t \001(\0132\'.object_detection.protos.PostPro" +
      "cessing\022+\n\035normalize_loss_by_num_matches" +
      "\030\n \001(\010:\004true\022-\n\036normalize_loc_loss_by_co" +
      "desize\030\016 \001(\010:\005false\022+\n\004loss\030\013 \001(\0132\035.obje" +
      "ct_detection.protos.Loss\022\037\n\020freeze_batch" +
      "norm\030\020 \001(\010:\005false\022\'\n\030inplace_batchnorm_u" +
      "pdate\030\017 \001(\010:\005false\022\"\n\024add_background_cla" +
      "ss\030\025 \001(\010:\004true\022(\n\031explicit_background_cl" +
      "ass\030\030 \001(\010:\005false\022)\n\032use_confidences_as_t" +
      "argets\030\026 \001(\010:\005false\022\"\n\027implicit_example_" +
      "weight\030\027 \001(\002:\0011\0223\n$return_raw_detections" +
      "_during_predict\030\032 \001(\010:\005false\022?\n\020mask_hea" +
      "d_config\030\031 \001(\0132%.object_detection.protos" +
      ".Ssd.MaskHead\032\204\003\n\010MaskHead\022\027\n\013mask_heigh" +
      "t\030\001 \001(\005:\00215\022\026\n\nmask_width\030\002 \001(\005:\00215\022&\n\030m" +
      "asks_are_class_agnostic\030\003 \001(\010:\004true\022\'\n\032m" +
      "ask_prediction_conv_depth\030\004 \001(\005:\003256\022*\n\037" +
      "mask_prediction_num_conv_layers\030\005 \001(\005:\0012" +
      "\022+\n\034convolve_then_upsample_masks\030\006 \001(\010:\005" +
      "false\022\033\n\020mask_loss_weight\030\007 \001(\002:\0015\022!\n\025ma" +
      "sk_loss_sample_size\030\010 \001(\005:\00216\022>\n\020conv_hy" +
      "perparams\030\t \001(\0132$.object_detection.proto" +
      "s.Hyperparams\022\035\n\021initial_crop_size\030\n \001(\005" +
      ":\00215\"\255\004\n\023SsdFeatureExtractor\022\014\n\004type\030\001 \001" +
      "(\t\022\033\n\020depth_multiplier\030\002 \001(\002:\0011\022\025\n\tmin_d" +
      "epth\030\003 \001(\005:\00216\022>\n\020conv_hyperparams\030\004 \001(\013" +
      "2$.object_detection.protos.Hyperparams\022:" +
      "\n+override_base_feature_extractor_hyperp" +
      "arams\030\t \001(\010:\005false\022\032\n\017pad_to_multiple\030\005 " +
      "\001(\005:\0011\022#\n\024use_explicit_padding\030\007 \001(\010:\005fa" +
      "lse\022\034\n\ruse_depthwise\030\010 \001(\010:\005false\022>\n\003fpn" +
      "\030\n \001(\0132/.object_detection.protos.Feature" +
      "PyramidNetworksH\000\022M\n\005bifpn\030\023 \001(\0132<.objec" +
      "t_detection.protos.BidirectionalFeatureP" +
      "yramidNetworksH\000\0224\n%replace_preprocessor" +
      "_with_placeholder\030\013 \001(\010:\005false\022\025\n\nnum_la" +
      "yers\030\014 \001(\005:\0016B\027\n\025feature_pyramid_oneofJ\004" +
      "\010\006\020\007"
    };
    descriptor = com.google.protobuf.Descriptors.FileDescriptor
      .internalBuildGeneratedFileFrom(descriptorData,
        new com.google.protobuf.Descriptors.FileDescriptor[] {
          object_detection.protos.AnchorGeneratorOuterClass.getDescriptor(),
          object_detection.protos.BoxCoderOuterClass.getDescriptor(),
          object_detection.protos.BoxPredictorOuterClass.getDescriptor(),
          object_detection.protos.HyperparamsOuterClass.getDescriptor(),
          object_detection.protos.ImageResizerOuterClass.getDescriptor(),
          object_detection.protos.Losses.getDescriptor(),
          object_detection.protos.MatcherOuterClass.getDescriptor(),
          object_detection.protos.PostProcessingOuterClass.getDescriptor(),
          object_detection.protos.RegionSimilarityCalculatorOuterClass.getDescriptor(),
          object_detection.protos.Fpn.getDescriptor(),
        });
    internal_static_object_detection_protos_Ssd_descriptor =
      getDescriptor().getMessageTypes().get(0);
    internal_static_object_detection_protos_Ssd_fieldAccessorTable = new
      com.google.protobuf.GeneratedMessageV3.FieldAccessorTable(
        internal_static_object_detection_protos_Ssd_descriptor,
        new java.lang.String[] { "NumClasses", "ImageResizer", "FeatureExtractor", "BoxCoder", "Matcher", "SimilarityCalculator", "EncodeBackgroundAsZeros", "NegativeClassWeight", "BoxPredictor", "AnchorGenerator", "PostProcessing", "NormalizeLossByNumMatches", "NormalizeLocLossByCodesize", "Loss", "FreezeBatchnorm", "InplaceBatchnormUpdate", "AddBackgroundClass", "ExplicitBackgroundClass", "UseConfidencesAsTargets", "ImplicitExampleWeight", "ReturnRawDetectionsDuringPredict", "MaskHeadConfig", });
    internal_static_object_detection_protos_Ssd_MaskHead_descriptor =
      internal_static_object_detection_protos_Ssd_descriptor.getNestedTypes().get(0);
    internal_static_object_detection_protos_Ssd_MaskHead_fieldAccessorTable = new
      com.google.protobuf.GeneratedMessageV3.FieldAccessorTable(
        internal_static_object_detection_protos_Ssd_MaskHead_descriptor,
        new java.lang.String[] { "MaskHeight", "MaskWidth", "MasksAreClassAgnostic", "MaskPredictionConvDepth", "MaskPredictionNumConvLayers", "ConvolveThenUpsampleMasks", "MaskLossWeight", "MaskLossSampleSize", "ConvHyperparams", "InitialCropSize", });
    internal_static_object_detection_protos_SsdFeatureExtractor_descriptor =
      getDescriptor().getMessageTypes().get(1);
    internal_static_object_detection_protos_SsdFeatureExtractor_fieldAccessorTable = new
      com.google.protobuf.GeneratedMessageV3.FieldAccessorTable(
        internal_static_object_detection_protos_SsdFeatureExtractor_descriptor,
        new java.lang.String[] { "Type", "DepthMultiplier", "MinDepth", "ConvHyperparams", "OverrideBaseFeatureExtractorHyperparams", "PadToMultiple", "UseExplicitPadding", "UseDepthwise", "Fpn", "Bifpn", "ReplacePreprocessorWithPlaceholder", "NumLayers", "FeaturePyramidOneof", });
    object_detection.protos.AnchorGeneratorOuterClass.getDescriptor();
    object_detection.protos.BoxCoderOuterClass.getDescriptor();
    object_detection.protos.BoxPredictorOuterClass.getDescriptor();
    object_detection.protos.HyperparamsOuterClass.getDescriptor();
    object_detection.protos.ImageResizerOuterClass.getDescriptor();
    object_detection.protos.Losses.getDescriptor();
    object_detection.protos.MatcherOuterClass.getDescriptor();
    object_detection.protos.PostProcessingOuterClass.getDescriptor();
    object_detection.protos.RegionSimilarityCalculatorOuterClass.getDescriptor();
    object_detection.protos.Fpn.getDescriptor();
  }

  // @@protoc_insertion_point(outer_class_scope)
}
