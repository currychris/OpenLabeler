/*
 * Copyright (c) 2020. Kin-Hong Wong. All Rights Reserved.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

// Generated by the protocol buffer compiler.  DO NOT EDIT!
// source: object_detection/protos/input_reader.proto

package object_detection.protos;

public final class InputReaderOuterClass {
  private InputReaderOuterClass() {}
  public static void registerAllExtensions(
      com.google.protobuf.ExtensionRegistryLite registry) {
  }

  public static void registerAllExtensions(
      com.google.protobuf.ExtensionRegistry registry) {
    registerAllExtensions(
        (com.google.protobuf.ExtensionRegistryLite) registry);
  }
  /**
   * <pre>
   * Instance mask format. Note that PNG masks are much more space efficient.
   * </pre>
   *
   * Protobuf enum {@code object_detection.protos.InstanceMaskType}
   */
  public enum InstanceMaskType
      implements com.google.protobuf.ProtocolMessageEnum {
    /**
     * <pre>
     * Default implementation, currently NUMERICAL_MASKS
     * </pre>
     *
     * <code>DEFAULT = 0;</code>
     */
    DEFAULT(0),
    /**
     * <pre>
     * [num_masks, H, W] float32 binary masks.
     * </pre>
     *
     * <code>NUMERICAL_MASKS = 1;</code>
     */
    NUMERICAL_MASKS(1),
    /**
     * <pre>
     * Encoded PNG masks.
     * </pre>
     *
     * <code>PNG_MASKS = 2;</code>
     */
    PNG_MASKS(2),
    ;

    /**
     * <pre>
     * Default implementation, currently NUMERICAL_MASKS
     * </pre>
     *
     * <code>DEFAULT = 0;</code>
     */
    public static final int DEFAULT_VALUE = 0;
    /**
     * <pre>
     * [num_masks, H, W] float32 binary masks.
     * </pre>
     *
     * <code>NUMERICAL_MASKS = 1;</code>
     */
    public static final int NUMERICAL_MASKS_VALUE = 1;
    /**
     * <pre>
     * Encoded PNG masks.
     * </pre>
     *
     * <code>PNG_MASKS = 2;</code>
     */
    public static final int PNG_MASKS_VALUE = 2;


    public final int getNumber() {
      return value;
    }

    /**
     * @param value The numeric wire value of the corresponding enum entry.
     * @return The enum associated with the given numeric wire value.
     * @deprecated Use {@link #forNumber(int)} instead.
     */
    @java.lang.Deprecated
    public static InstanceMaskType valueOf(int value) {
      return forNumber(value);
    }

    /**
     * @param value The numeric wire value of the corresponding enum entry.
     * @return The enum associated with the given numeric wire value.
     */
    public static InstanceMaskType forNumber(int value) {
      switch (value) {
        case 0: return DEFAULT;
        case 1: return NUMERICAL_MASKS;
        case 2: return PNG_MASKS;
        default: return null;
      }
    }

    public static com.google.protobuf.Internal.EnumLiteMap<InstanceMaskType>
        internalGetValueMap() {
      return internalValueMap;
    }
    private static final com.google.protobuf.Internal.EnumLiteMap<
        InstanceMaskType> internalValueMap =
          new com.google.protobuf.Internal.EnumLiteMap<InstanceMaskType>() {
            public InstanceMaskType findValueByNumber(int number) {
              return InstanceMaskType.forNumber(number);
            }
          };

    public final com.google.protobuf.Descriptors.EnumValueDescriptor
        getValueDescriptor() {
      return getDescriptor().getValues().get(ordinal());
    }
    public final com.google.protobuf.Descriptors.EnumDescriptor
        getDescriptorForType() {
      return getDescriptor();
    }
    public static final com.google.protobuf.Descriptors.EnumDescriptor
        getDescriptor() {
      return object_detection.protos.InputReaderOuterClass.getDescriptor().getEnumTypes().get(0);
    }

    private static final InstanceMaskType[] VALUES = values();

    public static InstanceMaskType valueOf(
        com.google.protobuf.Descriptors.EnumValueDescriptor desc) {
      if (desc.getType() != getDescriptor()) {
        throw new java.lang.IllegalArgumentException(
          "EnumValueDescriptor is not for this type.");
      }
      return VALUES[desc.getIndex()];
    }

    private final int value;

    private InstanceMaskType(int value) {
      this.value = value;
    }

    // @@protoc_insertion_point(enum_scope:object_detection.protos.InstanceMaskType)
  }

  /**
   * <pre>
   * Input type format: whether inputs are TfExamples or TfSequenceExamples.
   * </pre>
   *
   * Protobuf enum {@code object_detection.protos.InputType}
   */
  public enum InputType
      implements com.google.protobuf.ProtocolMessageEnum {
    /**
     * <pre>
     * Default implementation, currently TF_EXAMPLE
     * </pre>
     *
     * <code>INPUT_DEFAULT = 0;</code>
     */
    INPUT_DEFAULT(0),
    /**
     * <pre>
     * TfExample input
     * </pre>
     *
     * <code>TF_EXAMPLE = 1;</code>
     */
    TF_EXAMPLE(1),
    /**
     * <pre>
     * TfSequenceExample Input
     * </pre>
     *
     * <code>TF_SEQUENCE_EXAMPLE = 2;</code>
     */
    TF_SEQUENCE_EXAMPLE(2),
    ;

    /**
     * <pre>
     * Default implementation, currently TF_EXAMPLE
     * </pre>
     *
     * <code>INPUT_DEFAULT = 0;</code>
     */
    public static final int INPUT_DEFAULT_VALUE = 0;
    /**
     * <pre>
     * TfExample input
     * </pre>
     *
     * <code>TF_EXAMPLE = 1;</code>
     */
    public static final int TF_EXAMPLE_VALUE = 1;
    /**
     * <pre>
     * TfSequenceExample Input
     * </pre>
     *
     * <code>TF_SEQUENCE_EXAMPLE = 2;</code>
     */
    public static final int TF_SEQUENCE_EXAMPLE_VALUE = 2;


    public final int getNumber() {
      return value;
    }

    /**
     * @param value The numeric wire value of the corresponding enum entry.
     * @return The enum associated with the given numeric wire value.
     * @deprecated Use {@link #forNumber(int)} instead.
     */
    @java.lang.Deprecated
    public static InputType valueOf(int value) {
      return forNumber(value);
    }

    /**
     * @param value The numeric wire value of the corresponding enum entry.
     * @return The enum associated with the given numeric wire value.
     */
    public static InputType forNumber(int value) {
      switch (value) {
        case 0: return INPUT_DEFAULT;
        case 1: return TF_EXAMPLE;
        case 2: return TF_SEQUENCE_EXAMPLE;
        default: return null;
      }
    }

    public static com.google.protobuf.Internal.EnumLiteMap<InputType>
        internalGetValueMap() {
      return internalValueMap;
    }
    private static final com.google.protobuf.Internal.EnumLiteMap<
        InputType> internalValueMap =
          new com.google.protobuf.Internal.EnumLiteMap<InputType>() {
            public InputType findValueByNumber(int number) {
              return InputType.forNumber(number);
            }
          };

    public final com.google.protobuf.Descriptors.EnumValueDescriptor
        getValueDescriptor() {
      return getDescriptor().getValues().get(ordinal());
    }
    public final com.google.protobuf.Descriptors.EnumDescriptor
        getDescriptorForType() {
      return getDescriptor();
    }
    public static final com.google.protobuf.Descriptors.EnumDescriptor
        getDescriptor() {
      return object_detection.protos.InputReaderOuterClass.getDescriptor().getEnumTypes().get(1);
    }

    private static final InputType[] VALUES = values();

    public static InputType valueOf(
        com.google.protobuf.Descriptors.EnumValueDescriptor desc) {
      if (desc.getType() != getDescriptor()) {
        throw new java.lang.IllegalArgumentException(
          "EnumValueDescriptor is not for this type.");
      }
      return VALUES[desc.getIndex()];
    }

    private final int value;

    private InputType(int value) {
      this.value = value;
    }

    // @@protoc_insertion_point(enum_scope:object_detection.protos.InputType)
  }

  public interface InputReaderOrBuilder extends
      // @@protoc_insertion_point(interface_extends:object_detection.protos.InputReader)
      com.google.protobuf.MessageOrBuilder {

    /**
     * <pre>
     * Name of input reader. Typically used to describe the dataset that is read
     * by this input reader.
     * </pre>
     *
     * <code>optional string name = 23 [default = ""];</code>
     * @return Whether the name field is set.
     */
    boolean hasName();
    /**
     * <pre>
     * Name of input reader. Typically used to describe the dataset that is read
     * by this input reader.
     * </pre>
     *
     * <code>optional string name = 23 [default = ""];</code>
     * @return The name.
     */
    java.lang.String getName();
    /**
     * <pre>
     * Name of input reader. Typically used to describe the dataset that is read
     * by this input reader.
     * </pre>
     *
     * <code>optional string name = 23 [default = ""];</code>
     * @return The bytes for name.
     */
    com.google.protobuf.ByteString
        getNameBytes();

    /**
     * <pre>
     * Path to StringIntLabelMap pbtxt file specifying the mapping from string
     * labels to integer ids.
     * </pre>
     *
     * <code>optional string label_map_path = 1 [default = ""];</code>
     * @return Whether the labelMapPath field is set.
     */
    boolean hasLabelMapPath();
    /**
     * <pre>
     * Path to StringIntLabelMap pbtxt file specifying the mapping from string
     * labels to integer ids.
     * </pre>
     *
     * <code>optional string label_map_path = 1 [default = ""];</code>
     * @return The labelMapPath.
     */
    java.lang.String getLabelMapPath();
    /**
     * <pre>
     * Path to StringIntLabelMap pbtxt file specifying the mapping from string
     * labels to integer ids.
     * </pre>
     *
     * <code>optional string label_map_path = 1 [default = ""];</code>
     * @return The bytes for labelMapPath.
     */
    com.google.protobuf.ByteString
        getLabelMapPathBytes();

    /**
     * <pre>
     * Whether data should be processed in the order they are read in, or
     * shuffled randomly.
     * </pre>
     *
     * <code>optional bool shuffle = 2 [default = true];</code>
     * @return Whether the shuffle field is set.
     */
    boolean hasShuffle();
    /**
     * <pre>
     * Whether data should be processed in the order they are read in, or
     * shuffled randomly.
     * </pre>
     *
     * <code>optional bool shuffle = 2 [default = true];</code>
     * @return The shuffle.
     */
    boolean getShuffle();

    /**
     * <pre>
     * Buffer size to be used when shuffling.
     * </pre>
     *
     * <code>optional uint32 shuffle_buffer_size = 11 [default = 2048];</code>
     * @return Whether the shuffleBufferSize field is set.
     */
    boolean hasShuffleBufferSize();
    /**
     * <pre>
     * Buffer size to be used when shuffling.
     * </pre>
     *
     * <code>optional uint32 shuffle_buffer_size = 11 [default = 2048];</code>
     * @return The shuffleBufferSize.
     */
    int getShuffleBufferSize();

    /**
     * <pre>
     * Buffer size to be used when shuffling file names.
     * </pre>
     *
     * <code>optional uint32 filenames_shuffle_buffer_size = 12 [default = 100];</code>
     * @return Whether the filenamesShuffleBufferSize field is set.
     */
    boolean hasFilenamesShuffleBufferSize();
    /**
     * <pre>
     * Buffer size to be used when shuffling file names.
     * </pre>
     *
     * <code>optional uint32 filenames_shuffle_buffer_size = 12 [default = 100];</code>
     * @return The filenamesShuffleBufferSize.
     */
    int getFilenamesShuffleBufferSize();

    /**
     * <pre>
     * The number of times a data source is read. If set to zero, the data source
     * will be reused indefinitely.
     * </pre>
     *
     * <code>optional uint32 num_epochs = 5 [default = 0];</code>
     * @return Whether the numEpochs field is set.
     */
    boolean hasNumEpochs();
    /**
     * <pre>
     * The number of times a data source is read. If set to zero, the data source
     * will be reused indefinitely.
     * </pre>
     *
     * <code>optional uint32 num_epochs = 5 [default = 0];</code>
     * @return The numEpochs.
     */
    int getNumEpochs();

    /**
     * <pre>
     * Integer representing how often an example should be sampled. To feed
     * only 1/3 of your data into your model, set `sample_1_of_n_examples` to 3.
     * This is particularly useful for evaluation, where you might not prefer to
     * evaluate all of your samples.
     * </pre>
     *
     * <code>optional uint32 sample_1_of_n_examples = 22 [default = 1];</code>
     * @return Whether the sample1OfNExamples field is set.
     */
    boolean hasSample1OfNExamples();
    /**
     * <pre>
     * Integer representing how often an example should be sampled. To feed
     * only 1/3 of your data into your model, set `sample_1_of_n_examples` to 3.
     * This is particularly useful for evaluation, where you might not prefer to
     * evaluate all of your samples.
     * </pre>
     *
     * <code>optional uint32 sample_1_of_n_examples = 22 [default = 1];</code>
     * @return The sample1OfNExamples.
     */
    int getSample1OfNExamples();

    /**
     * <pre>
     * Number of file shards to read in parallel.
     * When sample_from_datasets_weights are configured, num_readers is applied
     * for each dataset.
     * </pre>
     *
     * <code>optional uint32 num_readers = 6 [default = 64];</code>
     * @return Whether the numReaders field is set.
     */
    boolean hasNumReaders();
    /**
     * <pre>
     * Number of file shards to read in parallel.
     * When sample_from_datasets_weights are configured, num_readers is applied
     * for each dataset.
     * </pre>
     *
     * <code>optional uint32 num_readers = 6 [default = 64];</code>
     * @return The numReaders.
     */
    int getNumReaders();

    /**
     * <pre>
     * Number of batches to produce in parallel. If this is run on a 2x2 TPU set
     * this to 8.
     * </pre>
     *
     * <code>optional uint32 num_parallel_batches = 19 [default = 8];</code>
     * @return Whether the numParallelBatches field is set.
     */
    boolean hasNumParallelBatches();
    /**
     * <pre>
     * Number of batches to produce in parallel. If this is run on a 2x2 TPU set
     * this to 8.
     * </pre>
     *
     * <code>optional uint32 num_parallel_batches = 19 [default = 8];</code>
     * @return The numParallelBatches.
     */
    int getNumParallelBatches();

    /**
     * <pre>
     * Number of batches to prefetch. Prefetch decouples input pipeline and
     * model so they can be pipelined resulting in higher throughput. Set this
     * to a small constant and increment linearly until the improvements become
     * marginal or you exceed your cpu memory budget. Setting this to -1,
     * automatically tunes this value for you.
     * </pre>
     *
     * <code>optional int32 num_prefetch_batches = 20 [default = 2];</code>
     * @return Whether the numPrefetchBatches field is set.
     */
    boolean hasNumPrefetchBatches();
    /**
     * <pre>
     * Number of batches to prefetch. Prefetch decouples input pipeline and
     * model so they can be pipelined resulting in higher throughput. Set this
     * to a small constant and increment linearly until the improvements become
     * marginal or you exceed your cpu memory budget. Setting this to -1,
     * automatically tunes this value for you.
     * </pre>
     *
     * <code>optional int32 num_prefetch_batches = 20 [default = 2];</code>
     * @return The numPrefetchBatches.
     */
    int getNumPrefetchBatches();

    /**
     * <pre>
     * Maximum number of records to keep in reader queue.
     * </pre>
     *
     * <code>optional uint32 queue_capacity = 3 [default = 2000, deprecated = true];</code>
     * @return Whether the queueCapacity field is set.
     */
    @java.lang.Deprecated boolean hasQueueCapacity();
    /**
     * <pre>
     * Maximum number of records to keep in reader queue.
     * </pre>
     *
     * <code>optional uint32 queue_capacity = 3 [default = 2000, deprecated = true];</code>
     * @return The queueCapacity.
     */
    @java.lang.Deprecated int getQueueCapacity();

    /**
     * <pre>
     * Minimum number of records to keep in reader queue. A large value is needed
     * to generate a good random shuffle.
     * </pre>
     *
     * <code>optional uint32 min_after_dequeue = 4 [default = 1000, deprecated = true];</code>
     * @return Whether the minAfterDequeue field is set.
     */
    @java.lang.Deprecated boolean hasMinAfterDequeue();
    /**
     * <pre>
     * Minimum number of records to keep in reader queue. A large value is needed
     * to generate a good random shuffle.
     * </pre>
     *
     * <code>optional uint32 min_after_dequeue = 4 [default = 1000, deprecated = true];</code>
     * @return The minAfterDequeue.
     */
    @java.lang.Deprecated int getMinAfterDequeue();

    /**
     * <pre>
     * Number of records to read from each reader at once.
     * </pre>
     *
     * <code>optional uint32 read_block_length = 15 [default = 32];</code>
     * @return Whether the readBlockLength field is set.
     */
    boolean hasReadBlockLength();
    /**
     * <pre>
     * Number of records to read from each reader at once.
     * </pre>
     *
     * <code>optional uint32 read_block_length = 15 [default = 32];</code>
     * @return The readBlockLength.
     */
    int getReadBlockLength();

    /**
     * <pre>
     * Number of decoded records to prefetch before batching.
     * </pre>
     *
     * <code>optional uint32 prefetch_size = 13 [default = 512, deprecated = true];</code>
     * @return Whether the prefetchSize field is set.
     */
    @java.lang.Deprecated boolean hasPrefetchSize();
    /**
     * <pre>
     * Number of decoded records to prefetch before batching.
     * </pre>
     *
     * <code>optional uint32 prefetch_size = 13 [default = 512, deprecated = true];</code>
     * @return The prefetchSize.
     */
    @java.lang.Deprecated int getPrefetchSize();

    /**
     * <pre>
     * Number of parallel decode ops to apply.
     * </pre>
     *
     * <code>optional uint32 num_parallel_map_calls = 14 [default = 64, deprecated = true];</code>
     * @return Whether the numParallelMapCalls field is set.
     */
    @java.lang.Deprecated boolean hasNumParallelMapCalls();
    /**
     * <pre>
     * Number of parallel decode ops to apply.
     * </pre>
     *
     * <code>optional uint32 num_parallel_map_calls = 14 [default = 64, deprecated = true];</code>
     * @return The numParallelMapCalls.
     */
    @java.lang.Deprecated int getNumParallelMapCalls();

    /**
     * <pre>
     * Drop remainder when batch size does not divide dataset size.
     * </pre>
     *
     * <code>optional bool drop_remainder = 35 [default = true];</code>
     * @return Whether the dropRemainder field is set.
     */
    boolean hasDropRemainder();
    /**
     * <pre>
     * Drop remainder when batch size does not divide dataset size.
     * </pre>
     *
     * <code>optional bool drop_remainder = 35 [default = true];</code>
     * @return The dropRemainder.
     */
    boolean getDropRemainder();

    /**
     * <pre>
     * If positive, TfExampleDecoder will try to decode rasters of additional
     * channels from tf.Examples.
     * </pre>
     *
     * <code>optional int32 num_additional_channels = 18 [default = 0];</code>
     * @return Whether the numAdditionalChannels field is set.
     */
    boolean hasNumAdditionalChannels();
    /**
     * <pre>
     * If positive, TfExampleDecoder will try to decode rasters of additional
     * channels from tf.Examples.
     * </pre>
     *
     * <code>optional int32 num_additional_channels = 18 [default = 0];</code>
     * @return The numAdditionalChannels.
     */
    int getNumAdditionalChannels();

    /**
     * <pre>
     * Number of groundtruth keypoints per object.
     * </pre>
     *
     * <code>optional uint32 num_keypoints = 16 [default = 0];</code>
     * @return Whether the numKeypoints field is set.
     */
    boolean hasNumKeypoints();
    /**
     * <pre>
     * Number of groundtruth keypoints per object.
     * </pre>
     *
     * <code>optional uint32 num_keypoints = 16 [default = 0];</code>
     * @return The numKeypoints.
     */
    int getNumKeypoints();

    /**
     * <pre>
     * Keypoint weights. These weights can be used to apply per-keypoint loss
     * multipliers. The size of this field should agree with `num_keypoints`.
     * </pre>
     *
     * <code>repeated float keypoint_type_weight = 26;</code>
     * @return A list containing the keypointTypeWeight.
     */
    java.util.List<java.lang.Float> getKeypointTypeWeightList();
    /**
     * <pre>
     * Keypoint weights. These weights can be used to apply per-keypoint loss
     * multipliers. The size of this field should agree with `num_keypoints`.
     * </pre>
     *
     * <code>repeated float keypoint_type_weight = 26;</code>
     * @return The count of keypointTypeWeight.
     */
    int getKeypointTypeWeightCount();
    /**
     * <pre>
     * Keypoint weights. These weights can be used to apply per-keypoint loss
     * multipliers. The size of this field should agree with `num_keypoints`.
     * </pre>
     *
     * <code>repeated float keypoint_type_weight = 26;</code>
     * @param index The index of the element to return.
     * @return The keypointTypeWeight at the given index.
     */
    float getKeypointTypeWeight(int index);

    /**
     * <pre>
     * Maximum number of boxes to pad to during training / evaluation.
     * Set this to at least the maximum amount of boxes in the input data,
     * otherwise some groundtruth boxes may be clipped.
     * </pre>
     *
     * <code>optional int32 max_number_of_boxes = 21 [default = 100];</code>
     * @return Whether the maxNumberOfBoxes field is set.
     */
    boolean hasMaxNumberOfBoxes();
    /**
     * <pre>
     * Maximum number of boxes to pad to during training / evaluation.
     * Set this to at least the maximum amount of boxes in the input data,
     * otherwise some groundtruth boxes may be clipped.
     * </pre>
     *
     * <code>optional int32 max_number_of_boxes = 21 [default = 100];</code>
     * @return The maxNumberOfBoxes.
     */
    int getMaxNumberOfBoxes();

    /**
     * <pre>
     * Whether to load multiclass scores from the dataset.
     * </pre>
     *
     * <code>optional bool load_multiclass_scores = 24 [default = false];</code>
     * @return Whether the loadMulticlassScores field is set.
     */
    boolean hasLoadMulticlassScores();
    /**
     * <pre>
     * Whether to load multiclass scores from the dataset.
     * </pre>
     *
     * <code>optional bool load_multiclass_scores = 24 [default = false];</code>
     * @return The loadMulticlassScores.
     */
    boolean getLoadMulticlassScores();

    /**
     * <pre>
     * Whether to load context features from the dataset.
     * </pre>
     *
     * <code>optional bool load_context_features = 25 [default = false];</code>
     * @return Whether the loadContextFeatures field is set.
     */
    boolean hasLoadContextFeatures();
    /**
     * <pre>
     * Whether to load context features from the dataset.
     * </pre>
     *
     * <code>optional bool load_context_features = 25 [default = false];</code>
     * @return The loadContextFeatures.
     */
    boolean getLoadContextFeatures();

    /**
     * <pre>
     * Whether to load context image ids from the dataset.
     * </pre>
     *
     * <code>optional bool load_context_image_ids = 36 [default = false];</code>
     * @return Whether the loadContextImageIds field is set.
     */
    boolean hasLoadContextImageIds();
    /**
     * <pre>
     * Whether to load context image ids from the dataset.
     * </pre>
     *
     * <code>optional bool load_context_image_ids = 36 [default = false];</code>
     * @return The loadContextImageIds.
     */
    boolean getLoadContextImageIds();

    /**
     * <pre>
     * Whether to load groundtruth instance masks.
     * </pre>
     *
     * <code>optional bool load_instance_masks = 7 [default = false];</code>
     * @return Whether the loadInstanceMasks field is set.
     */
    boolean hasLoadInstanceMasks();
    /**
     * <pre>
     * Whether to load groundtruth instance masks.
     * </pre>
     *
     * <code>optional bool load_instance_masks = 7 [default = false];</code>
     * @return The loadInstanceMasks.
     */
    boolean getLoadInstanceMasks();

    /**
     * <pre>
     * Type of instance mask.
     * </pre>
     *
     * <code>optional .object_detection.protos.InstanceMaskType mask_type = 10 [default = NUMERICAL_MASKS];</code>
     * @return Whether the maskType field is set.
     */
    boolean hasMaskType();
    /**
     * <pre>
     * Type of instance mask.
     * </pre>
     *
     * <code>optional .object_detection.protos.InstanceMaskType mask_type = 10 [default = NUMERICAL_MASKS];</code>
     * @return The maskType.
     */
    object_detection.protos.InputReaderOuterClass.InstanceMaskType getMaskType();

    /**
     * <pre>
     * Whether to load DensePose data. If set, must also set load_instance_masks
     * to true.
     * </pre>
     *
     * <code>optional bool load_dense_pose = 31 [default = false];</code>
     * @return Whether the loadDensePose field is set.
     */
    boolean hasLoadDensePose();
    /**
     * <pre>
     * Whether to load DensePose data. If set, must also set load_instance_masks
     * to true.
     * </pre>
     *
     * <code>optional bool load_dense_pose = 31 [default = false];</code>
     * @return The loadDensePose.
     */
    boolean getLoadDensePose();

    /**
     * <pre>
     * Whether to load track information.
     * </pre>
     *
     * <code>optional bool load_track_id = 33 [default = false];</code>
     * @return Whether the loadTrackId field is set.
     */
    boolean hasLoadTrackId();
    /**
     * <pre>
     * Whether to load track information.
     * </pre>
     *
     * <code>optional bool load_track_id = 33 [default = false];</code>
     * @return The loadTrackId.
     */
    boolean getLoadTrackId();

    /**
     * <pre>
     * Whether to use the display name when decoding examples. This is only used
     * when mapping class text strings to integers.
     * </pre>
     *
     * <code>optional bool use_display_name = 17 [default = false];</code>
     * @return Whether the useDisplayName field is set.
     */
    boolean hasUseDisplayName();
    /**
     * <pre>
     * Whether to use the display name when decoding examples. This is only used
     * when mapping class text strings to integers.
     * </pre>
     *
     * <code>optional bool use_display_name = 17 [default = false];</code>
     * @return The useDisplayName.
     */
    boolean getUseDisplayName();

    /**
     * <pre>
     * Whether to include the source_id string in the input features.
     * </pre>
     *
     * <code>optional bool include_source_id = 27 [default = false];</code>
     * @return Whether the includeSourceId field is set.
     */
    boolean hasIncludeSourceId();
    /**
     * <pre>
     * Whether to include the source_id string in the input features.
     * </pre>
     *
     * <code>optional bool include_source_id = 27 [default = false];</code>
     * @return The includeSourceId.
     */
    boolean getIncludeSourceId();

    /**
     * <pre>
     * Whether input data type is tf.Examples or tf.SequenceExamples
     * </pre>
     *
     * <code>optional .object_detection.protos.InputType input_type = 30 [default = TF_EXAMPLE];</code>
     * @return Whether the inputType field is set.
     */
    boolean hasInputType();
    /**
     * <pre>
     * Whether input data type is tf.Examples or tf.SequenceExamples
     * </pre>
     *
     * <code>optional .object_detection.protos.InputType input_type = 30 [default = TF_EXAMPLE];</code>
     * @return The inputType.
     */
    object_detection.protos.InputReaderOuterClass.InputType getInputType();

    /**
     * <pre>
     * Which frame to choose from the input if Sequence Example. -1 indicates
     * random choice.
     * </pre>
     *
     * <code>optional int32 frame_index = 32 [default = -1];</code>
     * @return Whether the frameIndex field is set.
     */
    boolean hasFrameIndex();
    /**
     * <pre>
     * Which frame to choose from the input if Sequence Example. -1 indicates
     * random choice.
     * </pre>
     *
     * <code>optional int32 frame_index = 32 [default = -1];</code>
     * @return The frameIndex.
     */
    int getFrameIndex();

    /**
     * <code>.object_detection.protos.TFRecordInputReader tf_record_input_reader = 8;</code>
     * @return Whether the tfRecordInputReader field is set.
     */
    boolean hasTfRecordInputReader();
    /**
     * <code>.object_detection.protos.TFRecordInputReader tf_record_input_reader = 8;</code>
     * @return The tfRecordInputReader.
     */
    object_detection.protos.InputReaderOuterClass.TFRecordInputReader getTfRecordInputReader();
    /**
     * <code>.object_detection.protos.TFRecordInputReader tf_record_input_reader = 8;</code>
     */
    object_detection.protos.InputReaderOuterClass.TFRecordInputReaderOrBuilder getTfRecordInputReaderOrBuilder();

    /**
     * <code>.object_detection.protos.ExternalInputReader external_input_reader = 9;</code>
     * @return Whether the externalInputReader field is set.
     */
    boolean hasExternalInputReader();
    /**
     * <code>.object_detection.protos.ExternalInputReader external_input_reader = 9;</code>
     * @return The externalInputReader.
     */
    object_detection.protos.InputReaderOuterClass.ExternalInputReader getExternalInputReader();
    /**
     * <code>.object_detection.protos.ExternalInputReader external_input_reader = 9;</code>
     */
    object_detection.protos.InputReaderOuterClass.ExternalInputReaderOrBuilder getExternalInputReaderOrBuilder();

    /**
     * <pre>
     * When multiple input files are configured, we can sample across them based
     * on weights.
     * The number of weights must match the number of input files configured.
     * When set, shuffling, shuffle buffer size, and num_readers settings are
     * applied individually to each dataset.
     * Implementation follows tf.data.experimental.sample_from_datasets sampling
     * strategy. Weights may take any value - only relative weights matter.
     * Zero weights will result in a dataset not being sampled.
     * Examples, assuming two input files configured:
     * Equal weighting:
     * sample_from_datasets_weights: 0.5
     * sample_from_datasets_weights: 0.5
     * 2:1 weighting:
     * sample_from_datasets_weights: 2
     * sample_from_datasets_weights: 1
     * Exclude the second dataset:
     * sample_from_datasets_weights: 1
     * sample_from_datasets_weights: 0
     * </pre>
     *
     * <code>repeated float sample_from_datasets_weights = 34;</code>
     * @return A list containing the sampleFromDatasetsWeights.
     */
    java.util.List<java.lang.Float> getSampleFromDatasetsWeightsList();
    /**
     * <pre>
     * When multiple input files are configured, we can sample across them based
     * on weights.
     * The number of weights must match the number of input files configured.
     * When set, shuffling, shuffle buffer size, and num_readers settings are
     * applied individually to each dataset.
     * Implementation follows tf.data.experimental.sample_from_datasets sampling
     * strategy. Weights may take any value - only relative weights matter.
     * Zero weights will result in a dataset not being sampled.
     * Examples, assuming two input files configured:
     * Equal weighting:
     * sample_from_datasets_weights: 0.5
     * sample_from_datasets_weights: 0.5
     * 2:1 weighting:
     * sample_from_datasets_weights: 2
     * sample_from_datasets_weights: 1
     * Exclude the second dataset:
     * sample_from_datasets_weights: 1
     * sample_from_datasets_weights: 0
     * </pre>
     *
     * <code>repeated float sample_from_datasets_weights = 34;</code>
     * @return The count of sampleFromDatasetsWeights.
     */
    int getSampleFromDatasetsWeightsCount();
    /**
     * <pre>
     * When multiple input files are configured, we can sample across them based
     * on weights.
     * The number of weights must match the number of input files configured.
     * When set, shuffling, shuffle buffer size, and num_readers settings are
     * applied individually to each dataset.
     * Implementation follows tf.data.experimental.sample_from_datasets sampling
     * strategy. Weights may take any value - only relative weights matter.
     * Zero weights will result in a dataset not being sampled.
     * Examples, assuming two input files configured:
     * Equal weighting:
     * sample_from_datasets_weights: 0.5
     * sample_from_datasets_weights: 0.5
     * 2:1 weighting:
     * sample_from_datasets_weights: 2
     * sample_from_datasets_weights: 1
     * Exclude the second dataset:
     * sample_from_datasets_weights: 1
     * sample_from_datasets_weights: 0
     * </pre>
     *
     * <code>repeated float sample_from_datasets_weights = 34;</code>
     * @param index The index of the element to return.
     * @return The sampleFromDatasetsWeights at the given index.
     */
    float getSampleFromDatasetsWeights(int index);

    /**
     * <pre>
     * Expand labels to ancestors or descendants in the hierarchy for
     * for positive and negative labels, respectively.
     * </pre>
     *
     * <code>optional bool expand_labels_hierarchy = 29 [default = false];</code>
     * @return Whether the expandLabelsHierarchy field is set.
     */
    boolean hasExpandLabelsHierarchy();
    /**
     * <pre>
     * Expand labels to ancestors or descendants in the hierarchy for
     * for positive and negative labels, respectively.
     * </pre>
     *
     * <code>optional bool expand_labels_hierarchy = 29 [default = false];</code>
     * @return The expandLabelsHierarchy.
     */
    boolean getExpandLabelsHierarchy();

    public object_detection.protos.InputReaderOuterClass.InputReader.InputReaderCase getInputReaderCase();
  }
  /**
   * <pre>
   * Next id: 37
   * </pre>
   *
   * Protobuf type {@code object_detection.protos.InputReader}
   */
  public static final class InputReader extends
      com.google.protobuf.GeneratedMessageV3 implements
      // @@protoc_insertion_point(message_implements:object_detection.protos.InputReader)
      InputReaderOrBuilder {
  private static final long serialVersionUID = 0L;
    // Use InputReader.newBuilder() to construct.
    private InputReader(com.google.protobuf.GeneratedMessageV3.Builder<?> builder) {
      super(builder);
    }
    private InputReader() {
      name_ = "";
      labelMapPath_ = "";
      shuffle_ = true;
      shuffleBufferSize_ = 2048;
      filenamesShuffleBufferSize_ = 100;
      sample1OfNExamples_ = 1;
      numReaders_ = 64;
      numParallelBatches_ = 8;
      numPrefetchBatches_ = 2;
      queueCapacity_ = 2000;
      minAfterDequeue_ = 1000;
      readBlockLength_ = 32;
      prefetchSize_ = 512;
      numParallelMapCalls_ = 64;
      dropRemainder_ = true;
      keypointTypeWeight_ = emptyFloatList();
      maxNumberOfBoxes_ = 100;
      maskType_ = 1;
      inputType_ = 1;
      frameIndex_ = -1;
      sampleFromDatasetsWeights_ = emptyFloatList();
    }

    @java.lang.Override
    @SuppressWarnings({"unused"})
    protected java.lang.Object newInstance(
        UnusedPrivateParameter unused) {
      return new InputReader();
    }

    @java.lang.Override
    public final com.google.protobuf.UnknownFieldSet
    getUnknownFields() {
      return this.unknownFields;
    }
    private InputReader(
        com.google.protobuf.CodedInputStream input,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws com.google.protobuf.InvalidProtocolBufferException {
      this();
      if (extensionRegistry == null) {
        throw new java.lang.NullPointerException();
      }
      int mutable_bitField0_ = 0;
      int mutable_bitField1_ = 0;
      com.google.protobuf.UnknownFieldSet.Builder unknownFields =
          com.google.protobuf.UnknownFieldSet.newBuilder();
      try {
        boolean done = false;
        while (!done) {
          int tag = input.readTag();
          switch (tag) {
            case 0:
              done = true;
              break;
            case 10: {
              com.google.protobuf.ByteString bs = input.readBytes();
              bitField0_ |= 0x00000002;
              labelMapPath_ = bs;
              break;
            }
            case 16: {
              bitField0_ |= 0x00000004;
              shuffle_ = input.readBool();
              break;
            }
            case 24: {
              bitField0_ |= 0x00000400;
              queueCapacity_ = input.readUInt32();
              break;
            }
            case 32: {
              bitField0_ |= 0x00000800;
              minAfterDequeue_ = input.readUInt32();
              break;
            }
            case 40: {
              bitField0_ |= 0x00000020;
              numEpochs_ = input.readUInt32();
              break;
            }
            case 48: {
              bitField0_ |= 0x00000080;
              numReaders_ = input.readUInt32();
              break;
            }
            case 56: {
              bitField0_ |= 0x00400000;
              loadInstanceMasks_ = input.readBool();
              break;
            }
            case 66: {
              object_detection.protos.InputReaderOuterClass.TFRecordInputReader.Builder subBuilder = null;
              if (inputReaderCase_ == 8) {
                subBuilder = ((object_detection.protos.InputReaderOuterClass.TFRecordInputReader) inputReader_).toBuilder();
              }
              inputReader_ =
                  input.readMessage(object_detection.protos.InputReaderOuterClass.TFRecordInputReader.PARSER, extensionRegistry);
              if (subBuilder != null) {
                subBuilder.mergeFrom((object_detection.protos.InputReaderOuterClass.TFRecordInputReader) inputReader_);
                inputReader_ = subBuilder.buildPartial();
              }
              inputReaderCase_ = 8;
              break;
            }
            case 74: {
              object_detection.protos.InputReaderOuterClass.ExternalInputReader.Builder subBuilder = null;
              if (inputReaderCase_ == 9) {
                subBuilder = ((object_detection.protos.InputReaderOuterClass.ExternalInputReader) inputReader_).toBuilder();
              }
              inputReader_ =
                  input.readMessage(object_detection.protos.InputReaderOuterClass.ExternalInputReader.PARSER, extensionRegistry);
              if (subBuilder != null) {
                subBuilder.mergeFrom((object_detection.protos.InputReaderOuterClass.ExternalInputReader) inputReader_);
                inputReader_ = subBuilder.buildPartial();
              }
              inputReaderCase_ = 9;
              break;
            }
            case 80: {
              int rawValue = input.readEnum();
                @SuppressWarnings("deprecation")
              object_detection.protos.InputReaderOuterClass.InstanceMaskType value = object_detection.protos.InputReaderOuterClass.InstanceMaskType.valueOf(rawValue);
              if (value == null) {
                unknownFields.mergeVarintField(10, rawValue);
              } else {
                bitField0_ |= 0x00800000;
                maskType_ = rawValue;
              }
              break;
            }
            case 88: {
              bitField0_ |= 0x00000008;
              shuffleBufferSize_ = input.readUInt32();
              break;
            }
            case 96: {
              bitField0_ |= 0x00000010;
              filenamesShuffleBufferSize_ = input.readUInt32();
              break;
            }
            case 104: {
              bitField0_ |= 0x00002000;
              prefetchSize_ = input.readUInt32();
              break;
            }
            case 112: {
              bitField0_ |= 0x00004000;
              numParallelMapCalls_ = input.readUInt32();
              break;
            }
            case 120: {
              bitField0_ |= 0x00001000;
              readBlockLength_ = input.readUInt32();
              break;
            }
            case 128: {
              bitField0_ |= 0x00020000;
              numKeypoints_ = input.readUInt32();
              break;
            }
            case 136: {
              bitField0_ |= 0x04000000;
              useDisplayName_ = input.readBool();
              break;
            }
            case 144: {
              bitField0_ |= 0x00010000;
              numAdditionalChannels_ = input.readInt32();
              break;
            }
            case 152: {
              bitField0_ |= 0x00000100;
              numParallelBatches_ = input.readUInt32();
              break;
            }
            case 160: {
              bitField0_ |= 0x00000200;
              numPrefetchBatches_ = input.readInt32();
              break;
            }
            case 168: {
              bitField0_ |= 0x00040000;
              maxNumberOfBoxes_ = input.readInt32();
              break;
            }
            case 176: {
              bitField0_ |= 0x00000040;
              sample1OfNExamples_ = input.readUInt32();
              break;
            }
            case 186: {
              com.google.protobuf.ByteString bs = input.readBytes();
              bitField0_ |= 0x00000001;
              name_ = bs;
              break;
            }
            case 192: {
              bitField0_ |= 0x00080000;
              loadMulticlassScores_ = input.readBool();
              break;
            }
            case 200: {
              bitField0_ |= 0x00100000;
              loadContextFeatures_ = input.readBool();
              break;
            }
            case 213: {
              if (!((mutable_bitField0_ & 0x00040000) != 0)) {
                keypointTypeWeight_ = newFloatList();
                mutable_bitField0_ |= 0x00040000;
              }
              keypointTypeWeight_.addFloat(input.readFloat());
              break;
            }
            case 210: {
              int length = input.readRawVarint32();
              int limit = input.pushLimit(length);
              if (!((mutable_bitField0_ & 0x00040000) != 0) && input.getBytesUntilLimit() > 0) {
                keypointTypeWeight_ = newFloatList();
                mutable_bitField0_ |= 0x00040000;
              }
              while (input.getBytesUntilLimit() > 0) {
                keypointTypeWeight_.addFloat(input.readFloat());
              }
              input.popLimit(limit);
              break;
            }
            case 216: {
              bitField0_ |= 0x08000000;
              includeSourceId_ = input.readBool();
              break;
            }
            case 232: {
              bitField1_ |= 0x00000001;
              expandLabelsHierarchy_ = input.readBool();
              break;
            }
            case 240: {
              int rawValue = input.readEnum();
                @SuppressWarnings("deprecation")
              object_detection.protos.InputReaderOuterClass.InputType value = object_detection.protos.InputReaderOuterClass.InputType.valueOf(rawValue);
              if (value == null) {
                unknownFields.mergeVarintField(30, rawValue);
              } else {
                bitField0_ |= 0x10000000;
                inputType_ = rawValue;
              }
              break;
            }
            case 248: {
              bitField0_ |= 0x01000000;
              loadDensePose_ = input.readBool();
              break;
            }
            case 256: {
              bitField0_ |= 0x20000000;
              frameIndex_ = input.readInt32();
              break;
            }
            case 264: {
              bitField0_ |= 0x02000000;
              loadTrackId_ = input.readBool();
              break;
            }
            case 277: {
              if (!((mutable_bitField1_ & 0x00000002) != 0)) {
                sampleFromDatasetsWeights_ = newFloatList();
                mutable_bitField1_ |= 0x00000002;
              }
              sampleFromDatasetsWeights_.addFloat(input.readFloat());
              break;
            }
            case 274: {
              int length = input.readRawVarint32();
              int limit = input.pushLimit(length);
              if (!((mutable_bitField1_ & 0x00000002) != 0) && input.getBytesUntilLimit() > 0) {
                sampleFromDatasetsWeights_ = newFloatList();
                mutable_bitField1_ |= 0x00000002;
              }
              while (input.getBytesUntilLimit() > 0) {
                sampleFromDatasetsWeights_.addFloat(input.readFloat());
              }
              input.popLimit(limit);
              break;
            }
            case 280: {
              bitField0_ |= 0x00008000;
              dropRemainder_ = input.readBool();
              break;
            }
            case 288: {
              bitField0_ |= 0x00200000;
              loadContextImageIds_ = input.readBool();
              break;
            }
            default: {
              if (!parseUnknownField(
                  input, unknownFields, extensionRegistry, tag)) {
                done = true;
              }
              break;
            }
          }
        }
      } catch (com.google.protobuf.InvalidProtocolBufferException e) {
        throw e.setUnfinishedMessage(this);
      } catch (java.io.IOException e) {
        throw new com.google.protobuf.InvalidProtocolBufferException(
            e).setUnfinishedMessage(this);
      } finally {
        if (((mutable_bitField0_ & 0x00040000) != 0)) {
          keypointTypeWeight_.makeImmutable(); // C
        }
        if (((mutable_bitField1_ & 0x00000002) != 0)) {
          sampleFromDatasetsWeights_.makeImmutable(); // C
        }
        this.unknownFields = unknownFields.build();
        makeExtensionsImmutable();
      }
    }
    public static final com.google.protobuf.Descriptors.Descriptor
        getDescriptor() {
      return object_detection.protos.InputReaderOuterClass.internal_static_object_detection_protos_InputReader_descriptor;
    }

    @java.lang.Override
    protected com.google.protobuf.GeneratedMessageV3.FieldAccessorTable
        internalGetFieldAccessorTable() {
      return object_detection.protos.InputReaderOuterClass.internal_static_object_detection_protos_InputReader_fieldAccessorTable
          .ensureFieldAccessorsInitialized(
              object_detection.protos.InputReaderOuterClass.InputReader.class, object_detection.protos.InputReaderOuterClass.InputReader.Builder.class);
    }

    private int bitField0_;
    private int bitField1_;
    private int inputReaderCase_ = 0;
    private java.lang.Object inputReader_;
    public enum InputReaderCase
        implements com.google.protobuf.Internal.EnumLite,
            com.google.protobuf.AbstractMessage.InternalOneOfEnum {
      TF_RECORD_INPUT_READER(8),
      EXTERNAL_INPUT_READER(9),
      INPUTREADER_NOT_SET(0);
      private final int value;
      private InputReaderCase(int value) {
        this.value = value;
      }
      /**
       * @param value The number of the enum to look for.
       * @return The enum associated with the given number.
       * @deprecated Use {@link #forNumber(int)} instead.
       */
      @java.lang.Deprecated
      public static InputReaderCase valueOf(int value) {
        return forNumber(value);
      }

      public static InputReaderCase forNumber(int value) {
        switch (value) {
          case 8: return TF_RECORD_INPUT_READER;
          case 9: return EXTERNAL_INPUT_READER;
          case 0: return INPUTREADER_NOT_SET;
          default: return null;
        }
      }
      public int getNumber() {
        return this.value;
      }
    };

    public InputReaderCase
    getInputReaderCase() {
      return InputReaderCase.forNumber(
          inputReaderCase_);
    }

    public static final int NAME_FIELD_NUMBER = 23;
    private volatile java.lang.Object name_;
    /**
     * <pre>
     * Name of input reader. Typically used to describe the dataset that is read
     * by this input reader.
     * </pre>
     *
     * <code>optional string name = 23 [default = ""];</code>
     * @return Whether the name field is set.
     */
    @java.lang.Override
    public boolean hasName() {
      return ((bitField0_ & 0x00000001) != 0);
    }
    /**
     * <pre>
     * Name of input reader. Typically used to describe the dataset that is read
     * by this input reader.
     * </pre>
     *
     * <code>optional string name = 23 [default = ""];</code>
     * @return The name.
     */
    @java.lang.Override
    public java.lang.String getName() {
      java.lang.Object ref = name_;
      if (ref instanceof java.lang.String) {
        return (java.lang.String) ref;
      } else {
        com.google.protobuf.ByteString bs =
            (com.google.protobuf.ByteString) ref;
        java.lang.String s = bs.toStringUtf8();
        if (bs.isValidUtf8()) {
          name_ = s;
        }
        return s;
      }
    }
    /**
     * <pre>
     * Name of input reader. Typically used to describe the dataset that is read
     * by this input reader.
     * </pre>
     *
     * <code>optional string name = 23 [default = ""];</code>
     * @return The bytes for name.
     */
    @java.lang.Override
    public com.google.protobuf.ByteString
        getNameBytes() {
      java.lang.Object ref = name_;
      if (ref instanceof java.lang.String) {
        com.google.protobuf.ByteString b =
            com.google.protobuf.ByteString.copyFromUtf8(
                (java.lang.String) ref);
        name_ = b;
        return b;
      } else {
        return (com.google.protobuf.ByteString) ref;
      }
    }

    public static final int LABEL_MAP_PATH_FIELD_NUMBER = 1;
    private volatile java.lang.Object labelMapPath_;
    /**
     * <pre>
     * Path to StringIntLabelMap pbtxt file specifying the mapping from string
     * labels to integer ids.
     * </pre>
     *
     * <code>optional string label_map_path = 1 [default = ""];</code>
     * @return Whether the labelMapPath field is set.
     */
    @java.lang.Override
    public boolean hasLabelMapPath() {
      return ((bitField0_ & 0x00000002) != 0);
    }
    /**
     * <pre>
     * Path to StringIntLabelMap pbtxt file specifying the mapping from string
     * labels to integer ids.
     * </pre>
     *
     * <code>optional string label_map_path = 1 [default = ""];</code>
     * @return The labelMapPath.
     */
    @java.lang.Override
    public java.lang.String getLabelMapPath() {
      java.lang.Object ref = labelMapPath_;
      if (ref instanceof java.lang.String) {
        return (java.lang.String) ref;
      } else {
        com.google.protobuf.ByteString bs =
            (com.google.protobuf.ByteString) ref;
        java.lang.String s = bs.toStringUtf8();
        if (bs.isValidUtf8()) {
          labelMapPath_ = s;
        }
        return s;
      }
    }
    /**
     * <pre>
     * Path to StringIntLabelMap pbtxt file specifying the mapping from string
     * labels to integer ids.
     * </pre>
     *
     * <code>optional string label_map_path = 1 [default = ""];</code>
     * @return The bytes for labelMapPath.
     */
    @java.lang.Override
    public com.google.protobuf.ByteString
        getLabelMapPathBytes() {
      java.lang.Object ref = labelMapPath_;
      if (ref instanceof java.lang.String) {
        com.google.protobuf.ByteString b =
            com.google.protobuf.ByteString.copyFromUtf8(
                (java.lang.String) ref);
        labelMapPath_ = b;
        return b;
      } else {
        return (com.google.protobuf.ByteString) ref;
      }
    }

    public static final int SHUFFLE_FIELD_NUMBER = 2;
    private boolean shuffle_;
    /**
     * <pre>
     * Whether data should be processed in the order they are read in, or
     * shuffled randomly.
     * </pre>
     *
     * <code>optional bool shuffle = 2 [default = true];</code>
     * @return Whether the shuffle field is set.
     */
    @java.lang.Override
    public boolean hasShuffle() {
      return ((bitField0_ & 0x00000004) != 0);
    }
    /**
     * <pre>
     * Whether data should be processed in the order they are read in, or
     * shuffled randomly.
     * </pre>
     *
     * <code>optional bool shuffle = 2 [default = true];</code>
     * @return The shuffle.
     */
    @java.lang.Override
    public boolean getShuffle() {
      return shuffle_;
    }

    public static final int SHUFFLE_BUFFER_SIZE_FIELD_NUMBER = 11;
    private int shuffleBufferSize_;
    /**
     * <pre>
     * Buffer size to be used when shuffling.
     * </pre>
     *
     * <code>optional uint32 shuffle_buffer_size = 11 [default = 2048];</code>
     * @return Whether the shuffleBufferSize field is set.
     */
    @java.lang.Override
    public boolean hasShuffleBufferSize() {
      return ((bitField0_ & 0x00000008) != 0);
    }
    /**
     * <pre>
     * Buffer size to be used when shuffling.
     * </pre>
     *
     * <code>optional uint32 shuffle_buffer_size = 11 [default = 2048];</code>
     * @return The shuffleBufferSize.
     */
    @java.lang.Override
    public int getShuffleBufferSize() {
      return shuffleBufferSize_;
    }

    public static final int FILENAMES_SHUFFLE_BUFFER_SIZE_FIELD_NUMBER = 12;
    private int filenamesShuffleBufferSize_;
    /**
     * <pre>
     * Buffer size to be used when shuffling file names.
     * </pre>
     *
     * <code>optional uint32 filenames_shuffle_buffer_size = 12 [default = 100];</code>
     * @return Whether the filenamesShuffleBufferSize field is set.
     */
    @java.lang.Override
    public boolean hasFilenamesShuffleBufferSize() {
      return ((bitField0_ & 0x00000010) != 0);
    }
    /**
     * <pre>
     * Buffer size to be used when shuffling file names.
     * </pre>
     *
     * <code>optional uint32 filenames_shuffle_buffer_size = 12 [default = 100];</code>
     * @return The filenamesShuffleBufferSize.
     */
    @java.lang.Override
    public int getFilenamesShuffleBufferSize() {
      return filenamesShuffleBufferSize_;
    }

    public static final int NUM_EPOCHS_FIELD_NUMBER = 5;
    private int numEpochs_;
    /**
     * <pre>
     * The number of times a data source is read. If set to zero, the data source
     * will be reused indefinitely.
     * </pre>
     *
     * <code>optional uint32 num_epochs = 5 [default = 0];</code>
     * @return Whether the numEpochs field is set.
     */
    @java.lang.Override
    public boolean hasNumEpochs() {
      return ((bitField0_ & 0x00000020) != 0);
    }
    /**
     * <pre>
     * The number of times a data source is read. If set to zero, the data source
     * will be reused indefinitely.
     * </pre>
     *
     * <code>optional uint32 num_epochs = 5 [default = 0];</code>
     * @return The numEpochs.
     */
    @java.lang.Override
    public int getNumEpochs() {
      return numEpochs_;
    }

    public static final int SAMPLE_1_OF_N_EXAMPLES_FIELD_NUMBER = 22;
    private int sample1OfNExamples_;
    /**
     * <pre>
     * Integer representing how often an example should be sampled. To feed
     * only 1/3 of your data into your model, set `sample_1_of_n_examples` to 3.
     * This is particularly useful for evaluation, where you might not prefer to
     * evaluate all of your samples.
     * </pre>
     *
     * <code>optional uint32 sample_1_of_n_examples = 22 [default = 1];</code>
     * @return Whether the sample1OfNExamples field is set.
     */
    @java.lang.Override
    public boolean hasSample1OfNExamples() {
      return ((bitField0_ & 0x00000040) != 0);
    }
    /**
     * <pre>
     * Integer representing how often an example should be sampled. To feed
     * only 1/3 of your data into your model, set `sample_1_of_n_examples` to 3.
     * This is particularly useful for evaluation, where you might not prefer to
     * evaluate all of your samples.
     * </pre>
     *
     * <code>optional uint32 sample_1_of_n_examples = 22 [default = 1];</code>
     * @return The sample1OfNExamples.
     */
    @java.lang.Override
    public int getSample1OfNExamples() {
      return sample1OfNExamples_;
    }

    public static final int NUM_READERS_FIELD_NUMBER = 6;
    private int numReaders_;
    /**
     * <pre>
     * Number of file shards to read in parallel.
     * When sample_from_datasets_weights are configured, num_readers is applied
     * for each dataset.
     * </pre>
     *
     * <code>optional uint32 num_readers = 6 [default = 64];</code>
     * @return Whether the numReaders field is set.
     */
    @java.lang.Override
    public boolean hasNumReaders() {
      return ((bitField0_ & 0x00000080) != 0);
    }
    /**
     * <pre>
     * Number of file shards to read in parallel.
     * When sample_from_datasets_weights are configured, num_readers is applied
     * for each dataset.
     * </pre>
     *
     * <code>optional uint32 num_readers = 6 [default = 64];</code>
     * @return The numReaders.
     */
    @java.lang.Override
    public int getNumReaders() {
      return numReaders_;
    }

    public static final int NUM_PARALLEL_BATCHES_FIELD_NUMBER = 19;
    private int numParallelBatches_;
    /**
     * <pre>
     * Number of batches to produce in parallel. If this is run on a 2x2 TPU set
     * this to 8.
     * </pre>
     *
     * <code>optional uint32 num_parallel_batches = 19 [default = 8];</code>
     * @return Whether the numParallelBatches field is set.
     */
    @java.lang.Override
    public boolean hasNumParallelBatches() {
      return ((bitField0_ & 0x00000100) != 0);
    }
    /**
     * <pre>
     * Number of batches to produce in parallel. If this is run on a 2x2 TPU set
     * this to 8.
     * </pre>
     *
     * <code>optional uint32 num_parallel_batches = 19 [default = 8];</code>
     * @return The numParallelBatches.
     */
    @java.lang.Override
    public int getNumParallelBatches() {
      return numParallelBatches_;
    }

    public static final int NUM_PREFETCH_BATCHES_FIELD_NUMBER = 20;
    private int numPrefetchBatches_;
    /**
     * <pre>
     * Number of batches to prefetch. Prefetch decouples input pipeline and
     * model so they can be pipelined resulting in higher throughput. Set this
     * to a small constant and increment linearly until the improvements become
     * marginal or you exceed your cpu memory budget. Setting this to -1,
     * automatically tunes this value for you.
     * </pre>
     *
     * <code>optional int32 num_prefetch_batches = 20 [default = 2];</code>
     * @return Whether the numPrefetchBatches field is set.
     */
    @java.lang.Override
    public boolean hasNumPrefetchBatches() {
      return ((bitField0_ & 0x00000200) != 0);
    }
    /**
     * <pre>
     * Number of batches to prefetch. Prefetch decouples input pipeline and
     * model so they can be pipelined resulting in higher throughput. Set this
     * to a small constant and increment linearly until the improvements become
     * marginal or you exceed your cpu memory budget. Setting this to -1,
     * automatically tunes this value for you.
     * </pre>
     *
     * <code>optional int32 num_prefetch_batches = 20 [default = 2];</code>
     * @return The numPrefetchBatches.
     */
    @java.lang.Override
    public int getNumPrefetchBatches() {
      return numPrefetchBatches_;
    }

    public static final int QUEUE_CAPACITY_FIELD_NUMBER = 3;
    private int queueCapacity_;
    /**
     * <pre>
     * Maximum number of records to keep in reader queue.
     * </pre>
     *
     * <code>optional uint32 queue_capacity = 3 [default = 2000, deprecated = true];</code>
     * @return Whether the queueCapacity field is set.
     */
    @java.lang.Override
    @java.lang.Deprecated public boolean hasQueueCapacity() {
      return ((bitField0_ & 0x00000400) != 0);
    }
    /**
     * <pre>
     * Maximum number of records to keep in reader queue.
     * </pre>
     *
     * <code>optional uint32 queue_capacity = 3 [default = 2000, deprecated = true];</code>
     * @return The queueCapacity.
     */
    @java.lang.Override
    @java.lang.Deprecated public int getQueueCapacity() {
      return queueCapacity_;
    }

    public static final int MIN_AFTER_DEQUEUE_FIELD_NUMBER = 4;
    private int minAfterDequeue_;
    /**
     * <pre>
     * Minimum number of records to keep in reader queue. A large value is needed
     * to generate a good random shuffle.
     * </pre>
     *
     * <code>optional uint32 min_after_dequeue = 4 [default = 1000, deprecated = true];</code>
     * @return Whether the minAfterDequeue field is set.
     */
    @java.lang.Override
    @java.lang.Deprecated public boolean hasMinAfterDequeue() {
      return ((bitField0_ & 0x00000800) != 0);
    }
    /**
     * <pre>
     * Minimum number of records to keep in reader queue. A large value is needed
     * to generate a good random shuffle.
     * </pre>
     *
     * <code>optional uint32 min_after_dequeue = 4 [default = 1000, deprecated = true];</code>
     * @return The minAfterDequeue.
     */
    @java.lang.Override
    @java.lang.Deprecated public int getMinAfterDequeue() {
      return minAfterDequeue_;
    }

    public static final int READ_BLOCK_LENGTH_FIELD_NUMBER = 15;
    private int readBlockLength_;
    /**
     * <pre>
     * Number of records to read from each reader at once.
     * </pre>
     *
     * <code>optional uint32 read_block_length = 15 [default = 32];</code>
     * @return Whether the readBlockLength field is set.
     */
    @java.lang.Override
    public boolean hasReadBlockLength() {
      return ((bitField0_ & 0x00001000) != 0);
    }
    /**
     * <pre>
     * Number of records to read from each reader at once.
     * </pre>
     *
     * <code>optional uint32 read_block_length = 15 [default = 32];</code>
     * @return The readBlockLength.
     */
    @java.lang.Override
    public int getReadBlockLength() {
      return readBlockLength_;
    }

    public static final int PREFETCH_SIZE_FIELD_NUMBER = 13;
    private int prefetchSize_;
    /**
     * <pre>
     * Number of decoded records to prefetch before batching.
     * </pre>
     *
     * <code>optional uint32 prefetch_size = 13 [default = 512, deprecated = true];</code>
     * @return Whether the prefetchSize field is set.
     */
    @java.lang.Override
    @java.lang.Deprecated public boolean hasPrefetchSize() {
      return ((bitField0_ & 0x00002000) != 0);
    }
    /**
     * <pre>
     * Number of decoded records to prefetch before batching.
     * </pre>
     *
     * <code>optional uint32 prefetch_size = 13 [default = 512, deprecated = true];</code>
     * @return The prefetchSize.
     */
    @java.lang.Override
    @java.lang.Deprecated public int getPrefetchSize() {
      return prefetchSize_;
    }

    public static final int NUM_PARALLEL_MAP_CALLS_FIELD_NUMBER = 14;
    private int numParallelMapCalls_;
    /**
     * <pre>
     * Number of parallel decode ops to apply.
     * </pre>
     *
     * <code>optional uint32 num_parallel_map_calls = 14 [default = 64, deprecated = true];</code>
     * @return Whether the numParallelMapCalls field is set.
     */
    @java.lang.Override
    @java.lang.Deprecated public boolean hasNumParallelMapCalls() {
      return ((bitField0_ & 0x00004000) != 0);
    }
    /**
     * <pre>
     * Number of parallel decode ops to apply.
     * </pre>
     *
     * <code>optional uint32 num_parallel_map_calls = 14 [default = 64, deprecated = true];</code>
     * @return The numParallelMapCalls.
     */
    @java.lang.Override
    @java.lang.Deprecated public int getNumParallelMapCalls() {
      return numParallelMapCalls_;
    }

    public static final int DROP_REMAINDER_FIELD_NUMBER = 35;
    private boolean dropRemainder_;
    /**
     * <pre>
     * Drop remainder when batch size does not divide dataset size.
     * </pre>
     *
     * <code>optional bool drop_remainder = 35 [default = true];</code>
     * @return Whether the dropRemainder field is set.
     */
    @java.lang.Override
    public boolean hasDropRemainder() {
      return ((bitField0_ & 0x00008000) != 0);
    }
    /**
     * <pre>
     * Drop remainder when batch size does not divide dataset size.
     * </pre>
     *
     * <code>optional bool drop_remainder = 35 [default = true];</code>
     * @return The dropRemainder.
     */
    @java.lang.Override
    public boolean getDropRemainder() {
      return dropRemainder_;
    }

    public static final int NUM_ADDITIONAL_CHANNELS_FIELD_NUMBER = 18;
    private int numAdditionalChannels_;
    /**
     * <pre>
     * If positive, TfExampleDecoder will try to decode rasters of additional
     * channels from tf.Examples.
     * </pre>
     *
     * <code>optional int32 num_additional_channels = 18 [default = 0];</code>
     * @return Whether the numAdditionalChannels field is set.
     */
    @java.lang.Override
    public boolean hasNumAdditionalChannels() {
      return ((bitField0_ & 0x00010000) != 0);
    }
    /**
     * <pre>
     * If positive, TfExampleDecoder will try to decode rasters of additional
     * channels from tf.Examples.
     * </pre>
     *
     * <code>optional int32 num_additional_channels = 18 [default = 0];</code>
     * @return The numAdditionalChannels.
     */
    @java.lang.Override
    public int getNumAdditionalChannels() {
      return numAdditionalChannels_;
    }

    public static final int NUM_KEYPOINTS_FIELD_NUMBER = 16;
    private int numKeypoints_;
    /**
     * <pre>
     * Number of groundtruth keypoints per object.
     * </pre>
     *
     * <code>optional uint32 num_keypoints = 16 [default = 0];</code>
     * @return Whether the numKeypoints field is set.
     */
    @java.lang.Override
    public boolean hasNumKeypoints() {
      return ((bitField0_ & 0x00020000) != 0);
    }
    /**
     * <pre>
     * Number of groundtruth keypoints per object.
     * </pre>
     *
     * <code>optional uint32 num_keypoints = 16 [default = 0];</code>
     * @return The numKeypoints.
     */
    @java.lang.Override
    public int getNumKeypoints() {
      return numKeypoints_;
    }

    public static final int KEYPOINT_TYPE_WEIGHT_FIELD_NUMBER = 26;
    private com.google.protobuf.Internal.FloatList keypointTypeWeight_;
    /**
     * <pre>
     * Keypoint weights. These weights can be used to apply per-keypoint loss
     * multipliers. The size of this field should agree with `num_keypoints`.
     * </pre>
     *
     * <code>repeated float keypoint_type_weight = 26;</code>
     * @return A list containing the keypointTypeWeight.
     */
    @java.lang.Override
    public java.util.List<java.lang.Float>
        getKeypointTypeWeightList() {
      return keypointTypeWeight_;
    }
    /**
     * <pre>
     * Keypoint weights. These weights can be used to apply per-keypoint loss
     * multipliers. The size of this field should agree with `num_keypoints`.
     * </pre>
     *
     * <code>repeated float keypoint_type_weight = 26;</code>
     * @return The count of keypointTypeWeight.
     */
    public int getKeypointTypeWeightCount() {
      return keypointTypeWeight_.size();
    }
    /**
     * <pre>
     * Keypoint weights. These weights can be used to apply per-keypoint loss
     * multipliers. The size of this field should agree with `num_keypoints`.
     * </pre>
     *
     * <code>repeated float keypoint_type_weight = 26;</code>
     * @param index The index of the element to return.
     * @return The keypointTypeWeight at the given index.
     */
    public float getKeypointTypeWeight(int index) {
      return keypointTypeWeight_.getFloat(index);
    }

    public static final int MAX_NUMBER_OF_BOXES_FIELD_NUMBER = 21;
    private int maxNumberOfBoxes_;
    /**
     * <pre>
     * Maximum number of boxes to pad to during training / evaluation.
     * Set this to at least the maximum amount of boxes in the input data,
     * otherwise some groundtruth boxes may be clipped.
     * </pre>
     *
     * <code>optional int32 max_number_of_boxes = 21 [default = 100];</code>
     * @return Whether the maxNumberOfBoxes field is set.
     */
    @java.lang.Override
    public boolean hasMaxNumberOfBoxes() {
      return ((bitField0_ & 0x00040000) != 0);
    }
    /**
     * <pre>
     * Maximum number of boxes to pad to during training / evaluation.
     * Set this to at least the maximum amount of boxes in the input data,
     * otherwise some groundtruth boxes may be clipped.
     * </pre>
     *
     * <code>optional int32 max_number_of_boxes = 21 [default = 100];</code>
     * @return The maxNumberOfBoxes.
     */
    @java.lang.Override
    public int getMaxNumberOfBoxes() {
      return maxNumberOfBoxes_;
    }

    public static final int LOAD_MULTICLASS_SCORES_FIELD_NUMBER = 24;
    private boolean loadMulticlassScores_;
    /**
     * <pre>
     * Whether to load multiclass scores from the dataset.
     * </pre>
     *
     * <code>optional bool load_multiclass_scores = 24 [default = false];</code>
     * @return Whether the loadMulticlassScores field is set.
     */
    @java.lang.Override
    public boolean hasLoadMulticlassScores() {
      return ((bitField0_ & 0x00080000) != 0);
    }
    /**
     * <pre>
     * Whether to load multiclass scores from the dataset.
     * </pre>
     *
     * <code>optional bool load_multiclass_scores = 24 [default = false];</code>
     * @return The loadMulticlassScores.
     */
    @java.lang.Override
    public boolean getLoadMulticlassScores() {
      return loadMulticlassScores_;
    }

    public static final int LOAD_CONTEXT_FEATURES_FIELD_NUMBER = 25;
    private boolean loadContextFeatures_;
    /**
     * <pre>
     * Whether to load context features from the dataset.
     * </pre>
     *
     * <code>optional bool load_context_features = 25 [default = false];</code>
     * @return Whether the loadContextFeatures field is set.
     */
    @java.lang.Override
    public boolean hasLoadContextFeatures() {
      return ((bitField0_ & 0x00100000) != 0);
    }
    /**
     * <pre>
     * Whether to load context features from the dataset.
     * </pre>
     *
     * <code>optional bool load_context_features = 25 [default = false];</code>
     * @return The loadContextFeatures.
     */
    @java.lang.Override
    public boolean getLoadContextFeatures() {
      return loadContextFeatures_;
    }

    public static final int LOAD_CONTEXT_IMAGE_IDS_FIELD_NUMBER = 36;
    private boolean loadContextImageIds_;
    /**
     * <pre>
     * Whether to load context image ids from the dataset.
     * </pre>
     *
     * <code>optional bool load_context_image_ids = 36 [default = false];</code>
     * @return Whether the loadContextImageIds field is set.
     */
    @java.lang.Override
    public boolean hasLoadContextImageIds() {
      return ((bitField0_ & 0x00200000) != 0);
    }
    /**
     * <pre>
     * Whether to load context image ids from the dataset.
     * </pre>
     *
     * <code>optional bool load_context_image_ids = 36 [default = false];</code>
     * @return The loadContextImageIds.
     */
    @java.lang.Override
    public boolean getLoadContextImageIds() {
      return loadContextImageIds_;
    }

    public static final int LOAD_INSTANCE_MASKS_FIELD_NUMBER = 7;
    private boolean loadInstanceMasks_;
    /**
     * <pre>
     * Whether to load groundtruth instance masks.
     * </pre>
     *
     * <code>optional bool load_instance_masks = 7 [default = false];</code>
     * @return Whether the loadInstanceMasks field is set.
     */
    @java.lang.Override
    public boolean hasLoadInstanceMasks() {
      return ((bitField0_ & 0x00400000) != 0);
    }
    /**
     * <pre>
     * Whether to load groundtruth instance masks.
     * </pre>
     *
     * <code>optional bool load_instance_masks = 7 [default = false];</code>
     * @return The loadInstanceMasks.
     */
    @java.lang.Override
    public boolean getLoadInstanceMasks() {
      return loadInstanceMasks_;
    }

    public static final int MASK_TYPE_FIELD_NUMBER = 10;
    private int maskType_;
    /**
     * <pre>
     * Type of instance mask.
     * </pre>
     *
     * <code>optional .object_detection.protos.InstanceMaskType mask_type = 10 [default = NUMERICAL_MASKS];</code>
     * @return Whether the maskType field is set.
     */
    @java.lang.Override public boolean hasMaskType() {
      return ((bitField0_ & 0x00800000) != 0);
    }
    /**
     * <pre>
     * Type of instance mask.
     * </pre>
     *
     * <code>optional .object_detection.protos.InstanceMaskType mask_type = 10 [default = NUMERICAL_MASKS];</code>
     * @return The maskType.
     */
    @java.lang.Override public object_detection.protos.InputReaderOuterClass.InstanceMaskType getMaskType() {
      @SuppressWarnings("deprecation")
      object_detection.protos.InputReaderOuterClass.InstanceMaskType result = object_detection.protos.InputReaderOuterClass.InstanceMaskType.valueOf(maskType_);
      return result == null ? object_detection.protos.InputReaderOuterClass.InstanceMaskType.NUMERICAL_MASKS : result;
    }

    public static final int LOAD_DENSE_POSE_FIELD_NUMBER = 31;
    private boolean loadDensePose_;
    /**
     * <pre>
     * Whether to load DensePose data. If set, must also set load_instance_masks
     * to true.
     * </pre>
     *
     * <code>optional bool load_dense_pose = 31 [default = false];</code>
     * @return Whether the loadDensePose field is set.
     */
    @java.lang.Override
    public boolean hasLoadDensePose() {
      return ((bitField0_ & 0x01000000) != 0);
    }
    /**
     * <pre>
     * Whether to load DensePose data. If set, must also set load_instance_masks
     * to true.
     * </pre>
     *
     * <code>optional bool load_dense_pose = 31 [default = false];</code>
     * @return The loadDensePose.
     */
    @java.lang.Override
    public boolean getLoadDensePose() {
      return loadDensePose_;
    }

    public static final int LOAD_TRACK_ID_FIELD_NUMBER = 33;
    private boolean loadTrackId_;
    /**
     * <pre>
     * Whether to load track information.
     * </pre>
     *
     * <code>optional bool load_track_id = 33 [default = false];</code>
     * @return Whether the loadTrackId field is set.
     */
    @java.lang.Override
    public boolean hasLoadTrackId() {
      return ((bitField0_ & 0x02000000) != 0);
    }
    /**
     * <pre>
     * Whether to load track information.
     * </pre>
     *
     * <code>optional bool load_track_id = 33 [default = false];</code>
     * @return The loadTrackId.
     */
    @java.lang.Override
    public boolean getLoadTrackId() {
      return loadTrackId_;
    }

    public static final int USE_DISPLAY_NAME_FIELD_NUMBER = 17;
    private boolean useDisplayName_;
    /**
     * <pre>
     * Whether to use the display name when decoding examples. This is only used
     * when mapping class text strings to integers.
     * </pre>
     *
     * <code>optional bool use_display_name = 17 [default = false];</code>
     * @return Whether the useDisplayName field is set.
     */
    @java.lang.Override
    public boolean hasUseDisplayName() {
      return ((bitField0_ & 0x04000000) != 0);
    }
    /**
     * <pre>
     * Whether to use the display name when decoding examples. This is only used
     * when mapping class text strings to integers.
     * </pre>
     *
     * <code>optional bool use_display_name = 17 [default = false];</code>
     * @return The useDisplayName.
     */
    @java.lang.Override
    public boolean getUseDisplayName() {
      return useDisplayName_;
    }

    public static final int INCLUDE_SOURCE_ID_FIELD_NUMBER = 27;
    private boolean includeSourceId_;
    /**
     * <pre>
     * Whether to include the source_id string in the input features.
     * </pre>
     *
     * <code>optional bool include_source_id = 27 [default = false];</code>
     * @return Whether the includeSourceId field is set.
     */
    @java.lang.Override
    public boolean hasIncludeSourceId() {
      return ((bitField0_ & 0x08000000) != 0);
    }
    /**
     * <pre>
     * Whether to include the source_id string in the input features.
     * </pre>
     *
     * <code>optional bool include_source_id = 27 [default = false];</code>
     * @return The includeSourceId.
     */
    @java.lang.Override
    public boolean getIncludeSourceId() {
      return includeSourceId_;
    }

    public static final int INPUT_TYPE_FIELD_NUMBER = 30;
    private int inputType_;
    /**
     * <pre>
     * Whether input data type is tf.Examples or tf.SequenceExamples
     * </pre>
     *
     * <code>optional .object_detection.protos.InputType input_type = 30 [default = TF_EXAMPLE];</code>
     * @return Whether the inputType field is set.
     */
    @java.lang.Override public boolean hasInputType() {
      return ((bitField0_ & 0x10000000) != 0);
    }
    /**
     * <pre>
     * Whether input data type is tf.Examples or tf.SequenceExamples
     * </pre>
     *
     * <code>optional .object_detection.protos.InputType input_type = 30 [default = TF_EXAMPLE];</code>
     * @return The inputType.
     */
    @java.lang.Override public object_detection.protos.InputReaderOuterClass.InputType getInputType() {
      @SuppressWarnings("deprecation")
      object_detection.protos.InputReaderOuterClass.InputType result = object_detection.protos.InputReaderOuterClass.InputType.valueOf(inputType_);
      return result == null ? object_detection.protos.InputReaderOuterClass.InputType.TF_EXAMPLE : result;
    }

    public static final int FRAME_INDEX_FIELD_NUMBER = 32;
    private int frameIndex_;
    /**
     * <pre>
     * Which frame to choose from the input if Sequence Example. -1 indicates
     * random choice.
     * </pre>
     *
     * <code>optional int32 frame_index = 32 [default = -1];</code>
     * @return Whether the frameIndex field is set.
     */
    @java.lang.Override
    public boolean hasFrameIndex() {
      return ((bitField0_ & 0x20000000) != 0);
    }
    /**
     * <pre>
     * Which frame to choose from the input if Sequence Example. -1 indicates
     * random choice.
     * </pre>
     *
     * <code>optional int32 frame_index = 32 [default = -1];</code>
     * @return The frameIndex.
     */
    @java.lang.Override
    public int getFrameIndex() {
      return frameIndex_;
    }

    public static final int TF_RECORD_INPUT_READER_FIELD_NUMBER = 8;
    /**
     * <code>.object_detection.protos.TFRecordInputReader tf_record_input_reader = 8;</code>
     * @return Whether the tfRecordInputReader field is set.
     */
    @java.lang.Override
    public boolean hasTfRecordInputReader() {
      return inputReaderCase_ == 8;
    }
    /**
     * <code>.object_detection.protos.TFRecordInputReader tf_record_input_reader = 8;</code>
     * @return The tfRecordInputReader.
     */
    @java.lang.Override
    public object_detection.protos.InputReaderOuterClass.TFRecordInputReader getTfRecordInputReader() {
      if (inputReaderCase_ == 8) {
         return (object_detection.protos.InputReaderOuterClass.TFRecordInputReader) inputReader_;
      }
      return object_detection.protos.InputReaderOuterClass.TFRecordInputReader.getDefaultInstance();
    }
    /**
     * <code>.object_detection.protos.TFRecordInputReader tf_record_input_reader = 8;</code>
     */
    @java.lang.Override
    public object_detection.protos.InputReaderOuterClass.TFRecordInputReaderOrBuilder getTfRecordInputReaderOrBuilder() {
      if (inputReaderCase_ == 8) {
         return (object_detection.protos.InputReaderOuterClass.TFRecordInputReader) inputReader_;
      }
      return object_detection.protos.InputReaderOuterClass.TFRecordInputReader.getDefaultInstance();
    }

    public static final int EXTERNAL_INPUT_READER_FIELD_NUMBER = 9;
    /**
     * <code>.object_detection.protos.ExternalInputReader external_input_reader = 9;</code>
     * @return Whether the externalInputReader field is set.
     */
    @java.lang.Override
    public boolean hasExternalInputReader() {
      return inputReaderCase_ == 9;
    }
    /**
     * <code>.object_detection.protos.ExternalInputReader external_input_reader = 9;</code>
     * @return The externalInputReader.
     */
    @java.lang.Override
    public object_detection.protos.InputReaderOuterClass.ExternalInputReader getExternalInputReader() {
      if (inputReaderCase_ == 9) {
         return (object_detection.protos.InputReaderOuterClass.ExternalInputReader) inputReader_;
      }
      return object_detection.protos.InputReaderOuterClass.ExternalInputReader.getDefaultInstance();
    }
    /**
     * <code>.object_detection.protos.ExternalInputReader external_input_reader = 9;</code>
     */
    @java.lang.Override
    public object_detection.protos.InputReaderOuterClass.ExternalInputReaderOrBuilder getExternalInputReaderOrBuilder() {
      if (inputReaderCase_ == 9) {
         return (object_detection.protos.InputReaderOuterClass.ExternalInputReader) inputReader_;
      }
      return object_detection.protos.InputReaderOuterClass.ExternalInputReader.getDefaultInstance();
    }

    public static final int SAMPLE_FROM_DATASETS_WEIGHTS_FIELD_NUMBER = 34;
    private com.google.protobuf.Internal.FloatList sampleFromDatasetsWeights_;
    /**
     * <pre>
     * When multiple input files are configured, we can sample across them based
     * on weights.
     * The number of weights must match the number of input files configured.
     * When set, shuffling, shuffle buffer size, and num_readers settings are
     * applied individually to each dataset.
     * Implementation follows tf.data.experimental.sample_from_datasets sampling
     * strategy. Weights may take any value - only relative weights matter.
     * Zero weights will result in a dataset not being sampled.
     * Examples, assuming two input files configured:
     * Equal weighting:
     * sample_from_datasets_weights: 0.5
     * sample_from_datasets_weights: 0.5
     * 2:1 weighting:
     * sample_from_datasets_weights: 2
     * sample_from_datasets_weights: 1
     * Exclude the second dataset:
     * sample_from_datasets_weights: 1
     * sample_from_datasets_weights: 0
     * </pre>
     *
     * <code>repeated float sample_from_datasets_weights = 34;</code>
     * @return A list containing the sampleFromDatasetsWeights.
     */
    @java.lang.Override
    public java.util.List<java.lang.Float>
        getSampleFromDatasetsWeightsList() {
      return sampleFromDatasetsWeights_;
    }
    /**
     * <pre>
     * When multiple input files are configured, we can sample across them based
     * on weights.
     * The number of weights must match the number of input files configured.
     * When set, shuffling, shuffle buffer size, and num_readers settings are
     * applied individually to each dataset.
     * Implementation follows tf.data.experimental.sample_from_datasets sampling
     * strategy. Weights may take any value - only relative weights matter.
     * Zero weights will result in a dataset not being sampled.
     * Examples, assuming two input files configured:
     * Equal weighting:
     * sample_from_datasets_weights: 0.5
     * sample_from_datasets_weights: 0.5
     * 2:1 weighting:
     * sample_from_datasets_weights: 2
     * sample_from_datasets_weights: 1
     * Exclude the second dataset:
     * sample_from_datasets_weights: 1
     * sample_from_datasets_weights: 0
     * </pre>
     *
     * <code>repeated float sample_from_datasets_weights = 34;</code>
     * @return The count of sampleFromDatasetsWeights.
     */
    public int getSampleFromDatasetsWeightsCount() {
      return sampleFromDatasetsWeights_.size();
    }
    /**
     * <pre>
     * When multiple input files are configured, we can sample across them based
     * on weights.
     * The number of weights must match the number of input files configured.
     * When set, shuffling, shuffle buffer size, and num_readers settings are
     * applied individually to each dataset.
     * Implementation follows tf.data.experimental.sample_from_datasets sampling
     * strategy. Weights may take any value - only relative weights matter.
     * Zero weights will result in a dataset not being sampled.
     * Examples, assuming two input files configured:
     * Equal weighting:
     * sample_from_datasets_weights: 0.5
     * sample_from_datasets_weights: 0.5
     * 2:1 weighting:
     * sample_from_datasets_weights: 2
     * sample_from_datasets_weights: 1
     * Exclude the second dataset:
     * sample_from_datasets_weights: 1
     * sample_from_datasets_weights: 0
     * </pre>
     *
     * <code>repeated float sample_from_datasets_weights = 34;</code>
     * @param index The index of the element to return.
     * @return The sampleFromDatasetsWeights at the given index.
     */
    public float getSampleFromDatasetsWeights(int index) {
      return sampleFromDatasetsWeights_.getFloat(index);
    }

    public static final int EXPAND_LABELS_HIERARCHY_FIELD_NUMBER = 29;
    private boolean expandLabelsHierarchy_;
    /**
     * <pre>
     * Expand labels to ancestors or descendants in the hierarchy for
     * for positive and negative labels, respectively.
     * </pre>
     *
     * <code>optional bool expand_labels_hierarchy = 29 [default = false];</code>
     * @return Whether the expandLabelsHierarchy field is set.
     */
    @java.lang.Override
    public boolean hasExpandLabelsHierarchy() {
      return ((bitField1_ & 0x00000001) != 0);
    }
    /**
     * <pre>
     * Expand labels to ancestors or descendants in the hierarchy for
     * for positive and negative labels, respectively.
     * </pre>
     *
     * <code>optional bool expand_labels_hierarchy = 29 [default = false];</code>
     * @return The expandLabelsHierarchy.
     */
    @java.lang.Override
    public boolean getExpandLabelsHierarchy() {
      return expandLabelsHierarchy_;
    }

    private byte memoizedIsInitialized = -1;
    @java.lang.Override
    public final boolean isInitialized() {
      byte isInitialized = memoizedIsInitialized;
      if (isInitialized == 1) return true;
      if (isInitialized == 0) return false;

      if (hasExternalInputReader()) {
        if (!getExternalInputReader().isInitialized()) {
          memoizedIsInitialized = 0;
          return false;
        }
      }
      memoizedIsInitialized = 1;
      return true;
    }

    @java.lang.Override
    public void writeTo(com.google.protobuf.CodedOutputStream output)
                        throws java.io.IOException {
      if (((bitField0_ & 0x00000002) != 0)) {
        com.google.protobuf.GeneratedMessageV3.writeString(output, 1, labelMapPath_);
      }
      if (((bitField0_ & 0x00000004) != 0)) {
        output.writeBool(2, shuffle_);
      }
      if (((bitField0_ & 0x00000400) != 0)) {
        output.writeUInt32(3, queueCapacity_);
      }
      if (((bitField0_ & 0x00000800) != 0)) {
        output.writeUInt32(4, minAfterDequeue_);
      }
      if (((bitField0_ & 0x00000020) != 0)) {
        output.writeUInt32(5, numEpochs_);
      }
      if (((bitField0_ & 0x00000080) != 0)) {
        output.writeUInt32(6, numReaders_);
      }
      if (((bitField0_ & 0x00400000) != 0)) {
        output.writeBool(7, loadInstanceMasks_);
      }
      if (inputReaderCase_ == 8) {
        output.writeMessage(8, (object_detection.protos.InputReaderOuterClass.TFRecordInputReader) inputReader_);
      }
      if (inputReaderCase_ == 9) {
        output.writeMessage(9, (object_detection.protos.InputReaderOuterClass.ExternalInputReader) inputReader_);
      }
      if (((bitField0_ & 0x00800000) != 0)) {
        output.writeEnum(10, maskType_);
      }
      if (((bitField0_ & 0x00000008) != 0)) {
        output.writeUInt32(11, shuffleBufferSize_);
      }
      if (((bitField0_ & 0x00000010) != 0)) {
        output.writeUInt32(12, filenamesShuffleBufferSize_);
      }
      if (((bitField0_ & 0x00002000) != 0)) {
        output.writeUInt32(13, prefetchSize_);
      }
      if (((bitField0_ & 0x00004000) != 0)) {
        output.writeUInt32(14, numParallelMapCalls_);
      }
      if (((bitField0_ & 0x00001000) != 0)) {
        output.writeUInt32(15, readBlockLength_);
      }
      if (((bitField0_ & 0x00020000) != 0)) {
        output.writeUInt32(16, numKeypoints_);
      }
      if (((bitField0_ & 0x04000000) != 0)) {
        output.writeBool(17, useDisplayName_);
      }
      if (((bitField0_ & 0x00010000) != 0)) {
        output.writeInt32(18, numAdditionalChannels_);
      }
      if (((bitField0_ & 0x00000100) != 0)) {
        output.writeUInt32(19, numParallelBatches_);
      }
      if (((bitField0_ & 0x00000200) != 0)) {
        output.writeInt32(20, numPrefetchBatches_);
      }
      if (((bitField0_ & 0x00040000) != 0)) {
        output.writeInt32(21, maxNumberOfBoxes_);
      }
      if (((bitField0_ & 0x00000040) != 0)) {
        output.writeUInt32(22, sample1OfNExamples_);
      }
      if (((bitField0_ & 0x00000001) != 0)) {
        com.google.protobuf.GeneratedMessageV3.writeString(output, 23, name_);
      }
      if (((bitField0_ & 0x00080000) != 0)) {
        output.writeBool(24, loadMulticlassScores_);
      }
      if (((bitField0_ & 0x00100000) != 0)) {
        output.writeBool(25, loadContextFeatures_);
      }
      for (int i = 0; i < keypointTypeWeight_.size(); i++) {
        output.writeFloat(26, keypointTypeWeight_.getFloat(i));
      }
      if (((bitField0_ & 0x08000000) != 0)) {
        output.writeBool(27, includeSourceId_);
      }
      if (((bitField1_ & 0x00000001) != 0)) {
        output.writeBool(29, expandLabelsHierarchy_);
      }
      if (((bitField0_ & 0x10000000) != 0)) {
        output.writeEnum(30, inputType_);
      }
      if (((bitField0_ & 0x01000000) != 0)) {
        output.writeBool(31, loadDensePose_);
      }
      if (((bitField0_ & 0x20000000) != 0)) {
        output.writeInt32(32, frameIndex_);
      }
      if (((bitField0_ & 0x02000000) != 0)) {
        output.writeBool(33, loadTrackId_);
      }
      for (int i = 0; i < sampleFromDatasetsWeights_.size(); i++) {
        output.writeFloat(34, sampleFromDatasetsWeights_.getFloat(i));
      }
      if (((bitField0_ & 0x00008000) != 0)) {
        output.writeBool(35, dropRemainder_);
      }
      if (((bitField0_ & 0x00200000) != 0)) {
        output.writeBool(36, loadContextImageIds_);
      }
      unknownFields.writeTo(output);
    }

    @java.lang.Override
    public int getSerializedSize() {
      int size = memoizedSize;
      if (size != -1) return size;

      size = 0;
      if (((bitField0_ & 0x00000002) != 0)) {
        size += com.google.protobuf.GeneratedMessageV3.computeStringSize(1, labelMapPath_);
      }
      if (((bitField0_ & 0x00000004) != 0)) {
        size += com.google.protobuf.CodedOutputStream
          .computeBoolSize(2, shuffle_);
      }
      if (((bitField0_ & 0x00000400) != 0)) {
        size += com.google.protobuf.CodedOutputStream
          .computeUInt32Size(3, queueCapacity_);
      }
      if (((bitField0_ & 0x00000800) != 0)) {
        size += com.google.protobuf.CodedOutputStream
          .computeUInt32Size(4, minAfterDequeue_);
      }
      if (((bitField0_ & 0x00000020) != 0)) {
        size += com.google.protobuf.CodedOutputStream
          .computeUInt32Size(5, numEpochs_);
      }
      if (((bitField0_ & 0x00000080) != 0)) {
        size += com.google.protobuf.CodedOutputStream
          .computeUInt32Size(6, numReaders_);
      }
      if (((bitField0_ & 0x00400000) != 0)) {
        size += com.google.protobuf.CodedOutputStream
          .computeBoolSize(7, loadInstanceMasks_);
      }
      if (inputReaderCase_ == 8) {
        size += com.google.protobuf.CodedOutputStream
          .computeMessageSize(8, (object_detection.protos.InputReaderOuterClass.TFRecordInputReader) inputReader_);
      }
      if (inputReaderCase_ == 9) {
        size += com.google.protobuf.CodedOutputStream
          .computeMessageSize(9, (object_detection.protos.InputReaderOuterClass.ExternalInputReader) inputReader_);
      }
      if (((bitField0_ & 0x00800000) != 0)) {
        size += com.google.protobuf.CodedOutputStream
          .computeEnumSize(10, maskType_);
      }
      if (((bitField0_ & 0x00000008) != 0)) {
        size += com.google.protobuf.CodedOutputStream
          .computeUInt32Size(11, shuffleBufferSize_);
      }
      if (((bitField0_ & 0x00000010) != 0)) {
        size += com.google.protobuf.CodedOutputStream
          .computeUInt32Size(12, filenamesShuffleBufferSize_);
      }
      if (((bitField0_ & 0x00002000) != 0)) {
        size += com.google.protobuf.CodedOutputStream
          .computeUInt32Size(13, prefetchSize_);
      }
      if (((bitField0_ & 0x00004000) != 0)) {
        size += com.google.protobuf.CodedOutputStream
          .computeUInt32Size(14, numParallelMapCalls_);
      }
      if (((bitField0_ & 0x00001000) != 0)) {
        size += com.google.protobuf.CodedOutputStream
          .computeUInt32Size(15, readBlockLength_);
      }
      if (((bitField0_ & 0x00020000) != 0)) {
        size += com.google.protobuf.CodedOutputStream
          .computeUInt32Size(16, numKeypoints_);
      }
      if (((bitField0_ & 0x04000000) != 0)) {
        size += com.google.protobuf.CodedOutputStream
          .computeBoolSize(17, useDisplayName_);
      }
      if (((bitField0_ & 0x00010000) != 0)) {
        size += com.google.protobuf.CodedOutputStream
          .computeInt32Size(18, numAdditionalChannels_);
      }
      if (((bitField0_ & 0x00000100) != 0)) {
        size += com.google.protobuf.CodedOutputStream
          .computeUInt32Size(19, numParallelBatches_);
      }
      if (((bitField0_ & 0x00000200) != 0)) {
        size += com.google.protobuf.CodedOutputStream
          .computeInt32Size(20, numPrefetchBatches_);
      }
      if (((bitField0_ & 0x00040000) != 0)) {
        size += com.google.protobuf.CodedOutputStream
          .computeInt32Size(21, maxNumberOfBoxes_);
      }
      if (((bitField0_ & 0x00000040) != 0)) {
        size += com.google.protobuf.CodedOutputStream
          .computeUInt32Size(22, sample1OfNExamples_);
      }
      if (((bitField0_ & 0x00000001) != 0)) {
        size += com.google.protobuf.GeneratedMessageV3.computeStringSize(23, name_);
      }
      if (((bitField0_ & 0x00080000) != 0)) {
        size += com.google.protobuf.CodedOutputStream
          .computeBoolSize(24, loadMulticlassScores_);
      }
      if (((bitField0_ & 0x00100000) != 0)) {
        size += com.google.protobuf.CodedOutputStream
          .computeBoolSize(25, loadContextFeatures_);
      }
      {
        int dataSize = 0;
        dataSize = 4 * getKeypointTypeWeightList().size();
        size += dataSize;
        size += 2 * getKeypointTypeWeightList().size();
      }
      if (((bitField0_ & 0x08000000) != 0)) {
        size += com.google.protobuf.CodedOutputStream
          .computeBoolSize(27, includeSourceId_);
      }
      if (((bitField1_ & 0x00000001) != 0)) {
        size += com.google.protobuf.CodedOutputStream
          .computeBoolSize(29, expandLabelsHierarchy_);
      }
      if (((bitField0_ & 0x10000000) != 0)) {
        size += com.google.protobuf.CodedOutputStream
          .computeEnumSize(30, inputType_);
      }
      if (((bitField0_ & 0x01000000) != 0)) {
        size += com.google.protobuf.CodedOutputStream
          .computeBoolSize(31, loadDensePose_);
      }
      if (((bitField0_ & 0x20000000) != 0)) {
        size += com.google.protobuf.CodedOutputStream
          .computeInt32Size(32, frameIndex_);
      }
      if (((bitField0_ & 0x02000000) != 0)) {
        size += com.google.protobuf.CodedOutputStream
          .computeBoolSize(33, loadTrackId_);
      }
      {
        int dataSize = 0;
        dataSize = 4 * getSampleFromDatasetsWeightsList().size();
        size += dataSize;
        size += 2 * getSampleFromDatasetsWeightsList().size();
      }
      if (((bitField0_ & 0x00008000) != 0)) {
        size += com.google.protobuf.CodedOutputStream
          .computeBoolSize(35, dropRemainder_);
      }
      if (((bitField0_ & 0x00200000) != 0)) {
        size += com.google.protobuf.CodedOutputStream
          .computeBoolSize(36, loadContextImageIds_);
      }
      size += unknownFields.getSerializedSize();
      memoizedSize = size;
      return size;
    }

    @java.lang.Override
    public boolean equals(final java.lang.Object obj) {
      if (obj == this) {
       return true;
      }
      if (!(obj instanceof object_detection.protos.InputReaderOuterClass.InputReader)) {
        return super.equals(obj);
      }
      object_detection.protos.InputReaderOuterClass.InputReader other = (object_detection.protos.InputReaderOuterClass.InputReader) obj;

      if (hasName() != other.hasName()) return false;
      if (hasName()) {
        if (!getName()
            .equals(other.getName())) return false;
      }
      if (hasLabelMapPath() != other.hasLabelMapPath()) return false;
      if (hasLabelMapPath()) {
        if (!getLabelMapPath()
            .equals(other.getLabelMapPath())) return false;
      }
      if (hasShuffle() != other.hasShuffle()) return false;
      if (hasShuffle()) {
        if (getShuffle()
            != other.getShuffle()) return false;
      }
      if (hasShuffleBufferSize() != other.hasShuffleBufferSize()) return false;
      if (hasShuffleBufferSize()) {
        if (getShuffleBufferSize()
            != other.getShuffleBufferSize()) return false;
      }
      if (hasFilenamesShuffleBufferSize() != other.hasFilenamesShuffleBufferSize()) return false;
      if (hasFilenamesShuffleBufferSize()) {
        if (getFilenamesShuffleBufferSize()
            != other.getFilenamesShuffleBufferSize()) return false;
      }
      if (hasNumEpochs() != other.hasNumEpochs()) return false;
      if (hasNumEpochs()) {
        if (getNumEpochs()
            != other.getNumEpochs()) return false;
      }
      if (hasSample1OfNExamples() != other.hasSample1OfNExamples()) return false;
      if (hasSample1OfNExamples()) {
        if (getSample1OfNExamples()
            != other.getSample1OfNExamples()) return false;
      }
      if (hasNumReaders() != other.hasNumReaders()) return false;
      if (hasNumReaders()) {
        if (getNumReaders()
            != other.getNumReaders()) return false;
      }
      if (hasNumParallelBatches() != other.hasNumParallelBatches()) return false;
      if (hasNumParallelBatches()) {
        if (getNumParallelBatches()
            != other.getNumParallelBatches()) return false;
      }
      if (hasNumPrefetchBatches() != other.hasNumPrefetchBatches()) return false;
      if (hasNumPrefetchBatches()) {
        if (getNumPrefetchBatches()
            != other.getNumPrefetchBatches()) return false;
      }
      if (hasQueueCapacity() != other.hasQueueCapacity()) return false;
      if (hasQueueCapacity()) {
        if (getQueueCapacity()
            != other.getQueueCapacity()) return false;
      }
      if (hasMinAfterDequeue() != other.hasMinAfterDequeue()) return false;
      if (hasMinAfterDequeue()) {
        if (getMinAfterDequeue()
            != other.getMinAfterDequeue()) return false;
      }
      if (hasReadBlockLength() != other.hasReadBlockLength()) return false;
      if (hasReadBlockLength()) {
        if (getReadBlockLength()
            != other.getReadBlockLength()) return false;
      }
      if (hasPrefetchSize() != other.hasPrefetchSize()) return false;
      if (hasPrefetchSize()) {
        if (getPrefetchSize()
            != other.getPrefetchSize()) return false;
      }
      if (hasNumParallelMapCalls() != other.hasNumParallelMapCalls()) return false;
      if (hasNumParallelMapCalls()) {
        if (getNumParallelMapCalls()
            != other.getNumParallelMapCalls()) return false;
      }
      if (hasDropRemainder() != other.hasDropRemainder()) return false;
      if (hasDropRemainder()) {
        if (getDropRemainder()
            != other.getDropRemainder()) return false;
      }
      if (hasNumAdditionalChannels() != other.hasNumAdditionalChannels()) return false;
      if (hasNumAdditionalChannels()) {
        if (getNumAdditionalChannels()
            != other.getNumAdditionalChannels()) return false;
      }
      if (hasNumKeypoints() != other.hasNumKeypoints()) return false;
      if (hasNumKeypoints()) {
        if (getNumKeypoints()
            != other.getNumKeypoints()) return false;
      }
      if (!getKeypointTypeWeightList()
          .equals(other.getKeypointTypeWeightList())) return false;
      if (hasMaxNumberOfBoxes() != other.hasMaxNumberOfBoxes()) return false;
      if (hasMaxNumberOfBoxes()) {
        if (getMaxNumberOfBoxes()
            != other.getMaxNumberOfBoxes()) return false;
      }
      if (hasLoadMulticlassScores() != other.hasLoadMulticlassScores()) return false;
      if (hasLoadMulticlassScores()) {
        if (getLoadMulticlassScores()
            != other.getLoadMulticlassScores()) return false;
      }
      if (hasLoadContextFeatures() != other.hasLoadContextFeatures()) return false;
      if (hasLoadContextFeatures()) {
        if (getLoadContextFeatures()
            != other.getLoadContextFeatures()) return false;
      }
      if (hasLoadContextImageIds() != other.hasLoadContextImageIds()) return false;
      if (hasLoadContextImageIds()) {
        if (getLoadContextImageIds()
            != other.getLoadContextImageIds()) return false;
      }
      if (hasLoadInstanceMasks() != other.hasLoadInstanceMasks()) return false;
      if (hasLoadInstanceMasks()) {
        if (getLoadInstanceMasks()
            != other.getLoadInstanceMasks()) return false;
      }
      if (hasMaskType() != other.hasMaskType()) return false;
      if (hasMaskType()) {
        if (maskType_ != other.maskType_) return false;
      }
      if (hasLoadDensePose() != other.hasLoadDensePose()) return false;
      if (hasLoadDensePose()) {
        if (getLoadDensePose()
            != other.getLoadDensePose()) return false;
      }
      if (hasLoadTrackId() != other.hasLoadTrackId()) return false;
      if (hasLoadTrackId()) {
        if (getLoadTrackId()
            != other.getLoadTrackId()) return false;
      }
      if (hasUseDisplayName() != other.hasUseDisplayName()) return false;
      if (hasUseDisplayName()) {
        if (getUseDisplayName()
            != other.getUseDisplayName()) return false;
      }
      if (hasIncludeSourceId() != other.hasIncludeSourceId()) return false;
      if (hasIncludeSourceId()) {
        if (getIncludeSourceId()
            != other.getIncludeSourceId()) return false;
      }
      if (hasInputType() != other.hasInputType()) return false;
      if (hasInputType()) {
        if (inputType_ != other.inputType_) return false;
      }
      if (hasFrameIndex() != other.hasFrameIndex()) return false;
      if (hasFrameIndex()) {
        if (getFrameIndex()
            != other.getFrameIndex()) return false;
      }
      if (!getSampleFromDatasetsWeightsList()
          .equals(other.getSampleFromDatasetsWeightsList())) return false;
      if (hasExpandLabelsHierarchy() != other.hasExpandLabelsHierarchy()) return false;
      if (hasExpandLabelsHierarchy()) {
        if (getExpandLabelsHierarchy()
            != other.getExpandLabelsHierarchy()) return false;
      }
      if (!getInputReaderCase().equals(other.getInputReaderCase())) return false;
      switch (inputReaderCase_) {
        case 8:
          if (!getTfRecordInputReader()
              .equals(other.getTfRecordInputReader())) return false;
          break;
        case 9:
          if (!getExternalInputReader()
              .equals(other.getExternalInputReader())) return false;
          break;
        case 0:
        default:
      }
      if (!unknownFields.equals(other.unknownFields)) return false;
      return true;
    }

    @java.lang.Override
    public int hashCode() {
      if (memoizedHashCode != 0) {
        return memoizedHashCode;
      }
      int hash = 41;
      hash = (19 * hash) + getDescriptor().hashCode();
      if (hasName()) {
        hash = (37 * hash) + NAME_FIELD_NUMBER;
        hash = (53 * hash) + getName().hashCode();
      }
      if (hasLabelMapPath()) {
        hash = (37 * hash) + LABEL_MAP_PATH_FIELD_NUMBER;
        hash = (53 * hash) + getLabelMapPath().hashCode();
      }
      if (hasShuffle()) {
        hash = (37 * hash) + SHUFFLE_FIELD_NUMBER;
        hash = (53 * hash) + com.google.protobuf.Internal.hashBoolean(
            getShuffle());
      }
      if (hasShuffleBufferSize()) {
        hash = (37 * hash) + SHUFFLE_BUFFER_SIZE_FIELD_NUMBER;
        hash = (53 * hash) + getShuffleBufferSize();
      }
      if (hasFilenamesShuffleBufferSize()) {
        hash = (37 * hash) + FILENAMES_SHUFFLE_BUFFER_SIZE_FIELD_NUMBER;
        hash = (53 * hash) + getFilenamesShuffleBufferSize();
      }
      if (hasNumEpochs()) {
        hash = (37 * hash) + NUM_EPOCHS_FIELD_NUMBER;
        hash = (53 * hash) + getNumEpochs();
      }
      if (hasSample1OfNExamples()) {
        hash = (37 * hash) + SAMPLE_1_OF_N_EXAMPLES_FIELD_NUMBER;
        hash = (53 * hash) + getSample1OfNExamples();
      }
      if (hasNumReaders()) {
        hash = (37 * hash) + NUM_READERS_FIELD_NUMBER;
        hash = (53 * hash) + getNumReaders();
      }
      if (hasNumParallelBatches()) {
        hash = (37 * hash) + NUM_PARALLEL_BATCHES_FIELD_NUMBER;
        hash = (53 * hash) + getNumParallelBatches();
      }
      if (hasNumPrefetchBatches()) {
        hash = (37 * hash) + NUM_PREFETCH_BATCHES_FIELD_NUMBER;
        hash = (53 * hash) + getNumPrefetchBatches();
      }
      if (hasQueueCapacity()) {
        hash = (37 * hash) + QUEUE_CAPACITY_FIELD_NUMBER;
        hash = (53 * hash) + getQueueCapacity();
      }
      if (hasMinAfterDequeue()) {
        hash = (37 * hash) + MIN_AFTER_DEQUEUE_FIELD_NUMBER;
        hash = (53 * hash) + getMinAfterDequeue();
      }
      if (hasReadBlockLength()) {
        hash = (37 * hash) + READ_BLOCK_LENGTH_FIELD_NUMBER;
        hash = (53 * hash) + getReadBlockLength();
      }
      if (hasPrefetchSize()) {
        hash = (37 * hash) + PREFETCH_SIZE_FIELD_NUMBER;
        hash = (53 * hash) + getPrefetchSize();
      }
      if (hasNumParallelMapCalls()) {
        hash = (37 * hash) + NUM_PARALLEL_MAP_CALLS_FIELD_NUMBER;
        hash = (53 * hash) + getNumParallelMapCalls();
      }
      if (hasDropRemainder()) {
        hash = (37 * hash) + DROP_REMAINDER_FIELD_NUMBER;
        hash = (53 * hash) + com.google.protobuf.Internal.hashBoolean(
            getDropRemainder());
      }
      if (hasNumAdditionalChannels()) {
        hash = (37 * hash) + NUM_ADDITIONAL_CHANNELS_FIELD_NUMBER;
        hash = (53 * hash) + getNumAdditionalChannels();
      }
      if (hasNumKeypoints()) {
        hash = (37 * hash) + NUM_KEYPOINTS_FIELD_NUMBER;
        hash = (53 * hash) + getNumKeypoints();
      }
      if (getKeypointTypeWeightCount() > 0) {
        hash = (37 * hash) + KEYPOINT_TYPE_WEIGHT_FIELD_NUMBER;
        hash = (53 * hash) + getKeypointTypeWeightList().hashCode();
      }
      if (hasMaxNumberOfBoxes()) {
        hash = (37 * hash) + MAX_NUMBER_OF_BOXES_FIELD_NUMBER;
        hash = (53 * hash) + getMaxNumberOfBoxes();
      }
      if (hasLoadMulticlassScores()) {
        hash = (37 * hash) + LOAD_MULTICLASS_SCORES_FIELD_NUMBER;
        hash = (53 * hash) + com.google.protobuf.Internal.hashBoolean(
            getLoadMulticlassScores());
      }
      if (hasLoadContextFeatures()) {
        hash = (37 * hash) + LOAD_CONTEXT_FEATURES_FIELD_NUMBER;
        hash = (53 * hash) + com.google.protobuf.Internal.hashBoolean(
            getLoadContextFeatures());
      }
      if (hasLoadContextImageIds()) {
        hash = (37 * hash) + LOAD_CONTEXT_IMAGE_IDS_FIELD_NUMBER;
        hash = (53 * hash) + com.google.protobuf.Internal.hashBoolean(
            getLoadContextImageIds());
      }
      if (hasLoadInstanceMasks()) {
        hash = (37 * hash) + LOAD_INSTANCE_MASKS_FIELD_NUMBER;
        hash = (53 * hash) + com.google.protobuf.Internal.hashBoolean(
            getLoadInstanceMasks());
      }
      if (hasMaskType()) {
        hash = (37 * hash) + MASK_TYPE_FIELD_NUMBER;
        hash = (53 * hash) + maskType_;
      }
      if (hasLoadDensePose()) {
        hash = (37 * hash) + LOAD_DENSE_POSE_FIELD_NUMBER;
        hash = (53 * hash) + com.google.protobuf.Internal.hashBoolean(
            getLoadDensePose());
      }
      if (hasLoadTrackId()) {
        hash = (37 * hash) + LOAD_TRACK_ID_FIELD_NUMBER;
        hash = (53 * hash) + com.google.protobuf.Internal.hashBoolean(
            getLoadTrackId());
      }
      if (hasUseDisplayName()) {
        hash = (37 * hash) + USE_DISPLAY_NAME_FIELD_NUMBER;
        hash = (53 * hash) + com.google.protobuf.Internal.hashBoolean(
            getUseDisplayName());
      }
      if (hasIncludeSourceId()) {
        hash = (37 * hash) + INCLUDE_SOURCE_ID_FIELD_NUMBER;
        hash = (53 * hash) + com.google.protobuf.Internal.hashBoolean(
            getIncludeSourceId());
      }
      if (hasInputType()) {
        hash = (37 * hash) + INPUT_TYPE_FIELD_NUMBER;
        hash = (53 * hash) + inputType_;
      }
      if (hasFrameIndex()) {
        hash = (37 * hash) + FRAME_INDEX_FIELD_NUMBER;
        hash = (53 * hash) + getFrameIndex();
      }
      if (getSampleFromDatasetsWeightsCount() > 0) {
        hash = (37 * hash) + SAMPLE_FROM_DATASETS_WEIGHTS_FIELD_NUMBER;
        hash = (53 * hash) + getSampleFromDatasetsWeightsList().hashCode();
      }
      if (hasExpandLabelsHierarchy()) {
        hash = (37 * hash) + EXPAND_LABELS_HIERARCHY_FIELD_NUMBER;
        hash = (53 * hash) + com.google.protobuf.Internal.hashBoolean(
            getExpandLabelsHierarchy());
      }
      switch (inputReaderCase_) {
        case 8:
          hash = (37 * hash) + TF_RECORD_INPUT_READER_FIELD_NUMBER;
          hash = (53 * hash) + getTfRecordInputReader().hashCode();
          break;
        case 9:
          hash = (37 * hash) + EXTERNAL_INPUT_READER_FIELD_NUMBER;
          hash = (53 * hash) + getExternalInputReader().hashCode();
          break;
        case 0:
        default:
      }
      hash = (29 * hash) + unknownFields.hashCode();
      memoizedHashCode = hash;
      return hash;
    }

    public static object_detection.protos.InputReaderOuterClass.InputReader parseFrom(
        java.nio.ByteBuffer data)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return PARSER.parseFrom(data);
    }
    public static object_detection.protos.InputReaderOuterClass.InputReader parseFrom(
        java.nio.ByteBuffer data,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return PARSER.parseFrom(data, extensionRegistry);
    }
    public static object_detection.protos.InputReaderOuterClass.InputReader parseFrom(
        com.google.protobuf.ByteString data)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return PARSER.parseFrom(data);
    }
    public static object_detection.protos.InputReaderOuterClass.InputReader parseFrom(
        com.google.protobuf.ByteString data,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return PARSER.parseFrom(data, extensionRegistry);
    }
    public static object_detection.protos.InputReaderOuterClass.InputReader parseFrom(byte[] data)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return PARSER.parseFrom(data);
    }
    public static object_detection.protos.InputReaderOuterClass.InputReader parseFrom(
        byte[] data,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return PARSER.parseFrom(data, extensionRegistry);
    }
    public static object_detection.protos.InputReaderOuterClass.InputReader parseFrom(java.io.InputStream input)
        throws java.io.IOException {
      return com.google.protobuf.GeneratedMessageV3
          .parseWithIOException(PARSER, input);
    }
    public static object_detection.protos.InputReaderOuterClass.InputReader parseFrom(
        java.io.InputStream input,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws java.io.IOException {
      return com.google.protobuf.GeneratedMessageV3
          .parseWithIOException(PARSER, input, extensionRegistry);
    }
    public static object_detection.protos.InputReaderOuterClass.InputReader parseDelimitedFrom(java.io.InputStream input)
        throws java.io.IOException {
      return com.google.protobuf.GeneratedMessageV3
          .parseDelimitedWithIOException(PARSER, input);
    }
    public static object_detection.protos.InputReaderOuterClass.InputReader parseDelimitedFrom(
        java.io.InputStream input,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws java.io.IOException {
      return com.google.protobuf.GeneratedMessageV3
          .parseDelimitedWithIOException(PARSER, input, extensionRegistry);
    }
    public static object_detection.protos.InputReaderOuterClass.InputReader parseFrom(
        com.google.protobuf.CodedInputStream input)
        throws java.io.IOException {
      return com.google.protobuf.GeneratedMessageV3
          .parseWithIOException(PARSER, input);
    }
    public static object_detection.protos.InputReaderOuterClass.InputReader parseFrom(
        com.google.protobuf.CodedInputStream input,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws java.io.IOException {
      return com.google.protobuf.GeneratedMessageV3
          .parseWithIOException(PARSER, input, extensionRegistry);
    }

    @java.lang.Override
    public Builder newBuilderForType() { return newBuilder(); }
    public static Builder newBuilder() {
      return DEFAULT_INSTANCE.toBuilder();
    }
    public static Builder newBuilder(object_detection.protos.InputReaderOuterClass.InputReader prototype) {
      return DEFAULT_INSTANCE.toBuilder().mergeFrom(prototype);
    }
    @java.lang.Override
    public Builder toBuilder() {
      return this == DEFAULT_INSTANCE
          ? new Builder() : new Builder().mergeFrom(this);
    }

    @java.lang.Override
    protected Builder newBuilderForType(
        com.google.protobuf.GeneratedMessageV3.BuilderParent parent) {
      Builder builder = new Builder(parent);
      return builder;
    }
    /**
     * <pre>
     * Next id: 37
     * </pre>
     *
     * Protobuf type {@code object_detection.protos.InputReader}
     */
    public static final class Builder extends
        com.google.protobuf.GeneratedMessageV3.Builder<Builder> implements
        // @@protoc_insertion_point(builder_implements:object_detection.protos.InputReader)
        object_detection.protos.InputReaderOuterClass.InputReaderOrBuilder {
      public static final com.google.protobuf.Descriptors.Descriptor
          getDescriptor() {
        return object_detection.protos.InputReaderOuterClass.internal_static_object_detection_protos_InputReader_descriptor;
      }

      @java.lang.Override
      protected com.google.protobuf.GeneratedMessageV3.FieldAccessorTable
          internalGetFieldAccessorTable() {
        return object_detection.protos.InputReaderOuterClass.internal_static_object_detection_protos_InputReader_fieldAccessorTable
            .ensureFieldAccessorsInitialized(
                object_detection.protos.InputReaderOuterClass.InputReader.class, object_detection.protos.InputReaderOuterClass.InputReader.Builder.class);
      }

      // Construct using object_detection.protos.InputReaderOuterClass.InputReader.newBuilder()
      private Builder() {
        maybeForceBuilderInitialization();
      }

      private Builder(
          com.google.protobuf.GeneratedMessageV3.BuilderParent parent) {
        super(parent);
        maybeForceBuilderInitialization();
      }
      private void maybeForceBuilderInitialization() {
        if (com.google.protobuf.GeneratedMessageV3
                .alwaysUseFieldBuilders) {
        }
      }
      @java.lang.Override
      public Builder clear() {
        super.clear();
        name_ = "";
        bitField0_ = (bitField0_ & ~0x00000001);
        labelMapPath_ = "";
        bitField0_ = (bitField0_ & ~0x00000002);
        shuffle_ = true;
        bitField0_ = (bitField0_ & ~0x00000004);
        shuffleBufferSize_ = 2048;
        bitField0_ = (bitField0_ & ~0x00000008);
        filenamesShuffleBufferSize_ = 100;
        bitField0_ = (bitField0_ & ~0x00000010);
        numEpochs_ = 0;
        bitField0_ = (bitField0_ & ~0x00000020);
        sample1OfNExamples_ = 1;
        bitField0_ = (bitField0_ & ~0x00000040);
        numReaders_ = 64;
        bitField0_ = (bitField0_ & ~0x00000080);
        numParallelBatches_ = 8;
        bitField0_ = (bitField0_ & ~0x00000100);
        numPrefetchBatches_ = 2;
        bitField0_ = (bitField0_ & ~0x00000200);
        queueCapacity_ = 2000;
        bitField0_ = (bitField0_ & ~0x00000400);
        minAfterDequeue_ = 1000;
        bitField0_ = (bitField0_ & ~0x00000800);
        readBlockLength_ = 32;
        bitField0_ = (bitField0_ & ~0x00001000);
        prefetchSize_ = 512;
        bitField0_ = (bitField0_ & ~0x00002000);
        numParallelMapCalls_ = 64;
        bitField0_ = (bitField0_ & ~0x00004000);
        dropRemainder_ = true;
        bitField0_ = (bitField0_ & ~0x00008000);
        numAdditionalChannels_ = 0;
        bitField0_ = (bitField0_ & ~0x00010000);
        numKeypoints_ = 0;
        bitField0_ = (bitField0_ & ~0x00020000);
        keypointTypeWeight_ = emptyFloatList();
        bitField0_ = (bitField0_ & ~0x00040000);
        maxNumberOfBoxes_ = 100;
        bitField0_ = (bitField0_ & ~0x00080000);
        loadMulticlassScores_ = false;
        bitField0_ = (bitField0_ & ~0x00100000);
        loadContextFeatures_ = false;
        bitField0_ = (bitField0_ & ~0x00200000);
        loadContextImageIds_ = false;
        bitField0_ = (bitField0_ & ~0x00400000);
        loadInstanceMasks_ = false;
        bitField0_ = (bitField0_ & ~0x00800000);
        maskType_ = 1;
        bitField0_ = (bitField0_ & ~0x01000000);
        loadDensePose_ = false;
        bitField0_ = (bitField0_ & ~0x02000000);
        loadTrackId_ = false;
        bitField0_ = (bitField0_ & ~0x04000000);
        useDisplayName_ = false;
        bitField0_ = (bitField0_ & ~0x08000000);
        includeSourceId_ = false;
        bitField0_ = (bitField0_ & ~0x10000000);
        inputType_ = 1;
        bitField0_ = (bitField0_ & ~0x20000000);
        frameIndex_ = -1;
        bitField0_ = (bitField0_ & ~0x40000000);
        sampleFromDatasetsWeights_ = emptyFloatList();
        bitField1_ = (bitField1_ & ~0x00000002);
        expandLabelsHierarchy_ = false;
        bitField1_ = (bitField1_ & ~0x00000004);
        inputReaderCase_ = 0;
        inputReader_ = null;
        return this;
      }

      @java.lang.Override
      public com.google.protobuf.Descriptors.Descriptor
          getDescriptorForType() {
        return object_detection.protos.InputReaderOuterClass.internal_static_object_detection_protos_InputReader_descriptor;
      }

      @java.lang.Override
      public object_detection.protos.InputReaderOuterClass.InputReader getDefaultInstanceForType() {
        return object_detection.protos.InputReaderOuterClass.InputReader.getDefaultInstance();
      }

      @java.lang.Override
      public object_detection.protos.InputReaderOuterClass.InputReader build() {
        object_detection.protos.InputReaderOuterClass.InputReader result = buildPartial();
        if (!result.isInitialized()) {
          throw newUninitializedMessageException(result);
        }
        return result;
      }

      @java.lang.Override
      public object_detection.protos.InputReaderOuterClass.InputReader buildPartial() {
        object_detection.protos.InputReaderOuterClass.InputReader result = new object_detection.protos.InputReaderOuterClass.InputReader(this);
        int from_bitField0_ = bitField0_;
        int from_bitField1_ = bitField1_;
        int to_bitField0_ = 0;
        int to_bitField1_ = 0;
        if (((from_bitField0_ & 0x00000001) != 0)) {
          to_bitField0_ |= 0x00000001;
        }
        result.name_ = name_;
        if (((from_bitField0_ & 0x00000002) != 0)) {
          to_bitField0_ |= 0x00000002;
        }
        result.labelMapPath_ = labelMapPath_;
        if (((from_bitField0_ & 0x00000004) != 0)) {
          to_bitField0_ |= 0x00000004;
        }
        result.shuffle_ = shuffle_;
        if (((from_bitField0_ & 0x00000008) != 0)) {
          to_bitField0_ |= 0x00000008;
        }
        result.shuffleBufferSize_ = shuffleBufferSize_;
        if (((from_bitField0_ & 0x00000010) != 0)) {
          to_bitField0_ |= 0x00000010;
        }
        result.filenamesShuffleBufferSize_ = filenamesShuffleBufferSize_;
        if (((from_bitField0_ & 0x00000020) != 0)) {
          result.numEpochs_ = numEpochs_;
          to_bitField0_ |= 0x00000020;
        }
        if (((from_bitField0_ & 0x00000040) != 0)) {
          to_bitField0_ |= 0x00000040;
        }
        result.sample1OfNExamples_ = sample1OfNExamples_;
        if (((from_bitField0_ & 0x00000080) != 0)) {
          to_bitField0_ |= 0x00000080;
        }
        result.numReaders_ = numReaders_;
        if (((from_bitField0_ & 0x00000100) != 0)) {
          to_bitField0_ |= 0x00000100;
        }
        result.numParallelBatches_ = numParallelBatches_;
        if (((from_bitField0_ & 0x00000200) != 0)) {
          to_bitField0_ |= 0x00000200;
        }
        result.numPrefetchBatches_ = numPrefetchBatches_;
        if (((from_bitField0_ & 0x00000400) != 0)) {
          to_bitField0_ |= 0x00000400;
        }
        result.queueCapacity_ = queueCapacity_;
        if (((from_bitField0_ & 0x00000800) != 0)) {
          to_bitField0_ |= 0x00000800;
        }
        result.minAfterDequeue_ = minAfterDequeue_;
        if (((from_bitField0_ & 0x00001000) != 0)) {
          to_bitField0_ |= 0x00001000;
        }
        result.readBlockLength_ = readBlockLength_;
        if (((from_bitField0_ & 0x00002000) != 0)) {
          to_bitField0_ |= 0x00002000;
        }
        result.prefetchSize_ = prefetchSize_;
        if (((from_bitField0_ & 0x00004000) != 0)) {
          to_bitField0_ |= 0x00004000;
        }
        result.numParallelMapCalls_ = numParallelMapCalls_;
        if (((from_bitField0_ & 0x00008000) != 0)) {
          to_bitField0_ |= 0x00008000;
        }
        result.dropRemainder_ = dropRemainder_;
        if (((from_bitField0_ & 0x00010000) != 0)) {
          result.numAdditionalChannels_ = numAdditionalChannels_;
          to_bitField0_ |= 0x00010000;
        }
        if (((from_bitField0_ & 0x00020000) != 0)) {
          result.numKeypoints_ = numKeypoints_;
          to_bitField0_ |= 0x00020000;
        }
        if (((bitField0_ & 0x00040000) != 0)) {
          keypointTypeWeight_.makeImmutable();
          bitField0_ = (bitField0_ & ~0x00040000);
        }
        result.keypointTypeWeight_ = keypointTypeWeight_;
        if (((from_bitField0_ & 0x00080000) != 0)) {
          to_bitField0_ |= 0x00040000;
        }
        result.maxNumberOfBoxes_ = maxNumberOfBoxes_;
        if (((from_bitField0_ & 0x00100000) != 0)) {
          result.loadMulticlassScores_ = loadMulticlassScores_;
          to_bitField0_ |= 0x00080000;
        }
        if (((from_bitField0_ & 0x00200000) != 0)) {
          result.loadContextFeatures_ = loadContextFeatures_;
          to_bitField0_ |= 0x00100000;
        }
        if (((from_bitField0_ & 0x00400000) != 0)) {
          result.loadContextImageIds_ = loadContextImageIds_;
          to_bitField0_ |= 0x00200000;
        }
        if (((from_bitField0_ & 0x00800000) != 0)) {
          result.loadInstanceMasks_ = loadInstanceMasks_;
          to_bitField0_ |= 0x00400000;
        }
        if (((from_bitField0_ & 0x01000000) != 0)) {
          to_bitField0_ |= 0x00800000;
        }
        result.maskType_ = maskType_;
        if (((from_bitField0_ & 0x02000000) != 0)) {
          result.loadDensePose_ = loadDensePose_;
          to_bitField0_ |= 0x01000000;
        }
        if (((from_bitField0_ & 0x04000000) != 0)) {
          result.loadTrackId_ = loadTrackId_;
          to_bitField0_ |= 0x02000000;
        }
        if (((from_bitField0_ & 0x08000000) != 0)) {
          result.useDisplayName_ = useDisplayName_;
          to_bitField0_ |= 0x04000000;
        }
        if (((from_bitField0_ & 0x10000000) != 0)) {
          result.includeSourceId_ = includeSourceId_;
          to_bitField0_ |= 0x08000000;
        }
        if (((from_bitField0_ & 0x20000000) != 0)) {
          to_bitField0_ |= 0x10000000;
        }
        result.inputType_ = inputType_;
        if (((from_bitField0_ & 0x40000000) != 0)) {
          to_bitField0_ |= 0x20000000;
        }
        result.frameIndex_ = frameIndex_;
        if (inputReaderCase_ == 8) {
          if (tfRecordInputReaderBuilder_ == null) {
            result.inputReader_ = inputReader_;
          } else {
            result.inputReader_ = tfRecordInputReaderBuilder_.build();
          }
        }
        if (inputReaderCase_ == 9) {
          if (externalInputReaderBuilder_ == null) {
            result.inputReader_ = inputReader_;
          } else {
            result.inputReader_ = externalInputReaderBuilder_.build();
          }
        }
        if (((bitField1_ & 0x00000002) != 0)) {
          sampleFromDatasetsWeights_.makeImmutable();
          bitField1_ = (bitField1_ & ~0x00000002);
        }
        result.sampleFromDatasetsWeights_ = sampleFromDatasetsWeights_;
        if (((from_bitField1_ & 0x00000004) != 0)) {
          result.expandLabelsHierarchy_ = expandLabelsHierarchy_;
          to_bitField1_ |= 0x00000001;
        }
        result.bitField0_ = to_bitField0_;
        result.bitField1_ = to_bitField1_;
        result.inputReaderCase_ = inputReaderCase_;
        onBuilt();
        return result;
      }

      @java.lang.Override
      public Builder clone() {
        return super.clone();
      }
      @java.lang.Override
      public Builder setField(
          com.google.protobuf.Descriptors.FieldDescriptor field,
          java.lang.Object value) {
        return super.setField(field, value);
      }
      @java.lang.Override
      public Builder clearField(
          com.google.protobuf.Descriptors.FieldDescriptor field) {
        return super.clearField(field);
      }
      @java.lang.Override
      public Builder clearOneof(
          com.google.protobuf.Descriptors.OneofDescriptor oneof) {
        return super.clearOneof(oneof);
      }
      @java.lang.Override
      public Builder setRepeatedField(
          com.google.protobuf.Descriptors.FieldDescriptor field,
          int index, java.lang.Object value) {
        return super.setRepeatedField(field, index, value);
      }
      @java.lang.Override
      public Builder addRepeatedField(
          com.google.protobuf.Descriptors.FieldDescriptor field,
          java.lang.Object value) {
        return super.addRepeatedField(field, value);
      }
      @java.lang.Override
      public Builder mergeFrom(com.google.protobuf.Message other) {
        if (other instanceof object_detection.protos.InputReaderOuterClass.InputReader) {
          return mergeFrom((object_detection.protos.InputReaderOuterClass.InputReader)other);
        } else {
          super.mergeFrom(other);
          return this;
        }
      }

      public Builder mergeFrom(object_detection.protos.InputReaderOuterClass.InputReader other) {
        if (other == object_detection.protos.InputReaderOuterClass.InputReader.getDefaultInstance()) return this;
        if (other.hasName()) {
          bitField0_ |= 0x00000001;
          name_ = other.name_;
          onChanged();
        }
        if (other.hasLabelMapPath()) {
          bitField0_ |= 0x00000002;
          labelMapPath_ = other.labelMapPath_;
          onChanged();
        }
        if (other.hasShuffle()) {
          setShuffle(other.getShuffle());
        }
        if (other.hasShuffleBufferSize()) {
          setShuffleBufferSize(other.getShuffleBufferSize());
        }
        if (other.hasFilenamesShuffleBufferSize()) {
          setFilenamesShuffleBufferSize(other.getFilenamesShuffleBufferSize());
        }
        if (other.hasNumEpochs()) {
          setNumEpochs(other.getNumEpochs());
        }
        if (other.hasSample1OfNExamples()) {
          setSample1OfNExamples(other.getSample1OfNExamples());
        }
        if (other.hasNumReaders()) {
          setNumReaders(other.getNumReaders());
        }
        if (other.hasNumParallelBatches()) {
          setNumParallelBatches(other.getNumParallelBatches());
        }
        if (other.hasNumPrefetchBatches()) {
          setNumPrefetchBatches(other.getNumPrefetchBatches());
        }
        if (other.hasQueueCapacity()) {
          setQueueCapacity(other.getQueueCapacity());
        }
        if (other.hasMinAfterDequeue()) {
          setMinAfterDequeue(other.getMinAfterDequeue());
        }
        if (other.hasReadBlockLength()) {
          setReadBlockLength(other.getReadBlockLength());
        }
        if (other.hasPrefetchSize()) {
          setPrefetchSize(other.getPrefetchSize());
        }
        if (other.hasNumParallelMapCalls()) {
          setNumParallelMapCalls(other.getNumParallelMapCalls());
        }
        if (other.hasDropRemainder()) {
          setDropRemainder(other.getDropRemainder());
        }
        if (other.hasNumAdditionalChannels()) {
          setNumAdditionalChannels(other.getNumAdditionalChannels());
        }
        if (other.hasNumKeypoints()) {
          setNumKeypoints(other.getNumKeypoints());
        }
        if (!other.keypointTypeWeight_.isEmpty()) {
          if (keypointTypeWeight_.isEmpty()) {
            keypointTypeWeight_ = other.keypointTypeWeight_;
            bitField0_ = (bitField0_ & ~0x00040000);
          } else {
            ensureKeypointTypeWeightIsMutable();
            keypointTypeWeight_.addAll(other.keypointTypeWeight_);
          }
          onChanged();
        }
        if (other.hasMaxNumberOfBoxes()) {
          setMaxNumberOfBoxes(other.getMaxNumberOfBoxes());
        }
        if (other.hasLoadMulticlassScores()) {
          setLoadMulticlassScores(other.getLoadMulticlassScores());
        }
        if (other.hasLoadContextFeatures()) {
          setLoadContextFeatures(other.getLoadContextFeatures());
        }
        if (other.hasLoadContextImageIds()) {
          setLoadContextImageIds(other.getLoadContextImageIds());
        }
        if (other.hasLoadInstanceMasks()) {
          setLoadInstanceMasks(other.getLoadInstanceMasks());
        }
        if (other.hasMaskType()) {
          setMaskType(other.getMaskType());
        }
        if (other.hasLoadDensePose()) {
          setLoadDensePose(other.getLoadDensePose());
        }
        if (other.hasLoadTrackId()) {
          setLoadTrackId(other.getLoadTrackId());
        }
        if (other.hasUseDisplayName()) {
          setUseDisplayName(other.getUseDisplayName());
        }
        if (other.hasIncludeSourceId()) {
          setIncludeSourceId(other.getIncludeSourceId());
        }
        if (other.hasInputType()) {
          setInputType(other.getInputType());
        }
        if (other.hasFrameIndex()) {
          setFrameIndex(other.getFrameIndex());
        }
        if (!other.sampleFromDatasetsWeights_.isEmpty()) {
          if (sampleFromDatasetsWeights_.isEmpty()) {
            sampleFromDatasetsWeights_ = other.sampleFromDatasetsWeights_;
            bitField1_ = (bitField1_ & ~0x00000002);
          } else {
            ensureSampleFromDatasetsWeightsIsMutable();
            sampleFromDatasetsWeights_.addAll(other.sampleFromDatasetsWeights_);
          }
          onChanged();
        }
        if (other.hasExpandLabelsHierarchy()) {
          setExpandLabelsHierarchy(other.getExpandLabelsHierarchy());
        }
        switch (other.getInputReaderCase()) {
          case TF_RECORD_INPUT_READER: {
            mergeTfRecordInputReader(other.getTfRecordInputReader());
            break;
          }
          case EXTERNAL_INPUT_READER: {
            mergeExternalInputReader(other.getExternalInputReader());
            break;
          }
          case INPUTREADER_NOT_SET: {
            break;
          }
        }
        this.mergeUnknownFields(other.unknownFields);
        onChanged();
        return this;
      }

      @java.lang.Override
      public final boolean isInitialized() {
        if (hasExternalInputReader()) {
          if (!getExternalInputReader().isInitialized()) {
            return false;
          }
        }
        return true;
      }

      @java.lang.Override
      public Builder mergeFrom(
          com.google.protobuf.CodedInputStream input,
          com.google.protobuf.ExtensionRegistryLite extensionRegistry)
          throws java.io.IOException {
        object_detection.protos.InputReaderOuterClass.InputReader parsedMessage = null;
        try {
          parsedMessage = PARSER.parsePartialFrom(input, extensionRegistry);
        } catch (com.google.protobuf.InvalidProtocolBufferException e) {
          parsedMessage = (object_detection.protos.InputReaderOuterClass.InputReader) e.getUnfinishedMessage();
          throw e.unwrapIOException();
        } finally {
          if (parsedMessage != null) {
            mergeFrom(parsedMessage);
          }
        }
        return this;
      }
      private int inputReaderCase_ = 0;
      private java.lang.Object inputReader_;
      public InputReaderCase
          getInputReaderCase() {
        return InputReaderCase.forNumber(
            inputReaderCase_);
      }

      public Builder clearInputReader() {
        inputReaderCase_ = 0;
        inputReader_ = null;
        onChanged();
        return this;
      }

      private int bitField0_;
      private int bitField1_;

      private java.lang.Object name_ = "";
      /**
       * <pre>
       * Name of input reader. Typically used to describe the dataset that is read
       * by this input reader.
       * </pre>
       *
       * <code>optional string name = 23 [default = ""];</code>
       * @return Whether the name field is set.
       */
      public boolean hasName() {
        return ((bitField0_ & 0x00000001) != 0);
      }
      /**
       * <pre>
       * Name of input reader. Typically used to describe the dataset that is read
       * by this input reader.
       * </pre>
       *
       * <code>optional string name = 23 [default = ""];</code>
       * @return The name.
       */
      public java.lang.String getName() {
        java.lang.Object ref = name_;
        if (!(ref instanceof java.lang.String)) {
          com.google.protobuf.ByteString bs =
              (com.google.protobuf.ByteString) ref;
          java.lang.String s = bs.toStringUtf8();
          if (bs.isValidUtf8()) {
            name_ = s;
          }
          return s;
        } else {
          return (java.lang.String) ref;
        }
      }
      /**
       * <pre>
       * Name of input reader. Typically used to describe the dataset that is read
       * by this input reader.
       * </pre>
       *
       * <code>optional string name = 23 [default = ""];</code>
       * @return The bytes for name.
       */
      public com.google.protobuf.ByteString
          getNameBytes() {
        java.lang.Object ref = name_;
        if (ref instanceof String) {
          com.google.protobuf.ByteString b =
              com.google.protobuf.ByteString.copyFromUtf8(
                  (java.lang.String) ref);
          name_ = b;
          return b;
        } else {
          return (com.google.protobuf.ByteString) ref;
        }
      }
      /**
       * <pre>
       * Name of input reader. Typically used to describe the dataset that is read
       * by this input reader.
       * </pre>
       *
       * <code>optional string name = 23 [default = ""];</code>
       * @param value The name to set.
       * @return This builder for chaining.
       */
      public Builder setName(
          java.lang.String value) {
        if (value == null) {
    throw new NullPointerException();
  }
  bitField0_ |= 0x00000001;
        name_ = value;
        onChanged();
        return this;
      }
      /**
       * <pre>
       * Name of input reader. Typically used to describe the dataset that is read
       * by this input reader.
       * </pre>
       *
       * <code>optional string name = 23 [default = ""];</code>
       * @return This builder for chaining.
       */
      public Builder clearName() {
        bitField0_ = (bitField0_ & ~0x00000001);
        name_ = getDefaultInstance().getName();
        onChanged();
        return this;
      }
      /**
       * <pre>
       * Name of input reader. Typically used to describe the dataset that is read
       * by this input reader.
       * </pre>
       *
       * <code>optional string name = 23 [default = ""];</code>
       * @param value The bytes for name to set.
       * @return This builder for chaining.
       */
      public Builder setNameBytes(
          com.google.protobuf.ByteString value) {
        if (value == null) {
    throw new NullPointerException();
  }
  bitField0_ |= 0x00000001;
        name_ = value;
        onChanged();
        return this;
      }

      private java.lang.Object labelMapPath_ = "";
      /**
       * <pre>
       * Path to StringIntLabelMap pbtxt file specifying the mapping from string
       * labels to integer ids.
       * </pre>
       *
       * <code>optional string label_map_path = 1 [default = ""];</code>
       * @return Whether the labelMapPath field is set.
       */
      public boolean hasLabelMapPath() {
        return ((bitField0_ & 0x00000002) != 0);
      }
      /**
       * <pre>
       * Path to StringIntLabelMap pbtxt file specifying the mapping from string
       * labels to integer ids.
       * </pre>
       *
       * <code>optional string label_map_path = 1 [default = ""];</code>
       * @return The labelMapPath.
       */
      public java.lang.String getLabelMapPath() {
        java.lang.Object ref = labelMapPath_;
        if (!(ref instanceof java.lang.String)) {
          com.google.protobuf.ByteString bs =
              (com.google.protobuf.ByteString) ref;
          java.lang.String s = bs.toStringUtf8();
          if (bs.isValidUtf8()) {
            labelMapPath_ = s;
          }
          return s;
        } else {
          return (java.lang.String) ref;
        }
      }
      /**
       * <pre>
       * Path to StringIntLabelMap pbtxt file specifying the mapping from string
       * labels to integer ids.
       * </pre>
       *
       * <code>optional string label_map_path = 1 [default = ""];</code>
       * @return The bytes for labelMapPath.
       */
      public com.google.protobuf.ByteString
          getLabelMapPathBytes() {
        java.lang.Object ref = labelMapPath_;
        if (ref instanceof String) {
          com.google.protobuf.ByteString b =
              com.google.protobuf.ByteString.copyFromUtf8(
                  (java.lang.String) ref);
          labelMapPath_ = b;
          return b;
        } else {
          return (com.google.protobuf.ByteString) ref;
        }
      }
      /**
       * <pre>
       * Path to StringIntLabelMap pbtxt file specifying the mapping from string
       * labels to integer ids.
       * </pre>
       *
       * <code>optional string label_map_path = 1 [default = ""];</code>
       * @param value The labelMapPath to set.
       * @return This builder for chaining.
       */
      public Builder setLabelMapPath(
          java.lang.String value) {
        if (value == null) {
    throw new NullPointerException();
  }
  bitField0_ |= 0x00000002;
        labelMapPath_ = value;
        onChanged();
        return this;
      }
      /**
       * <pre>
       * Path to StringIntLabelMap pbtxt file specifying the mapping from string
       * labels to integer ids.
       * </pre>
       *
       * <code>optional string label_map_path = 1 [default = ""];</code>
       * @return This builder for chaining.
       */
      public Builder clearLabelMapPath() {
        bitField0_ = (bitField0_ & ~0x00000002);
        labelMapPath_ = getDefaultInstance().getLabelMapPath();
        onChanged();
        return this;
      }
      /**
       * <pre>
       * Path to StringIntLabelMap pbtxt file specifying the mapping from string
       * labels to integer ids.
       * </pre>
       *
       * <code>optional string label_map_path = 1 [default = ""];</code>
       * @param value The bytes for labelMapPath to set.
       * @return This builder for chaining.
       */
      public Builder setLabelMapPathBytes(
          com.google.protobuf.ByteString value) {
        if (value == null) {
    throw new NullPointerException();
  }
  bitField0_ |= 0x00000002;
        labelMapPath_ = value;
        onChanged();
        return this;
      }

      private boolean shuffle_ = true;
      /**
       * <pre>
       * Whether data should be processed in the order they are read in, or
       * shuffled randomly.
       * </pre>
       *
       * <code>optional bool shuffle = 2 [default = true];</code>
       * @return Whether the shuffle field is set.
       */
      @java.lang.Override
      public boolean hasShuffle() {
        return ((bitField0_ & 0x00000004) != 0);
      }
      /**
       * <pre>
       * Whether data should be processed in the order they are read in, or
       * shuffled randomly.
       * </pre>
       *
       * <code>optional bool shuffle = 2 [default = true];</code>
       * @return The shuffle.
       */
      @java.lang.Override
      public boolean getShuffle() {
        return shuffle_;
      }
      /**
       * <pre>
       * Whether data should be processed in the order they are read in, or
       * shuffled randomly.
       * </pre>
       *
       * <code>optional bool shuffle = 2 [default = true];</code>
       * @param value The shuffle to set.
       * @return This builder for chaining.
       */
      public Builder setShuffle(boolean value) {
        bitField0_ |= 0x00000004;
        shuffle_ = value;
        onChanged();
        return this;
      }
      /**
       * <pre>
       * Whether data should be processed in the order they are read in, or
       * shuffled randomly.
       * </pre>
       *
       * <code>optional bool shuffle = 2 [default = true];</code>
       * @return This builder for chaining.
       */
      public Builder clearShuffle() {
        bitField0_ = (bitField0_ & ~0x00000004);
        shuffle_ = true;
        onChanged();
        return this;
      }

      private int shuffleBufferSize_ = 2048;
      /**
       * <pre>
       * Buffer size to be used when shuffling.
       * </pre>
       *
       * <code>optional uint32 shuffle_buffer_size = 11 [default = 2048];</code>
       * @return Whether the shuffleBufferSize field is set.
       */
      @java.lang.Override
      public boolean hasShuffleBufferSize() {
        return ((bitField0_ & 0x00000008) != 0);
      }
      /**
       * <pre>
       * Buffer size to be used when shuffling.
       * </pre>
       *
       * <code>optional uint32 shuffle_buffer_size = 11 [default = 2048];</code>
       * @return The shuffleBufferSize.
       */
      @java.lang.Override
      public int getShuffleBufferSize() {
        return shuffleBufferSize_;
      }
      /**
       * <pre>
       * Buffer size to be used when shuffling.
       * </pre>
       *
       * <code>optional uint32 shuffle_buffer_size = 11 [default = 2048];</code>
       * @param value The shuffleBufferSize to set.
       * @return This builder for chaining.
       */
      public Builder setShuffleBufferSize(int value) {
        bitField0_ |= 0x00000008;
        shuffleBufferSize_ = value;
        onChanged();
        return this;
      }
      /**
       * <pre>
       * Buffer size to be used when shuffling.
       * </pre>
       *
       * <code>optional uint32 shuffle_buffer_size = 11 [default = 2048];</code>
       * @return This builder for chaining.
       */
      public Builder clearShuffleBufferSize() {
        bitField0_ = (bitField0_ & ~0x00000008);
        shuffleBufferSize_ = 2048;
        onChanged();
        return this;
      }

      private int filenamesShuffleBufferSize_ = 100;
      /**
       * <pre>
       * Buffer size to be used when shuffling file names.
       * </pre>
       *
       * <code>optional uint32 filenames_shuffle_buffer_size = 12 [default = 100];</code>
       * @return Whether the filenamesShuffleBufferSize field is set.
       */
      @java.lang.Override
      public boolean hasFilenamesShuffleBufferSize() {
        return ((bitField0_ & 0x00000010) != 0);
      }
      /**
       * <pre>
       * Buffer size to be used when shuffling file names.
       * </pre>
       *
       * <code>optional uint32 filenames_shuffle_buffer_size = 12 [default = 100];</code>
       * @return The filenamesShuffleBufferSize.
       */
      @java.lang.Override
      public int getFilenamesShuffleBufferSize() {
        return filenamesShuffleBufferSize_;
      }
      /**
       * <pre>
       * Buffer size to be used when shuffling file names.
       * </pre>
       *
       * <code>optional uint32 filenames_shuffle_buffer_size = 12 [default = 100];</code>
       * @param value The filenamesShuffleBufferSize to set.
       * @return This builder for chaining.
       */
      public Builder setFilenamesShuffleBufferSize(int value) {
        bitField0_ |= 0x00000010;
        filenamesShuffleBufferSize_ = value;
        onChanged();
        return this;
      }
      /**
       * <pre>
       * Buffer size to be used when shuffling file names.
       * </pre>
       *
       * <code>optional uint32 filenames_shuffle_buffer_size = 12 [default = 100];</code>
       * @return This builder for chaining.
       */
      public Builder clearFilenamesShuffleBufferSize() {
        bitField0_ = (bitField0_ & ~0x00000010);
        filenamesShuffleBufferSize_ = 100;
        onChanged();
        return this;
      }

      private int numEpochs_ ;
      /**
       * <pre>
       * The number of times a data source is read. If set to zero, the data source
       * will be reused indefinitely.
       * </pre>
       *
       * <code>optional uint32 num_epochs = 5 [default = 0];</code>
       * @return Whether the numEpochs field is set.
       */
      @java.lang.Override
      public boolean hasNumEpochs() {
        return ((bitField0_ & 0x00000020) != 0);
      }
      /**
       * <pre>
       * The number of times a data source is read. If set to zero, the data source
       * will be reused indefinitely.
       * </pre>
       *
       * <code>optional uint32 num_epochs = 5 [default = 0];</code>
       * @return The numEpochs.
       */
      @java.lang.Override
      public int getNumEpochs() {
        return numEpochs_;
      }
      /**
       * <pre>
       * The number of times a data source is read. If set to zero, the data source
       * will be reused indefinitely.
       * </pre>
       *
       * <code>optional uint32 num_epochs = 5 [default = 0];</code>
       * @param value The numEpochs to set.
       * @return This builder for chaining.
       */
      public Builder setNumEpochs(int value) {
        bitField0_ |= 0x00000020;
        numEpochs_ = value;
        onChanged();
        return this;
      }
      /**
       * <pre>
       * The number of times a data source is read. If set to zero, the data source
       * will be reused indefinitely.
       * </pre>
       *
       * <code>optional uint32 num_epochs = 5 [default = 0];</code>
       * @return This builder for chaining.
       */
      public Builder clearNumEpochs() {
        bitField0_ = (bitField0_ & ~0x00000020);
        numEpochs_ = 0;
        onChanged();
        return this;
      }

      private int sample1OfNExamples_ = 1;
      /**
       * <pre>
       * Integer representing how often an example should be sampled. To feed
       * only 1/3 of your data into your model, set `sample_1_of_n_examples` to 3.
       * This is particularly useful for evaluation, where you might not prefer to
       * evaluate all of your samples.
       * </pre>
       *
       * <code>optional uint32 sample_1_of_n_examples = 22 [default = 1];</code>
       * @return Whether the sample1OfNExamples field is set.
       */
      @java.lang.Override
      public boolean hasSample1OfNExamples() {
        return ((bitField0_ & 0x00000040) != 0);
      }
      /**
       * <pre>
       * Integer representing how often an example should be sampled. To feed
       * only 1/3 of your data into your model, set `sample_1_of_n_examples` to 3.
       * This is particularly useful for evaluation, where you might not prefer to
       * evaluate all of your samples.
       * </pre>
       *
       * <code>optional uint32 sample_1_of_n_examples = 22 [default = 1];</code>
       * @return The sample1OfNExamples.
       */
      @java.lang.Override
      public int getSample1OfNExamples() {
        return sample1OfNExamples_;
      }
      /**
       * <pre>
       * Integer representing how often an example should be sampled. To feed
       * only 1/3 of your data into your model, set `sample_1_of_n_examples` to 3.
       * This is particularly useful for evaluation, where you might not prefer to
       * evaluate all of your samples.
       * </pre>
       *
       * <code>optional uint32 sample_1_of_n_examples = 22 [default = 1];</code>
       * @param value The sample1OfNExamples to set.
       * @return This builder for chaining.
       */
      public Builder setSample1OfNExamples(int value) {
        bitField0_ |= 0x00000040;
        sample1OfNExamples_ = value;
        onChanged();
        return this;
      }
      /**
       * <pre>
       * Integer representing how often an example should be sampled. To feed
       * only 1/3 of your data into your model, set `sample_1_of_n_examples` to 3.
       * This is particularly useful for evaluation, where you might not prefer to
       * evaluate all of your samples.
       * </pre>
       *
       * <code>optional uint32 sample_1_of_n_examples = 22 [default = 1];</code>
       * @return This builder for chaining.
       */
      public Builder clearSample1OfNExamples() {
        bitField0_ = (bitField0_ & ~0x00000040);
        sample1OfNExamples_ = 1;
        onChanged();
        return this;
      }

      private int numReaders_ = 64;
      /**
       * <pre>
       * Number of file shards to read in parallel.
       * When sample_from_datasets_weights are configured, num_readers is applied
       * for each dataset.
       * </pre>
       *
       * <code>optional uint32 num_readers = 6 [default = 64];</code>
       * @return Whether the numReaders field is set.
       */
      @java.lang.Override
      public boolean hasNumReaders() {
        return ((bitField0_ & 0x00000080) != 0);
      }
      /**
       * <pre>
       * Number of file shards to read in parallel.
       * When sample_from_datasets_weights are configured, num_readers is applied
       * for each dataset.
       * </pre>
       *
       * <code>optional uint32 num_readers = 6 [default = 64];</code>
       * @return The numReaders.
       */
      @java.lang.Override
      public int getNumReaders() {
        return numReaders_;
      }
      /**
       * <pre>
       * Number of file shards to read in parallel.
       * When sample_from_datasets_weights are configured, num_readers is applied
       * for each dataset.
       * </pre>
       *
       * <code>optional uint32 num_readers = 6 [default = 64];</code>
       * @param value The numReaders to set.
       * @return This builder for chaining.
       */
      public Builder setNumReaders(int value) {
        bitField0_ |= 0x00000080;
        numReaders_ = value;
        onChanged();
        return this;
      }
      /**
       * <pre>
       * Number of file shards to read in parallel.
       * When sample_from_datasets_weights are configured, num_readers is applied
       * for each dataset.
       * </pre>
       *
       * <code>optional uint32 num_readers = 6 [default = 64];</code>
       * @return This builder for chaining.
       */
      public Builder clearNumReaders() {
        bitField0_ = (bitField0_ & ~0x00000080);
        numReaders_ = 64;
        onChanged();
        return this;
      }

      private int numParallelBatches_ = 8;
      /**
       * <pre>
       * Number of batches to produce in parallel. If this is run on a 2x2 TPU set
       * this to 8.
       * </pre>
       *
       * <code>optional uint32 num_parallel_batches = 19 [default = 8];</code>
       * @return Whether the numParallelBatches field is set.
       */
      @java.lang.Override
      public boolean hasNumParallelBatches() {
        return ((bitField0_ & 0x00000100) != 0);
      }
      /**
       * <pre>
       * Number of batches to produce in parallel. If this is run on a 2x2 TPU set
       * this to 8.
       * </pre>
       *
       * <code>optional uint32 num_parallel_batches = 19 [default = 8];</code>
       * @return The numParallelBatches.
       */
      @java.lang.Override
      public int getNumParallelBatches() {
        return numParallelBatches_;
      }
      /**
       * <pre>
       * Number of batches to produce in parallel. If this is run on a 2x2 TPU set
       * this to 8.
       * </pre>
       *
       * <code>optional uint32 num_parallel_batches = 19 [default = 8];</code>
       * @param value The numParallelBatches to set.
       * @return This builder for chaining.
       */
      public Builder setNumParallelBatches(int value) {
        bitField0_ |= 0x00000100;
        numParallelBatches_ = value;
        onChanged();
        return this;
      }
      /**
       * <pre>
       * Number of batches to produce in parallel. If this is run on a 2x2 TPU set
       * this to 8.
       * </pre>
       *
       * <code>optional uint32 num_parallel_batches = 19 [default = 8];</code>
       * @return This builder for chaining.
       */
      public Builder clearNumParallelBatches() {
        bitField0_ = (bitField0_ & ~0x00000100);
        numParallelBatches_ = 8;
        onChanged();
        return this;
      }

      private int numPrefetchBatches_ = 2;
      /**
       * <pre>
       * Number of batches to prefetch. Prefetch decouples input pipeline and
       * model so they can be pipelined resulting in higher throughput. Set this
       * to a small constant and increment linearly until the improvements become
       * marginal or you exceed your cpu memory budget. Setting this to -1,
       * automatically tunes this value for you.
       * </pre>
       *
       * <code>optional int32 num_prefetch_batches = 20 [default = 2];</code>
       * @return Whether the numPrefetchBatches field is set.
       */
      @java.lang.Override
      public boolean hasNumPrefetchBatches() {
        return ((bitField0_ & 0x00000200) != 0);
      }
      /**
       * <pre>
       * Number of batches to prefetch. Prefetch decouples input pipeline and
       * model so they can be pipelined resulting in higher throughput. Set this
       * to a small constant and increment linearly until the improvements become
       * marginal or you exceed your cpu memory budget. Setting this to -1,
       * automatically tunes this value for you.
       * </pre>
       *
       * <code>optional int32 num_prefetch_batches = 20 [default = 2];</code>
       * @return The numPrefetchBatches.
       */
      @java.lang.Override
      public int getNumPrefetchBatches() {
        return numPrefetchBatches_;
      }
      /**
       * <pre>
       * Number of batches to prefetch. Prefetch decouples input pipeline and
       * model so they can be pipelined resulting in higher throughput. Set this
       * to a small constant and increment linearly until the improvements become
       * marginal or you exceed your cpu memory budget. Setting this to -1,
       * automatically tunes this value for you.
       * </pre>
       *
       * <code>optional int32 num_prefetch_batches = 20 [default = 2];</code>
       * @param value The numPrefetchBatches to set.
       * @return This builder for chaining.
       */
      public Builder setNumPrefetchBatches(int value) {
        bitField0_ |= 0x00000200;
        numPrefetchBatches_ = value;
        onChanged();
        return this;
      }
      /**
       * <pre>
       * Number of batches to prefetch. Prefetch decouples input pipeline and
       * model so they can be pipelined resulting in higher throughput. Set this
       * to a small constant and increment linearly until the improvements become
       * marginal or you exceed your cpu memory budget. Setting this to -1,
       * automatically tunes this value for you.
       * </pre>
       *
       * <code>optional int32 num_prefetch_batches = 20 [default = 2];</code>
       * @return This builder for chaining.
       */
      public Builder clearNumPrefetchBatches() {
        bitField0_ = (bitField0_ & ~0x00000200);
        numPrefetchBatches_ = 2;
        onChanged();
        return this;
      }

      private int queueCapacity_ = 2000;
      /**
       * <pre>
       * Maximum number of records to keep in reader queue.
       * </pre>
       *
       * <code>optional uint32 queue_capacity = 3 [default = 2000, deprecated = true];</code>
       * @return Whether the queueCapacity field is set.
       */
      @java.lang.Override
      @java.lang.Deprecated public boolean hasQueueCapacity() {
        return ((bitField0_ & 0x00000400) != 0);
      }
      /**
       * <pre>
       * Maximum number of records to keep in reader queue.
       * </pre>
       *
       * <code>optional uint32 queue_capacity = 3 [default = 2000, deprecated = true];</code>
       * @return The queueCapacity.
       */
      @java.lang.Override
      @java.lang.Deprecated public int getQueueCapacity() {
        return queueCapacity_;
      }
      /**
       * <pre>
       * Maximum number of records to keep in reader queue.
       * </pre>
       *
       * <code>optional uint32 queue_capacity = 3 [default = 2000, deprecated = true];</code>
       * @param value The queueCapacity to set.
       * @return This builder for chaining.
       */
      @java.lang.Deprecated public Builder setQueueCapacity(int value) {
        bitField0_ |= 0x00000400;
        queueCapacity_ = value;
        onChanged();
        return this;
      }
      /**
       * <pre>
       * Maximum number of records to keep in reader queue.
       * </pre>
       *
       * <code>optional uint32 queue_capacity = 3 [default = 2000, deprecated = true];</code>
       * @return This builder for chaining.
       */
      @java.lang.Deprecated public Builder clearQueueCapacity() {
        bitField0_ = (bitField0_ & ~0x00000400);
        queueCapacity_ = 2000;
        onChanged();
        return this;
      }

      private int minAfterDequeue_ = 1000;
      /**
       * <pre>
       * Minimum number of records to keep in reader queue. A large value is needed
       * to generate a good random shuffle.
       * </pre>
       *
       * <code>optional uint32 min_after_dequeue = 4 [default = 1000, deprecated = true];</code>
       * @return Whether the minAfterDequeue field is set.
       */
      @java.lang.Override
      @java.lang.Deprecated public boolean hasMinAfterDequeue() {
        return ((bitField0_ & 0x00000800) != 0);
      }
      /**
       * <pre>
       * Minimum number of records to keep in reader queue. A large value is needed
       * to generate a good random shuffle.
       * </pre>
       *
       * <code>optional uint32 min_after_dequeue = 4 [default = 1000, deprecated = true];</code>
       * @return The minAfterDequeue.
       */
      @java.lang.Override
      @java.lang.Deprecated public int getMinAfterDequeue() {
        return minAfterDequeue_;
      }
      /**
       * <pre>
       * Minimum number of records to keep in reader queue. A large value is needed
       * to generate a good random shuffle.
       * </pre>
       *
       * <code>optional uint32 min_after_dequeue = 4 [default = 1000, deprecated = true];</code>
       * @param value The minAfterDequeue to set.
       * @return This builder for chaining.
       */
      @java.lang.Deprecated public Builder setMinAfterDequeue(int value) {
        bitField0_ |= 0x00000800;
        minAfterDequeue_ = value;
        onChanged();
        return this;
      }
      /**
       * <pre>
       * Minimum number of records to keep in reader queue. A large value is needed
       * to generate a good random shuffle.
       * </pre>
       *
       * <code>optional uint32 min_after_dequeue = 4 [default = 1000, deprecated = true];</code>
       * @return This builder for chaining.
       */
      @java.lang.Deprecated public Builder clearMinAfterDequeue() {
        bitField0_ = (bitField0_ & ~0x00000800);
        minAfterDequeue_ = 1000;
        onChanged();
        return this;
      }

      private int readBlockLength_ = 32;
      /**
       * <pre>
       * Number of records to read from each reader at once.
       * </pre>
       *
       * <code>optional uint32 read_block_length = 15 [default = 32];</code>
       * @return Whether the readBlockLength field is set.
       */
      @java.lang.Override
      public boolean hasReadBlockLength() {
        return ((bitField0_ & 0x00001000) != 0);
      }
      /**
       * <pre>
       * Number of records to read from each reader at once.
       * </pre>
       *
       * <code>optional uint32 read_block_length = 15 [default = 32];</code>
       * @return The readBlockLength.
       */
      @java.lang.Override
      public int getReadBlockLength() {
        return readBlockLength_;
      }
      /**
       * <pre>
       * Number of records to read from each reader at once.
       * </pre>
       *
       * <code>optional uint32 read_block_length = 15 [default = 32];</code>
       * @param value The readBlockLength to set.
       * @return This builder for chaining.
       */
      public Builder setReadBlockLength(int value) {
        bitField0_ |= 0x00001000;
        readBlockLength_ = value;
        onChanged();
        return this;
      }
      /**
       * <pre>
       * Number of records to read from each reader at once.
       * </pre>
       *
       * <code>optional uint32 read_block_length = 15 [default = 32];</code>
       * @return This builder for chaining.
       */
      public Builder clearReadBlockLength() {
        bitField0_ = (bitField0_ & ~0x00001000);
        readBlockLength_ = 32;
        onChanged();
        return this;
      }

      private int prefetchSize_ = 512;
      /**
       * <pre>
       * Number of decoded records to prefetch before batching.
       * </pre>
       *
       * <code>optional uint32 prefetch_size = 13 [default = 512, deprecated = true];</code>
       * @return Whether the prefetchSize field is set.
       */
      @java.lang.Override
      @java.lang.Deprecated public boolean hasPrefetchSize() {
        return ((bitField0_ & 0x00002000) != 0);
      }
      /**
       * <pre>
       * Number of decoded records to prefetch before batching.
       * </pre>
       *
       * <code>optional uint32 prefetch_size = 13 [default = 512, deprecated = true];</code>
       * @return The prefetchSize.
       */
      @java.lang.Override
      @java.lang.Deprecated public int getPrefetchSize() {
        return prefetchSize_;
      }
      /**
       * <pre>
       * Number of decoded records to prefetch before batching.
       * </pre>
       *
       * <code>optional uint32 prefetch_size = 13 [default = 512, deprecated = true];</code>
       * @param value The prefetchSize to set.
       * @return This builder for chaining.
       */
      @java.lang.Deprecated public Builder setPrefetchSize(int value) {
        bitField0_ |= 0x00002000;
        prefetchSize_ = value;
        onChanged();
        return this;
      }
      /**
       * <pre>
       * Number of decoded records to prefetch before batching.
       * </pre>
       *
       * <code>optional uint32 prefetch_size = 13 [default = 512, deprecated = true];</code>
       * @return This builder for chaining.
       */
      @java.lang.Deprecated public Builder clearPrefetchSize() {
        bitField0_ = (bitField0_ & ~0x00002000);
        prefetchSize_ = 512;
        onChanged();
        return this;
      }

      private int numParallelMapCalls_ = 64;
      /**
       * <pre>
       * Number of parallel decode ops to apply.
       * </pre>
       *
       * <code>optional uint32 num_parallel_map_calls = 14 [default = 64, deprecated = true];</code>
       * @return Whether the numParallelMapCalls field is set.
       */
      @java.lang.Override
      @java.lang.Deprecated public boolean hasNumParallelMapCalls() {
        return ((bitField0_ & 0x00004000) != 0);
      }
      /**
       * <pre>
       * Number of parallel decode ops to apply.
       * </pre>
       *
       * <code>optional uint32 num_parallel_map_calls = 14 [default = 64, deprecated = true];</code>
       * @return The numParallelMapCalls.
       */
      @java.lang.Override
      @java.lang.Deprecated public int getNumParallelMapCalls() {
        return numParallelMapCalls_;
      }
      /**
       * <pre>
       * Number of parallel decode ops to apply.
       * </pre>
       *
       * <code>optional uint32 num_parallel_map_calls = 14 [default = 64, deprecated = true];</code>
       * @param value The numParallelMapCalls to set.
       * @return This builder for chaining.
       */
      @java.lang.Deprecated public Builder setNumParallelMapCalls(int value) {
        bitField0_ |= 0x00004000;
        numParallelMapCalls_ = value;
        onChanged();
        return this;
      }
      /**
       * <pre>
       * Number of parallel decode ops to apply.
       * </pre>
       *
       * <code>optional uint32 num_parallel_map_calls = 14 [default = 64, deprecated = true];</code>
       * @return This builder for chaining.
       */
      @java.lang.Deprecated public Builder clearNumParallelMapCalls() {
        bitField0_ = (bitField0_ & ~0x00004000);
        numParallelMapCalls_ = 64;
        onChanged();
        return this;
      }

      private boolean dropRemainder_ = true;
      /**
       * <pre>
       * Drop remainder when batch size does not divide dataset size.
       * </pre>
       *
       * <code>optional bool drop_remainder = 35 [default = true];</code>
       * @return Whether the dropRemainder field is set.
       */
      @java.lang.Override
      public boolean hasDropRemainder() {
        return ((bitField0_ & 0x00008000) != 0);
      }
      /**
       * <pre>
       * Drop remainder when batch size does not divide dataset size.
       * </pre>
       *
       * <code>optional bool drop_remainder = 35 [default = true];</code>
       * @return The dropRemainder.
       */
      @java.lang.Override
      public boolean getDropRemainder() {
        return dropRemainder_;
      }
      /**
       * <pre>
       * Drop remainder when batch size does not divide dataset size.
       * </pre>
       *
       * <code>optional bool drop_remainder = 35 [default = true];</code>
       * @param value The dropRemainder to set.
       * @return This builder for chaining.
       */
      public Builder setDropRemainder(boolean value) {
        bitField0_ |= 0x00008000;
        dropRemainder_ = value;
        onChanged();
        return this;
      }
      /**
       * <pre>
       * Drop remainder when batch size does not divide dataset size.
       * </pre>
       *
       * <code>optional bool drop_remainder = 35 [default = true];</code>
       * @return This builder for chaining.
       */
      public Builder clearDropRemainder() {
        bitField0_ = (bitField0_ & ~0x00008000);
        dropRemainder_ = true;
        onChanged();
        return this;
      }

      private int numAdditionalChannels_ ;
      /**
       * <pre>
       * If positive, TfExampleDecoder will try to decode rasters of additional
       * channels from tf.Examples.
       * </pre>
       *
       * <code>optional int32 num_additional_channels = 18 [default = 0];</code>
       * @return Whether the numAdditionalChannels field is set.
       */
      @java.lang.Override
      public boolean hasNumAdditionalChannels() {
        return ((bitField0_ & 0x00010000) != 0);
      }
      /**
       * <pre>
       * If positive, TfExampleDecoder will try to decode rasters of additional
       * channels from tf.Examples.
       * </pre>
       *
       * <code>optional int32 num_additional_channels = 18 [default = 0];</code>
       * @return The numAdditionalChannels.
       */
      @java.lang.Override
      public int getNumAdditionalChannels() {
        return numAdditionalChannels_;
      }
      /**
       * <pre>
       * If positive, TfExampleDecoder will try to decode rasters of additional
       * channels from tf.Examples.
       * </pre>
       *
       * <code>optional int32 num_additional_channels = 18 [default = 0];</code>
       * @param value The numAdditionalChannels to set.
       * @return This builder for chaining.
       */
      public Builder setNumAdditionalChannels(int value) {
        bitField0_ |= 0x00010000;
        numAdditionalChannels_ = value;
        onChanged();
        return this;
      }
      /**
       * <pre>
       * If positive, TfExampleDecoder will try to decode rasters of additional
       * channels from tf.Examples.
       * </pre>
       *
       * <code>optional int32 num_additional_channels = 18 [default = 0];</code>
       * @return This builder for chaining.
       */
      public Builder clearNumAdditionalChannels() {
        bitField0_ = (bitField0_ & ~0x00010000);
        numAdditionalChannels_ = 0;
        onChanged();
        return this;
      }

      private int numKeypoints_ ;
      /**
       * <pre>
       * Number of groundtruth keypoints per object.
       * </pre>
       *
       * <code>optional uint32 num_keypoints = 16 [default = 0];</code>
       * @return Whether the numKeypoints field is set.
       */
      @java.lang.Override
      public boolean hasNumKeypoints() {
        return ((bitField0_ & 0x00020000) != 0);
      }
      /**
       * <pre>
       * Number of groundtruth keypoints per object.
       * </pre>
       *
       * <code>optional uint32 num_keypoints = 16 [default = 0];</code>
       * @return The numKeypoints.
       */
      @java.lang.Override
      public int getNumKeypoints() {
        return numKeypoints_;
      }
      /**
       * <pre>
       * Number of groundtruth keypoints per object.
       * </pre>
       *
       * <code>optional uint32 num_keypoints = 16 [default = 0];</code>
       * @param value The numKeypoints to set.
       * @return This builder for chaining.
       */
      public Builder setNumKeypoints(int value) {
        bitField0_ |= 0x00020000;
        numKeypoints_ = value;
        onChanged();
        return this;
      }
      /**
       * <pre>
       * Number of groundtruth keypoints per object.
       * </pre>
       *
       * <code>optional uint32 num_keypoints = 16 [default = 0];</code>
       * @return This builder for chaining.
       */
      public Builder clearNumKeypoints() {
        bitField0_ = (bitField0_ & ~0x00020000);
        numKeypoints_ = 0;
        onChanged();
        return this;
      }

      private com.google.protobuf.Internal.FloatList keypointTypeWeight_ = emptyFloatList();
      private void ensureKeypointTypeWeightIsMutable() {
        if (!((bitField0_ & 0x00040000) != 0)) {
          keypointTypeWeight_ = mutableCopy(keypointTypeWeight_);
          bitField0_ |= 0x00040000;
         }
      }
      /**
       * <pre>
       * Keypoint weights. These weights can be used to apply per-keypoint loss
       * multipliers. The size of this field should agree with `num_keypoints`.
       * </pre>
       *
       * <code>repeated float keypoint_type_weight = 26;</code>
       * @return A list containing the keypointTypeWeight.
       */
      public java.util.List<java.lang.Float>
          getKeypointTypeWeightList() {
        return ((bitField0_ & 0x00040000) != 0) ?
                 java.util.Collections.unmodifiableList(keypointTypeWeight_) : keypointTypeWeight_;
      }
      /**
       * <pre>
       * Keypoint weights. These weights can be used to apply per-keypoint loss
       * multipliers. The size of this field should agree with `num_keypoints`.
       * </pre>
       *
       * <code>repeated float keypoint_type_weight = 26;</code>
       * @return The count of keypointTypeWeight.
       */
      public int getKeypointTypeWeightCount() {
        return keypointTypeWeight_.size();
      }
      /**
       * <pre>
       * Keypoint weights. These weights can be used to apply per-keypoint loss
       * multipliers. The size of this field should agree with `num_keypoints`.
       * </pre>
       *
       * <code>repeated float keypoint_type_weight = 26;</code>
       * @param index The index of the element to return.
       * @return The keypointTypeWeight at the given index.
       */
      public float getKeypointTypeWeight(int index) {
        return keypointTypeWeight_.getFloat(index);
      }
      /**
       * <pre>
       * Keypoint weights. These weights can be used to apply per-keypoint loss
       * multipliers. The size of this field should agree with `num_keypoints`.
       * </pre>
       *
       * <code>repeated float keypoint_type_weight = 26;</code>
       * @param index The index to set the value at.
       * @param value The keypointTypeWeight to set.
       * @return This builder for chaining.
       */
      public Builder setKeypointTypeWeight(
          int index, float value) {
        ensureKeypointTypeWeightIsMutable();
        keypointTypeWeight_.setFloat(index, value);
        onChanged();
        return this;
      }
      /**
       * <pre>
       * Keypoint weights. These weights can be used to apply per-keypoint loss
       * multipliers. The size of this field should agree with `num_keypoints`.
       * </pre>
       *
       * <code>repeated float keypoint_type_weight = 26;</code>
       * @param value The keypointTypeWeight to add.
       * @return This builder for chaining.
       */
      public Builder addKeypointTypeWeight(float value) {
        ensureKeypointTypeWeightIsMutable();
        keypointTypeWeight_.addFloat(value);
        onChanged();
        return this;
      }
      /**
       * <pre>
       * Keypoint weights. These weights can be used to apply per-keypoint loss
       * multipliers. The size of this field should agree with `num_keypoints`.
       * </pre>
       *
       * <code>repeated float keypoint_type_weight = 26;</code>
       * @param values The keypointTypeWeight to add.
       * @return This builder for chaining.
       */
      public Builder addAllKeypointTypeWeight(
          java.lang.Iterable<? extends java.lang.Float> values) {
        ensureKeypointTypeWeightIsMutable();
        com.google.protobuf.AbstractMessageLite.Builder.addAll(
            values, keypointTypeWeight_);
        onChanged();
        return this;
      }
      /**
       * <pre>
       * Keypoint weights. These weights can be used to apply per-keypoint loss
       * multipliers. The size of this field should agree with `num_keypoints`.
       * </pre>
       *
       * <code>repeated float keypoint_type_weight = 26;</code>
       * @return This builder for chaining.
       */
      public Builder clearKeypointTypeWeight() {
        keypointTypeWeight_ = emptyFloatList();
        bitField0_ = (bitField0_ & ~0x00040000);
        onChanged();
        return this;
      }

      private int maxNumberOfBoxes_ = 100;
      /**
       * <pre>
       * Maximum number of boxes to pad to during training / evaluation.
       * Set this to at least the maximum amount of boxes in the input data,
       * otherwise some groundtruth boxes may be clipped.
       * </pre>
       *
       * <code>optional int32 max_number_of_boxes = 21 [default = 100];</code>
       * @return Whether the maxNumberOfBoxes field is set.
       */
      @java.lang.Override
      public boolean hasMaxNumberOfBoxes() {
        return ((bitField0_ & 0x00080000) != 0);
      }
      /**
       * <pre>
       * Maximum number of boxes to pad to during training / evaluation.
       * Set this to at least the maximum amount of boxes in the input data,
       * otherwise some groundtruth boxes may be clipped.
       * </pre>
       *
       * <code>optional int32 max_number_of_boxes = 21 [default = 100];</code>
       * @return The maxNumberOfBoxes.
       */
      @java.lang.Override
      public int getMaxNumberOfBoxes() {
        return maxNumberOfBoxes_;
      }
      /**
       * <pre>
       * Maximum number of boxes to pad to during training / evaluation.
       * Set this to at least the maximum amount of boxes in the input data,
       * otherwise some groundtruth boxes may be clipped.
       * </pre>
       *
       * <code>optional int32 max_number_of_boxes = 21 [default = 100];</code>
       * @param value The maxNumberOfBoxes to set.
       * @return This builder for chaining.
       */
      public Builder setMaxNumberOfBoxes(int value) {
        bitField0_ |= 0x00080000;
        maxNumberOfBoxes_ = value;
        onChanged();
        return this;
      }
      /**
       * <pre>
       * Maximum number of boxes to pad to during training / evaluation.
       * Set this to at least the maximum amount of boxes in the input data,
       * otherwise some groundtruth boxes may be clipped.
       * </pre>
       *
       * <code>optional int32 max_number_of_boxes = 21 [default = 100];</code>
       * @return This builder for chaining.
       */
      public Builder clearMaxNumberOfBoxes() {
        bitField0_ = (bitField0_ & ~0x00080000);
        maxNumberOfBoxes_ = 100;
        onChanged();
        return this;
      }

      private boolean loadMulticlassScores_ ;
      /**
       * <pre>
       * Whether to load multiclass scores from the dataset.
       * </pre>
       *
       * <code>optional bool load_multiclass_scores = 24 [default = false];</code>
       * @return Whether the loadMulticlassScores field is set.
       */
      @java.lang.Override
      public boolean hasLoadMulticlassScores() {
        return ((bitField0_ & 0x00100000) != 0);
      }
      /**
       * <pre>
       * Whether to load multiclass scores from the dataset.
       * </pre>
       *
       * <code>optional bool load_multiclass_scores = 24 [default = false];</code>
       * @return The loadMulticlassScores.
       */
      @java.lang.Override
      public boolean getLoadMulticlassScores() {
        return loadMulticlassScores_;
      }
      /**
       * <pre>
       * Whether to load multiclass scores from the dataset.
       * </pre>
       *
       * <code>optional bool load_multiclass_scores = 24 [default = false];</code>
       * @param value The loadMulticlassScores to set.
       * @return This builder for chaining.
       */
      public Builder setLoadMulticlassScores(boolean value) {
        bitField0_ |= 0x00100000;
        loadMulticlassScores_ = value;
        onChanged();
        return this;
      }
      /**
       * <pre>
       * Whether to load multiclass scores from the dataset.
       * </pre>
       *
       * <code>optional bool load_multiclass_scores = 24 [default = false];</code>
       * @return This builder for chaining.
       */
      public Builder clearLoadMulticlassScores() {
        bitField0_ = (bitField0_ & ~0x00100000);
        loadMulticlassScores_ = false;
        onChanged();
        return this;
      }

      private boolean loadContextFeatures_ ;
      /**
       * <pre>
       * Whether to load context features from the dataset.
       * </pre>
       *
       * <code>optional bool load_context_features = 25 [default = false];</code>
       * @return Whether the loadContextFeatures field is set.
       */
      @java.lang.Override
      public boolean hasLoadContextFeatures() {
        return ((bitField0_ & 0x00200000) != 0);
      }
      /**
       * <pre>
       * Whether to load context features from the dataset.
       * </pre>
       *
       * <code>optional bool load_context_features = 25 [default = false];</code>
       * @return The loadContextFeatures.
       */
      @java.lang.Override
      public boolean getLoadContextFeatures() {
        return loadContextFeatures_;
      }
      /**
       * <pre>
       * Whether to load context features from the dataset.
       * </pre>
       *
       * <code>optional bool load_context_features = 25 [default = false];</code>
       * @param value The loadContextFeatures to set.
       * @return This builder for chaining.
       */
      public Builder setLoadContextFeatures(boolean value) {
        bitField0_ |= 0x00200000;
        loadContextFeatures_ = value;
        onChanged();
        return this;
      }
      /**
       * <pre>
       * Whether to load context features from the dataset.
       * </pre>
       *
       * <code>optional bool load_context_features = 25 [default = false];</code>
       * @return This builder for chaining.
       */
      public Builder clearLoadContextFeatures() {
        bitField0_ = (bitField0_ & ~0x00200000);
        loadContextFeatures_ = false;
        onChanged();
        return this;
      }

      private boolean loadContextImageIds_ ;
      /**
       * <pre>
       * Whether to load context image ids from the dataset.
       * </pre>
       *
       * <code>optional bool load_context_image_ids = 36 [default = false];</code>
       * @return Whether the loadContextImageIds field is set.
       */
      @java.lang.Override
      public boolean hasLoadContextImageIds() {
        return ((bitField0_ & 0x00400000) != 0);
      }
      /**
       * <pre>
       * Whether to load context image ids from the dataset.
       * </pre>
       *
       * <code>optional bool load_context_image_ids = 36 [default = false];</code>
       * @return The loadContextImageIds.
       */
      @java.lang.Override
      public boolean getLoadContextImageIds() {
        return loadContextImageIds_;
      }
      /**
       * <pre>
       * Whether to load context image ids from the dataset.
       * </pre>
       *
       * <code>optional bool load_context_image_ids = 36 [default = false];</code>
       * @param value The loadContextImageIds to set.
       * @return This builder for chaining.
       */
      public Builder setLoadContextImageIds(boolean value) {
        bitField0_ |= 0x00400000;
        loadContextImageIds_ = value;
        onChanged();
        return this;
      }
      /**
       * <pre>
       * Whether to load context image ids from the dataset.
       * </pre>
       *
       * <code>optional bool load_context_image_ids = 36 [default = false];</code>
       * @return This builder for chaining.
       */
      public Builder clearLoadContextImageIds() {
        bitField0_ = (bitField0_ & ~0x00400000);
        loadContextImageIds_ = false;
        onChanged();
        return this;
      }

      private boolean loadInstanceMasks_ ;
      /**
       * <pre>
       * Whether to load groundtruth instance masks.
       * </pre>
       *
       * <code>optional bool load_instance_masks = 7 [default = false];</code>
       * @return Whether the loadInstanceMasks field is set.
       */
      @java.lang.Override
      public boolean hasLoadInstanceMasks() {
        return ((bitField0_ & 0x00800000) != 0);
      }
      /**
       * <pre>
       * Whether to load groundtruth instance masks.
       * </pre>
       *
       * <code>optional bool load_instance_masks = 7 [default = false];</code>
       * @return The loadInstanceMasks.
       */
      @java.lang.Override
      public boolean getLoadInstanceMasks() {
        return loadInstanceMasks_;
      }
      /**
       * <pre>
       * Whether to load groundtruth instance masks.
       * </pre>
       *
       * <code>optional bool load_instance_masks = 7 [default = false];</code>
       * @param value The loadInstanceMasks to set.
       * @return This builder for chaining.
       */
      public Builder setLoadInstanceMasks(boolean value) {
        bitField0_ |= 0x00800000;
        loadInstanceMasks_ = value;
        onChanged();
        return this;
      }
      /**
       * <pre>
       * Whether to load groundtruth instance masks.
       * </pre>
       *
       * <code>optional bool load_instance_masks = 7 [default = false];</code>
       * @return This builder for chaining.
       */
      public Builder clearLoadInstanceMasks() {
        bitField0_ = (bitField0_ & ~0x00800000);
        loadInstanceMasks_ = false;
        onChanged();
        return this;
      }

      private int maskType_ = 1;
      /**
       * <pre>
       * Type of instance mask.
       * </pre>
       *
       * <code>optional .object_detection.protos.InstanceMaskType mask_type = 10 [default = NUMERICAL_MASKS];</code>
       * @return Whether the maskType field is set.
       */
      @java.lang.Override public boolean hasMaskType() {
        return ((bitField0_ & 0x01000000) != 0);
      }
      /**
       * <pre>
       * Type of instance mask.
       * </pre>
       *
       * <code>optional .object_detection.protos.InstanceMaskType mask_type = 10 [default = NUMERICAL_MASKS];</code>
       * @return The maskType.
       */
      @java.lang.Override
      public object_detection.protos.InputReaderOuterClass.InstanceMaskType getMaskType() {
        @SuppressWarnings("deprecation")
        object_detection.protos.InputReaderOuterClass.InstanceMaskType result = object_detection.protos.InputReaderOuterClass.InstanceMaskType.valueOf(maskType_);
        return result == null ? object_detection.protos.InputReaderOuterClass.InstanceMaskType.NUMERICAL_MASKS : result;
      }
      /**
       * <pre>
       * Type of instance mask.
       * </pre>
       *
       * <code>optional .object_detection.protos.InstanceMaskType mask_type = 10 [default = NUMERICAL_MASKS];</code>
       * @param value The maskType to set.
       * @return This builder for chaining.
       */
      public Builder setMaskType(object_detection.protos.InputReaderOuterClass.InstanceMaskType value) {
        if (value == null) {
          throw new NullPointerException();
        }
        bitField0_ |= 0x01000000;
        maskType_ = value.getNumber();
        onChanged();
        return this;
      }
      /**
       * <pre>
       * Type of instance mask.
       * </pre>
       *
       * <code>optional .object_detection.protos.InstanceMaskType mask_type = 10 [default = NUMERICAL_MASKS];</code>
       * @return This builder for chaining.
       */
      public Builder clearMaskType() {
        bitField0_ = (bitField0_ & ~0x01000000);
        maskType_ = 1;
        onChanged();
        return this;
      }

      private boolean loadDensePose_ ;
      /**
       * <pre>
       * Whether to load DensePose data. If set, must also set load_instance_masks
       * to true.
       * </pre>
       *
       * <code>optional bool load_dense_pose = 31 [default = false];</code>
       * @return Whether the loadDensePose field is set.
       */
      @java.lang.Override
      public boolean hasLoadDensePose() {
        return ((bitField0_ & 0x02000000) != 0);
      }
      /**
       * <pre>
       * Whether to load DensePose data. If set, must also set load_instance_masks
       * to true.
       * </pre>
       *
       * <code>optional bool load_dense_pose = 31 [default = false];</code>
       * @return The loadDensePose.
       */
      @java.lang.Override
      public boolean getLoadDensePose() {
        return loadDensePose_;
      }
      /**
       * <pre>
       * Whether to load DensePose data. If set, must also set load_instance_masks
       * to true.
       * </pre>
       *
       * <code>optional bool load_dense_pose = 31 [default = false];</code>
       * @param value The loadDensePose to set.
       * @return This builder for chaining.
       */
      public Builder setLoadDensePose(boolean value) {
        bitField0_ |= 0x02000000;
        loadDensePose_ = value;
        onChanged();
        return this;
      }
      /**
       * <pre>
       * Whether to load DensePose data. If set, must also set load_instance_masks
       * to true.
       * </pre>
       *
       * <code>optional bool load_dense_pose = 31 [default = false];</code>
       * @return This builder for chaining.
       */
      public Builder clearLoadDensePose() {
        bitField0_ = (bitField0_ & ~0x02000000);
        loadDensePose_ = false;
        onChanged();
        return this;
      }

      private boolean loadTrackId_ ;
      /**
       * <pre>
       * Whether to load track information.
       * </pre>
       *
       * <code>optional bool load_track_id = 33 [default = false];</code>
       * @return Whether the loadTrackId field is set.
       */
      @java.lang.Override
      public boolean hasLoadTrackId() {
        return ((bitField0_ & 0x04000000) != 0);
      }
      /**
       * <pre>
       * Whether to load track information.
       * </pre>
       *
       * <code>optional bool load_track_id = 33 [default = false];</code>
       * @return The loadTrackId.
       */
      @java.lang.Override
      public boolean getLoadTrackId() {
        return loadTrackId_;
      }
      /**
       * <pre>
       * Whether to load track information.
       * </pre>
       *
       * <code>optional bool load_track_id = 33 [default = false];</code>
       * @param value The loadTrackId to set.
       * @return This builder for chaining.
       */
      public Builder setLoadTrackId(boolean value) {
        bitField0_ |= 0x04000000;
        loadTrackId_ = value;
        onChanged();
        return this;
      }
      /**
       * <pre>
       * Whether to load track information.
       * </pre>
       *
       * <code>optional bool load_track_id = 33 [default = false];</code>
       * @return This builder for chaining.
       */
      public Builder clearLoadTrackId() {
        bitField0_ = (bitField0_ & ~0x04000000);
        loadTrackId_ = false;
        onChanged();
        return this;
      }

      private boolean useDisplayName_ ;
      /**
       * <pre>
       * Whether to use the display name when decoding examples. This is only used
       * when mapping class text strings to integers.
       * </pre>
       *
       * <code>optional bool use_display_name = 17 [default = false];</code>
       * @return Whether the useDisplayName field is set.
       */
      @java.lang.Override
      public boolean hasUseDisplayName() {
        return ((bitField0_ & 0x08000000) != 0);
      }
      /**
       * <pre>
       * Whether to use the display name when decoding examples. This is only used
       * when mapping class text strings to integers.
       * </pre>
       *
       * <code>optional bool use_display_name = 17 [default = false];</code>
       * @return The useDisplayName.
       */
      @java.lang.Override
      public boolean getUseDisplayName() {
        return useDisplayName_;
      }
      /**
       * <pre>
       * Whether to use the display name when decoding examples. This is only used
       * when mapping class text strings to integers.
       * </pre>
       *
       * <code>optional bool use_display_name = 17 [default = false];</code>
       * @param value The useDisplayName to set.
       * @return This builder for chaining.
       */
      public Builder setUseDisplayName(boolean value) {
        bitField0_ |= 0x08000000;
        useDisplayName_ = value;
        onChanged();
        return this;
      }
      /**
       * <pre>
       * Whether to use the display name when decoding examples. This is only used
       * when mapping class text strings to integers.
       * </pre>
       *
       * <code>optional bool use_display_name = 17 [default = false];</code>
       * @return This builder for chaining.
       */
      public Builder clearUseDisplayName() {
        bitField0_ = (bitField0_ & ~0x08000000);
        useDisplayName_ = false;
        onChanged();
        return this;
      }

      private boolean includeSourceId_ ;
      /**
       * <pre>
       * Whether to include the source_id string in the input features.
       * </pre>
       *
       * <code>optional bool include_source_id = 27 [default = false];</code>
       * @return Whether the includeSourceId field is set.
       */
      @java.lang.Override
      public boolean hasIncludeSourceId() {
        return ((bitField0_ & 0x10000000) != 0);
      }
      /**
       * <pre>
       * Whether to include the source_id string in the input features.
       * </pre>
       *
       * <code>optional bool include_source_id = 27 [default = false];</code>
       * @return The includeSourceId.
       */
      @java.lang.Override
      public boolean getIncludeSourceId() {
        return includeSourceId_;
      }
      /**
       * <pre>
       * Whether to include the source_id string in the input features.
       * </pre>
       *
       * <code>optional bool include_source_id = 27 [default = false];</code>
       * @param value The includeSourceId to set.
       * @return This builder for chaining.
       */
      public Builder setIncludeSourceId(boolean value) {
        bitField0_ |= 0x10000000;
        includeSourceId_ = value;
        onChanged();
        return this;
      }
      /**
       * <pre>
       * Whether to include the source_id string in the input features.
       * </pre>
       *
       * <code>optional bool include_source_id = 27 [default = false];</code>
       * @return This builder for chaining.
       */
      public Builder clearIncludeSourceId() {
        bitField0_ = (bitField0_ & ~0x10000000);
        includeSourceId_ = false;
        onChanged();
        return this;
      }

      private int inputType_ = 1;
      /**
       * <pre>
       * Whether input data type is tf.Examples or tf.SequenceExamples
       * </pre>
       *
       * <code>optional .object_detection.protos.InputType input_type = 30 [default = TF_EXAMPLE];</code>
       * @return Whether the inputType field is set.
       */
      @java.lang.Override public boolean hasInputType() {
        return ((bitField0_ & 0x20000000) != 0);
      }
      /**
       * <pre>
       * Whether input data type is tf.Examples or tf.SequenceExamples
       * </pre>
       *
       * <code>optional .object_detection.protos.InputType input_type = 30 [default = TF_EXAMPLE];</code>
       * @return The inputType.
       */
      @java.lang.Override
      public object_detection.protos.InputReaderOuterClass.InputType getInputType() {
        @SuppressWarnings("deprecation")
        object_detection.protos.InputReaderOuterClass.InputType result = object_detection.protos.InputReaderOuterClass.InputType.valueOf(inputType_);
        return result == null ? object_detection.protos.InputReaderOuterClass.InputType.TF_EXAMPLE : result;
      }
      /**
       * <pre>
       * Whether input data type is tf.Examples or tf.SequenceExamples
       * </pre>
       *
       * <code>optional .object_detection.protos.InputType input_type = 30 [default = TF_EXAMPLE];</code>
       * @param value The inputType to set.
       * @return This builder for chaining.
       */
      public Builder setInputType(object_detection.protos.InputReaderOuterClass.InputType value) {
        if (value == null) {
          throw new NullPointerException();
        }
        bitField0_ |= 0x20000000;
        inputType_ = value.getNumber();
        onChanged();
        return this;
      }
      /**
       * <pre>
       * Whether input data type is tf.Examples or tf.SequenceExamples
       * </pre>
       *
       * <code>optional .object_detection.protos.InputType input_type = 30 [default = TF_EXAMPLE];</code>
       * @return This builder for chaining.
       */
      public Builder clearInputType() {
        bitField0_ = (bitField0_ & ~0x20000000);
        inputType_ = 1;
        onChanged();
        return this;
      }

      private int frameIndex_ = -1;
      /**
       * <pre>
       * Which frame to choose from the input if Sequence Example. -1 indicates
       * random choice.
       * </pre>
       *
       * <code>optional int32 frame_index = 32 [default = -1];</code>
       * @return Whether the frameIndex field is set.
       */
      @java.lang.Override
      public boolean hasFrameIndex() {
        return ((bitField0_ & 0x40000000) != 0);
      }
      /**
       * <pre>
       * Which frame to choose from the input if Sequence Example. -1 indicates
       * random choice.
       * </pre>
       *
       * <code>optional int32 frame_index = 32 [default = -1];</code>
       * @return The frameIndex.
       */
      @java.lang.Override
      public int getFrameIndex() {
        return frameIndex_;
      }
      /**
       * <pre>
       * Which frame to choose from the input if Sequence Example. -1 indicates
       * random choice.
       * </pre>
       *
       * <code>optional int32 frame_index = 32 [default = -1];</code>
       * @param value The frameIndex to set.
       * @return This builder for chaining.
       */
      public Builder setFrameIndex(int value) {
        bitField0_ |= 0x40000000;
        frameIndex_ = value;
        onChanged();
        return this;
      }
      /**
       * <pre>
       * Which frame to choose from the input if Sequence Example. -1 indicates
       * random choice.
       * </pre>
       *
       * <code>optional int32 frame_index = 32 [default = -1];</code>
       * @return This builder for chaining.
       */
      public Builder clearFrameIndex() {
        bitField0_ = (bitField0_ & ~0x40000000);
        frameIndex_ = -1;
        onChanged();
        return this;
      }

      private com.google.protobuf.SingleFieldBuilderV3<
          object_detection.protos.InputReaderOuterClass.TFRecordInputReader, object_detection.protos.InputReaderOuterClass.TFRecordInputReader.Builder, object_detection.protos.InputReaderOuterClass.TFRecordInputReaderOrBuilder> tfRecordInputReaderBuilder_;
      /**
       * <code>.object_detection.protos.TFRecordInputReader tf_record_input_reader = 8;</code>
       * @return Whether the tfRecordInputReader field is set.
       */
      @java.lang.Override
      public boolean hasTfRecordInputReader() {
        return inputReaderCase_ == 8;
      }
      /**
       * <code>.object_detection.protos.TFRecordInputReader tf_record_input_reader = 8;</code>
       * @return The tfRecordInputReader.
       */
      @java.lang.Override
      public object_detection.protos.InputReaderOuterClass.TFRecordInputReader getTfRecordInputReader() {
        if (tfRecordInputReaderBuilder_ == null) {
          if (inputReaderCase_ == 8) {
            return (object_detection.protos.InputReaderOuterClass.TFRecordInputReader) inputReader_;
          }
          return object_detection.protos.InputReaderOuterClass.TFRecordInputReader.getDefaultInstance();
        } else {
          if (inputReaderCase_ == 8) {
            return tfRecordInputReaderBuilder_.getMessage();
          }
          return object_detection.protos.InputReaderOuterClass.TFRecordInputReader.getDefaultInstance();
        }
      }
      /**
       * <code>.object_detection.protos.TFRecordInputReader tf_record_input_reader = 8;</code>
       */
      public Builder setTfRecordInputReader(object_detection.protos.InputReaderOuterClass.TFRecordInputReader value) {
        if (tfRecordInputReaderBuilder_ == null) {
          if (value == null) {
            throw new NullPointerException();
          }
          inputReader_ = value;
          onChanged();
        } else {
          tfRecordInputReaderBuilder_.setMessage(value);
        }
        inputReaderCase_ = 8;
        return this;
      }
      /**
       * <code>.object_detection.protos.TFRecordInputReader tf_record_input_reader = 8;</code>
       */
      public Builder setTfRecordInputReader(
          object_detection.protos.InputReaderOuterClass.TFRecordInputReader.Builder builderForValue) {
        if (tfRecordInputReaderBuilder_ == null) {
          inputReader_ = builderForValue.build();
          onChanged();
        } else {
          tfRecordInputReaderBuilder_.setMessage(builderForValue.build());
        }
        inputReaderCase_ = 8;
        return this;
      }
      /**
       * <code>.object_detection.protos.TFRecordInputReader tf_record_input_reader = 8;</code>
       */
      public Builder mergeTfRecordInputReader(object_detection.protos.InputReaderOuterClass.TFRecordInputReader value) {
        if (tfRecordInputReaderBuilder_ == null) {
          if (inputReaderCase_ == 8 &&
              inputReader_ != object_detection.protos.InputReaderOuterClass.TFRecordInputReader.getDefaultInstance()) {
            inputReader_ = object_detection.protos.InputReaderOuterClass.TFRecordInputReader.newBuilder((object_detection.protos.InputReaderOuterClass.TFRecordInputReader) inputReader_)
                .mergeFrom(value).buildPartial();
          } else {
            inputReader_ = value;
          }
          onChanged();
        } else {
          if (inputReaderCase_ == 8) {
            tfRecordInputReaderBuilder_.mergeFrom(value);
          }
          tfRecordInputReaderBuilder_.setMessage(value);
        }
        inputReaderCase_ = 8;
        return this;
      }
      /**
       * <code>.object_detection.protos.TFRecordInputReader tf_record_input_reader = 8;</code>
       */
      public Builder clearTfRecordInputReader() {
        if (tfRecordInputReaderBuilder_ == null) {
          if (inputReaderCase_ == 8) {
            inputReaderCase_ = 0;
            inputReader_ = null;
            onChanged();
          }
        } else {
          if (inputReaderCase_ == 8) {
            inputReaderCase_ = 0;
            inputReader_ = null;
          }
          tfRecordInputReaderBuilder_.clear();
        }
        return this;
      }
      /**
       * <code>.object_detection.protos.TFRecordInputReader tf_record_input_reader = 8;</code>
       */
      public object_detection.protos.InputReaderOuterClass.TFRecordInputReader.Builder getTfRecordInputReaderBuilder() {
        return getTfRecordInputReaderFieldBuilder().getBuilder();
      }
      /**
       * <code>.object_detection.protos.TFRecordInputReader tf_record_input_reader = 8;</code>
       */
      @java.lang.Override
      public object_detection.protos.InputReaderOuterClass.TFRecordInputReaderOrBuilder getTfRecordInputReaderOrBuilder() {
        if ((inputReaderCase_ == 8) && (tfRecordInputReaderBuilder_ != null)) {
          return tfRecordInputReaderBuilder_.getMessageOrBuilder();
        } else {
          if (inputReaderCase_ == 8) {
            return (object_detection.protos.InputReaderOuterClass.TFRecordInputReader) inputReader_;
          }
          return object_detection.protos.InputReaderOuterClass.TFRecordInputReader.getDefaultInstance();
        }
      }
      /**
       * <code>.object_detection.protos.TFRecordInputReader tf_record_input_reader = 8;</code>
       */
      private com.google.protobuf.SingleFieldBuilderV3<
          object_detection.protos.InputReaderOuterClass.TFRecordInputReader, object_detection.protos.InputReaderOuterClass.TFRecordInputReader.Builder, object_detection.protos.InputReaderOuterClass.TFRecordInputReaderOrBuilder>
          getTfRecordInputReaderFieldBuilder() {
        if (tfRecordInputReaderBuilder_ == null) {
          if (!(inputReaderCase_ == 8)) {
            inputReader_ = object_detection.protos.InputReaderOuterClass.TFRecordInputReader.getDefaultInstance();
          }
          tfRecordInputReaderBuilder_ = new com.google.protobuf.SingleFieldBuilderV3<
              object_detection.protos.InputReaderOuterClass.TFRecordInputReader, object_detection.protos.InputReaderOuterClass.TFRecordInputReader.Builder, object_detection.protos.InputReaderOuterClass.TFRecordInputReaderOrBuilder>(
                  (object_detection.protos.InputReaderOuterClass.TFRecordInputReader) inputReader_,
                  getParentForChildren(),
                  isClean());
          inputReader_ = null;
        }
        inputReaderCase_ = 8;
        onChanged();;
        return tfRecordInputReaderBuilder_;
      }

      private com.google.protobuf.SingleFieldBuilderV3<
          object_detection.protos.InputReaderOuterClass.ExternalInputReader, object_detection.protos.InputReaderOuterClass.ExternalInputReader.Builder, object_detection.protos.InputReaderOuterClass.ExternalInputReaderOrBuilder> externalInputReaderBuilder_;
      /**
       * <code>.object_detection.protos.ExternalInputReader external_input_reader = 9;</code>
       * @return Whether the externalInputReader field is set.
       */
      @java.lang.Override
      public boolean hasExternalInputReader() {
        return inputReaderCase_ == 9;
      }
      /**
       * <code>.object_detection.protos.ExternalInputReader external_input_reader = 9;</code>
       * @return The externalInputReader.
       */
      @java.lang.Override
      public object_detection.protos.InputReaderOuterClass.ExternalInputReader getExternalInputReader() {
        if (externalInputReaderBuilder_ == null) {
          if (inputReaderCase_ == 9) {
            return (object_detection.protos.InputReaderOuterClass.ExternalInputReader) inputReader_;
          }
          return object_detection.protos.InputReaderOuterClass.ExternalInputReader.getDefaultInstance();
        } else {
          if (inputReaderCase_ == 9) {
            return externalInputReaderBuilder_.getMessage();
          }
          return object_detection.protos.InputReaderOuterClass.ExternalInputReader.getDefaultInstance();
        }
      }
      /**
       * <code>.object_detection.protos.ExternalInputReader external_input_reader = 9;</code>
       */
      public Builder setExternalInputReader(object_detection.protos.InputReaderOuterClass.ExternalInputReader value) {
        if (externalInputReaderBuilder_ == null) {
          if (value == null) {
            throw new NullPointerException();
          }
          inputReader_ = value;
          onChanged();
        } else {
          externalInputReaderBuilder_.setMessage(value);
        }
        inputReaderCase_ = 9;
        return this;
      }
      /**
       * <code>.object_detection.protos.ExternalInputReader external_input_reader = 9;</code>
       */
      public Builder setExternalInputReader(
          object_detection.protos.InputReaderOuterClass.ExternalInputReader.Builder builderForValue) {
        if (externalInputReaderBuilder_ == null) {
          inputReader_ = builderForValue.build();
          onChanged();
        } else {
          externalInputReaderBuilder_.setMessage(builderForValue.build());
        }
        inputReaderCase_ = 9;
        return this;
      }
      /**
       * <code>.object_detection.protos.ExternalInputReader external_input_reader = 9;</code>
       */
      public Builder mergeExternalInputReader(object_detection.protos.InputReaderOuterClass.ExternalInputReader value) {
        if (externalInputReaderBuilder_ == null) {
          if (inputReaderCase_ == 9 &&
              inputReader_ != object_detection.protos.InputReaderOuterClass.ExternalInputReader.getDefaultInstance()) {
            inputReader_ = object_detection.protos.InputReaderOuterClass.ExternalInputReader.newBuilder((object_detection.protos.InputReaderOuterClass.ExternalInputReader) inputReader_)
                .mergeFrom(value).buildPartial();
          } else {
            inputReader_ = value;
          }
          onChanged();
        } else {
          if (inputReaderCase_ == 9) {
            externalInputReaderBuilder_.mergeFrom(value);
          }
          externalInputReaderBuilder_.setMessage(value);
        }
        inputReaderCase_ = 9;
        return this;
      }
      /**
       * <code>.object_detection.protos.ExternalInputReader external_input_reader = 9;</code>
       */
      public Builder clearExternalInputReader() {
        if (externalInputReaderBuilder_ == null) {
          if (inputReaderCase_ == 9) {
            inputReaderCase_ = 0;
            inputReader_ = null;
            onChanged();
          }
        } else {
          if (inputReaderCase_ == 9) {
            inputReaderCase_ = 0;
            inputReader_ = null;
          }
          externalInputReaderBuilder_.clear();
        }
        return this;
      }
      /**
       * <code>.object_detection.protos.ExternalInputReader external_input_reader = 9;</code>
       */
      public object_detection.protos.InputReaderOuterClass.ExternalInputReader.Builder getExternalInputReaderBuilder() {
        return getExternalInputReaderFieldBuilder().getBuilder();
      }
      /**
       * <code>.object_detection.protos.ExternalInputReader external_input_reader = 9;</code>
       */
      @java.lang.Override
      public object_detection.protos.InputReaderOuterClass.ExternalInputReaderOrBuilder getExternalInputReaderOrBuilder() {
        if ((inputReaderCase_ == 9) && (externalInputReaderBuilder_ != null)) {
          return externalInputReaderBuilder_.getMessageOrBuilder();
        } else {
          if (inputReaderCase_ == 9) {
            return (object_detection.protos.InputReaderOuterClass.ExternalInputReader) inputReader_;
          }
          return object_detection.protos.InputReaderOuterClass.ExternalInputReader.getDefaultInstance();
        }
      }
      /**
       * <code>.object_detection.protos.ExternalInputReader external_input_reader = 9;</code>
       */
      private com.google.protobuf.SingleFieldBuilderV3<
          object_detection.protos.InputReaderOuterClass.ExternalInputReader, object_detection.protos.InputReaderOuterClass.ExternalInputReader.Builder, object_detection.protos.InputReaderOuterClass.ExternalInputReaderOrBuilder>
          getExternalInputReaderFieldBuilder() {
        if (externalInputReaderBuilder_ == null) {
          if (!(inputReaderCase_ == 9)) {
            inputReader_ = object_detection.protos.InputReaderOuterClass.ExternalInputReader.getDefaultInstance();
          }
          externalInputReaderBuilder_ = new com.google.protobuf.SingleFieldBuilderV3<
              object_detection.protos.InputReaderOuterClass.ExternalInputReader, object_detection.protos.InputReaderOuterClass.ExternalInputReader.Builder, object_detection.protos.InputReaderOuterClass.ExternalInputReaderOrBuilder>(
                  (object_detection.protos.InputReaderOuterClass.ExternalInputReader) inputReader_,
                  getParentForChildren(),
                  isClean());
          inputReader_ = null;
        }
        inputReaderCase_ = 9;
        onChanged();;
        return externalInputReaderBuilder_;
      }

      private com.google.protobuf.Internal.FloatList sampleFromDatasetsWeights_ = emptyFloatList();
      private void ensureSampleFromDatasetsWeightsIsMutable() {
        if (!((bitField1_ & 0x00000002) != 0)) {
          sampleFromDatasetsWeights_ = mutableCopy(sampleFromDatasetsWeights_);
          bitField1_ |= 0x00000002;
         }
      }
      /**
       * <pre>
       * When multiple input files are configured, we can sample across them based
       * on weights.
       * The number of weights must match the number of input files configured.
       * When set, shuffling, shuffle buffer size, and num_readers settings are
       * applied individually to each dataset.
       * Implementation follows tf.data.experimental.sample_from_datasets sampling
       * strategy. Weights may take any value - only relative weights matter.
       * Zero weights will result in a dataset not being sampled.
       * Examples, assuming two input files configured:
       * Equal weighting:
       * sample_from_datasets_weights: 0.5
       * sample_from_datasets_weights: 0.5
       * 2:1 weighting:
       * sample_from_datasets_weights: 2
       * sample_from_datasets_weights: 1
       * Exclude the second dataset:
       * sample_from_datasets_weights: 1
       * sample_from_datasets_weights: 0
       * </pre>
       *
       * <code>repeated float sample_from_datasets_weights = 34;</code>
       * @return A list containing the sampleFromDatasetsWeights.
       */
      public java.util.List<java.lang.Float>
          getSampleFromDatasetsWeightsList() {
        return ((bitField1_ & 0x00000002) != 0) ?
                 java.util.Collections.unmodifiableList(sampleFromDatasetsWeights_) : sampleFromDatasetsWeights_;
      }
      /**
       * <pre>
       * When multiple input files are configured, we can sample across them based
       * on weights.
       * The number of weights must match the number of input files configured.
       * When set, shuffling, shuffle buffer size, and num_readers settings are
       * applied individually to each dataset.
       * Implementation follows tf.data.experimental.sample_from_datasets sampling
       * strategy. Weights may take any value - only relative weights matter.
       * Zero weights will result in a dataset not being sampled.
       * Examples, assuming two input files configured:
       * Equal weighting:
       * sample_from_datasets_weights: 0.5
       * sample_from_datasets_weights: 0.5
       * 2:1 weighting:
       * sample_from_datasets_weights: 2
       * sample_from_datasets_weights: 1
       * Exclude the second dataset:
       * sample_from_datasets_weights: 1
       * sample_from_datasets_weights: 0
       * </pre>
       *
       * <code>repeated float sample_from_datasets_weights = 34;</code>
       * @return The count of sampleFromDatasetsWeights.
       */
      public int getSampleFromDatasetsWeightsCount() {
        return sampleFromDatasetsWeights_.size();
      }
      /**
       * <pre>
       * When multiple input files are configured, we can sample across them based
       * on weights.
       * The number of weights must match the number of input files configured.
       * When set, shuffling, shuffle buffer size, and num_readers settings are
       * applied individually to each dataset.
       * Implementation follows tf.data.experimental.sample_from_datasets sampling
       * strategy. Weights may take any value - only relative weights matter.
       * Zero weights will result in a dataset not being sampled.
       * Examples, assuming two input files configured:
       * Equal weighting:
       * sample_from_datasets_weights: 0.5
       * sample_from_datasets_weights: 0.5
       * 2:1 weighting:
       * sample_from_datasets_weights: 2
       * sample_from_datasets_weights: 1
       * Exclude the second dataset:
       * sample_from_datasets_weights: 1
       * sample_from_datasets_weights: 0
       * </pre>
       *
       * <code>repeated float sample_from_datasets_weights = 34;</code>
       * @param index The index of the element to return.
       * @return The sampleFromDatasetsWeights at the given index.
       */
      public float getSampleFromDatasetsWeights(int index) {
        return sampleFromDatasetsWeights_.getFloat(index);
      }
      /**
       * <pre>
       * When multiple input files are configured, we can sample across them based
       * on weights.
       * The number of weights must match the number of input files configured.
       * When set, shuffling, shuffle buffer size, and num_readers settings are
       * applied individually to each dataset.
       * Implementation follows tf.data.experimental.sample_from_datasets sampling
       * strategy. Weights may take any value - only relative weights matter.
       * Zero weights will result in a dataset not being sampled.
       * Examples, assuming two input files configured:
       * Equal weighting:
       * sample_from_datasets_weights: 0.5
       * sample_from_datasets_weights: 0.5
       * 2:1 weighting:
       * sample_from_datasets_weights: 2
       * sample_from_datasets_weights: 1
       * Exclude the second dataset:
       * sample_from_datasets_weights: 1
       * sample_from_datasets_weights: 0
       * </pre>
       *
       * <code>repeated float sample_from_datasets_weights = 34;</code>
       * @param index The index to set the value at.
       * @param value The sampleFromDatasetsWeights to set.
       * @return This builder for chaining.
       */
      public Builder setSampleFromDatasetsWeights(
          int index, float value) {
        ensureSampleFromDatasetsWeightsIsMutable();
        sampleFromDatasetsWeights_.setFloat(index, value);
        onChanged();
        return this;
      }
      /**
       * <pre>
       * When multiple input files are configured, we can sample across them based
       * on weights.
       * The number of weights must match the number of input files configured.
       * When set, shuffling, shuffle buffer size, and num_readers settings are
       * applied individually to each dataset.
       * Implementation follows tf.data.experimental.sample_from_datasets sampling
       * strategy. Weights may take any value - only relative weights matter.
       * Zero weights will result in a dataset not being sampled.
       * Examples, assuming two input files configured:
       * Equal weighting:
       * sample_from_datasets_weights: 0.5
       * sample_from_datasets_weights: 0.5
       * 2:1 weighting:
       * sample_from_datasets_weights: 2
       * sample_from_datasets_weights: 1
       * Exclude the second dataset:
       * sample_from_datasets_weights: 1
       * sample_from_datasets_weights: 0
       * </pre>
       *
       * <code>repeated float sample_from_datasets_weights = 34;</code>
       * @param value The sampleFromDatasetsWeights to add.
       * @return This builder for chaining.
       */
      public Builder addSampleFromDatasetsWeights(float value) {
        ensureSampleFromDatasetsWeightsIsMutable();
        sampleFromDatasetsWeights_.addFloat(value);
        onChanged();
        return this;
      }
      /**
       * <pre>
       * When multiple input files are configured, we can sample across them based
       * on weights.
       * The number of weights must match the number of input files configured.
       * When set, shuffling, shuffle buffer size, and num_readers settings are
       * applied individually to each dataset.
       * Implementation follows tf.data.experimental.sample_from_datasets sampling
       * strategy. Weights may take any value - only relative weights matter.
       * Zero weights will result in a dataset not being sampled.
       * Examples, assuming two input files configured:
       * Equal weighting:
       * sample_from_datasets_weights: 0.5
       * sample_from_datasets_weights: 0.5
       * 2:1 weighting:
       * sample_from_datasets_weights: 2
       * sample_from_datasets_weights: 1
       * Exclude the second dataset:
       * sample_from_datasets_weights: 1
       * sample_from_datasets_weights: 0
       * </pre>
       *
       * <code>repeated float sample_from_datasets_weights = 34;</code>
       * @param values The sampleFromDatasetsWeights to add.
       * @return This builder for chaining.
       */
      public Builder addAllSampleFromDatasetsWeights(
          java.lang.Iterable<? extends java.lang.Float> values) {
        ensureSampleFromDatasetsWeightsIsMutable();
        com.google.protobuf.AbstractMessageLite.Builder.addAll(
            values, sampleFromDatasetsWeights_);
        onChanged();
        return this;
      }
      /**
       * <pre>
       * When multiple input files are configured, we can sample across them based
       * on weights.
       * The number of weights must match the number of input files configured.
       * When set, shuffling, shuffle buffer size, and num_readers settings are
       * applied individually to each dataset.
       * Implementation follows tf.data.experimental.sample_from_datasets sampling
       * strategy. Weights may take any value - only relative weights matter.
       * Zero weights will result in a dataset not being sampled.
       * Examples, assuming two input files configured:
       * Equal weighting:
       * sample_from_datasets_weights: 0.5
       * sample_from_datasets_weights: 0.5
       * 2:1 weighting:
       * sample_from_datasets_weights: 2
       * sample_from_datasets_weights: 1
       * Exclude the second dataset:
       * sample_from_datasets_weights: 1
       * sample_from_datasets_weights: 0
       * </pre>
       *
       * <code>repeated float sample_from_datasets_weights = 34;</code>
       * @return This builder for chaining.
       */
      public Builder clearSampleFromDatasetsWeights() {
        sampleFromDatasetsWeights_ = emptyFloatList();
        bitField1_ = (bitField1_ & ~0x00000002);
        onChanged();
        return this;
      }

      private boolean expandLabelsHierarchy_ ;
      /**
       * <pre>
       * Expand labels to ancestors or descendants in the hierarchy for
       * for positive and negative labels, respectively.
       * </pre>
       *
       * <code>optional bool expand_labels_hierarchy = 29 [default = false];</code>
       * @return Whether the expandLabelsHierarchy field is set.
       */
      @java.lang.Override
      public boolean hasExpandLabelsHierarchy() {
        return ((bitField1_ & 0x00000004) != 0);
      }
      /**
       * <pre>
       * Expand labels to ancestors or descendants in the hierarchy for
       * for positive and negative labels, respectively.
       * </pre>
       *
       * <code>optional bool expand_labels_hierarchy = 29 [default = false];</code>
       * @return The expandLabelsHierarchy.
       */
      @java.lang.Override
      public boolean getExpandLabelsHierarchy() {
        return expandLabelsHierarchy_;
      }
      /**
       * <pre>
       * Expand labels to ancestors or descendants in the hierarchy for
       * for positive and negative labels, respectively.
       * </pre>
       *
       * <code>optional bool expand_labels_hierarchy = 29 [default = false];</code>
       * @param value The expandLabelsHierarchy to set.
       * @return This builder for chaining.
       */
      public Builder setExpandLabelsHierarchy(boolean value) {
        bitField1_ |= 0x00000004;
        expandLabelsHierarchy_ = value;
        onChanged();
        return this;
      }
      /**
       * <pre>
       * Expand labels to ancestors or descendants in the hierarchy for
       * for positive and negative labels, respectively.
       * </pre>
       *
       * <code>optional bool expand_labels_hierarchy = 29 [default = false];</code>
       * @return This builder for chaining.
       */
      public Builder clearExpandLabelsHierarchy() {
        bitField1_ = (bitField1_ & ~0x00000004);
        expandLabelsHierarchy_ = false;
        onChanged();
        return this;
      }
      @java.lang.Override
      public final Builder setUnknownFields(
          final com.google.protobuf.UnknownFieldSet unknownFields) {
        return super.setUnknownFields(unknownFields);
      }

      @java.lang.Override
      public final Builder mergeUnknownFields(
          final com.google.protobuf.UnknownFieldSet unknownFields) {
        return super.mergeUnknownFields(unknownFields);
      }


      // @@protoc_insertion_point(builder_scope:object_detection.protos.InputReader)
    }

    // @@protoc_insertion_point(class_scope:object_detection.protos.InputReader)
    private static final object_detection.protos.InputReaderOuterClass.InputReader DEFAULT_INSTANCE;
    static {
      DEFAULT_INSTANCE = new object_detection.protos.InputReaderOuterClass.InputReader();
    }

    public static object_detection.protos.InputReaderOuterClass.InputReader getDefaultInstance() {
      return DEFAULT_INSTANCE;
    }

    @java.lang.Deprecated public static final com.google.protobuf.Parser<InputReader>
        PARSER = new com.google.protobuf.AbstractParser<InputReader>() {
      @java.lang.Override
      public InputReader parsePartialFrom(
          com.google.protobuf.CodedInputStream input,
          com.google.protobuf.ExtensionRegistryLite extensionRegistry)
          throws com.google.protobuf.InvalidProtocolBufferException {
        return new InputReader(input, extensionRegistry);
      }
    };

    public static com.google.protobuf.Parser<InputReader> parser() {
      return PARSER;
    }

    @java.lang.Override
    public com.google.protobuf.Parser<InputReader> getParserForType() {
      return PARSER;
    }

    @java.lang.Override
    public object_detection.protos.InputReaderOuterClass.InputReader getDefaultInstanceForType() {
      return DEFAULT_INSTANCE;
    }

  }

  public interface TFRecordInputReaderOrBuilder extends
      // @@protoc_insertion_point(interface_extends:object_detection.protos.TFRecordInputReader)
      com.google.protobuf.MessageOrBuilder {

    /**
     * <pre>
     * Path(s) to `TFRecordFile`s.
     * </pre>
     *
     * <code>repeated string input_path = 1;</code>
     * @return A list containing the inputPath.
     */
    java.util.List<java.lang.String>
        getInputPathList();
    /**
     * <pre>
     * Path(s) to `TFRecordFile`s.
     * </pre>
     *
     * <code>repeated string input_path = 1;</code>
     * @return The count of inputPath.
     */
    int getInputPathCount();
    /**
     * <pre>
     * Path(s) to `TFRecordFile`s.
     * </pre>
     *
     * <code>repeated string input_path = 1;</code>
     * @param index The index of the element to return.
     * @return The inputPath at the given index.
     */
    java.lang.String getInputPath(int index);
    /**
     * <pre>
     * Path(s) to `TFRecordFile`s.
     * </pre>
     *
     * <code>repeated string input_path = 1;</code>
     * @param index The index of the value to return.
     * @return The bytes of the inputPath at the given index.
     */
    com.google.protobuf.ByteString
        getInputPathBytes(int index);
  }
  /**
   * <pre>
   * An input reader that reads TF Example or TF Sequence Example protos from
   * local TFRecord files.
   * </pre>
   *
   * Protobuf type {@code object_detection.protos.TFRecordInputReader}
   */
  public static final class TFRecordInputReader extends
      com.google.protobuf.GeneratedMessageV3 implements
      // @@protoc_insertion_point(message_implements:object_detection.protos.TFRecordInputReader)
      TFRecordInputReaderOrBuilder {
  private static final long serialVersionUID = 0L;
    // Use TFRecordInputReader.newBuilder() to construct.
    private TFRecordInputReader(com.google.protobuf.GeneratedMessageV3.Builder<?> builder) {
      super(builder);
    }
    private TFRecordInputReader() {
      inputPath_ = com.google.protobuf.LazyStringArrayList.EMPTY;
    }

    @java.lang.Override
    @SuppressWarnings({"unused"})
    protected java.lang.Object newInstance(
        UnusedPrivateParameter unused) {
      return new TFRecordInputReader();
    }

    @java.lang.Override
    public final com.google.protobuf.UnknownFieldSet
    getUnknownFields() {
      return this.unknownFields;
    }
    private TFRecordInputReader(
        com.google.protobuf.CodedInputStream input,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws com.google.protobuf.InvalidProtocolBufferException {
      this();
      if (extensionRegistry == null) {
        throw new java.lang.NullPointerException();
      }
      int mutable_bitField0_ = 0;
      com.google.protobuf.UnknownFieldSet.Builder unknownFields =
          com.google.protobuf.UnknownFieldSet.newBuilder();
      try {
        boolean done = false;
        while (!done) {
          int tag = input.readTag();
          switch (tag) {
            case 0:
              done = true;
              break;
            case 10: {
              com.google.protobuf.ByteString bs = input.readBytes();
              if (!((mutable_bitField0_ & 0x00000001) != 0)) {
                inputPath_ = new com.google.protobuf.LazyStringArrayList();
                mutable_bitField0_ |= 0x00000001;
              }
              inputPath_.add(bs);
              break;
            }
            default: {
              if (!parseUnknownField(
                  input, unknownFields, extensionRegistry, tag)) {
                done = true;
              }
              break;
            }
          }
        }
      } catch (com.google.protobuf.InvalidProtocolBufferException e) {
        throw e.setUnfinishedMessage(this);
      } catch (java.io.IOException e) {
        throw new com.google.protobuf.InvalidProtocolBufferException(
            e).setUnfinishedMessage(this);
      } finally {
        if (((mutable_bitField0_ & 0x00000001) != 0)) {
          inputPath_ = inputPath_.getUnmodifiableView();
        }
        this.unknownFields = unknownFields.build();
        makeExtensionsImmutable();
      }
    }
    public static final com.google.protobuf.Descriptors.Descriptor
        getDescriptor() {
      return object_detection.protos.InputReaderOuterClass.internal_static_object_detection_protos_TFRecordInputReader_descriptor;
    }

    @java.lang.Override
    protected com.google.protobuf.GeneratedMessageV3.FieldAccessorTable
        internalGetFieldAccessorTable() {
      return object_detection.protos.InputReaderOuterClass.internal_static_object_detection_protos_TFRecordInputReader_fieldAccessorTable
          .ensureFieldAccessorsInitialized(
              object_detection.protos.InputReaderOuterClass.TFRecordInputReader.class, object_detection.protos.InputReaderOuterClass.TFRecordInputReader.Builder.class);
    }

    public static final int INPUT_PATH_FIELD_NUMBER = 1;
    private com.google.protobuf.LazyStringList inputPath_;
    /**
     * <pre>
     * Path(s) to `TFRecordFile`s.
     * </pre>
     *
     * <code>repeated string input_path = 1;</code>
     * @return A list containing the inputPath.
     */
    public com.google.protobuf.ProtocolStringList
        getInputPathList() {
      return inputPath_;
    }
    /**
     * <pre>
     * Path(s) to `TFRecordFile`s.
     * </pre>
     *
     * <code>repeated string input_path = 1;</code>
     * @return The count of inputPath.
     */
    public int getInputPathCount() {
      return inputPath_.size();
    }
    /**
     * <pre>
     * Path(s) to `TFRecordFile`s.
     * </pre>
     *
     * <code>repeated string input_path = 1;</code>
     * @param index The index of the element to return.
     * @return The inputPath at the given index.
     */
    public java.lang.String getInputPath(int index) {
      return inputPath_.get(index);
    }
    /**
     * <pre>
     * Path(s) to `TFRecordFile`s.
     * </pre>
     *
     * <code>repeated string input_path = 1;</code>
     * @param index The index of the value to return.
     * @return The bytes of the inputPath at the given index.
     */
    public com.google.protobuf.ByteString
        getInputPathBytes(int index) {
      return inputPath_.getByteString(index);
    }

    private byte memoizedIsInitialized = -1;
    @java.lang.Override
    public final boolean isInitialized() {
      byte isInitialized = memoizedIsInitialized;
      if (isInitialized == 1) return true;
      if (isInitialized == 0) return false;

      memoizedIsInitialized = 1;
      return true;
    }

    @java.lang.Override
    public void writeTo(com.google.protobuf.CodedOutputStream output)
                        throws java.io.IOException {
      for (int i = 0; i < inputPath_.size(); i++) {
        com.google.protobuf.GeneratedMessageV3.writeString(output, 1, inputPath_.getRaw(i));
      }
      unknownFields.writeTo(output);
    }

    @java.lang.Override
    public int getSerializedSize() {
      int size = memoizedSize;
      if (size != -1) return size;

      size = 0;
      {
        int dataSize = 0;
        for (int i = 0; i < inputPath_.size(); i++) {
          dataSize += computeStringSizeNoTag(inputPath_.getRaw(i));
        }
        size += dataSize;
        size += 1 * getInputPathList().size();
      }
      size += unknownFields.getSerializedSize();
      memoizedSize = size;
      return size;
    }

    @java.lang.Override
    public boolean equals(final java.lang.Object obj) {
      if (obj == this) {
       return true;
      }
      if (!(obj instanceof object_detection.protos.InputReaderOuterClass.TFRecordInputReader)) {
        return super.equals(obj);
      }
      object_detection.protos.InputReaderOuterClass.TFRecordInputReader other = (object_detection.protos.InputReaderOuterClass.TFRecordInputReader) obj;

      if (!getInputPathList()
          .equals(other.getInputPathList())) return false;
      if (!unknownFields.equals(other.unknownFields)) return false;
      return true;
    }

    @java.lang.Override
    public int hashCode() {
      if (memoizedHashCode != 0) {
        return memoizedHashCode;
      }
      int hash = 41;
      hash = (19 * hash) + getDescriptor().hashCode();
      if (getInputPathCount() > 0) {
        hash = (37 * hash) + INPUT_PATH_FIELD_NUMBER;
        hash = (53 * hash) + getInputPathList().hashCode();
      }
      hash = (29 * hash) + unknownFields.hashCode();
      memoizedHashCode = hash;
      return hash;
    }

    public static object_detection.protos.InputReaderOuterClass.TFRecordInputReader parseFrom(
        java.nio.ByteBuffer data)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return PARSER.parseFrom(data);
    }
    public static object_detection.protos.InputReaderOuterClass.TFRecordInputReader parseFrom(
        java.nio.ByteBuffer data,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return PARSER.parseFrom(data, extensionRegistry);
    }
    public static object_detection.protos.InputReaderOuterClass.TFRecordInputReader parseFrom(
        com.google.protobuf.ByteString data)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return PARSER.parseFrom(data);
    }
    public static object_detection.protos.InputReaderOuterClass.TFRecordInputReader parseFrom(
        com.google.protobuf.ByteString data,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return PARSER.parseFrom(data, extensionRegistry);
    }
    public static object_detection.protos.InputReaderOuterClass.TFRecordInputReader parseFrom(byte[] data)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return PARSER.parseFrom(data);
    }
    public static object_detection.protos.InputReaderOuterClass.TFRecordInputReader parseFrom(
        byte[] data,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return PARSER.parseFrom(data, extensionRegistry);
    }
    public static object_detection.protos.InputReaderOuterClass.TFRecordInputReader parseFrom(java.io.InputStream input)
        throws java.io.IOException {
      return com.google.protobuf.GeneratedMessageV3
          .parseWithIOException(PARSER, input);
    }
    public static object_detection.protos.InputReaderOuterClass.TFRecordInputReader parseFrom(
        java.io.InputStream input,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws java.io.IOException {
      return com.google.protobuf.GeneratedMessageV3
          .parseWithIOException(PARSER, input, extensionRegistry);
    }
    public static object_detection.protos.InputReaderOuterClass.TFRecordInputReader parseDelimitedFrom(java.io.InputStream input)
        throws java.io.IOException {
      return com.google.protobuf.GeneratedMessageV3
          .parseDelimitedWithIOException(PARSER, input);
    }
    public static object_detection.protos.InputReaderOuterClass.TFRecordInputReader parseDelimitedFrom(
        java.io.InputStream input,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws java.io.IOException {
      return com.google.protobuf.GeneratedMessageV3
          .parseDelimitedWithIOException(PARSER, input, extensionRegistry);
    }
    public static object_detection.protos.InputReaderOuterClass.TFRecordInputReader parseFrom(
        com.google.protobuf.CodedInputStream input)
        throws java.io.IOException {
      return com.google.protobuf.GeneratedMessageV3
          .parseWithIOException(PARSER, input);
    }
    public static object_detection.protos.InputReaderOuterClass.TFRecordInputReader parseFrom(
        com.google.protobuf.CodedInputStream input,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws java.io.IOException {
      return com.google.protobuf.GeneratedMessageV3
          .parseWithIOException(PARSER, input, extensionRegistry);
    }

    @java.lang.Override
    public Builder newBuilderForType() { return newBuilder(); }
    public static Builder newBuilder() {
      return DEFAULT_INSTANCE.toBuilder();
    }
    public static Builder newBuilder(object_detection.protos.InputReaderOuterClass.TFRecordInputReader prototype) {
      return DEFAULT_INSTANCE.toBuilder().mergeFrom(prototype);
    }
    @java.lang.Override
    public Builder toBuilder() {
      return this == DEFAULT_INSTANCE
          ? new Builder() : new Builder().mergeFrom(this);
    }

    @java.lang.Override
    protected Builder newBuilderForType(
        com.google.protobuf.GeneratedMessageV3.BuilderParent parent) {
      Builder builder = new Builder(parent);
      return builder;
    }
    /**
     * <pre>
     * An input reader that reads TF Example or TF Sequence Example protos from
     * local TFRecord files.
     * </pre>
     *
     * Protobuf type {@code object_detection.protos.TFRecordInputReader}
     */
    public static final class Builder extends
        com.google.protobuf.GeneratedMessageV3.Builder<Builder> implements
        // @@protoc_insertion_point(builder_implements:object_detection.protos.TFRecordInputReader)
        object_detection.protos.InputReaderOuterClass.TFRecordInputReaderOrBuilder {
      public static final com.google.protobuf.Descriptors.Descriptor
          getDescriptor() {
        return object_detection.protos.InputReaderOuterClass.internal_static_object_detection_protos_TFRecordInputReader_descriptor;
      }

      @java.lang.Override
      protected com.google.protobuf.GeneratedMessageV3.FieldAccessorTable
          internalGetFieldAccessorTable() {
        return object_detection.protos.InputReaderOuterClass.internal_static_object_detection_protos_TFRecordInputReader_fieldAccessorTable
            .ensureFieldAccessorsInitialized(
                object_detection.protos.InputReaderOuterClass.TFRecordInputReader.class, object_detection.protos.InputReaderOuterClass.TFRecordInputReader.Builder.class);
      }

      // Construct using object_detection.protos.InputReaderOuterClass.TFRecordInputReader.newBuilder()
      private Builder() {
        maybeForceBuilderInitialization();
      }

      private Builder(
          com.google.protobuf.GeneratedMessageV3.BuilderParent parent) {
        super(parent);
        maybeForceBuilderInitialization();
      }
      private void maybeForceBuilderInitialization() {
        if (com.google.protobuf.GeneratedMessageV3
                .alwaysUseFieldBuilders) {
        }
      }
      @java.lang.Override
      public Builder clear() {
        super.clear();
        inputPath_ = com.google.protobuf.LazyStringArrayList.EMPTY;
        bitField0_ = (bitField0_ & ~0x00000001);
        return this;
      }

      @java.lang.Override
      public com.google.protobuf.Descriptors.Descriptor
          getDescriptorForType() {
        return object_detection.protos.InputReaderOuterClass.internal_static_object_detection_protos_TFRecordInputReader_descriptor;
      }

      @java.lang.Override
      public object_detection.protos.InputReaderOuterClass.TFRecordInputReader getDefaultInstanceForType() {
        return object_detection.protos.InputReaderOuterClass.TFRecordInputReader.getDefaultInstance();
      }

      @java.lang.Override
      public object_detection.protos.InputReaderOuterClass.TFRecordInputReader build() {
        object_detection.protos.InputReaderOuterClass.TFRecordInputReader result = buildPartial();
        if (!result.isInitialized()) {
          throw newUninitializedMessageException(result);
        }
        return result;
      }

      @java.lang.Override
      public object_detection.protos.InputReaderOuterClass.TFRecordInputReader buildPartial() {
        object_detection.protos.InputReaderOuterClass.TFRecordInputReader result = new object_detection.protos.InputReaderOuterClass.TFRecordInputReader(this);
        int from_bitField0_ = bitField0_;
        if (((bitField0_ & 0x00000001) != 0)) {
          inputPath_ = inputPath_.getUnmodifiableView();
          bitField0_ = (bitField0_ & ~0x00000001);
        }
        result.inputPath_ = inputPath_;
        onBuilt();
        return result;
      }

      @java.lang.Override
      public Builder clone() {
        return super.clone();
      }
      @java.lang.Override
      public Builder setField(
          com.google.protobuf.Descriptors.FieldDescriptor field,
          java.lang.Object value) {
        return super.setField(field, value);
      }
      @java.lang.Override
      public Builder clearField(
          com.google.protobuf.Descriptors.FieldDescriptor field) {
        return super.clearField(field);
      }
      @java.lang.Override
      public Builder clearOneof(
          com.google.protobuf.Descriptors.OneofDescriptor oneof) {
        return super.clearOneof(oneof);
      }
      @java.lang.Override
      public Builder setRepeatedField(
          com.google.protobuf.Descriptors.FieldDescriptor field,
          int index, java.lang.Object value) {
        return super.setRepeatedField(field, index, value);
      }
      @java.lang.Override
      public Builder addRepeatedField(
          com.google.protobuf.Descriptors.FieldDescriptor field,
          java.lang.Object value) {
        return super.addRepeatedField(field, value);
      }
      @java.lang.Override
      public Builder mergeFrom(com.google.protobuf.Message other) {
        if (other instanceof object_detection.protos.InputReaderOuterClass.TFRecordInputReader) {
          return mergeFrom((object_detection.protos.InputReaderOuterClass.TFRecordInputReader)other);
        } else {
          super.mergeFrom(other);
          return this;
        }
      }

      public Builder mergeFrom(object_detection.protos.InputReaderOuterClass.TFRecordInputReader other) {
        if (other == object_detection.protos.InputReaderOuterClass.TFRecordInputReader.getDefaultInstance()) return this;
        if (!other.inputPath_.isEmpty()) {
          if (inputPath_.isEmpty()) {
            inputPath_ = other.inputPath_;
            bitField0_ = (bitField0_ & ~0x00000001);
          } else {
            ensureInputPathIsMutable();
            inputPath_.addAll(other.inputPath_);
          }
          onChanged();
        }
        this.mergeUnknownFields(other.unknownFields);
        onChanged();
        return this;
      }

      @java.lang.Override
      public final boolean isInitialized() {
        return true;
      }

      @java.lang.Override
      public Builder mergeFrom(
          com.google.protobuf.CodedInputStream input,
          com.google.protobuf.ExtensionRegistryLite extensionRegistry)
          throws java.io.IOException {
        object_detection.protos.InputReaderOuterClass.TFRecordInputReader parsedMessage = null;
        try {
          parsedMessage = PARSER.parsePartialFrom(input, extensionRegistry);
        } catch (com.google.protobuf.InvalidProtocolBufferException e) {
          parsedMessage = (object_detection.protos.InputReaderOuterClass.TFRecordInputReader) e.getUnfinishedMessage();
          throw e.unwrapIOException();
        } finally {
          if (parsedMessage != null) {
            mergeFrom(parsedMessage);
          }
        }
        return this;
      }
      private int bitField0_;

      private com.google.protobuf.LazyStringList inputPath_ = com.google.protobuf.LazyStringArrayList.EMPTY;
      private void ensureInputPathIsMutable() {
        if (!((bitField0_ & 0x00000001) != 0)) {
          inputPath_ = new com.google.protobuf.LazyStringArrayList(inputPath_);
          bitField0_ |= 0x00000001;
         }
      }
      /**
       * <pre>
       * Path(s) to `TFRecordFile`s.
       * </pre>
       *
       * <code>repeated string input_path = 1;</code>
       * @return A list containing the inputPath.
       */
      public com.google.protobuf.ProtocolStringList
          getInputPathList() {
        return inputPath_.getUnmodifiableView();
      }
      /**
       * <pre>
       * Path(s) to `TFRecordFile`s.
       * </pre>
       *
       * <code>repeated string input_path = 1;</code>
       * @return The count of inputPath.
       */
      public int getInputPathCount() {
        return inputPath_.size();
      }
      /**
       * <pre>
       * Path(s) to `TFRecordFile`s.
       * </pre>
       *
       * <code>repeated string input_path = 1;</code>
       * @param index The index of the element to return.
       * @return The inputPath at the given index.
       */
      public java.lang.String getInputPath(int index) {
        return inputPath_.get(index);
      }
      /**
       * <pre>
       * Path(s) to `TFRecordFile`s.
       * </pre>
       *
       * <code>repeated string input_path = 1;</code>
       * @param index The index of the value to return.
       * @return The bytes of the inputPath at the given index.
       */
      public com.google.protobuf.ByteString
          getInputPathBytes(int index) {
        return inputPath_.getByteString(index);
      }
      /**
       * <pre>
       * Path(s) to `TFRecordFile`s.
       * </pre>
       *
       * <code>repeated string input_path = 1;</code>
       * @param index The index to set the value at.
       * @param value The inputPath to set.
       * @return This builder for chaining.
       */
      public Builder setInputPath(
          int index, java.lang.String value) {
        if (value == null) {
    throw new NullPointerException();
  }
  ensureInputPathIsMutable();
        inputPath_.set(index, value);
        onChanged();
        return this;
      }
      /**
       * <pre>
       * Path(s) to `TFRecordFile`s.
       * </pre>
       *
       * <code>repeated string input_path = 1;</code>
       * @param value The inputPath to add.
       * @return This builder for chaining.
       */
      public Builder addInputPath(
          java.lang.String value) {
        if (value == null) {
    throw new NullPointerException();
  }
  ensureInputPathIsMutable();
        inputPath_.add(value);
        onChanged();
        return this;
      }
      /**
       * <pre>
       * Path(s) to `TFRecordFile`s.
       * </pre>
       *
       * <code>repeated string input_path = 1;</code>
       * @param values The inputPath to add.
       * @return This builder for chaining.
       */
      public Builder addAllInputPath(
          java.lang.Iterable<java.lang.String> values) {
        ensureInputPathIsMutable();
        com.google.protobuf.AbstractMessageLite.Builder.addAll(
            values, inputPath_);
        onChanged();
        return this;
      }
      /**
       * <pre>
       * Path(s) to `TFRecordFile`s.
       * </pre>
       *
       * <code>repeated string input_path = 1;</code>
       * @return This builder for chaining.
       */
      public Builder clearInputPath() {
        inputPath_ = com.google.protobuf.LazyStringArrayList.EMPTY;
        bitField0_ = (bitField0_ & ~0x00000001);
        onChanged();
        return this;
      }
      /**
       * <pre>
       * Path(s) to `TFRecordFile`s.
       * </pre>
       *
       * <code>repeated string input_path = 1;</code>
       * @param value The bytes of the inputPath to add.
       * @return This builder for chaining.
       */
      public Builder addInputPathBytes(
          com.google.protobuf.ByteString value) {
        if (value == null) {
    throw new NullPointerException();
  }
  ensureInputPathIsMutable();
        inputPath_.add(value);
        onChanged();
        return this;
      }
      @java.lang.Override
      public final Builder setUnknownFields(
          final com.google.protobuf.UnknownFieldSet unknownFields) {
        return super.setUnknownFields(unknownFields);
      }

      @java.lang.Override
      public final Builder mergeUnknownFields(
          final com.google.protobuf.UnknownFieldSet unknownFields) {
        return super.mergeUnknownFields(unknownFields);
      }


      // @@protoc_insertion_point(builder_scope:object_detection.protos.TFRecordInputReader)
    }

    // @@protoc_insertion_point(class_scope:object_detection.protos.TFRecordInputReader)
    private static final object_detection.protos.InputReaderOuterClass.TFRecordInputReader DEFAULT_INSTANCE;
    static {
      DEFAULT_INSTANCE = new object_detection.protos.InputReaderOuterClass.TFRecordInputReader();
    }

    public static object_detection.protos.InputReaderOuterClass.TFRecordInputReader getDefaultInstance() {
      return DEFAULT_INSTANCE;
    }

    @java.lang.Deprecated public static final com.google.protobuf.Parser<TFRecordInputReader>
        PARSER = new com.google.protobuf.AbstractParser<TFRecordInputReader>() {
      @java.lang.Override
      public TFRecordInputReader parsePartialFrom(
          com.google.protobuf.CodedInputStream input,
          com.google.protobuf.ExtensionRegistryLite extensionRegistry)
          throws com.google.protobuf.InvalidProtocolBufferException {
        return new TFRecordInputReader(input, extensionRegistry);
      }
    };

    public static com.google.protobuf.Parser<TFRecordInputReader> parser() {
      return PARSER;
    }

    @java.lang.Override
    public com.google.protobuf.Parser<TFRecordInputReader> getParserForType() {
      return PARSER;
    }

    @java.lang.Override
    public object_detection.protos.InputReaderOuterClass.TFRecordInputReader getDefaultInstanceForType() {
      return DEFAULT_INSTANCE;
    }

  }

  public interface ExternalInputReaderOrBuilder extends
      // @@protoc_insertion_point(interface_extends:object_detection.protos.ExternalInputReader)
      com.google.protobuf.GeneratedMessageV3.
          ExtendableMessageOrBuilder<ExternalInputReader> {
  }
  /**
   * <pre>
   * An externally defined input reader. Users may define an extension to this
   * proto to interface their own input readers.
   * </pre>
   *
   * Protobuf type {@code object_detection.protos.ExternalInputReader}
   */
  public static final class ExternalInputReader extends
      com.google.protobuf.GeneratedMessageV3.ExtendableMessage<
        ExternalInputReader> implements
      // @@protoc_insertion_point(message_implements:object_detection.protos.ExternalInputReader)
      ExternalInputReaderOrBuilder {
  private static final long serialVersionUID = 0L;
    // Use ExternalInputReader.newBuilder() to construct.
    private ExternalInputReader(com.google.protobuf.GeneratedMessageV3.ExtendableBuilder<object_detection.protos.InputReaderOuterClass.ExternalInputReader, ?> builder) {
      super(builder);
    }
    private ExternalInputReader() {
    }

    @java.lang.Override
    @SuppressWarnings({"unused"})
    protected java.lang.Object newInstance(
        UnusedPrivateParameter unused) {
      return new ExternalInputReader();
    }

    @java.lang.Override
    public final com.google.protobuf.UnknownFieldSet
    getUnknownFields() {
      return this.unknownFields;
    }
    private ExternalInputReader(
        com.google.protobuf.CodedInputStream input,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws com.google.protobuf.InvalidProtocolBufferException {
      this();
      if (extensionRegistry == null) {
        throw new java.lang.NullPointerException();
      }
      com.google.protobuf.UnknownFieldSet.Builder unknownFields =
          com.google.protobuf.UnknownFieldSet.newBuilder();
      try {
        boolean done = false;
        while (!done) {
          int tag = input.readTag();
          switch (tag) {
            case 0:
              done = true;
              break;
            default: {
              if (!parseUnknownField(
                  input, unknownFields, extensionRegistry, tag)) {
                done = true;
              }
              break;
            }
          }
        }
      } catch (com.google.protobuf.InvalidProtocolBufferException e) {
        throw e.setUnfinishedMessage(this);
      } catch (java.io.IOException e) {
        throw new com.google.protobuf.InvalidProtocolBufferException(
            e).setUnfinishedMessage(this);
      } finally {
        this.unknownFields = unknownFields.build();
        makeExtensionsImmutable();
      }
    }
    public static final com.google.protobuf.Descriptors.Descriptor
        getDescriptor() {
      return object_detection.protos.InputReaderOuterClass.internal_static_object_detection_protos_ExternalInputReader_descriptor;
    }

    @java.lang.Override
    protected com.google.protobuf.GeneratedMessageV3.FieldAccessorTable
        internalGetFieldAccessorTable() {
      return object_detection.protos.InputReaderOuterClass.internal_static_object_detection_protos_ExternalInputReader_fieldAccessorTable
          .ensureFieldAccessorsInitialized(
              object_detection.protos.InputReaderOuterClass.ExternalInputReader.class, object_detection.protos.InputReaderOuterClass.ExternalInputReader.Builder.class);
    }

    private byte memoizedIsInitialized = -1;
    @java.lang.Override
    public final boolean isInitialized() {
      byte isInitialized = memoizedIsInitialized;
      if (isInitialized == 1) return true;
      if (isInitialized == 0) return false;

      if (!extensionsAreInitialized()) {
        memoizedIsInitialized = 0;
        return false;
      }
      memoizedIsInitialized = 1;
      return true;
    }

    @java.lang.Override
    public void writeTo(com.google.protobuf.CodedOutputStream output)
                        throws java.io.IOException {
      com.google.protobuf.GeneratedMessageV3
        .ExtendableMessage<object_detection.protos.InputReaderOuterClass.ExternalInputReader>.ExtensionWriter
          extensionWriter = newExtensionWriter();
      extensionWriter.writeUntil(1000, output);
      unknownFields.writeTo(output);
    }

    @java.lang.Override
    public int getSerializedSize() {
      int size = memoizedSize;
      if (size != -1) return size;

      size = 0;
      size += extensionsSerializedSize();
      size += unknownFields.getSerializedSize();
      memoizedSize = size;
      return size;
    }

    @java.lang.Override
    public boolean equals(final java.lang.Object obj) {
      if (obj == this) {
       return true;
      }
      if (!(obj instanceof object_detection.protos.InputReaderOuterClass.ExternalInputReader)) {
        return super.equals(obj);
      }
      object_detection.protos.InputReaderOuterClass.ExternalInputReader other = (object_detection.protos.InputReaderOuterClass.ExternalInputReader) obj;

      if (!unknownFields.equals(other.unknownFields)) return false;
      if (!getExtensionFields().equals(other.getExtensionFields()))
        return false;
      return true;
    }

    @java.lang.Override
    public int hashCode() {
      if (memoizedHashCode != 0) {
        return memoizedHashCode;
      }
      int hash = 41;
      hash = (19 * hash) + getDescriptor().hashCode();
      hash = hashFields(hash, getExtensionFields());
      hash = (29 * hash) + unknownFields.hashCode();
      memoizedHashCode = hash;
      return hash;
    }

    public static object_detection.protos.InputReaderOuterClass.ExternalInputReader parseFrom(
        java.nio.ByteBuffer data)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return PARSER.parseFrom(data);
    }
    public static object_detection.protos.InputReaderOuterClass.ExternalInputReader parseFrom(
        java.nio.ByteBuffer data,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return PARSER.parseFrom(data, extensionRegistry);
    }
    public static object_detection.protos.InputReaderOuterClass.ExternalInputReader parseFrom(
        com.google.protobuf.ByteString data)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return PARSER.parseFrom(data);
    }
    public static object_detection.protos.InputReaderOuterClass.ExternalInputReader parseFrom(
        com.google.protobuf.ByteString data,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return PARSER.parseFrom(data, extensionRegistry);
    }
    public static object_detection.protos.InputReaderOuterClass.ExternalInputReader parseFrom(byte[] data)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return PARSER.parseFrom(data);
    }
    public static object_detection.protos.InputReaderOuterClass.ExternalInputReader parseFrom(
        byte[] data,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return PARSER.parseFrom(data, extensionRegistry);
    }
    public static object_detection.protos.InputReaderOuterClass.ExternalInputReader parseFrom(java.io.InputStream input)
        throws java.io.IOException {
      return com.google.protobuf.GeneratedMessageV3
          .parseWithIOException(PARSER, input);
    }
    public static object_detection.protos.InputReaderOuterClass.ExternalInputReader parseFrom(
        java.io.InputStream input,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws java.io.IOException {
      return com.google.protobuf.GeneratedMessageV3
          .parseWithIOException(PARSER, input, extensionRegistry);
    }
    public static object_detection.protos.InputReaderOuterClass.ExternalInputReader parseDelimitedFrom(java.io.InputStream input)
        throws java.io.IOException {
      return com.google.protobuf.GeneratedMessageV3
          .parseDelimitedWithIOException(PARSER, input);
    }
    public static object_detection.protos.InputReaderOuterClass.ExternalInputReader parseDelimitedFrom(
        java.io.InputStream input,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws java.io.IOException {
      return com.google.protobuf.GeneratedMessageV3
          .parseDelimitedWithIOException(PARSER, input, extensionRegistry);
    }
    public static object_detection.protos.InputReaderOuterClass.ExternalInputReader parseFrom(
        com.google.protobuf.CodedInputStream input)
        throws java.io.IOException {
      return com.google.protobuf.GeneratedMessageV3
          .parseWithIOException(PARSER, input);
    }
    public static object_detection.protos.InputReaderOuterClass.ExternalInputReader parseFrom(
        com.google.protobuf.CodedInputStream input,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws java.io.IOException {
      return com.google.protobuf.GeneratedMessageV3
          .parseWithIOException(PARSER, input, extensionRegistry);
    }

    @java.lang.Override
    public Builder newBuilderForType() { return newBuilder(); }
    public static Builder newBuilder() {
      return DEFAULT_INSTANCE.toBuilder();
    }
    public static Builder newBuilder(object_detection.protos.InputReaderOuterClass.ExternalInputReader prototype) {
      return DEFAULT_INSTANCE.toBuilder().mergeFrom(prototype);
    }
    @java.lang.Override
    public Builder toBuilder() {
      return this == DEFAULT_INSTANCE
          ? new Builder() : new Builder().mergeFrom(this);
    }

    @java.lang.Override
    protected Builder newBuilderForType(
        com.google.protobuf.GeneratedMessageV3.BuilderParent parent) {
      Builder builder = new Builder(parent);
      return builder;
    }
    /**
     * <pre>
     * An externally defined input reader. Users may define an extension to this
     * proto to interface their own input readers.
     * </pre>
     *
     * Protobuf type {@code object_detection.protos.ExternalInputReader}
     */
    public static final class Builder extends
        com.google.protobuf.GeneratedMessageV3.ExtendableBuilder<
          object_detection.protos.InputReaderOuterClass.ExternalInputReader, Builder> implements
        // @@protoc_insertion_point(builder_implements:object_detection.protos.ExternalInputReader)
        object_detection.protos.InputReaderOuterClass.ExternalInputReaderOrBuilder {
      public static final com.google.protobuf.Descriptors.Descriptor
          getDescriptor() {
        return object_detection.protos.InputReaderOuterClass.internal_static_object_detection_protos_ExternalInputReader_descriptor;
      }

      @java.lang.Override
      protected com.google.protobuf.GeneratedMessageV3.FieldAccessorTable
          internalGetFieldAccessorTable() {
        return object_detection.protos.InputReaderOuterClass.internal_static_object_detection_protos_ExternalInputReader_fieldAccessorTable
            .ensureFieldAccessorsInitialized(
                object_detection.protos.InputReaderOuterClass.ExternalInputReader.class, object_detection.protos.InputReaderOuterClass.ExternalInputReader.Builder.class);
      }

      // Construct using object_detection.protos.InputReaderOuterClass.ExternalInputReader.newBuilder()
      private Builder() {
        maybeForceBuilderInitialization();
      }

      private Builder(
          com.google.protobuf.GeneratedMessageV3.BuilderParent parent) {
        super(parent);
        maybeForceBuilderInitialization();
      }
      private void maybeForceBuilderInitialization() {
        if (com.google.protobuf.GeneratedMessageV3
                .alwaysUseFieldBuilders) {
        }
      }
      @java.lang.Override
      public Builder clear() {
        super.clear();
        return this;
      }

      @java.lang.Override
      public com.google.protobuf.Descriptors.Descriptor
          getDescriptorForType() {
        return object_detection.protos.InputReaderOuterClass.internal_static_object_detection_protos_ExternalInputReader_descriptor;
      }

      @java.lang.Override
      public object_detection.protos.InputReaderOuterClass.ExternalInputReader getDefaultInstanceForType() {
        return object_detection.protos.InputReaderOuterClass.ExternalInputReader.getDefaultInstance();
      }

      @java.lang.Override
      public object_detection.protos.InputReaderOuterClass.ExternalInputReader build() {
        object_detection.protos.InputReaderOuterClass.ExternalInputReader result = buildPartial();
        if (!result.isInitialized()) {
          throw newUninitializedMessageException(result);
        }
        return result;
      }

      @java.lang.Override
      public object_detection.protos.InputReaderOuterClass.ExternalInputReader buildPartial() {
        object_detection.protos.InputReaderOuterClass.ExternalInputReader result = new object_detection.protos.InputReaderOuterClass.ExternalInputReader(this);
        onBuilt();
        return result;
      }

      @java.lang.Override
      public Builder clone() {
        return super.clone();
      }
      @java.lang.Override
      public Builder setField(
          com.google.protobuf.Descriptors.FieldDescriptor field,
          java.lang.Object value) {
        return super.setField(field, value);
      }
      @java.lang.Override
      public Builder clearField(
          com.google.protobuf.Descriptors.FieldDescriptor field) {
        return super.clearField(field);
      }
      @java.lang.Override
      public Builder clearOneof(
          com.google.protobuf.Descriptors.OneofDescriptor oneof) {
        return super.clearOneof(oneof);
      }
      @java.lang.Override
      public Builder setRepeatedField(
          com.google.protobuf.Descriptors.FieldDescriptor field,
          int index, java.lang.Object value) {
        return super.setRepeatedField(field, index, value);
      }
      @java.lang.Override
      public Builder addRepeatedField(
          com.google.protobuf.Descriptors.FieldDescriptor field,
          java.lang.Object value) {
        return super.addRepeatedField(field, value);
      }
      @java.lang.Override
      public <Type> Builder setExtension(
          com.google.protobuf.GeneratedMessage.GeneratedExtension<
              object_detection.protos.InputReaderOuterClass.ExternalInputReader, Type> extension,
          Type value) {
        return super.setExtension(extension, value);
      }
      @java.lang.Override
      public <Type> Builder setExtension(
          com.google.protobuf.GeneratedMessage.GeneratedExtension<
              object_detection.protos.InputReaderOuterClass.ExternalInputReader, java.util.List<Type>> extension,
          int index, Type value) {
        return super.setExtension(extension, index, value);
      }
      @java.lang.Override
      public <Type> Builder addExtension(
          com.google.protobuf.GeneratedMessage.GeneratedExtension<
              object_detection.protos.InputReaderOuterClass.ExternalInputReader, java.util.List<Type>> extension,
          Type value) {
        return super.addExtension(extension, value);
      }
      @java.lang.Override
      public <Type> Builder clearExtension(
          com.google.protobuf.GeneratedMessage.GeneratedExtension<
              object_detection.protos.InputReaderOuterClass.ExternalInputReader, ?> extension) {
        return super.clearExtension(extension);
      }
      @java.lang.Override
      public Builder mergeFrom(com.google.protobuf.Message other) {
        if (other instanceof object_detection.protos.InputReaderOuterClass.ExternalInputReader) {
          return mergeFrom((object_detection.protos.InputReaderOuterClass.ExternalInputReader)other);
        } else {
          super.mergeFrom(other);
          return this;
        }
      }

      public Builder mergeFrom(object_detection.protos.InputReaderOuterClass.ExternalInputReader other) {
        if (other == object_detection.protos.InputReaderOuterClass.ExternalInputReader.getDefaultInstance()) return this;
        this.mergeExtensionFields(other);
        this.mergeUnknownFields(other.unknownFields);
        onChanged();
        return this;
      }

      @java.lang.Override
      public final boolean isInitialized() {
        if (!extensionsAreInitialized()) {
          return false;
        }
        return true;
      }

      @java.lang.Override
      public Builder mergeFrom(
          com.google.protobuf.CodedInputStream input,
          com.google.protobuf.ExtensionRegistryLite extensionRegistry)
          throws java.io.IOException {
        object_detection.protos.InputReaderOuterClass.ExternalInputReader parsedMessage = null;
        try {
          parsedMessage = PARSER.parsePartialFrom(input, extensionRegistry);
        } catch (com.google.protobuf.InvalidProtocolBufferException e) {
          parsedMessage = (object_detection.protos.InputReaderOuterClass.ExternalInputReader) e.getUnfinishedMessage();
          throw e.unwrapIOException();
        } finally {
          if (parsedMessage != null) {
            mergeFrom(parsedMessage);
          }
        }
        return this;
      }
      @java.lang.Override
      public final Builder setUnknownFields(
          final com.google.protobuf.UnknownFieldSet unknownFields) {
        return super.setUnknownFields(unknownFields);
      }

      @java.lang.Override
      public final Builder mergeUnknownFields(
          final com.google.protobuf.UnknownFieldSet unknownFields) {
        return super.mergeUnknownFields(unknownFields);
      }


      // @@protoc_insertion_point(builder_scope:object_detection.protos.ExternalInputReader)
    }

    // @@protoc_insertion_point(class_scope:object_detection.protos.ExternalInputReader)
    private static final object_detection.protos.InputReaderOuterClass.ExternalInputReader DEFAULT_INSTANCE;
    static {
      DEFAULT_INSTANCE = new object_detection.protos.InputReaderOuterClass.ExternalInputReader();
    }

    public static object_detection.protos.InputReaderOuterClass.ExternalInputReader getDefaultInstance() {
      return DEFAULT_INSTANCE;
    }

    @java.lang.Deprecated public static final com.google.protobuf.Parser<ExternalInputReader>
        PARSER = new com.google.protobuf.AbstractParser<ExternalInputReader>() {
      @java.lang.Override
      public ExternalInputReader parsePartialFrom(
          com.google.protobuf.CodedInputStream input,
          com.google.protobuf.ExtensionRegistryLite extensionRegistry)
          throws com.google.protobuf.InvalidProtocolBufferException {
        return new ExternalInputReader(input, extensionRegistry);
      }
    };

    public static com.google.protobuf.Parser<ExternalInputReader> parser() {
      return PARSER;
    }

    @java.lang.Override
    public com.google.protobuf.Parser<ExternalInputReader> getParserForType() {
      return PARSER;
    }

    @java.lang.Override
    public object_detection.protos.InputReaderOuterClass.ExternalInputReader getDefaultInstanceForType() {
      return DEFAULT_INSTANCE;
    }

  }

  private static final com.google.protobuf.Descriptors.Descriptor
    internal_static_object_detection_protos_InputReader_descriptor;
  private static final
    com.google.protobuf.GeneratedMessageV3.FieldAccessorTable
      internal_static_object_detection_protos_InputReader_fieldAccessorTable;
  private static final com.google.protobuf.Descriptors.Descriptor
    internal_static_object_detection_protos_TFRecordInputReader_descriptor;
  private static final
    com.google.protobuf.GeneratedMessageV3.FieldAccessorTable
      internal_static_object_detection_protos_TFRecordInputReader_fieldAccessorTable;
  private static final com.google.protobuf.Descriptors.Descriptor
    internal_static_object_detection_protos_ExternalInputReader_descriptor;
  private static final
    com.google.protobuf.GeneratedMessageV3.FieldAccessorTable
      internal_static_object_detection_protos_ExternalInputReader_fieldAccessorTable;

  public static com.google.protobuf.Descriptors.FileDescriptor
      getDescriptor() {
    return descriptor;
  }
  private static  com.google.protobuf.Descriptors.FileDescriptor
      descriptor;
  static {
    java.lang.String[] descriptorData = {
      "\n*object_detection/protos/input_reader.p" +
      "roto\022\027object_detection.protos\"\276\n\n\013InputR" +
      "eader\022\016\n\004name\030\027 \001(\t:\000\022\030\n\016label_map_path\030" +
      "\001 \001(\t:\000\022\025\n\007shuffle\030\002 \001(\010:\004true\022!\n\023shuffl" +
      "e_buffer_size\030\013 \001(\r:\0042048\022*\n\035filenames_s" +
      "huffle_buffer_size\030\014 \001(\r:\003100\022\025\n\nnum_epo" +
      "chs\030\005 \001(\r:\0010\022!\n\026sample_1_of_n_examples\030\026" +
      " \001(\r:\0011\022\027\n\013num_readers\030\006 \001(\r:\00264\022\037\n\024num_" +
      "parallel_batches\030\023 \001(\r:\0018\022\037\n\024num_prefetc" +
      "h_batches\030\024 \001(\005:\0012\022 \n\016queue_capacity\030\003 \001" +
      "(\r:\0042000B\002\030\001\022#\n\021min_after_dequeue\030\004 \001(\r:" +
      "\0041000B\002\030\001\022\035\n\021read_block_length\030\017 \001(\r:\00232" +
      "\022\036\n\rprefetch_size\030\r \001(\r:\003512B\002\030\001\022&\n\026num_" +
      "parallel_map_calls\030\016 \001(\r:\00264B\002\030\001\022\034\n\016drop" +
      "_remainder\030# \001(\010:\004true\022\"\n\027num_additional" +
      "_channels\030\022 \001(\005:\0010\022\030\n\rnum_keypoints\030\020 \001(" +
      "\r:\0010\022\034\n\024keypoint_type_weight\030\032 \003(\002\022 \n\023ma" +
      "x_number_of_boxes\030\025 \001(\005:\003100\022%\n\026load_mul" +
      "ticlass_scores\030\030 \001(\010:\005false\022$\n\025load_cont" +
      "ext_features\030\031 \001(\010:\005false\022%\n\026load_contex" +
      "t_image_ids\030$ \001(\010:\005false\022\"\n\023load_instanc" +
      "e_masks\030\007 \001(\010:\005false\022M\n\tmask_type\030\n \001(\0162" +
      ").object_detection.protos.InstanceMaskTy" +
      "pe:\017NUMERICAL_MASKS\022\036\n\017load_dense_pose\030\037" +
      " \001(\010:\005false\022\034\n\rload_track_id\030! \001(\010:\005fals" +
      "e\022\037\n\020use_display_name\030\021 \001(\010:\005false\022 \n\021in" +
      "clude_source_id\030\033 \001(\010:\005false\022B\n\ninput_ty" +
      "pe\030\036 \001(\0162\".object_detection.protos.Input" +
      "Type:\nTF_EXAMPLE\022\027\n\013frame_index\030  \001(\005:\002-" +
      "1\022N\n\026tf_record_input_reader\030\010 \001(\0132,.obje" +
      "ct_detection.protos.TFRecordInputReaderH" +
      "\000\022M\n\025external_input_reader\030\t \001(\0132,.objec" +
      "t_detection.protos.ExternalInputReaderH\000" +
      "\022$\n\034sample_from_datasets_weights\030\" \003(\002\022&" +
      "\n\027expand_labels_hierarchy\030\035 \001(\010:\005falseB\016" +
      "\n\014input_reader\")\n\023TFRecordInputReader\022\022\n" +
      "\ninput_path\030\001 \003(\t\"\034\n\023ExternalInputReader" +
      "*\005\010\001\020\350\007*C\n\020InstanceMaskType\022\013\n\007DEFAULT\020\000" +
      "\022\023\n\017NUMERICAL_MASKS\020\001\022\r\n\tPNG_MASKS\020\002*G\n\t" +
      "InputType\022\021\n\rINPUT_DEFAULT\020\000\022\016\n\nTF_EXAMP" +
      "LE\020\001\022\027\n\023TF_SEQUENCE_EXAMPLE\020\002"
    };
    descriptor = com.google.protobuf.Descriptors.FileDescriptor
      .internalBuildGeneratedFileFrom(descriptorData,
        new com.google.protobuf.Descriptors.FileDescriptor[] {
        });
    internal_static_object_detection_protos_InputReader_descriptor =
      getDescriptor().getMessageTypes().get(0);
    internal_static_object_detection_protos_InputReader_fieldAccessorTable = new
      com.google.protobuf.GeneratedMessageV3.FieldAccessorTable(
        internal_static_object_detection_protos_InputReader_descriptor,
        new java.lang.String[] { "Name", "LabelMapPath", "Shuffle", "ShuffleBufferSize", "FilenamesShuffleBufferSize", "NumEpochs", "Sample1OfNExamples", "NumReaders", "NumParallelBatches", "NumPrefetchBatches", "QueueCapacity", "MinAfterDequeue", "ReadBlockLength", "PrefetchSize", "NumParallelMapCalls", "DropRemainder", "NumAdditionalChannels", "NumKeypoints", "KeypointTypeWeight", "MaxNumberOfBoxes", "LoadMulticlassScores", "LoadContextFeatures", "LoadContextImageIds", "LoadInstanceMasks", "MaskType", "LoadDensePose", "LoadTrackId", "UseDisplayName", "IncludeSourceId", "InputType", "FrameIndex", "TfRecordInputReader", "ExternalInputReader", "SampleFromDatasetsWeights", "ExpandLabelsHierarchy", "InputReader", });
    internal_static_object_detection_protos_TFRecordInputReader_descriptor =
      getDescriptor().getMessageTypes().get(1);
    internal_static_object_detection_protos_TFRecordInputReader_fieldAccessorTable = new
      com.google.protobuf.GeneratedMessageV3.FieldAccessorTable(
        internal_static_object_detection_protos_TFRecordInputReader_descriptor,
        new java.lang.String[] { "InputPath", });
    internal_static_object_detection_protos_ExternalInputReader_descriptor =
      getDescriptor().getMessageTypes().get(2);
    internal_static_object_detection_protos_ExternalInputReader_fieldAccessorTable = new
      com.google.protobuf.GeneratedMessageV3.FieldAccessorTable(
        internal_static_object_detection_protos_ExternalInputReader_descriptor,
        new java.lang.String[] { });
  }

  // @@protoc_insertion_point(outer_class_scope)
}
