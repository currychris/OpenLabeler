/*
 * Copyright (c) 2020. Kin-Hong Wong. All Rights Reserved.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

// Generated by the protocol buffer compiler.  DO NOT EDIT!
// source: object_detection/protos/center_net.proto

package object_detection.protos;

public final class CenterNetOuterClass {
  private CenterNetOuterClass() {}
  public static void registerAllExtensions(
      com.google.protobuf.ExtensionRegistryLite registry) {
  }

  public static void registerAllExtensions(
      com.google.protobuf.ExtensionRegistry registry) {
    registerAllExtensions(
        (com.google.protobuf.ExtensionRegistryLite) registry);
  }
  public interface CenterNetOrBuilder extends
      // @@protoc_insertion_point(interface_extends:object_detection.protos.CenterNet)
      com.google.protobuf.MessageOrBuilder {

    /**
     * <pre>
     * Number of classes to predict.
     * </pre>
     *
     * <code>optional int32 num_classes = 1;</code>
     * @return Whether the numClasses field is set.
     */
    boolean hasNumClasses();
    /**
     * <pre>
     * Number of classes to predict.
     * </pre>
     *
     * <code>optional int32 num_classes = 1;</code>
     * @return The numClasses.
     */
    int getNumClasses();

    /**
     * <pre>
     * Feature extractor config.
     * </pre>
     *
     * <code>optional .object_detection.protos.CenterNetFeatureExtractor feature_extractor = 2;</code>
     * @return Whether the featureExtractor field is set.
     */
    boolean hasFeatureExtractor();
    /**
     * <pre>
     * Feature extractor config.
     * </pre>
     *
     * <code>optional .object_detection.protos.CenterNetFeatureExtractor feature_extractor = 2;</code>
     * @return The featureExtractor.
     */
    object_detection.protos.CenterNetOuterClass.CenterNetFeatureExtractor getFeatureExtractor();
    /**
     * <pre>
     * Feature extractor config.
     * </pre>
     *
     * <code>optional .object_detection.protos.CenterNetFeatureExtractor feature_extractor = 2;</code>
     */
    object_detection.protos.CenterNetOuterClass.CenterNetFeatureExtractorOrBuilder getFeatureExtractorOrBuilder();

    /**
     * <pre>
     * Image resizer for preprocessing the input image.
     * </pre>
     *
     * <code>optional .object_detection.protos.ImageResizer image_resizer = 3;</code>
     * @return Whether the imageResizer field is set.
     */
    boolean hasImageResizer();
    /**
     * <pre>
     * Image resizer for preprocessing the input image.
     * </pre>
     *
     * <code>optional .object_detection.protos.ImageResizer image_resizer = 3;</code>
     * @return The imageResizer.
     */
    object_detection.protos.ImageResizerOuterClass.ImageResizer getImageResizer();
    /**
     * <pre>
     * Image resizer for preprocessing the input image.
     * </pre>
     *
     * <code>optional .object_detection.protos.ImageResizer image_resizer = 3;</code>
     */
    object_detection.protos.ImageResizerOuterClass.ImageResizerOrBuilder getImageResizerOrBuilder();

    /**
     * <pre>
     * If set, all task heads will be constructed with separable convolutions.
     * </pre>
     *
     * <code>optional bool use_depthwise = 13 [default = false];</code>
     * @return Whether the useDepthwise field is set.
     */
    boolean hasUseDepthwise();
    /**
     * <pre>
     * If set, all task heads will be constructed with separable convolutions.
     * </pre>
     *
     * <code>optional bool use_depthwise = 13 [default = false];</code>
     * @return The useDepthwise.
     */
    boolean getUseDepthwise();

    /**
     * <pre>
     * Indicates whether or not to use the sparse version of the Op that computes
     * the center heatmaps. The sparse version scales better with number of
     * channels in the heatmap, but in some cases is known to cause an OOM error.
     * TODO(b/170989061) When bug is fixed, make this the default behavior.
     * </pre>
     *
     * <code>optional bool compute_heatmap_sparse = 15 [default = false];</code>
     * @return Whether the computeHeatmapSparse field is set.
     */
    boolean hasComputeHeatmapSparse();
    /**
     * <pre>
     * Indicates whether or not to use the sparse version of the Op that computes
     * the center heatmaps. The sparse version scales better with number of
     * channels in the heatmap, but in some cases is known to cause an OOM error.
     * TODO(b/170989061) When bug is fixed, make this the default behavior.
     * </pre>
     *
     * <code>optional bool compute_heatmap_sparse = 15 [default = false];</code>
     * @return The computeHeatmapSparse.
     */
    boolean getComputeHeatmapSparse();

    /**
     * <code>optional .object_detection.protos.CenterNet.ObjectDetection object_detection_task = 4;</code>
     * @return Whether the objectDetectionTask field is set.
     */
    boolean hasObjectDetectionTask();
    /**
     * <code>optional .object_detection.protos.CenterNet.ObjectDetection object_detection_task = 4;</code>
     * @return The objectDetectionTask.
     */
    object_detection.protos.CenterNetOuterClass.CenterNet.ObjectDetection getObjectDetectionTask();
    /**
     * <code>optional .object_detection.protos.CenterNet.ObjectDetection object_detection_task = 4;</code>
     */
    object_detection.protos.CenterNetOuterClass.CenterNet.ObjectDetectionOrBuilder getObjectDetectionTaskOrBuilder();

    /**
     * <code>optional .object_detection.protos.CenterNet.ObjectCenterParams object_center_params = 5;</code>
     * @return Whether the objectCenterParams field is set.
     */
    boolean hasObjectCenterParams();
    /**
     * <code>optional .object_detection.protos.CenterNet.ObjectCenterParams object_center_params = 5;</code>
     * @return The objectCenterParams.
     */
    object_detection.protos.CenterNetOuterClass.CenterNet.ObjectCenterParams getObjectCenterParams();
    /**
     * <code>optional .object_detection.protos.CenterNet.ObjectCenterParams object_center_params = 5;</code>
     */
    object_detection.protos.CenterNetOuterClass.CenterNet.ObjectCenterParamsOrBuilder getObjectCenterParamsOrBuilder();

    /**
     * <pre>
     * Path of the file that conatins the label map along with the keypoint
     * information, including the keypoint indices, corresponding labels, and the
     * corresponding class. The file should be the same one as used in the input
     * pipeline. Note that a plain text of StringIntLabelMap proto is expected in
     * this file.
     * It is required only if the keypoint estimation task is specified.
     * </pre>
     *
     * <code>optional string keypoint_label_map_path = 6;</code>
     * @return Whether the keypointLabelMapPath field is set.
     */
    boolean hasKeypointLabelMapPath();
    /**
     * <pre>
     * Path of the file that conatins the label map along with the keypoint
     * information, including the keypoint indices, corresponding labels, and the
     * corresponding class. The file should be the same one as used in the input
     * pipeline. Note that a plain text of StringIntLabelMap proto is expected in
     * this file.
     * It is required only if the keypoint estimation task is specified.
     * </pre>
     *
     * <code>optional string keypoint_label_map_path = 6;</code>
     * @return The keypointLabelMapPath.
     */
    java.lang.String getKeypointLabelMapPath();
    /**
     * <pre>
     * Path of the file that conatins the label map along with the keypoint
     * information, including the keypoint indices, corresponding labels, and the
     * corresponding class. The file should be the same one as used in the input
     * pipeline. Note that a plain text of StringIntLabelMap proto is expected in
     * this file.
     * It is required only if the keypoint estimation task is specified.
     * </pre>
     *
     * <code>optional string keypoint_label_map_path = 6;</code>
     * @return The bytes for keypointLabelMapPath.
     */
    com.google.protobuf.ByteString
        getKeypointLabelMapPathBytes();

    /**
     * <code>repeated .object_detection.protos.CenterNet.KeypointEstimation keypoint_estimation_task = 7;</code>
     */
    java.util.List<object_detection.protos.CenterNetOuterClass.CenterNet.KeypointEstimation>
        getKeypointEstimationTaskList();
    /**
     * <code>repeated .object_detection.protos.CenterNet.KeypointEstimation keypoint_estimation_task = 7;</code>
     */
    object_detection.protos.CenterNetOuterClass.CenterNet.KeypointEstimation getKeypointEstimationTask(int index);
    /**
     * <code>repeated .object_detection.protos.CenterNet.KeypointEstimation keypoint_estimation_task = 7;</code>
     */
    int getKeypointEstimationTaskCount();
    /**
     * <code>repeated .object_detection.protos.CenterNet.KeypointEstimation keypoint_estimation_task = 7;</code>
     */
    java.util.List<? extends object_detection.protos.CenterNetOuterClass.CenterNet.KeypointEstimationOrBuilder>
        getKeypointEstimationTaskOrBuilderList();
    /**
     * <code>repeated .object_detection.protos.CenterNet.KeypointEstimation keypoint_estimation_task = 7;</code>
     */
    object_detection.protos.CenterNetOuterClass.CenterNet.KeypointEstimationOrBuilder getKeypointEstimationTaskOrBuilder(
        int index);

    /**
     * <code>optional .object_detection.protos.CenterNet.MaskEstimation mask_estimation_task = 8;</code>
     * @return Whether the maskEstimationTask field is set.
     */
    boolean hasMaskEstimationTask();
    /**
     * <code>optional .object_detection.protos.CenterNet.MaskEstimation mask_estimation_task = 8;</code>
     * @return The maskEstimationTask.
     */
    object_detection.protos.CenterNetOuterClass.CenterNet.MaskEstimation getMaskEstimationTask();
    /**
     * <code>optional .object_detection.protos.CenterNet.MaskEstimation mask_estimation_task = 8;</code>
     */
    object_detection.protos.CenterNetOuterClass.CenterNet.MaskEstimationOrBuilder getMaskEstimationTaskOrBuilder();

    /**
     * <code>optional .object_detection.protos.CenterNet.DensePoseEstimation densepose_estimation_task = 9;</code>
     * @return Whether the denseposeEstimationTask field is set.
     */
    boolean hasDenseposeEstimationTask();
    /**
     * <code>optional .object_detection.protos.CenterNet.DensePoseEstimation densepose_estimation_task = 9;</code>
     * @return The denseposeEstimationTask.
     */
    object_detection.protos.CenterNetOuterClass.CenterNet.DensePoseEstimation getDenseposeEstimationTask();
    /**
     * <code>optional .object_detection.protos.CenterNet.DensePoseEstimation densepose_estimation_task = 9;</code>
     */
    object_detection.protos.CenterNetOuterClass.CenterNet.DensePoseEstimationOrBuilder getDenseposeEstimationTaskOrBuilder();

    /**
     * <code>optional .object_detection.protos.CenterNet.TrackEstimation track_estimation_task = 10;</code>
     * @return Whether the trackEstimationTask field is set.
     */
    boolean hasTrackEstimationTask();
    /**
     * <code>optional .object_detection.protos.CenterNet.TrackEstimation track_estimation_task = 10;</code>
     * @return The trackEstimationTask.
     */
    object_detection.protos.CenterNetOuterClass.CenterNet.TrackEstimation getTrackEstimationTask();
    /**
     * <code>optional .object_detection.protos.CenterNet.TrackEstimation track_estimation_task = 10;</code>
     */
    object_detection.protos.CenterNetOuterClass.CenterNet.TrackEstimationOrBuilder getTrackEstimationTaskOrBuilder();

    /**
     * <code>optional .object_detection.protos.CenterNet.TemporalOffsetEstimation temporal_offset_task = 12;</code>
     * @return Whether the temporalOffsetTask field is set.
     */
    boolean hasTemporalOffsetTask();
    /**
     * <code>optional .object_detection.protos.CenterNet.TemporalOffsetEstimation temporal_offset_task = 12;</code>
     * @return The temporalOffsetTask.
     */
    object_detection.protos.CenterNetOuterClass.CenterNet.TemporalOffsetEstimation getTemporalOffsetTask();
    /**
     * <code>optional .object_detection.protos.CenterNet.TemporalOffsetEstimation temporal_offset_task = 12;</code>
     */
    object_detection.protos.CenterNetOuterClass.CenterNet.TemporalOffsetEstimationOrBuilder getTemporalOffsetTaskOrBuilder();
  }
  /**
   * <pre>
   * Next Id = 16
   * </pre>
   *
   * Protobuf type {@code object_detection.protos.CenterNet}
   */
  public static final class CenterNet extends
      com.google.protobuf.GeneratedMessageV3 implements
      // @@protoc_insertion_point(message_implements:object_detection.protos.CenterNet)
      CenterNetOrBuilder {
  private static final long serialVersionUID = 0L;
    // Use CenterNet.newBuilder() to construct.
    private CenterNet(com.google.protobuf.GeneratedMessageV3.Builder<?> builder) {
      super(builder);
    }
    private CenterNet() {
      keypointLabelMapPath_ = "";
      keypointEstimationTask_ = java.util.Collections.emptyList();
    }

    @java.lang.Override
    @SuppressWarnings({"unused"})
    protected java.lang.Object newInstance(
        UnusedPrivateParameter unused) {
      return new CenterNet();
    }

    @java.lang.Override
    public final com.google.protobuf.UnknownFieldSet
    getUnknownFields() {
      return this.unknownFields;
    }
    private CenterNet(
        com.google.protobuf.CodedInputStream input,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws com.google.protobuf.InvalidProtocolBufferException {
      this();
      if (extensionRegistry == null) {
        throw new java.lang.NullPointerException();
      }
      int mutable_bitField0_ = 0;
      com.google.protobuf.UnknownFieldSet.Builder unknownFields =
          com.google.protobuf.UnknownFieldSet.newBuilder();
      try {
        boolean done = false;
        while (!done) {
          int tag = input.readTag();
          switch (tag) {
            case 0:
              done = true;
              break;
            case 8: {
              bitField0_ |= 0x00000001;
              numClasses_ = input.readInt32();
              break;
            }
            case 18: {
              object_detection.protos.CenterNetOuterClass.CenterNetFeatureExtractor.Builder subBuilder = null;
              if (((bitField0_ & 0x00000002) != 0)) {
                subBuilder = featureExtractor_.toBuilder();
              }
              featureExtractor_ = input.readMessage(object_detection.protos.CenterNetOuterClass.CenterNetFeatureExtractor.PARSER, extensionRegistry);
              if (subBuilder != null) {
                subBuilder.mergeFrom(featureExtractor_);
                featureExtractor_ = subBuilder.buildPartial();
              }
              bitField0_ |= 0x00000002;
              break;
            }
            case 26: {
              object_detection.protos.ImageResizerOuterClass.ImageResizer.Builder subBuilder = null;
              if (((bitField0_ & 0x00000004) != 0)) {
                subBuilder = imageResizer_.toBuilder();
              }
              imageResizer_ = input.readMessage(object_detection.protos.ImageResizerOuterClass.ImageResizer.PARSER, extensionRegistry);
              if (subBuilder != null) {
                subBuilder.mergeFrom(imageResizer_);
                imageResizer_ = subBuilder.buildPartial();
              }
              bitField0_ |= 0x00000004;
              break;
            }
            case 34: {
              object_detection.protos.CenterNetOuterClass.CenterNet.ObjectDetection.Builder subBuilder = null;
              if (((bitField0_ & 0x00000020) != 0)) {
                subBuilder = objectDetectionTask_.toBuilder();
              }
              objectDetectionTask_ = input.readMessage(object_detection.protos.CenterNetOuterClass.CenterNet.ObjectDetection.PARSER, extensionRegistry);
              if (subBuilder != null) {
                subBuilder.mergeFrom(objectDetectionTask_);
                objectDetectionTask_ = subBuilder.buildPartial();
              }
              bitField0_ |= 0x00000020;
              break;
            }
            case 42: {
              object_detection.protos.CenterNetOuterClass.CenterNet.ObjectCenterParams.Builder subBuilder = null;
              if (((bitField0_ & 0x00000040) != 0)) {
                subBuilder = objectCenterParams_.toBuilder();
              }
              objectCenterParams_ = input.readMessage(object_detection.protos.CenterNetOuterClass.CenterNet.ObjectCenterParams.PARSER, extensionRegistry);
              if (subBuilder != null) {
                subBuilder.mergeFrom(objectCenterParams_);
                objectCenterParams_ = subBuilder.buildPartial();
              }
              bitField0_ |= 0x00000040;
              break;
            }
            case 50: {
              com.google.protobuf.ByteString bs = input.readBytes();
              bitField0_ |= 0x00000080;
              keypointLabelMapPath_ = bs;
              break;
            }
            case 58: {
              if (!((mutable_bitField0_ & 0x00000100) != 0)) {
                keypointEstimationTask_ = new java.util.ArrayList<object_detection.protos.CenterNetOuterClass.CenterNet.KeypointEstimation>();
                mutable_bitField0_ |= 0x00000100;
              }
              keypointEstimationTask_.add(
                  input.readMessage(object_detection.protos.CenterNetOuterClass.CenterNet.KeypointEstimation.PARSER, extensionRegistry));
              break;
            }
            case 66: {
              object_detection.protos.CenterNetOuterClass.CenterNet.MaskEstimation.Builder subBuilder = null;
              if (((bitField0_ & 0x00000100) != 0)) {
                subBuilder = maskEstimationTask_.toBuilder();
              }
              maskEstimationTask_ = input.readMessage(object_detection.protos.CenterNetOuterClass.CenterNet.MaskEstimation.PARSER, extensionRegistry);
              if (subBuilder != null) {
                subBuilder.mergeFrom(maskEstimationTask_);
                maskEstimationTask_ = subBuilder.buildPartial();
              }
              bitField0_ |= 0x00000100;
              break;
            }
            case 74: {
              object_detection.protos.CenterNetOuterClass.CenterNet.DensePoseEstimation.Builder subBuilder = null;
              if (((bitField0_ & 0x00000200) != 0)) {
                subBuilder = denseposeEstimationTask_.toBuilder();
              }
              denseposeEstimationTask_ = input.readMessage(object_detection.protos.CenterNetOuterClass.CenterNet.DensePoseEstimation.PARSER, extensionRegistry);
              if (subBuilder != null) {
                subBuilder.mergeFrom(denseposeEstimationTask_);
                denseposeEstimationTask_ = subBuilder.buildPartial();
              }
              bitField0_ |= 0x00000200;
              break;
            }
            case 82: {
              object_detection.protos.CenterNetOuterClass.CenterNet.TrackEstimation.Builder subBuilder = null;
              if (((bitField0_ & 0x00000400) != 0)) {
                subBuilder = trackEstimationTask_.toBuilder();
              }
              trackEstimationTask_ = input.readMessage(object_detection.protos.CenterNetOuterClass.CenterNet.TrackEstimation.PARSER, extensionRegistry);
              if (subBuilder != null) {
                subBuilder.mergeFrom(trackEstimationTask_);
                trackEstimationTask_ = subBuilder.buildPartial();
              }
              bitField0_ |= 0x00000400;
              break;
            }
            case 98: {
              object_detection.protos.CenterNetOuterClass.CenterNet.TemporalOffsetEstimation.Builder subBuilder = null;
              if (((bitField0_ & 0x00000800) != 0)) {
                subBuilder = temporalOffsetTask_.toBuilder();
              }
              temporalOffsetTask_ = input.readMessage(object_detection.protos.CenterNetOuterClass.CenterNet.TemporalOffsetEstimation.PARSER, extensionRegistry);
              if (subBuilder != null) {
                subBuilder.mergeFrom(temporalOffsetTask_);
                temporalOffsetTask_ = subBuilder.buildPartial();
              }
              bitField0_ |= 0x00000800;
              break;
            }
            case 104: {
              bitField0_ |= 0x00000008;
              useDepthwise_ = input.readBool();
              break;
            }
            case 120: {
              bitField0_ |= 0x00000010;
              computeHeatmapSparse_ = input.readBool();
              break;
            }
            default: {
              if (!parseUnknownField(
                  input, unknownFields, extensionRegistry, tag)) {
                done = true;
              }
              break;
            }
          }
        }
      } catch (com.google.protobuf.InvalidProtocolBufferException e) {
        throw e.setUnfinishedMessage(this);
      } catch (java.io.IOException e) {
        throw new com.google.protobuf.InvalidProtocolBufferException(
            e).setUnfinishedMessage(this);
      } finally {
        if (((mutable_bitField0_ & 0x00000100) != 0)) {
          keypointEstimationTask_ = java.util.Collections.unmodifiableList(keypointEstimationTask_);
        }
        this.unknownFields = unknownFields.build();
        makeExtensionsImmutable();
      }
    }
    public static final com.google.protobuf.Descriptors.Descriptor
        getDescriptor() {
      return object_detection.protos.CenterNetOuterClass.internal_static_object_detection_protos_CenterNet_descriptor;
    }

    @java.lang.Override
    protected com.google.protobuf.GeneratedMessageV3.FieldAccessorTable
        internalGetFieldAccessorTable() {
      return object_detection.protos.CenterNetOuterClass.internal_static_object_detection_protos_CenterNet_fieldAccessorTable
          .ensureFieldAccessorsInitialized(
              object_detection.protos.CenterNetOuterClass.CenterNet.class, object_detection.protos.CenterNetOuterClass.CenterNet.Builder.class);
    }

    public interface ObjectDetectionOrBuilder extends
        // @@protoc_insertion_point(interface_extends:object_detection.protos.CenterNet.ObjectDetection)
        com.google.protobuf.MessageOrBuilder {

      /**
       * <pre>
       * Weight of the task loss. The total loss of the model will be the
       * summation of task losses weighted by the weights.
       * </pre>
       *
       * <code>optional float task_loss_weight = 1 [default = 1];</code>
       * @return Whether the taskLossWeight field is set.
       */
      boolean hasTaskLossWeight();
      /**
       * <pre>
       * Weight of the task loss. The total loss of the model will be the
       * summation of task losses weighted by the weights.
       * </pre>
       *
       * <code>optional float task_loss_weight = 1 [default = 1];</code>
       * @return The taskLossWeight.
       */
      float getTaskLossWeight();

      /**
       * <pre>
       * Weight for the offset localization loss.
       * </pre>
       *
       * <code>optional float offset_loss_weight = 3 [default = 1];</code>
       * @return Whether the offsetLossWeight field is set.
       */
      boolean hasOffsetLossWeight();
      /**
       * <pre>
       * Weight for the offset localization loss.
       * </pre>
       *
       * <code>optional float offset_loss_weight = 3 [default = 1];</code>
       * @return The offsetLossWeight.
       */
      float getOffsetLossWeight();

      /**
       * <pre>
       * Weight for the height/width localization loss.
       * </pre>
       *
       * <code>optional float scale_loss_weight = 4 [default = 0.1];</code>
       * @return Whether the scaleLossWeight field is set.
       */
      boolean hasScaleLossWeight();
      /**
       * <pre>
       * Weight for the height/width localization loss.
       * </pre>
       *
       * <code>optional float scale_loss_weight = 4 [default = 0.1];</code>
       * @return The scaleLossWeight.
       */
      float getScaleLossWeight();

      /**
       * <pre>
       * Localization loss configuration for object scale and offset losses.
       * </pre>
       *
       * <code>optional .object_detection.protos.LocalizationLoss localization_loss = 8;</code>
       * @return Whether the localizationLoss field is set.
       */
      boolean hasLocalizationLoss();
      /**
       * <pre>
       * Localization loss configuration for object scale and offset losses.
       * </pre>
       *
       * <code>optional .object_detection.protos.LocalizationLoss localization_loss = 8;</code>
       * @return The localizationLoss.
       */
      object_detection.protos.Losses.LocalizationLoss getLocalizationLoss();
      /**
       * <pre>
       * Localization loss configuration for object scale and offset losses.
       * </pre>
       *
       * <code>optional .object_detection.protos.LocalizationLoss localization_loss = 8;</code>
       */
      object_detection.protos.Losses.LocalizationLossOrBuilder getLocalizationLossOrBuilder();
    }
    /**
     * <pre>
     * Parameters which are related to object detection task.
     * </pre>
     *
     * Protobuf type {@code object_detection.protos.CenterNet.ObjectDetection}
     */
    public static final class ObjectDetection extends
        com.google.protobuf.GeneratedMessageV3 implements
        // @@protoc_insertion_point(message_implements:object_detection.protos.CenterNet.ObjectDetection)
        ObjectDetectionOrBuilder {
    private static final long serialVersionUID = 0L;
      // Use ObjectDetection.newBuilder() to construct.
      private ObjectDetection(com.google.protobuf.GeneratedMessageV3.Builder<?> builder) {
        super(builder);
      }
      private ObjectDetection() {
        taskLossWeight_ = 1F;
        offsetLossWeight_ = 1F;
        scaleLossWeight_ = 0.1F;
      }

      @java.lang.Override
      @SuppressWarnings({"unused"})
      protected java.lang.Object newInstance(
          UnusedPrivateParameter unused) {
        return new ObjectDetection();
      }

      @java.lang.Override
      public final com.google.protobuf.UnknownFieldSet
      getUnknownFields() {
        return this.unknownFields;
      }
      private ObjectDetection(
          com.google.protobuf.CodedInputStream input,
          com.google.protobuf.ExtensionRegistryLite extensionRegistry)
          throws com.google.protobuf.InvalidProtocolBufferException {
        this();
        if (extensionRegistry == null) {
          throw new java.lang.NullPointerException();
        }
        int mutable_bitField0_ = 0;
        com.google.protobuf.UnknownFieldSet.Builder unknownFields =
            com.google.protobuf.UnknownFieldSet.newBuilder();
        try {
          boolean done = false;
          while (!done) {
            int tag = input.readTag();
            switch (tag) {
              case 0:
                done = true;
                break;
              case 13: {
                bitField0_ |= 0x00000001;
                taskLossWeight_ = input.readFloat();
                break;
              }
              case 29: {
                bitField0_ |= 0x00000002;
                offsetLossWeight_ = input.readFloat();
                break;
              }
              case 37: {
                bitField0_ |= 0x00000004;
                scaleLossWeight_ = input.readFloat();
                break;
              }
              case 66: {
                object_detection.protos.Losses.LocalizationLoss.Builder subBuilder = null;
                if (((bitField0_ & 0x00000008) != 0)) {
                  subBuilder = localizationLoss_.toBuilder();
                }
                localizationLoss_ = input.readMessage(object_detection.protos.Losses.LocalizationLoss.PARSER, extensionRegistry);
                if (subBuilder != null) {
                  subBuilder.mergeFrom(localizationLoss_);
                  localizationLoss_ = subBuilder.buildPartial();
                }
                bitField0_ |= 0x00000008;
                break;
              }
              default: {
                if (!parseUnknownField(
                    input, unknownFields, extensionRegistry, tag)) {
                  done = true;
                }
                break;
              }
            }
          }
        } catch (com.google.protobuf.InvalidProtocolBufferException e) {
          throw e.setUnfinishedMessage(this);
        } catch (java.io.IOException e) {
          throw new com.google.protobuf.InvalidProtocolBufferException(
              e).setUnfinishedMessage(this);
        } finally {
          this.unknownFields = unknownFields.build();
          makeExtensionsImmutable();
        }
      }
      public static final com.google.protobuf.Descriptors.Descriptor
          getDescriptor() {
        return object_detection.protos.CenterNetOuterClass.internal_static_object_detection_protos_CenterNet_ObjectDetection_descriptor;
      }

      @java.lang.Override
      protected com.google.protobuf.GeneratedMessageV3.FieldAccessorTable
          internalGetFieldAccessorTable() {
        return object_detection.protos.CenterNetOuterClass.internal_static_object_detection_protos_CenterNet_ObjectDetection_fieldAccessorTable
            .ensureFieldAccessorsInitialized(
                object_detection.protos.CenterNetOuterClass.CenterNet.ObjectDetection.class, object_detection.protos.CenterNetOuterClass.CenterNet.ObjectDetection.Builder.class);
      }

      private int bitField0_;
      public static final int TASK_LOSS_WEIGHT_FIELD_NUMBER = 1;
      private float taskLossWeight_;
      /**
       * <pre>
       * Weight of the task loss. The total loss of the model will be the
       * summation of task losses weighted by the weights.
       * </pre>
       *
       * <code>optional float task_loss_weight = 1 [default = 1];</code>
       * @return Whether the taskLossWeight field is set.
       */
      @java.lang.Override
      public boolean hasTaskLossWeight() {
        return ((bitField0_ & 0x00000001) != 0);
      }
      /**
       * <pre>
       * Weight of the task loss. The total loss of the model will be the
       * summation of task losses weighted by the weights.
       * </pre>
       *
       * <code>optional float task_loss_weight = 1 [default = 1];</code>
       * @return The taskLossWeight.
       */
      @java.lang.Override
      public float getTaskLossWeight() {
        return taskLossWeight_;
      }

      public static final int OFFSET_LOSS_WEIGHT_FIELD_NUMBER = 3;
      private float offsetLossWeight_;
      /**
       * <pre>
       * Weight for the offset localization loss.
       * </pre>
       *
       * <code>optional float offset_loss_weight = 3 [default = 1];</code>
       * @return Whether the offsetLossWeight field is set.
       */
      @java.lang.Override
      public boolean hasOffsetLossWeight() {
        return ((bitField0_ & 0x00000002) != 0);
      }
      /**
       * <pre>
       * Weight for the offset localization loss.
       * </pre>
       *
       * <code>optional float offset_loss_weight = 3 [default = 1];</code>
       * @return The offsetLossWeight.
       */
      @java.lang.Override
      public float getOffsetLossWeight() {
        return offsetLossWeight_;
      }

      public static final int SCALE_LOSS_WEIGHT_FIELD_NUMBER = 4;
      private float scaleLossWeight_;
      /**
       * <pre>
       * Weight for the height/width localization loss.
       * </pre>
       *
       * <code>optional float scale_loss_weight = 4 [default = 0.1];</code>
       * @return Whether the scaleLossWeight field is set.
       */
      @java.lang.Override
      public boolean hasScaleLossWeight() {
        return ((bitField0_ & 0x00000004) != 0);
      }
      /**
       * <pre>
       * Weight for the height/width localization loss.
       * </pre>
       *
       * <code>optional float scale_loss_weight = 4 [default = 0.1];</code>
       * @return The scaleLossWeight.
       */
      @java.lang.Override
      public float getScaleLossWeight() {
        return scaleLossWeight_;
      }

      public static final int LOCALIZATION_LOSS_FIELD_NUMBER = 8;
      private object_detection.protos.Losses.LocalizationLoss localizationLoss_;
      /**
       * <pre>
       * Localization loss configuration for object scale and offset losses.
       * </pre>
       *
       * <code>optional .object_detection.protos.LocalizationLoss localization_loss = 8;</code>
       * @return Whether the localizationLoss field is set.
       */
      @java.lang.Override
      public boolean hasLocalizationLoss() {
        return ((bitField0_ & 0x00000008) != 0);
      }
      /**
       * <pre>
       * Localization loss configuration for object scale and offset losses.
       * </pre>
       *
       * <code>optional .object_detection.protos.LocalizationLoss localization_loss = 8;</code>
       * @return The localizationLoss.
       */
      @java.lang.Override
      public object_detection.protos.Losses.LocalizationLoss getLocalizationLoss() {
        return localizationLoss_ == null ? object_detection.protos.Losses.LocalizationLoss.getDefaultInstance() : localizationLoss_;
      }
      /**
       * <pre>
       * Localization loss configuration for object scale and offset losses.
       * </pre>
       *
       * <code>optional .object_detection.protos.LocalizationLoss localization_loss = 8;</code>
       */
      @java.lang.Override
      public object_detection.protos.Losses.LocalizationLossOrBuilder getLocalizationLossOrBuilder() {
        return localizationLoss_ == null ? object_detection.protos.Losses.LocalizationLoss.getDefaultInstance() : localizationLoss_;
      }

      private byte memoizedIsInitialized = -1;
      @java.lang.Override
      public final boolean isInitialized() {
        byte isInitialized = memoizedIsInitialized;
        if (isInitialized == 1) return true;
        if (isInitialized == 0) return false;

        memoizedIsInitialized = 1;
        return true;
      }

      @java.lang.Override
      public void writeTo(com.google.protobuf.CodedOutputStream output)
                          throws java.io.IOException {
        if (((bitField0_ & 0x00000001) != 0)) {
          output.writeFloat(1, taskLossWeight_);
        }
        if (((bitField0_ & 0x00000002) != 0)) {
          output.writeFloat(3, offsetLossWeight_);
        }
        if (((bitField0_ & 0x00000004) != 0)) {
          output.writeFloat(4, scaleLossWeight_);
        }
        if (((bitField0_ & 0x00000008) != 0)) {
          output.writeMessage(8, getLocalizationLoss());
        }
        unknownFields.writeTo(output);
      }

      @java.lang.Override
      public int getSerializedSize() {
        int size = memoizedSize;
        if (size != -1) return size;

        size = 0;
        if (((bitField0_ & 0x00000001) != 0)) {
          size += com.google.protobuf.CodedOutputStream
            .computeFloatSize(1, taskLossWeight_);
        }
        if (((bitField0_ & 0x00000002) != 0)) {
          size += com.google.protobuf.CodedOutputStream
            .computeFloatSize(3, offsetLossWeight_);
        }
        if (((bitField0_ & 0x00000004) != 0)) {
          size += com.google.protobuf.CodedOutputStream
            .computeFloatSize(4, scaleLossWeight_);
        }
        if (((bitField0_ & 0x00000008) != 0)) {
          size += com.google.protobuf.CodedOutputStream
            .computeMessageSize(8, getLocalizationLoss());
        }
        size += unknownFields.getSerializedSize();
        memoizedSize = size;
        return size;
      }

      @java.lang.Override
      public boolean equals(final java.lang.Object obj) {
        if (obj == this) {
         return true;
        }
        if (!(obj instanceof object_detection.protos.CenterNetOuterClass.CenterNet.ObjectDetection)) {
          return super.equals(obj);
        }
        object_detection.protos.CenterNetOuterClass.CenterNet.ObjectDetection other = (object_detection.protos.CenterNetOuterClass.CenterNet.ObjectDetection) obj;

        if (hasTaskLossWeight() != other.hasTaskLossWeight()) return false;
        if (hasTaskLossWeight()) {
          if (java.lang.Float.floatToIntBits(getTaskLossWeight())
              != java.lang.Float.floatToIntBits(
                  other.getTaskLossWeight())) return false;
        }
        if (hasOffsetLossWeight() != other.hasOffsetLossWeight()) return false;
        if (hasOffsetLossWeight()) {
          if (java.lang.Float.floatToIntBits(getOffsetLossWeight())
              != java.lang.Float.floatToIntBits(
                  other.getOffsetLossWeight())) return false;
        }
        if (hasScaleLossWeight() != other.hasScaleLossWeight()) return false;
        if (hasScaleLossWeight()) {
          if (java.lang.Float.floatToIntBits(getScaleLossWeight())
              != java.lang.Float.floatToIntBits(
                  other.getScaleLossWeight())) return false;
        }
        if (hasLocalizationLoss() != other.hasLocalizationLoss()) return false;
        if (hasLocalizationLoss()) {
          if (!getLocalizationLoss()
              .equals(other.getLocalizationLoss())) return false;
        }
        if (!unknownFields.equals(other.unknownFields)) return false;
        return true;
      }

      @java.lang.Override
      public int hashCode() {
        if (memoizedHashCode != 0) {
          return memoizedHashCode;
        }
        int hash = 41;
        hash = (19 * hash) + getDescriptor().hashCode();
        if (hasTaskLossWeight()) {
          hash = (37 * hash) + TASK_LOSS_WEIGHT_FIELD_NUMBER;
          hash = (53 * hash) + java.lang.Float.floatToIntBits(
              getTaskLossWeight());
        }
        if (hasOffsetLossWeight()) {
          hash = (37 * hash) + OFFSET_LOSS_WEIGHT_FIELD_NUMBER;
          hash = (53 * hash) + java.lang.Float.floatToIntBits(
              getOffsetLossWeight());
        }
        if (hasScaleLossWeight()) {
          hash = (37 * hash) + SCALE_LOSS_WEIGHT_FIELD_NUMBER;
          hash = (53 * hash) + java.lang.Float.floatToIntBits(
              getScaleLossWeight());
        }
        if (hasLocalizationLoss()) {
          hash = (37 * hash) + LOCALIZATION_LOSS_FIELD_NUMBER;
          hash = (53 * hash) + getLocalizationLoss().hashCode();
        }
        hash = (29 * hash) + unknownFields.hashCode();
        memoizedHashCode = hash;
        return hash;
      }

      public static object_detection.protos.CenterNetOuterClass.CenterNet.ObjectDetection parseFrom(
          java.nio.ByteBuffer data)
          throws com.google.protobuf.InvalidProtocolBufferException {
        return PARSER.parseFrom(data);
      }
      public static object_detection.protos.CenterNetOuterClass.CenterNet.ObjectDetection parseFrom(
          java.nio.ByteBuffer data,
          com.google.protobuf.ExtensionRegistryLite extensionRegistry)
          throws com.google.protobuf.InvalidProtocolBufferException {
        return PARSER.parseFrom(data, extensionRegistry);
      }
      public static object_detection.protos.CenterNetOuterClass.CenterNet.ObjectDetection parseFrom(
          com.google.protobuf.ByteString data)
          throws com.google.protobuf.InvalidProtocolBufferException {
        return PARSER.parseFrom(data);
      }
      public static object_detection.protos.CenterNetOuterClass.CenterNet.ObjectDetection parseFrom(
          com.google.protobuf.ByteString data,
          com.google.protobuf.ExtensionRegistryLite extensionRegistry)
          throws com.google.protobuf.InvalidProtocolBufferException {
        return PARSER.parseFrom(data, extensionRegistry);
      }
      public static object_detection.protos.CenterNetOuterClass.CenterNet.ObjectDetection parseFrom(byte[] data)
          throws com.google.protobuf.InvalidProtocolBufferException {
        return PARSER.parseFrom(data);
      }
      public static object_detection.protos.CenterNetOuterClass.CenterNet.ObjectDetection parseFrom(
          byte[] data,
          com.google.protobuf.ExtensionRegistryLite extensionRegistry)
          throws com.google.protobuf.InvalidProtocolBufferException {
        return PARSER.parseFrom(data, extensionRegistry);
      }
      public static object_detection.protos.CenterNetOuterClass.CenterNet.ObjectDetection parseFrom(java.io.InputStream input)
          throws java.io.IOException {
        return com.google.protobuf.GeneratedMessageV3
            .parseWithIOException(PARSER, input);
      }
      public static object_detection.protos.CenterNetOuterClass.CenterNet.ObjectDetection parseFrom(
          java.io.InputStream input,
          com.google.protobuf.ExtensionRegistryLite extensionRegistry)
          throws java.io.IOException {
        return com.google.protobuf.GeneratedMessageV3
            .parseWithIOException(PARSER, input, extensionRegistry);
      }
      public static object_detection.protos.CenterNetOuterClass.CenterNet.ObjectDetection parseDelimitedFrom(java.io.InputStream input)
          throws java.io.IOException {
        return com.google.protobuf.GeneratedMessageV3
            .parseDelimitedWithIOException(PARSER, input);
      }
      public static object_detection.protos.CenterNetOuterClass.CenterNet.ObjectDetection parseDelimitedFrom(
          java.io.InputStream input,
          com.google.protobuf.ExtensionRegistryLite extensionRegistry)
          throws java.io.IOException {
        return com.google.protobuf.GeneratedMessageV3
            .parseDelimitedWithIOException(PARSER, input, extensionRegistry);
      }
      public static object_detection.protos.CenterNetOuterClass.CenterNet.ObjectDetection parseFrom(
          com.google.protobuf.CodedInputStream input)
          throws java.io.IOException {
        return com.google.protobuf.GeneratedMessageV3
            .parseWithIOException(PARSER, input);
      }
      public static object_detection.protos.CenterNetOuterClass.CenterNet.ObjectDetection parseFrom(
          com.google.protobuf.CodedInputStream input,
          com.google.protobuf.ExtensionRegistryLite extensionRegistry)
          throws java.io.IOException {
        return com.google.protobuf.GeneratedMessageV3
            .parseWithIOException(PARSER, input, extensionRegistry);
      }

      @java.lang.Override
      public Builder newBuilderForType() { return newBuilder(); }
      public static Builder newBuilder() {
        return DEFAULT_INSTANCE.toBuilder();
      }
      public static Builder newBuilder(object_detection.protos.CenterNetOuterClass.CenterNet.ObjectDetection prototype) {
        return DEFAULT_INSTANCE.toBuilder().mergeFrom(prototype);
      }
      @java.lang.Override
      public Builder toBuilder() {
        return this == DEFAULT_INSTANCE
            ? new Builder() : new Builder().mergeFrom(this);
      }

      @java.lang.Override
      protected Builder newBuilderForType(
          com.google.protobuf.GeneratedMessageV3.BuilderParent parent) {
        Builder builder = new Builder(parent);
        return builder;
      }
      /**
       * <pre>
       * Parameters which are related to object detection task.
       * </pre>
       *
       * Protobuf type {@code object_detection.protos.CenterNet.ObjectDetection}
       */
      public static final class Builder extends
          com.google.protobuf.GeneratedMessageV3.Builder<Builder> implements
          // @@protoc_insertion_point(builder_implements:object_detection.protos.CenterNet.ObjectDetection)
          object_detection.protos.CenterNetOuterClass.CenterNet.ObjectDetectionOrBuilder {
        public static final com.google.protobuf.Descriptors.Descriptor
            getDescriptor() {
          return object_detection.protos.CenterNetOuterClass.internal_static_object_detection_protos_CenterNet_ObjectDetection_descriptor;
        }

        @java.lang.Override
        protected com.google.protobuf.GeneratedMessageV3.FieldAccessorTable
            internalGetFieldAccessorTable() {
          return object_detection.protos.CenterNetOuterClass.internal_static_object_detection_protos_CenterNet_ObjectDetection_fieldAccessorTable
              .ensureFieldAccessorsInitialized(
                  object_detection.protos.CenterNetOuterClass.CenterNet.ObjectDetection.class, object_detection.protos.CenterNetOuterClass.CenterNet.ObjectDetection.Builder.class);
        }

        // Construct using object_detection.protos.CenterNetOuterClass.CenterNet.ObjectDetection.newBuilder()
        private Builder() {
          maybeForceBuilderInitialization();
        }

        private Builder(
            com.google.protobuf.GeneratedMessageV3.BuilderParent parent) {
          super(parent);
          maybeForceBuilderInitialization();
        }
        private void maybeForceBuilderInitialization() {
          if (com.google.protobuf.GeneratedMessageV3
                  .alwaysUseFieldBuilders) {
            getLocalizationLossFieldBuilder();
          }
        }
        @java.lang.Override
        public Builder clear() {
          super.clear();
          taskLossWeight_ = 1F;
          bitField0_ = (bitField0_ & ~0x00000001);
          offsetLossWeight_ = 1F;
          bitField0_ = (bitField0_ & ~0x00000002);
          scaleLossWeight_ = 0.1F;
          bitField0_ = (bitField0_ & ~0x00000004);
          if (localizationLossBuilder_ == null) {
            localizationLoss_ = null;
          } else {
            localizationLossBuilder_.clear();
          }
          bitField0_ = (bitField0_ & ~0x00000008);
          return this;
        }

        @java.lang.Override
        public com.google.protobuf.Descriptors.Descriptor
            getDescriptorForType() {
          return object_detection.protos.CenterNetOuterClass.internal_static_object_detection_protos_CenterNet_ObjectDetection_descriptor;
        }

        @java.lang.Override
        public object_detection.protos.CenterNetOuterClass.CenterNet.ObjectDetection getDefaultInstanceForType() {
          return object_detection.protos.CenterNetOuterClass.CenterNet.ObjectDetection.getDefaultInstance();
        }

        @java.lang.Override
        public object_detection.protos.CenterNetOuterClass.CenterNet.ObjectDetection build() {
          object_detection.protos.CenterNetOuterClass.CenterNet.ObjectDetection result = buildPartial();
          if (!result.isInitialized()) {
            throw newUninitializedMessageException(result);
          }
          return result;
        }

        @java.lang.Override
        public object_detection.protos.CenterNetOuterClass.CenterNet.ObjectDetection buildPartial() {
          object_detection.protos.CenterNetOuterClass.CenterNet.ObjectDetection result = new object_detection.protos.CenterNetOuterClass.CenterNet.ObjectDetection(this);
          int from_bitField0_ = bitField0_;
          int to_bitField0_ = 0;
          if (((from_bitField0_ & 0x00000001) != 0)) {
            to_bitField0_ |= 0x00000001;
          }
          result.taskLossWeight_ = taskLossWeight_;
          if (((from_bitField0_ & 0x00000002) != 0)) {
            to_bitField0_ |= 0x00000002;
          }
          result.offsetLossWeight_ = offsetLossWeight_;
          if (((from_bitField0_ & 0x00000004) != 0)) {
            to_bitField0_ |= 0x00000004;
          }
          result.scaleLossWeight_ = scaleLossWeight_;
          if (((from_bitField0_ & 0x00000008) != 0)) {
            if (localizationLossBuilder_ == null) {
              result.localizationLoss_ = localizationLoss_;
            } else {
              result.localizationLoss_ = localizationLossBuilder_.build();
            }
            to_bitField0_ |= 0x00000008;
          }
          result.bitField0_ = to_bitField0_;
          onBuilt();
          return result;
        }

        @java.lang.Override
        public Builder clone() {
          return super.clone();
        }
        @java.lang.Override
        public Builder setField(
            com.google.protobuf.Descriptors.FieldDescriptor field,
            java.lang.Object value) {
          return super.setField(field, value);
        }
        @java.lang.Override
        public Builder clearField(
            com.google.protobuf.Descriptors.FieldDescriptor field) {
          return super.clearField(field);
        }
        @java.lang.Override
        public Builder clearOneof(
            com.google.protobuf.Descriptors.OneofDescriptor oneof) {
          return super.clearOneof(oneof);
        }
        @java.lang.Override
        public Builder setRepeatedField(
            com.google.protobuf.Descriptors.FieldDescriptor field,
            int index, java.lang.Object value) {
          return super.setRepeatedField(field, index, value);
        }
        @java.lang.Override
        public Builder addRepeatedField(
            com.google.protobuf.Descriptors.FieldDescriptor field,
            java.lang.Object value) {
          return super.addRepeatedField(field, value);
        }
        @java.lang.Override
        public Builder mergeFrom(com.google.protobuf.Message other) {
          if (other instanceof object_detection.protos.CenterNetOuterClass.CenterNet.ObjectDetection) {
            return mergeFrom((object_detection.protos.CenterNetOuterClass.CenterNet.ObjectDetection)other);
          } else {
            super.mergeFrom(other);
            return this;
          }
        }

        public Builder mergeFrom(object_detection.protos.CenterNetOuterClass.CenterNet.ObjectDetection other) {
          if (other == object_detection.protos.CenterNetOuterClass.CenterNet.ObjectDetection.getDefaultInstance()) return this;
          if (other.hasTaskLossWeight()) {
            setTaskLossWeight(other.getTaskLossWeight());
          }
          if (other.hasOffsetLossWeight()) {
            setOffsetLossWeight(other.getOffsetLossWeight());
          }
          if (other.hasScaleLossWeight()) {
            setScaleLossWeight(other.getScaleLossWeight());
          }
          if (other.hasLocalizationLoss()) {
            mergeLocalizationLoss(other.getLocalizationLoss());
          }
          this.mergeUnknownFields(other.unknownFields);
          onChanged();
          return this;
        }

        @java.lang.Override
        public final boolean isInitialized() {
          return true;
        }

        @java.lang.Override
        public Builder mergeFrom(
            com.google.protobuf.CodedInputStream input,
            com.google.protobuf.ExtensionRegistryLite extensionRegistry)
            throws java.io.IOException {
          object_detection.protos.CenterNetOuterClass.CenterNet.ObjectDetection parsedMessage = null;
          try {
            parsedMessage = PARSER.parsePartialFrom(input, extensionRegistry);
          } catch (com.google.protobuf.InvalidProtocolBufferException e) {
            parsedMessage = (object_detection.protos.CenterNetOuterClass.CenterNet.ObjectDetection) e.getUnfinishedMessage();
            throw e.unwrapIOException();
          } finally {
            if (parsedMessage != null) {
              mergeFrom(parsedMessage);
            }
          }
          return this;
        }
        private int bitField0_;

        private float taskLossWeight_ = 1F;
        /**
         * <pre>
         * Weight of the task loss. The total loss of the model will be the
         * summation of task losses weighted by the weights.
         * </pre>
         *
         * <code>optional float task_loss_weight = 1 [default = 1];</code>
         * @return Whether the taskLossWeight field is set.
         */
        @java.lang.Override
        public boolean hasTaskLossWeight() {
          return ((bitField0_ & 0x00000001) != 0);
        }
        /**
         * <pre>
         * Weight of the task loss. The total loss of the model will be the
         * summation of task losses weighted by the weights.
         * </pre>
         *
         * <code>optional float task_loss_weight = 1 [default = 1];</code>
         * @return The taskLossWeight.
         */
        @java.lang.Override
        public float getTaskLossWeight() {
          return taskLossWeight_;
        }
        /**
         * <pre>
         * Weight of the task loss. The total loss of the model will be the
         * summation of task losses weighted by the weights.
         * </pre>
         *
         * <code>optional float task_loss_weight = 1 [default = 1];</code>
         * @param value The taskLossWeight to set.
         * @return This builder for chaining.
         */
        public Builder setTaskLossWeight(float value) {
          bitField0_ |= 0x00000001;
          taskLossWeight_ = value;
          onChanged();
          return this;
        }
        /**
         * <pre>
         * Weight of the task loss. The total loss of the model will be the
         * summation of task losses weighted by the weights.
         * </pre>
         *
         * <code>optional float task_loss_weight = 1 [default = 1];</code>
         * @return This builder for chaining.
         */
        public Builder clearTaskLossWeight() {
          bitField0_ = (bitField0_ & ~0x00000001);
          taskLossWeight_ = 1F;
          onChanged();
          return this;
        }

        private float offsetLossWeight_ = 1F;
        /**
         * <pre>
         * Weight for the offset localization loss.
         * </pre>
         *
         * <code>optional float offset_loss_weight = 3 [default = 1];</code>
         * @return Whether the offsetLossWeight field is set.
         */
        @java.lang.Override
        public boolean hasOffsetLossWeight() {
          return ((bitField0_ & 0x00000002) != 0);
        }
        /**
         * <pre>
         * Weight for the offset localization loss.
         * </pre>
         *
         * <code>optional float offset_loss_weight = 3 [default = 1];</code>
         * @return The offsetLossWeight.
         */
        @java.lang.Override
        public float getOffsetLossWeight() {
          return offsetLossWeight_;
        }
        /**
         * <pre>
         * Weight for the offset localization loss.
         * </pre>
         *
         * <code>optional float offset_loss_weight = 3 [default = 1];</code>
         * @param value The offsetLossWeight to set.
         * @return This builder for chaining.
         */
        public Builder setOffsetLossWeight(float value) {
          bitField0_ |= 0x00000002;
          offsetLossWeight_ = value;
          onChanged();
          return this;
        }
        /**
         * <pre>
         * Weight for the offset localization loss.
         * </pre>
         *
         * <code>optional float offset_loss_weight = 3 [default = 1];</code>
         * @return This builder for chaining.
         */
        public Builder clearOffsetLossWeight() {
          bitField0_ = (bitField0_ & ~0x00000002);
          offsetLossWeight_ = 1F;
          onChanged();
          return this;
        }

        private float scaleLossWeight_ = 0.1F;
        /**
         * <pre>
         * Weight for the height/width localization loss.
         * </pre>
         *
         * <code>optional float scale_loss_weight = 4 [default = 0.1];</code>
         * @return Whether the scaleLossWeight field is set.
         */
        @java.lang.Override
        public boolean hasScaleLossWeight() {
          return ((bitField0_ & 0x00000004) != 0);
        }
        /**
         * <pre>
         * Weight for the height/width localization loss.
         * </pre>
         *
         * <code>optional float scale_loss_weight = 4 [default = 0.1];</code>
         * @return The scaleLossWeight.
         */
        @java.lang.Override
        public float getScaleLossWeight() {
          return scaleLossWeight_;
        }
        /**
         * <pre>
         * Weight for the height/width localization loss.
         * </pre>
         *
         * <code>optional float scale_loss_weight = 4 [default = 0.1];</code>
         * @param value The scaleLossWeight to set.
         * @return This builder for chaining.
         */
        public Builder setScaleLossWeight(float value) {
          bitField0_ |= 0x00000004;
          scaleLossWeight_ = value;
          onChanged();
          return this;
        }
        /**
         * <pre>
         * Weight for the height/width localization loss.
         * </pre>
         *
         * <code>optional float scale_loss_weight = 4 [default = 0.1];</code>
         * @return This builder for chaining.
         */
        public Builder clearScaleLossWeight() {
          bitField0_ = (bitField0_ & ~0x00000004);
          scaleLossWeight_ = 0.1F;
          onChanged();
          return this;
        }

        private object_detection.protos.Losses.LocalizationLoss localizationLoss_;
        private com.google.protobuf.SingleFieldBuilderV3<
            object_detection.protos.Losses.LocalizationLoss, object_detection.protos.Losses.LocalizationLoss.Builder, object_detection.protos.Losses.LocalizationLossOrBuilder> localizationLossBuilder_;
        /**
         * <pre>
         * Localization loss configuration for object scale and offset losses.
         * </pre>
         *
         * <code>optional .object_detection.protos.LocalizationLoss localization_loss = 8;</code>
         * @return Whether the localizationLoss field is set.
         */
        public boolean hasLocalizationLoss() {
          return ((bitField0_ & 0x00000008) != 0);
        }
        /**
         * <pre>
         * Localization loss configuration for object scale and offset losses.
         * </pre>
         *
         * <code>optional .object_detection.protos.LocalizationLoss localization_loss = 8;</code>
         * @return The localizationLoss.
         */
        public object_detection.protos.Losses.LocalizationLoss getLocalizationLoss() {
          if (localizationLossBuilder_ == null) {
            return localizationLoss_ == null ? object_detection.protos.Losses.LocalizationLoss.getDefaultInstance() : localizationLoss_;
          } else {
            return localizationLossBuilder_.getMessage();
          }
        }
        /**
         * <pre>
         * Localization loss configuration for object scale and offset losses.
         * </pre>
         *
         * <code>optional .object_detection.protos.LocalizationLoss localization_loss = 8;</code>
         */
        public Builder setLocalizationLoss(object_detection.protos.Losses.LocalizationLoss value) {
          if (localizationLossBuilder_ == null) {
            if (value == null) {
              throw new NullPointerException();
            }
            localizationLoss_ = value;
            onChanged();
          } else {
            localizationLossBuilder_.setMessage(value);
          }
          bitField0_ |= 0x00000008;
          return this;
        }
        /**
         * <pre>
         * Localization loss configuration for object scale and offset losses.
         * </pre>
         *
         * <code>optional .object_detection.protos.LocalizationLoss localization_loss = 8;</code>
         */
        public Builder setLocalizationLoss(
            object_detection.protos.Losses.LocalizationLoss.Builder builderForValue) {
          if (localizationLossBuilder_ == null) {
            localizationLoss_ = builderForValue.build();
            onChanged();
          } else {
            localizationLossBuilder_.setMessage(builderForValue.build());
          }
          bitField0_ |= 0x00000008;
          return this;
        }
        /**
         * <pre>
         * Localization loss configuration for object scale and offset losses.
         * </pre>
         *
         * <code>optional .object_detection.protos.LocalizationLoss localization_loss = 8;</code>
         */
        public Builder mergeLocalizationLoss(object_detection.protos.Losses.LocalizationLoss value) {
          if (localizationLossBuilder_ == null) {
            if (((bitField0_ & 0x00000008) != 0) &&
                localizationLoss_ != null &&
                localizationLoss_ != object_detection.protos.Losses.LocalizationLoss.getDefaultInstance()) {
              localizationLoss_ =
                object_detection.protos.Losses.LocalizationLoss.newBuilder(localizationLoss_).mergeFrom(value).buildPartial();
            } else {
              localizationLoss_ = value;
            }
            onChanged();
          } else {
            localizationLossBuilder_.mergeFrom(value);
          }
          bitField0_ |= 0x00000008;
          return this;
        }
        /**
         * <pre>
         * Localization loss configuration for object scale and offset losses.
         * </pre>
         *
         * <code>optional .object_detection.protos.LocalizationLoss localization_loss = 8;</code>
         */
        public Builder clearLocalizationLoss() {
          if (localizationLossBuilder_ == null) {
            localizationLoss_ = null;
            onChanged();
          } else {
            localizationLossBuilder_.clear();
          }
          bitField0_ = (bitField0_ & ~0x00000008);
          return this;
        }
        /**
         * <pre>
         * Localization loss configuration for object scale and offset losses.
         * </pre>
         *
         * <code>optional .object_detection.protos.LocalizationLoss localization_loss = 8;</code>
         */
        public object_detection.protos.Losses.LocalizationLoss.Builder getLocalizationLossBuilder() {
          bitField0_ |= 0x00000008;
          onChanged();
          return getLocalizationLossFieldBuilder().getBuilder();
        }
        /**
         * <pre>
         * Localization loss configuration for object scale and offset losses.
         * </pre>
         *
         * <code>optional .object_detection.protos.LocalizationLoss localization_loss = 8;</code>
         */
        public object_detection.protos.Losses.LocalizationLossOrBuilder getLocalizationLossOrBuilder() {
          if (localizationLossBuilder_ != null) {
            return localizationLossBuilder_.getMessageOrBuilder();
          } else {
            return localizationLoss_ == null ?
                object_detection.protos.Losses.LocalizationLoss.getDefaultInstance() : localizationLoss_;
          }
        }
        /**
         * <pre>
         * Localization loss configuration for object scale and offset losses.
         * </pre>
         *
         * <code>optional .object_detection.protos.LocalizationLoss localization_loss = 8;</code>
         */
        private com.google.protobuf.SingleFieldBuilderV3<
            object_detection.protos.Losses.LocalizationLoss, object_detection.protos.Losses.LocalizationLoss.Builder, object_detection.protos.Losses.LocalizationLossOrBuilder>
            getLocalizationLossFieldBuilder() {
          if (localizationLossBuilder_ == null) {
            localizationLossBuilder_ = new com.google.protobuf.SingleFieldBuilderV3<
                object_detection.protos.Losses.LocalizationLoss, object_detection.protos.Losses.LocalizationLoss.Builder, object_detection.protos.Losses.LocalizationLossOrBuilder>(
                    getLocalizationLoss(),
                    getParentForChildren(),
                    isClean());
            localizationLoss_ = null;
          }
          return localizationLossBuilder_;
        }
        @java.lang.Override
        public final Builder setUnknownFields(
            final com.google.protobuf.UnknownFieldSet unknownFields) {
          return super.setUnknownFields(unknownFields);
        }

        @java.lang.Override
        public final Builder mergeUnknownFields(
            final com.google.protobuf.UnknownFieldSet unknownFields) {
          return super.mergeUnknownFields(unknownFields);
        }


        // @@protoc_insertion_point(builder_scope:object_detection.protos.CenterNet.ObjectDetection)
      }

      // @@protoc_insertion_point(class_scope:object_detection.protos.CenterNet.ObjectDetection)
      private static final object_detection.protos.CenterNetOuterClass.CenterNet.ObjectDetection DEFAULT_INSTANCE;
      static {
        DEFAULT_INSTANCE = new object_detection.protos.CenterNetOuterClass.CenterNet.ObjectDetection();
      }

      public static object_detection.protos.CenterNetOuterClass.CenterNet.ObjectDetection getDefaultInstance() {
        return DEFAULT_INSTANCE;
      }

      @java.lang.Deprecated public static final com.google.protobuf.Parser<ObjectDetection>
          PARSER = new com.google.protobuf.AbstractParser<ObjectDetection>() {
        @java.lang.Override
        public ObjectDetection parsePartialFrom(
            com.google.protobuf.CodedInputStream input,
            com.google.protobuf.ExtensionRegistryLite extensionRegistry)
            throws com.google.protobuf.InvalidProtocolBufferException {
          return new ObjectDetection(input, extensionRegistry);
        }
      };

      public static com.google.protobuf.Parser<ObjectDetection> parser() {
        return PARSER;
      }

      @java.lang.Override
      public com.google.protobuf.Parser<ObjectDetection> getParserForType() {
        return PARSER;
      }

      @java.lang.Override
      public object_detection.protos.CenterNetOuterClass.CenterNet.ObjectDetection getDefaultInstanceForType() {
        return DEFAULT_INSTANCE;
      }

    }

    public interface ObjectCenterParamsOrBuilder extends
        // @@protoc_insertion_point(interface_extends:object_detection.protos.CenterNet.ObjectCenterParams)
        com.google.protobuf.MessageOrBuilder {

      /**
       * <pre>
       * Weight for the object center loss.
       * </pre>
       *
       * <code>optional float object_center_loss_weight = 1 [default = 1];</code>
       * @return Whether the objectCenterLossWeight field is set.
       */
      boolean hasObjectCenterLossWeight();
      /**
       * <pre>
       * Weight for the object center loss.
       * </pre>
       *
       * <code>optional float object_center_loss_weight = 1 [default = 1];</code>
       * @return The objectCenterLossWeight.
       */
      float getObjectCenterLossWeight();

      /**
       * <pre>
       * Classification loss configuration for object center loss.
       * </pre>
       *
       * <code>optional .object_detection.protos.ClassificationLoss classification_loss = 2;</code>
       * @return Whether the classificationLoss field is set.
       */
      boolean hasClassificationLoss();
      /**
       * <pre>
       * Classification loss configuration for object center loss.
       * </pre>
       *
       * <code>optional .object_detection.protos.ClassificationLoss classification_loss = 2;</code>
       * @return The classificationLoss.
       */
      object_detection.protos.Losses.ClassificationLoss getClassificationLoss();
      /**
       * <pre>
       * Classification loss configuration for object center loss.
       * </pre>
       *
       * <code>optional .object_detection.protos.ClassificationLoss classification_loss = 2;</code>
       */
      object_detection.protos.Losses.ClassificationLossOrBuilder getClassificationLossOrBuilder();

      /**
       * <pre>
       * The initial bias value of the convlution kernel of the class heatmap
       * prediction head. -2.19 corresponds to predicting foreground with
       * a probability of 0.1. See "Focal Loss for Dense Object Detection"
       * at https://arxiv.org/abs/1708.02002.
       * </pre>
       *
       * <code>optional float heatmap_bias_init = 3 [default = -2.19];</code>
       * @return Whether the heatmapBiasInit field is set.
       */
      boolean hasHeatmapBiasInit();
      /**
       * <pre>
       * The initial bias value of the convlution kernel of the class heatmap
       * prediction head. -2.19 corresponds to predicting foreground with
       * a probability of 0.1. See "Focal Loss for Dense Object Detection"
       * at https://arxiv.org/abs/1708.02002.
       * </pre>
       *
       * <code>optional float heatmap_bias_init = 3 [default = -2.19];</code>
       * @return The heatmapBiasInit.
       */
      float getHeatmapBiasInit();

      /**
       * <pre>
       * The minimum IOU overlap boxes need to have to not be penalized.
       * </pre>
       *
       * <code>optional float min_box_overlap_iou = 4 [default = 0.7];</code>
       * @return Whether the minBoxOverlapIou field is set.
       */
      boolean hasMinBoxOverlapIou();
      /**
       * <pre>
       * The minimum IOU overlap boxes need to have to not be penalized.
       * </pre>
       *
       * <code>optional float min_box_overlap_iou = 4 [default = 0.7];</code>
       * @return The minBoxOverlapIou.
       */
      float getMinBoxOverlapIou();

      /**
       * <pre>
       * Maximum number of boxes to predict.
       * </pre>
       *
       * <code>optional int32 max_box_predictions = 5 [default = 100];</code>
       * @return Whether the maxBoxPredictions field is set.
       */
      boolean hasMaxBoxPredictions();
      /**
       * <pre>
       * Maximum number of boxes to predict.
       * </pre>
       *
       * <code>optional int32 max_box_predictions = 5 [default = 100];</code>
       * @return The maxBoxPredictions.
       */
      int getMaxBoxPredictions();

      /**
       * <pre>
       * If set, loss is only computed for the labeled classes.
       * </pre>
       *
       * <code>optional bool use_labeled_classes = 6 [default = false];</code>
       * @return Whether the useLabeledClasses field is set.
       */
      boolean hasUseLabeledClasses();
      /**
       * <pre>
       * If set, loss is only computed for the labeled classes.
       * </pre>
       *
       * <code>optional bool use_labeled_classes = 6 [default = false];</code>
       * @return The useLabeledClasses.
       */
      boolean getUseLabeledClasses();
    }
    /**
     * <pre>
     * Parameters related to object center prediction. This is required for both
     * object detection and keypoint estimation tasks.
     * </pre>
     *
     * Protobuf type {@code object_detection.protos.CenterNet.ObjectCenterParams}
     */
    public static final class ObjectCenterParams extends
        com.google.protobuf.GeneratedMessageV3 implements
        // @@protoc_insertion_point(message_implements:object_detection.protos.CenterNet.ObjectCenterParams)
        ObjectCenterParamsOrBuilder {
    private static final long serialVersionUID = 0L;
      // Use ObjectCenterParams.newBuilder() to construct.
      private ObjectCenterParams(com.google.protobuf.GeneratedMessageV3.Builder<?> builder) {
        super(builder);
      }
      private ObjectCenterParams() {
        objectCenterLossWeight_ = 1F;
        heatmapBiasInit_ = -2.19F;
        minBoxOverlapIou_ = 0.7F;
        maxBoxPredictions_ = 100;
      }

      @java.lang.Override
      @SuppressWarnings({"unused"})
      protected java.lang.Object newInstance(
          UnusedPrivateParameter unused) {
        return new ObjectCenterParams();
      }

      @java.lang.Override
      public final com.google.protobuf.UnknownFieldSet
      getUnknownFields() {
        return this.unknownFields;
      }
      private ObjectCenterParams(
          com.google.protobuf.CodedInputStream input,
          com.google.protobuf.ExtensionRegistryLite extensionRegistry)
          throws com.google.protobuf.InvalidProtocolBufferException {
        this();
        if (extensionRegistry == null) {
          throw new java.lang.NullPointerException();
        }
        int mutable_bitField0_ = 0;
        com.google.protobuf.UnknownFieldSet.Builder unknownFields =
            com.google.protobuf.UnknownFieldSet.newBuilder();
        try {
          boolean done = false;
          while (!done) {
            int tag = input.readTag();
            switch (tag) {
              case 0:
                done = true;
                break;
              case 13: {
                bitField0_ |= 0x00000001;
                objectCenterLossWeight_ = input.readFloat();
                break;
              }
              case 18: {
                object_detection.protos.Losses.ClassificationLoss.Builder subBuilder = null;
                if (((bitField0_ & 0x00000002) != 0)) {
                  subBuilder = classificationLoss_.toBuilder();
                }
                classificationLoss_ = input.readMessage(object_detection.protos.Losses.ClassificationLoss.PARSER, extensionRegistry);
                if (subBuilder != null) {
                  subBuilder.mergeFrom(classificationLoss_);
                  classificationLoss_ = subBuilder.buildPartial();
                }
                bitField0_ |= 0x00000002;
                break;
              }
              case 29: {
                bitField0_ |= 0x00000004;
                heatmapBiasInit_ = input.readFloat();
                break;
              }
              case 37: {
                bitField0_ |= 0x00000008;
                minBoxOverlapIou_ = input.readFloat();
                break;
              }
              case 40: {
                bitField0_ |= 0x00000010;
                maxBoxPredictions_ = input.readInt32();
                break;
              }
              case 48: {
                bitField0_ |= 0x00000020;
                useLabeledClasses_ = input.readBool();
                break;
              }
              default: {
                if (!parseUnknownField(
                    input, unknownFields, extensionRegistry, tag)) {
                  done = true;
                }
                break;
              }
            }
          }
        } catch (com.google.protobuf.InvalidProtocolBufferException e) {
          throw e.setUnfinishedMessage(this);
        } catch (java.io.IOException e) {
          throw new com.google.protobuf.InvalidProtocolBufferException(
              e).setUnfinishedMessage(this);
        } finally {
          this.unknownFields = unknownFields.build();
          makeExtensionsImmutable();
        }
      }
      public static final com.google.protobuf.Descriptors.Descriptor
          getDescriptor() {
        return object_detection.protos.CenterNetOuterClass.internal_static_object_detection_protos_CenterNet_ObjectCenterParams_descriptor;
      }

      @java.lang.Override
      protected com.google.protobuf.GeneratedMessageV3.FieldAccessorTable
          internalGetFieldAccessorTable() {
        return object_detection.protos.CenterNetOuterClass.internal_static_object_detection_protos_CenterNet_ObjectCenterParams_fieldAccessorTable
            .ensureFieldAccessorsInitialized(
                object_detection.protos.CenterNetOuterClass.CenterNet.ObjectCenterParams.class, object_detection.protos.CenterNetOuterClass.CenterNet.ObjectCenterParams.Builder.class);
      }

      private int bitField0_;
      public static final int OBJECT_CENTER_LOSS_WEIGHT_FIELD_NUMBER = 1;
      private float objectCenterLossWeight_;
      /**
       * <pre>
       * Weight for the object center loss.
       * </pre>
       *
       * <code>optional float object_center_loss_weight = 1 [default = 1];</code>
       * @return Whether the objectCenterLossWeight field is set.
       */
      @java.lang.Override
      public boolean hasObjectCenterLossWeight() {
        return ((bitField0_ & 0x00000001) != 0);
      }
      /**
       * <pre>
       * Weight for the object center loss.
       * </pre>
       *
       * <code>optional float object_center_loss_weight = 1 [default = 1];</code>
       * @return The objectCenterLossWeight.
       */
      @java.lang.Override
      public float getObjectCenterLossWeight() {
        return objectCenterLossWeight_;
      }

      public static final int CLASSIFICATION_LOSS_FIELD_NUMBER = 2;
      private object_detection.protos.Losses.ClassificationLoss classificationLoss_;
      /**
       * <pre>
       * Classification loss configuration for object center loss.
       * </pre>
       *
       * <code>optional .object_detection.protos.ClassificationLoss classification_loss = 2;</code>
       * @return Whether the classificationLoss field is set.
       */
      @java.lang.Override
      public boolean hasClassificationLoss() {
        return ((bitField0_ & 0x00000002) != 0);
      }
      /**
       * <pre>
       * Classification loss configuration for object center loss.
       * </pre>
       *
       * <code>optional .object_detection.protos.ClassificationLoss classification_loss = 2;</code>
       * @return The classificationLoss.
       */
      @java.lang.Override
      public object_detection.protos.Losses.ClassificationLoss getClassificationLoss() {
        return classificationLoss_ == null ? object_detection.protos.Losses.ClassificationLoss.getDefaultInstance() : classificationLoss_;
      }
      /**
       * <pre>
       * Classification loss configuration for object center loss.
       * </pre>
       *
       * <code>optional .object_detection.protos.ClassificationLoss classification_loss = 2;</code>
       */
      @java.lang.Override
      public object_detection.protos.Losses.ClassificationLossOrBuilder getClassificationLossOrBuilder() {
        return classificationLoss_ == null ? object_detection.protos.Losses.ClassificationLoss.getDefaultInstance() : classificationLoss_;
      }

      public static final int HEATMAP_BIAS_INIT_FIELD_NUMBER = 3;
      private float heatmapBiasInit_;
      /**
       * <pre>
       * The initial bias value of the convlution kernel of the class heatmap
       * prediction head. -2.19 corresponds to predicting foreground with
       * a probability of 0.1. See "Focal Loss for Dense Object Detection"
       * at https://arxiv.org/abs/1708.02002.
       * </pre>
       *
       * <code>optional float heatmap_bias_init = 3 [default = -2.19];</code>
       * @return Whether the heatmapBiasInit field is set.
       */
      @java.lang.Override
      public boolean hasHeatmapBiasInit() {
        return ((bitField0_ & 0x00000004) != 0);
      }
      /**
       * <pre>
       * The initial bias value of the convlution kernel of the class heatmap
       * prediction head. -2.19 corresponds to predicting foreground with
       * a probability of 0.1. See "Focal Loss for Dense Object Detection"
       * at https://arxiv.org/abs/1708.02002.
       * </pre>
       *
       * <code>optional float heatmap_bias_init = 3 [default = -2.19];</code>
       * @return The heatmapBiasInit.
       */
      @java.lang.Override
      public float getHeatmapBiasInit() {
        return heatmapBiasInit_;
      }

      public static final int MIN_BOX_OVERLAP_IOU_FIELD_NUMBER = 4;
      private float minBoxOverlapIou_;
      /**
       * <pre>
       * The minimum IOU overlap boxes need to have to not be penalized.
       * </pre>
       *
       * <code>optional float min_box_overlap_iou = 4 [default = 0.7];</code>
       * @return Whether the minBoxOverlapIou field is set.
       */
      @java.lang.Override
      public boolean hasMinBoxOverlapIou() {
        return ((bitField0_ & 0x00000008) != 0);
      }
      /**
       * <pre>
       * The minimum IOU overlap boxes need to have to not be penalized.
       * </pre>
       *
       * <code>optional float min_box_overlap_iou = 4 [default = 0.7];</code>
       * @return The minBoxOverlapIou.
       */
      @java.lang.Override
      public float getMinBoxOverlapIou() {
        return minBoxOverlapIou_;
      }

      public static final int MAX_BOX_PREDICTIONS_FIELD_NUMBER = 5;
      private int maxBoxPredictions_;
      /**
       * <pre>
       * Maximum number of boxes to predict.
       * </pre>
       *
       * <code>optional int32 max_box_predictions = 5 [default = 100];</code>
       * @return Whether the maxBoxPredictions field is set.
       */
      @java.lang.Override
      public boolean hasMaxBoxPredictions() {
        return ((bitField0_ & 0x00000010) != 0);
      }
      /**
       * <pre>
       * Maximum number of boxes to predict.
       * </pre>
       *
       * <code>optional int32 max_box_predictions = 5 [default = 100];</code>
       * @return The maxBoxPredictions.
       */
      @java.lang.Override
      public int getMaxBoxPredictions() {
        return maxBoxPredictions_;
      }

      public static final int USE_LABELED_CLASSES_FIELD_NUMBER = 6;
      private boolean useLabeledClasses_;
      /**
       * <pre>
       * If set, loss is only computed for the labeled classes.
       * </pre>
       *
       * <code>optional bool use_labeled_classes = 6 [default = false];</code>
       * @return Whether the useLabeledClasses field is set.
       */
      @java.lang.Override
      public boolean hasUseLabeledClasses() {
        return ((bitField0_ & 0x00000020) != 0);
      }
      /**
       * <pre>
       * If set, loss is only computed for the labeled classes.
       * </pre>
       *
       * <code>optional bool use_labeled_classes = 6 [default = false];</code>
       * @return The useLabeledClasses.
       */
      @java.lang.Override
      public boolean getUseLabeledClasses() {
        return useLabeledClasses_;
      }

      private byte memoizedIsInitialized = -1;
      @java.lang.Override
      public final boolean isInitialized() {
        byte isInitialized = memoizedIsInitialized;
        if (isInitialized == 1) return true;
        if (isInitialized == 0) return false;

        memoizedIsInitialized = 1;
        return true;
      }

      @java.lang.Override
      public void writeTo(com.google.protobuf.CodedOutputStream output)
                          throws java.io.IOException {
        if (((bitField0_ & 0x00000001) != 0)) {
          output.writeFloat(1, objectCenterLossWeight_);
        }
        if (((bitField0_ & 0x00000002) != 0)) {
          output.writeMessage(2, getClassificationLoss());
        }
        if (((bitField0_ & 0x00000004) != 0)) {
          output.writeFloat(3, heatmapBiasInit_);
        }
        if (((bitField0_ & 0x00000008) != 0)) {
          output.writeFloat(4, minBoxOverlapIou_);
        }
        if (((bitField0_ & 0x00000010) != 0)) {
          output.writeInt32(5, maxBoxPredictions_);
        }
        if (((bitField0_ & 0x00000020) != 0)) {
          output.writeBool(6, useLabeledClasses_);
        }
        unknownFields.writeTo(output);
      }

      @java.lang.Override
      public int getSerializedSize() {
        int size = memoizedSize;
        if (size != -1) return size;

        size = 0;
        if (((bitField0_ & 0x00000001) != 0)) {
          size += com.google.protobuf.CodedOutputStream
            .computeFloatSize(1, objectCenterLossWeight_);
        }
        if (((bitField0_ & 0x00000002) != 0)) {
          size += com.google.protobuf.CodedOutputStream
            .computeMessageSize(2, getClassificationLoss());
        }
        if (((bitField0_ & 0x00000004) != 0)) {
          size += com.google.protobuf.CodedOutputStream
            .computeFloatSize(3, heatmapBiasInit_);
        }
        if (((bitField0_ & 0x00000008) != 0)) {
          size += com.google.protobuf.CodedOutputStream
            .computeFloatSize(4, minBoxOverlapIou_);
        }
        if (((bitField0_ & 0x00000010) != 0)) {
          size += com.google.protobuf.CodedOutputStream
            .computeInt32Size(5, maxBoxPredictions_);
        }
        if (((bitField0_ & 0x00000020) != 0)) {
          size += com.google.protobuf.CodedOutputStream
            .computeBoolSize(6, useLabeledClasses_);
        }
        size += unknownFields.getSerializedSize();
        memoizedSize = size;
        return size;
      }

      @java.lang.Override
      public boolean equals(final java.lang.Object obj) {
        if (obj == this) {
         return true;
        }
        if (!(obj instanceof object_detection.protos.CenterNetOuterClass.CenterNet.ObjectCenterParams)) {
          return super.equals(obj);
        }
        object_detection.protos.CenterNetOuterClass.CenterNet.ObjectCenterParams other = (object_detection.protos.CenterNetOuterClass.CenterNet.ObjectCenterParams) obj;

        if (hasObjectCenterLossWeight() != other.hasObjectCenterLossWeight()) return false;
        if (hasObjectCenterLossWeight()) {
          if (java.lang.Float.floatToIntBits(getObjectCenterLossWeight())
              != java.lang.Float.floatToIntBits(
                  other.getObjectCenterLossWeight())) return false;
        }
        if (hasClassificationLoss() != other.hasClassificationLoss()) return false;
        if (hasClassificationLoss()) {
          if (!getClassificationLoss()
              .equals(other.getClassificationLoss())) return false;
        }
        if (hasHeatmapBiasInit() != other.hasHeatmapBiasInit()) return false;
        if (hasHeatmapBiasInit()) {
          if (java.lang.Float.floatToIntBits(getHeatmapBiasInit())
              != java.lang.Float.floatToIntBits(
                  other.getHeatmapBiasInit())) return false;
        }
        if (hasMinBoxOverlapIou() != other.hasMinBoxOverlapIou()) return false;
        if (hasMinBoxOverlapIou()) {
          if (java.lang.Float.floatToIntBits(getMinBoxOverlapIou())
              != java.lang.Float.floatToIntBits(
                  other.getMinBoxOverlapIou())) return false;
        }
        if (hasMaxBoxPredictions() != other.hasMaxBoxPredictions()) return false;
        if (hasMaxBoxPredictions()) {
          if (getMaxBoxPredictions()
              != other.getMaxBoxPredictions()) return false;
        }
        if (hasUseLabeledClasses() != other.hasUseLabeledClasses()) return false;
        if (hasUseLabeledClasses()) {
          if (getUseLabeledClasses()
              != other.getUseLabeledClasses()) return false;
        }
        if (!unknownFields.equals(other.unknownFields)) return false;
        return true;
      }

      @java.lang.Override
      public int hashCode() {
        if (memoizedHashCode != 0) {
          return memoizedHashCode;
        }
        int hash = 41;
        hash = (19 * hash) + getDescriptor().hashCode();
        if (hasObjectCenterLossWeight()) {
          hash = (37 * hash) + OBJECT_CENTER_LOSS_WEIGHT_FIELD_NUMBER;
          hash = (53 * hash) + java.lang.Float.floatToIntBits(
              getObjectCenterLossWeight());
        }
        if (hasClassificationLoss()) {
          hash = (37 * hash) + CLASSIFICATION_LOSS_FIELD_NUMBER;
          hash = (53 * hash) + getClassificationLoss().hashCode();
        }
        if (hasHeatmapBiasInit()) {
          hash = (37 * hash) + HEATMAP_BIAS_INIT_FIELD_NUMBER;
          hash = (53 * hash) + java.lang.Float.floatToIntBits(
              getHeatmapBiasInit());
        }
        if (hasMinBoxOverlapIou()) {
          hash = (37 * hash) + MIN_BOX_OVERLAP_IOU_FIELD_NUMBER;
          hash = (53 * hash) + java.lang.Float.floatToIntBits(
              getMinBoxOverlapIou());
        }
        if (hasMaxBoxPredictions()) {
          hash = (37 * hash) + MAX_BOX_PREDICTIONS_FIELD_NUMBER;
          hash = (53 * hash) + getMaxBoxPredictions();
        }
        if (hasUseLabeledClasses()) {
          hash = (37 * hash) + USE_LABELED_CLASSES_FIELD_NUMBER;
          hash = (53 * hash) + com.google.protobuf.Internal.hashBoolean(
              getUseLabeledClasses());
        }
        hash = (29 * hash) + unknownFields.hashCode();
        memoizedHashCode = hash;
        return hash;
      }

      public static object_detection.protos.CenterNetOuterClass.CenterNet.ObjectCenterParams parseFrom(
          java.nio.ByteBuffer data)
          throws com.google.protobuf.InvalidProtocolBufferException {
        return PARSER.parseFrom(data);
      }
      public static object_detection.protos.CenterNetOuterClass.CenterNet.ObjectCenterParams parseFrom(
          java.nio.ByteBuffer data,
          com.google.protobuf.ExtensionRegistryLite extensionRegistry)
          throws com.google.protobuf.InvalidProtocolBufferException {
        return PARSER.parseFrom(data, extensionRegistry);
      }
      public static object_detection.protos.CenterNetOuterClass.CenterNet.ObjectCenterParams parseFrom(
          com.google.protobuf.ByteString data)
          throws com.google.protobuf.InvalidProtocolBufferException {
        return PARSER.parseFrom(data);
      }
      public static object_detection.protos.CenterNetOuterClass.CenterNet.ObjectCenterParams parseFrom(
          com.google.protobuf.ByteString data,
          com.google.protobuf.ExtensionRegistryLite extensionRegistry)
          throws com.google.protobuf.InvalidProtocolBufferException {
        return PARSER.parseFrom(data, extensionRegistry);
      }
      public static object_detection.protos.CenterNetOuterClass.CenterNet.ObjectCenterParams parseFrom(byte[] data)
          throws com.google.protobuf.InvalidProtocolBufferException {
        return PARSER.parseFrom(data);
      }
      public static object_detection.protos.CenterNetOuterClass.CenterNet.ObjectCenterParams parseFrom(
          byte[] data,
          com.google.protobuf.ExtensionRegistryLite extensionRegistry)
          throws com.google.protobuf.InvalidProtocolBufferException {
        return PARSER.parseFrom(data, extensionRegistry);
      }
      public static object_detection.protos.CenterNetOuterClass.CenterNet.ObjectCenterParams parseFrom(java.io.InputStream input)
          throws java.io.IOException {
        return com.google.protobuf.GeneratedMessageV3
            .parseWithIOException(PARSER, input);
      }
      public static object_detection.protos.CenterNetOuterClass.CenterNet.ObjectCenterParams parseFrom(
          java.io.InputStream input,
          com.google.protobuf.ExtensionRegistryLite extensionRegistry)
          throws java.io.IOException {
        return com.google.protobuf.GeneratedMessageV3
            .parseWithIOException(PARSER, input, extensionRegistry);
      }
      public static object_detection.protos.CenterNetOuterClass.CenterNet.ObjectCenterParams parseDelimitedFrom(java.io.InputStream input)
          throws java.io.IOException {
        return com.google.protobuf.GeneratedMessageV3
            .parseDelimitedWithIOException(PARSER, input);
      }
      public static object_detection.protos.CenterNetOuterClass.CenterNet.ObjectCenterParams parseDelimitedFrom(
          java.io.InputStream input,
          com.google.protobuf.ExtensionRegistryLite extensionRegistry)
          throws java.io.IOException {
        return com.google.protobuf.GeneratedMessageV3
            .parseDelimitedWithIOException(PARSER, input, extensionRegistry);
      }
      public static object_detection.protos.CenterNetOuterClass.CenterNet.ObjectCenterParams parseFrom(
          com.google.protobuf.CodedInputStream input)
          throws java.io.IOException {
        return com.google.protobuf.GeneratedMessageV3
            .parseWithIOException(PARSER, input);
      }
      public static object_detection.protos.CenterNetOuterClass.CenterNet.ObjectCenterParams parseFrom(
          com.google.protobuf.CodedInputStream input,
          com.google.protobuf.ExtensionRegistryLite extensionRegistry)
          throws java.io.IOException {
        return com.google.protobuf.GeneratedMessageV3
            .parseWithIOException(PARSER, input, extensionRegistry);
      }

      @java.lang.Override
      public Builder newBuilderForType() { return newBuilder(); }
      public static Builder newBuilder() {
        return DEFAULT_INSTANCE.toBuilder();
      }
      public static Builder newBuilder(object_detection.protos.CenterNetOuterClass.CenterNet.ObjectCenterParams prototype) {
        return DEFAULT_INSTANCE.toBuilder().mergeFrom(prototype);
      }
      @java.lang.Override
      public Builder toBuilder() {
        return this == DEFAULT_INSTANCE
            ? new Builder() : new Builder().mergeFrom(this);
      }

      @java.lang.Override
      protected Builder newBuilderForType(
          com.google.protobuf.GeneratedMessageV3.BuilderParent parent) {
        Builder builder = new Builder(parent);
        return builder;
      }
      /**
       * <pre>
       * Parameters related to object center prediction. This is required for both
       * object detection and keypoint estimation tasks.
       * </pre>
       *
       * Protobuf type {@code object_detection.protos.CenterNet.ObjectCenterParams}
       */
      public static final class Builder extends
          com.google.protobuf.GeneratedMessageV3.Builder<Builder> implements
          // @@protoc_insertion_point(builder_implements:object_detection.protos.CenterNet.ObjectCenterParams)
          object_detection.protos.CenterNetOuterClass.CenterNet.ObjectCenterParamsOrBuilder {
        public static final com.google.protobuf.Descriptors.Descriptor
            getDescriptor() {
          return object_detection.protos.CenterNetOuterClass.internal_static_object_detection_protos_CenterNet_ObjectCenterParams_descriptor;
        }

        @java.lang.Override
        protected com.google.protobuf.GeneratedMessageV3.FieldAccessorTable
            internalGetFieldAccessorTable() {
          return object_detection.protos.CenterNetOuterClass.internal_static_object_detection_protos_CenterNet_ObjectCenterParams_fieldAccessorTable
              .ensureFieldAccessorsInitialized(
                  object_detection.protos.CenterNetOuterClass.CenterNet.ObjectCenterParams.class, object_detection.protos.CenterNetOuterClass.CenterNet.ObjectCenterParams.Builder.class);
        }

        // Construct using object_detection.protos.CenterNetOuterClass.CenterNet.ObjectCenterParams.newBuilder()
        private Builder() {
          maybeForceBuilderInitialization();
        }

        private Builder(
            com.google.protobuf.GeneratedMessageV3.BuilderParent parent) {
          super(parent);
          maybeForceBuilderInitialization();
        }
        private void maybeForceBuilderInitialization() {
          if (com.google.protobuf.GeneratedMessageV3
                  .alwaysUseFieldBuilders) {
            getClassificationLossFieldBuilder();
          }
        }
        @java.lang.Override
        public Builder clear() {
          super.clear();
          objectCenterLossWeight_ = 1F;
          bitField0_ = (bitField0_ & ~0x00000001);
          if (classificationLossBuilder_ == null) {
            classificationLoss_ = null;
          } else {
            classificationLossBuilder_.clear();
          }
          bitField0_ = (bitField0_ & ~0x00000002);
          heatmapBiasInit_ = -2.19F;
          bitField0_ = (bitField0_ & ~0x00000004);
          minBoxOverlapIou_ = 0.7F;
          bitField0_ = (bitField0_ & ~0x00000008);
          maxBoxPredictions_ = 100;
          bitField0_ = (bitField0_ & ~0x00000010);
          useLabeledClasses_ = false;
          bitField0_ = (bitField0_ & ~0x00000020);
          return this;
        }

        @java.lang.Override
        public com.google.protobuf.Descriptors.Descriptor
            getDescriptorForType() {
          return object_detection.protos.CenterNetOuterClass.internal_static_object_detection_protos_CenterNet_ObjectCenterParams_descriptor;
        }

        @java.lang.Override
        public object_detection.protos.CenterNetOuterClass.CenterNet.ObjectCenterParams getDefaultInstanceForType() {
          return object_detection.protos.CenterNetOuterClass.CenterNet.ObjectCenterParams.getDefaultInstance();
        }

        @java.lang.Override
        public object_detection.protos.CenterNetOuterClass.CenterNet.ObjectCenterParams build() {
          object_detection.protos.CenterNetOuterClass.CenterNet.ObjectCenterParams result = buildPartial();
          if (!result.isInitialized()) {
            throw newUninitializedMessageException(result);
          }
          return result;
        }

        @java.lang.Override
        public object_detection.protos.CenterNetOuterClass.CenterNet.ObjectCenterParams buildPartial() {
          object_detection.protos.CenterNetOuterClass.CenterNet.ObjectCenterParams result = new object_detection.protos.CenterNetOuterClass.CenterNet.ObjectCenterParams(this);
          int from_bitField0_ = bitField0_;
          int to_bitField0_ = 0;
          if (((from_bitField0_ & 0x00000001) != 0)) {
            to_bitField0_ |= 0x00000001;
          }
          result.objectCenterLossWeight_ = objectCenterLossWeight_;
          if (((from_bitField0_ & 0x00000002) != 0)) {
            if (classificationLossBuilder_ == null) {
              result.classificationLoss_ = classificationLoss_;
            } else {
              result.classificationLoss_ = classificationLossBuilder_.build();
            }
            to_bitField0_ |= 0x00000002;
          }
          if (((from_bitField0_ & 0x00000004) != 0)) {
            to_bitField0_ |= 0x00000004;
          }
          result.heatmapBiasInit_ = heatmapBiasInit_;
          if (((from_bitField0_ & 0x00000008) != 0)) {
            to_bitField0_ |= 0x00000008;
          }
          result.minBoxOverlapIou_ = minBoxOverlapIou_;
          if (((from_bitField0_ & 0x00000010) != 0)) {
            to_bitField0_ |= 0x00000010;
          }
          result.maxBoxPredictions_ = maxBoxPredictions_;
          if (((from_bitField0_ & 0x00000020) != 0)) {
            result.useLabeledClasses_ = useLabeledClasses_;
            to_bitField0_ |= 0x00000020;
          }
          result.bitField0_ = to_bitField0_;
          onBuilt();
          return result;
        }

        @java.lang.Override
        public Builder clone() {
          return super.clone();
        }
        @java.lang.Override
        public Builder setField(
            com.google.protobuf.Descriptors.FieldDescriptor field,
            java.lang.Object value) {
          return super.setField(field, value);
        }
        @java.lang.Override
        public Builder clearField(
            com.google.protobuf.Descriptors.FieldDescriptor field) {
          return super.clearField(field);
        }
        @java.lang.Override
        public Builder clearOneof(
            com.google.protobuf.Descriptors.OneofDescriptor oneof) {
          return super.clearOneof(oneof);
        }
        @java.lang.Override
        public Builder setRepeatedField(
            com.google.protobuf.Descriptors.FieldDescriptor field,
            int index, java.lang.Object value) {
          return super.setRepeatedField(field, index, value);
        }
        @java.lang.Override
        public Builder addRepeatedField(
            com.google.protobuf.Descriptors.FieldDescriptor field,
            java.lang.Object value) {
          return super.addRepeatedField(field, value);
        }
        @java.lang.Override
        public Builder mergeFrom(com.google.protobuf.Message other) {
          if (other instanceof object_detection.protos.CenterNetOuterClass.CenterNet.ObjectCenterParams) {
            return mergeFrom((object_detection.protos.CenterNetOuterClass.CenterNet.ObjectCenterParams)other);
          } else {
            super.mergeFrom(other);
            return this;
          }
        }

        public Builder mergeFrom(object_detection.protos.CenterNetOuterClass.CenterNet.ObjectCenterParams other) {
          if (other == object_detection.protos.CenterNetOuterClass.CenterNet.ObjectCenterParams.getDefaultInstance()) return this;
          if (other.hasObjectCenterLossWeight()) {
            setObjectCenterLossWeight(other.getObjectCenterLossWeight());
          }
          if (other.hasClassificationLoss()) {
            mergeClassificationLoss(other.getClassificationLoss());
          }
          if (other.hasHeatmapBiasInit()) {
            setHeatmapBiasInit(other.getHeatmapBiasInit());
          }
          if (other.hasMinBoxOverlapIou()) {
            setMinBoxOverlapIou(other.getMinBoxOverlapIou());
          }
          if (other.hasMaxBoxPredictions()) {
            setMaxBoxPredictions(other.getMaxBoxPredictions());
          }
          if (other.hasUseLabeledClasses()) {
            setUseLabeledClasses(other.getUseLabeledClasses());
          }
          this.mergeUnknownFields(other.unknownFields);
          onChanged();
          return this;
        }

        @java.lang.Override
        public final boolean isInitialized() {
          return true;
        }

        @java.lang.Override
        public Builder mergeFrom(
            com.google.protobuf.CodedInputStream input,
            com.google.protobuf.ExtensionRegistryLite extensionRegistry)
            throws java.io.IOException {
          object_detection.protos.CenterNetOuterClass.CenterNet.ObjectCenterParams parsedMessage = null;
          try {
            parsedMessage = PARSER.parsePartialFrom(input, extensionRegistry);
          } catch (com.google.protobuf.InvalidProtocolBufferException e) {
            parsedMessage = (object_detection.protos.CenterNetOuterClass.CenterNet.ObjectCenterParams) e.getUnfinishedMessage();
            throw e.unwrapIOException();
          } finally {
            if (parsedMessage != null) {
              mergeFrom(parsedMessage);
            }
          }
          return this;
        }
        private int bitField0_;

        private float objectCenterLossWeight_ = 1F;
        /**
         * <pre>
         * Weight for the object center loss.
         * </pre>
         *
         * <code>optional float object_center_loss_weight = 1 [default = 1];</code>
         * @return Whether the objectCenterLossWeight field is set.
         */
        @java.lang.Override
        public boolean hasObjectCenterLossWeight() {
          return ((bitField0_ & 0x00000001) != 0);
        }
        /**
         * <pre>
         * Weight for the object center loss.
         * </pre>
         *
         * <code>optional float object_center_loss_weight = 1 [default = 1];</code>
         * @return The objectCenterLossWeight.
         */
        @java.lang.Override
        public float getObjectCenterLossWeight() {
          return objectCenterLossWeight_;
        }
        /**
         * <pre>
         * Weight for the object center loss.
         * </pre>
         *
         * <code>optional float object_center_loss_weight = 1 [default = 1];</code>
         * @param value The objectCenterLossWeight to set.
         * @return This builder for chaining.
         */
        public Builder setObjectCenterLossWeight(float value) {
          bitField0_ |= 0x00000001;
          objectCenterLossWeight_ = value;
          onChanged();
          return this;
        }
        /**
         * <pre>
         * Weight for the object center loss.
         * </pre>
         *
         * <code>optional float object_center_loss_weight = 1 [default = 1];</code>
         * @return This builder for chaining.
         */
        public Builder clearObjectCenterLossWeight() {
          bitField0_ = (bitField0_ & ~0x00000001);
          objectCenterLossWeight_ = 1F;
          onChanged();
          return this;
        }

        private object_detection.protos.Losses.ClassificationLoss classificationLoss_;
        private com.google.protobuf.SingleFieldBuilderV3<
            object_detection.protos.Losses.ClassificationLoss, object_detection.protos.Losses.ClassificationLoss.Builder, object_detection.protos.Losses.ClassificationLossOrBuilder> classificationLossBuilder_;
        /**
         * <pre>
         * Classification loss configuration for object center loss.
         * </pre>
         *
         * <code>optional .object_detection.protos.ClassificationLoss classification_loss = 2;</code>
         * @return Whether the classificationLoss field is set.
         */
        public boolean hasClassificationLoss() {
          return ((bitField0_ & 0x00000002) != 0);
        }
        /**
         * <pre>
         * Classification loss configuration for object center loss.
         * </pre>
         *
         * <code>optional .object_detection.protos.ClassificationLoss classification_loss = 2;</code>
         * @return The classificationLoss.
         */
        public object_detection.protos.Losses.ClassificationLoss getClassificationLoss() {
          if (classificationLossBuilder_ == null) {
            return classificationLoss_ == null ? object_detection.protos.Losses.ClassificationLoss.getDefaultInstance() : classificationLoss_;
          } else {
            return classificationLossBuilder_.getMessage();
          }
        }
        /**
         * <pre>
         * Classification loss configuration for object center loss.
         * </pre>
         *
         * <code>optional .object_detection.protos.ClassificationLoss classification_loss = 2;</code>
         */
        public Builder setClassificationLoss(object_detection.protos.Losses.ClassificationLoss value) {
          if (classificationLossBuilder_ == null) {
            if (value == null) {
              throw new NullPointerException();
            }
            classificationLoss_ = value;
            onChanged();
          } else {
            classificationLossBuilder_.setMessage(value);
          }
          bitField0_ |= 0x00000002;
          return this;
        }
        /**
         * <pre>
         * Classification loss configuration for object center loss.
         * </pre>
         *
         * <code>optional .object_detection.protos.ClassificationLoss classification_loss = 2;</code>
         */
        public Builder setClassificationLoss(
            object_detection.protos.Losses.ClassificationLoss.Builder builderForValue) {
          if (classificationLossBuilder_ == null) {
            classificationLoss_ = builderForValue.build();
            onChanged();
          } else {
            classificationLossBuilder_.setMessage(builderForValue.build());
          }
          bitField0_ |= 0x00000002;
          return this;
        }
        /**
         * <pre>
         * Classification loss configuration for object center loss.
         * </pre>
         *
         * <code>optional .object_detection.protos.ClassificationLoss classification_loss = 2;</code>
         */
        public Builder mergeClassificationLoss(object_detection.protos.Losses.ClassificationLoss value) {
          if (classificationLossBuilder_ == null) {
            if (((bitField0_ & 0x00000002) != 0) &&
                classificationLoss_ != null &&
                classificationLoss_ != object_detection.protos.Losses.ClassificationLoss.getDefaultInstance()) {
              classificationLoss_ =
                object_detection.protos.Losses.ClassificationLoss.newBuilder(classificationLoss_).mergeFrom(value).buildPartial();
            } else {
              classificationLoss_ = value;
            }
            onChanged();
          } else {
            classificationLossBuilder_.mergeFrom(value);
          }
          bitField0_ |= 0x00000002;
          return this;
        }
        /**
         * <pre>
         * Classification loss configuration for object center loss.
         * </pre>
         *
         * <code>optional .object_detection.protos.ClassificationLoss classification_loss = 2;</code>
         */
        public Builder clearClassificationLoss() {
          if (classificationLossBuilder_ == null) {
            classificationLoss_ = null;
            onChanged();
          } else {
            classificationLossBuilder_.clear();
          }
          bitField0_ = (bitField0_ & ~0x00000002);
          return this;
        }
        /**
         * <pre>
         * Classification loss configuration for object center loss.
         * </pre>
         *
         * <code>optional .object_detection.protos.ClassificationLoss classification_loss = 2;</code>
         */
        public object_detection.protos.Losses.ClassificationLoss.Builder getClassificationLossBuilder() {
          bitField0_ |= 0x00000002;
          onChanged();
          return getClassificationLossFieldBuilder().getBuilder();
        }
        /**
         * <pre>
         * Classification loss configuration for object center loss.
         * </pre>
         *
         * <code>optional .object_detection.protos.ClassificationLoss classification_loss = 2;</code>
         */
        public object_detection.protos.Losses.ClassificationLossOrBuilder getClassificationLossOrBuilder() {
          if (classificationLossBuilder_ != null) {
            return classificationLossBuilder_.getMessageOrBuilder();
          } else {
            return classificationLoss_ == null ?
                object_detection.protos.Losses.ClassificationLoss.getDefaultInstance() : classificationLoss_;
          }
        }
        /**
         * <pre>
         * Classification loss configuration for object center loss.
         * </pre>
         *
         * <code>optional .object_detection.protos.ClassificationLoss classification_loss = 2;</code>
         */
        private com.google.protobuf.SingleFieldBuilderV3<
            object_detection.protos.Losses.ClassificationLoss, object_detection.protos.Losses.ClassificationLoss.Builder, object_detection.protos.Losses.ClassificationLossOrBuilder>
            getClassificationLossFieldBuilder() {
          if (classificationLossBuilder_ == null) {
            classificationLossBuilder_ = new com.google.protobuf.SingleFieldBuilderV3<
                object_detection.protos.Losses.ClassificationLoss, object_detection.protos.Losses.ClassificationLoss.Builder, object_detection.protos.Losses.ClassificationLossOrBuilder>(
                    getClassificationLoss(),
                    getParentForChildren(),
                    isClean());
            classificationLoss_ = null;
          }
          return classificationLossBuilder_;
        }

        private float heatmapBiasInit_ = -2.19F;
        /**
         * <pre>
         * The initial bias value of the convlution kernel of the class heatmap
         * prediction head. -2.19 corresponds to predicting foreground with
         * a probability of 0.1. See "Focal Loss for Dense Object Detection"
         * at https://arxiv.org/abs/1708.02002.
         * </pre>
         *
         * <code>optional float heatmap_bias_init = 3 [default = -2.19];</code>
         * @return Whether the heatmapBiasInit field is set.
         */
        @java.lang.Override
        public boolean hasHeatmapBiasInit() {
          return ((bitField0_ & 0x00000004) != 0);
        }
        /**
         * <pre>
         * The initial bias value of the convlution kernel of the class heatmap
         * prediction head. -2.19 corresponds to predicting foreground with
         * a probability of 0.1. See "Focal Loss for Dense Object Detection"
         * at https://arxiv.org/abs/1708.02002.
         * </pre>
         *
         * <code>optional float heatmap_bias_init = 3 [default = -2.19];</code>
         * @return The heatmapBiasInit.
         */
        @java.lang.Override
        public float getHeatmapBiasInit() {
          return heatmapBiasInit_;
        }
        /**
         * <pre>
         * The initial bias value of the convlution kernel of the class heatmap
         * prediction head. -2.19 corresponds to predicting foreground with
         * a probability of 0.1. See "Focal Loss for Dense Object Detection"
         * at https://arxiv.org/abs/1708.02002.
         * </pre>
         *
         * <code>optional float heatmap_bias_init = 3 [default = -2.19];</code>
         * @param value The heatmapBiasInit to set.
         * @return This builder for chaining.
         */
        public Builder setHeatmapBiasInit(float value) {
          bitField0_ |= 0x00000004;
          heatmapBiasInit_ = value;
          onChanged();
          return this;
        }
        /**
         * <pre>
         * The initial bias value of the convlution kernel of the class heatmap
         * prediction head. -2.19 corresponds to predicting foreground with
         * a probability of 0.1. See "Focal Loss for Dense Object Detection"
         * at https://arxiv.org/abs/1708.02002.
         * </pre>
         *
         * <code>optional float heatmap_bias_init = 3 [default = -2.19];</code>
         * @return This builder for chaining.
         */
        public Builder clearHeatmapBiasInit() {
          bitField0_ = (bitField0_ & ~0x00000004);
          heatmapBiasInit_ = -2.19F;
          onChanged();
          return this;
        }

        private float minBoxOverlapIou_ = 0.7F;
        /**
         * <pre>
         * The minimum IOU overlap boxes need to have to not be penalized.
         * </pre>
         *
         * <code>optional float min_box_overlap_iou = 4 [default = 0.7];</code>
         * @return Whether the minBoxOverlapIou field is set.
         */
        @java.lang.Override
        public boolean hasMinBoxOverlapIou() {
          return ((bitField0_ & 0x00000008) != 0);
        }
        /**
         * <pre>
         * The minimum IOU overlap boxes need to have to not be penalized.
         * </pre>
         *
         * <code>optional float min_box_overlap_iou = 4 [default = 0.7];</code>
         * @return The minBoxOverlapIou.
         */
        @java.lang.Override
        public float getMinBoxOverlapIou() {
          return minBoxOverlapIou_;
        }
        /**
         * <pre>
         * The minimum IOU overlap boxes need to have to not be penalized.
         * </pre>
         *
         * <code>optional float min_box_overlap_iou = 4 [default = 0.7];</code>
         * @param value The minBoxOverlapIou to set.
         * @return This builder for chaining.
         */
        public Builder setMinBoxOverlapIou(float value) {
          bitField0_ |= 0x00000008;
          minBoxOverlapIou_ = value;
          onChanged();
          return this;
        }
        /**
         * <pre>
         * The minimum IOU overlap boxes need to have to not be penalized.
         * </pre>
         *
         * <code>optional float min_box_overlap_iou = 4 [default = 0.7];</code>
         * @return This builder for chaining.
         */
        public Builder clearMinBoxOverlapIou() {
          bitField0_ = (bitField0_ & ~0x00000008);
          minBoxOverlapIou_ = 0.7F;
          onChanged();
          return this;
        }

        private int maxBoxPredictions_ = 100;
        /**
         * <pre>
         * Maximum number of boxes to predict.
         * </pre>
         *
         * <code>optional int32 max_box_predictions = 5 [default = 100];</code>
         * @return Whether the maxBoxPredictions field is set.
         */
        @java.lang.Override
        public boolean hasMaxBoxPredictions() {
          return ((bitField0_ & 0x00000010) != 0);
        }
        /**
         * <pre>
         * Maximum number of boxes to predict.
         * </pre>
         *
         * <code>optional int32 max_box_predictions = 5 [default = 100];</code>
         * @return The maxBoxPredictions.
         */
        @java.lang.Override
        public int getMaxBoxPredictions() {
          return maxBoxPredictions_;
        }
        /**
         * <pre>
         * Maximum number of boxes to predict.
         * </pre>
         *
         * <code>optional int32 max_box_predictions = 5 [default = 100];</code>
         * @param value The maxBoxPredictions to set.
         * @return This builder for chaining.
         */
        public Builder setMaxBoxPredictions(int value) {
          bitField0_ |= 0x00000010;
          maxBoxPredictions_ = value;
          onChanged();
          return this;
        }
        /**
         * <pre>
         * Maximum number of boxes to predict.
         * </pre>
         *
         * <code>optional int32 max_box_predictions = 5 [default = 100];</code>
         * @return This builder for chaining.
         */
        public Builder clearMaxBoxPredictions() {
          bitField0_ = (bitField0_ & ~0x00000010);
          maxBoxPredictions_ = 100;
          onChanged();
          return this;
        }

        private boolean useLabeledClasses_ ;
        /**
         * <pre>
         * If set, loss is only computed for the labeled classes.
         * </pre>
         *
         * <code>optional bool use_labeled_classes = 6 [default = false];</code>
         * @return Whether the useLabeledClasses field is set.
         */
        @java.lang.Override
        public boolean hasUseLabeledClasses() {
          return ((bitField0_ & 0x00000020) != 0);
        }
        /**
         * <pre>
         * If set, loss is only computed for the labeled classes.
         * </pre>
         *
         * <code>optional bool use_labeled_classes = 6 [default = false];</code>
         * @return The useLabeledClasses.
         */
        @java.lang.Override
        public boolean getUseLabeledClasses() {
          return useLabeledClasses_;
        }
        /**
         * <pre>
         * If set, loss is only computed for the labeled classes.
         * </pre>
         *
         * <code>optional bool use_labeled_classes = 6 [default = false];</code>
         * @param value The useLabeledClasses to set.
         * @return This builder for chaining.
         */
        public Builder setUseLabeledClasses(boolean value) {
          bitField0_ |= 0x00000020;
          useLabeledClasses_ = value;
          onChanged();
          return this;
        }
        /**
         * <pre>
         * If set, loss is only computed for the labeled classes.
         * </pre>
         *
         * <code>optional bool use_labeled_classes = 6 [default = false];</code>
         * @return This builder for chaining.
         */
        public Builder clearUseLabeledClasses() {
          bitField0_ = (bitField0_ & ~0x00000020);
          useLabeledClasses_ = false;
          onChanged();
          return this;
        }
        @java.lang.Override
        public final Builder setUnknownFields(
            final com.google.protobuf.UnknownFieldSet unknownFields) {
          return super.setUnknownFields(unknownFields);
        }

        @java.lang.Override
        public final Builder mergeUnknownFields(
            final com.google.protobuf.UnknownFieldSet unknownFields) {
          return super.mergeUnknownFields(unknownFields);
        }


        // @@protoc_insertion_point(builder_scope:object_detection.protos.CenterNet.ObjectCenterParams)
      }

      // @@protoc_insertion_point(class_scope:object_detection.protos.CenterNet.ObjectCenterParams)
      private static final object_detection.protos.CenterNetOuterClass.CenterNet.ObjectCenterParams DEFAULT_INSTANCE;
      static {
        DEFAULT_INSTANCE = new object_detection.protos.CenterNetOuterClass.CenterNet.ObjectCenterParams();
      }

      public static object_detection.protos.CenterNetOuterClass.CenterNet.ObjectCenterParams getDefaultInstance() {
        return DEFAULT_INSTANCE;
      }

      @java.lang.Deprecated public static final com.google.protobuf.Parser<ObjectCenterParams>
          PARSER = new com.google.protobuf.AbstractParser<ObjectCenterParams>() {
        @java.lang.Override
        public ObjectCenterParams parsePartialFrom(
            com.google.protobuf.CodedInputStream input,
            com.google.protobuf.ExtensionRegistryLite extensionRegistry)
            throws com.google.protobuf.InvalidProtocolBufferException {
          return new ObjectCenterParams(input, extensionRegistry);
        }
      };

      public static com.google.protobuf.Parser<ObjectCenterParams> parser() {
        return PARSER;
      }

      @java.lang.Override
      public com.google.protobuf.Parser<ObjectCenterParams> getParserForType() {
        return PARSER;
      }

      @java.lang.Override
      public object_detection.protos.CenterNetOuterClass.CenterNet.ObjectCenterParams getDefaultInstanceForType() {
        return DEFAULT_INSTANCE;
      }

    }

    public interface KeypointEstimationOrBuilder extends
        // @@protoc_insertion_point(interface_extends:object_detection.protos.CenterNet.KeypointEstimation)
        com.google.protobuf.MessageOrBuilder {

      /**
       * <pre>
       * Name of the task, e.g. "human pose". Note that the task name should be
       * unique to each keypoint task.
       * </pre>
       *
       * <code>optional string task_name = 1;</code>
       * @return Whether the taskName field is set.
       */
      boolean hasTaskName();
      /**
       * <pre>
       * Name of the task, e.g. "human pose". Note that the task name should be
       * unique to each keypoint task.
       * </pre>
       *
       * <code>optional string task_name = 1;</code>
       * @return The taskName.
       */
      java.lang.String getTaskName();
      /**
       * <pre>
       * Name of the task, e.g. "human pose". Note that the task name should be
       * unique to each keypoint task.
       * </pre>
       *
       * <code>optional string task_name = 1;</code>
       * @return The bytes for taskName.
       */
      com.google.protobuf.ByteString
          getTaskNameBytes();

      /**
       * <pre>
       * Weight of the task loss. The total loss of the model will be their
       * summation of task losses weighted by the weights.
       * </pre>
       *
       * <code>optional float task_loss_weight = 2 [default = 1];</code>
       * @return Whether the taskLossWeight field is set.
       */
      boolean hasTaskLossWeight();
      /**
       * <pre>
       * Weight of the task loss. The total loss of the model will be their
       * summation of task losses weighted by the weights.
       * </pre>
       *
       * <code>optional float task_loss_weight = 2 [default = 1];</code>
       * @return The taskLossWeight.
       */
      float getTaskLossWeight();

      /**
       * <pre>
       * Loss configuration for keypoint heatmap, offset, regression losses. Note
       * that the localization loss is used for offset/regression losses and
       * classification loss is used for heatmap loss.
       * </pre>
       *
       * <code>optional .object_detection.protos.Loss loss = 3;</code>
       * @return Whether the loss field is set.
       */
      boolean hasLoss();
      /**
       * <pre>
       * Loss configuration for keypoint heatmap, offset, regression losses. Note
       * that the localization loss is used for offset/regression losses and
       * classification loss is used for heatmap loss.
       * </pre>
       *
       * <code>optional .object_detection.protos.Loss loss = 3;</code>
       * @return The loss.
       */
      object_detection.protos.Losses.Loss getLoss();
      /**
       * <pre>
       * Loss configuration for keypoint heatmap, offset, regression losses. Note
       * that the localization loss is used for offset/regression losses and
       * classification loss is used for heatmap loss.
       * </pre>
       *
       * <code>optional .object_detection.protos.Loss loss = 3;</code>
       */
      object_detection.protos.Losses.LossOrBuilder getLossOrBuilder();

      /**
       * <pre>
       * The name of the class that contains the keypoints for this task. This is
       * used to retrieve the corresponding keypoint indices from the label map.
       * Note that this corresponds to the "name" field, not "display_name".
       * </pre>
       *
       * <code>optional string keypoint_class_name = 4;</code>
       * @return Whether the keypointClassName field is set.
       */
      boolean hasKeypointClassName();
      /**
       * <pre>
       * The name of the class that contains the keypoints for this task. This is
       * used to retrieve the corresponding keypoint indices from the label map.
       * Note that this corresponds to the "name" field, not "display_name".
       * </pre>
       *
       * <code>optional string keypoint_class_name = 4;</code>
       * @return The keypointClassName.
       */
      java.lang.String getKeypointClassName();
      /**
       * <pre>
       * The name of the class that contains the keypoints for this task. This is
       * used to retrieve the corresponding keypoint indices from the label map.
       * Note that this corresponds to the "name" field, not "display_name".
       * </pre>
       *
       * <code>optional string keypoint_class_name = 4;</code>
       * @return The bytes for keypointClassName.
       */
      com.google.protobuf.ByteString
          getKeypointClassNameBytes();

      /**
       * <pre>
       * The standard deviation of the Gaussian kernel used to generate the
       * keypoint heatmap. The unit is the pixel in the output image. It is to
       * provide the flexibility of using different sizes of Gaussian kernel for
       * each keypoint class. Note that if provided, the keypoint standard
       * deviations will be overridden by the specified values here, otherwise,
       * the default value 5.0 will be used.
       * TODO(yuhuic): Update the default value once we found the best value.
       * </pre>
       *
       * <code>map&lt;string, float&gt; keypoint_label_to_std = 5;</code>
       */
      int getKeypointLabelToStdCount();
      /**
       * <pre>
       * The standard deviation of the Gaussian kernel used to generate the
       * keypoint heatmap. The unit is the pixel in the output image. It is to
       * provide the flexibility of using different sizes of Gaussian kernel for
       * each keypoint class. Note that if provided, the keypoint standard
       * deviations will be overridden by the specified values here, otherwise,
       * the default value 5.0 will be used.
       * TODO(yuhuic): Update the default value once we found the best value.
       * </pre>
       *
       * <code>map&lt;string, float&gt; keypoint_label_to_std = 5;</code>
       */
      boolean containsKeypointLabelToStd(
          java.lang.String key);
      /**
       * Use {@link #getKeypointLabelToStdMap()} instead.
       */
      @java.lang.Deprecated
      java.util.Map<java.lang.String, java.lang.Float>
      getKeypointLabelToStd();
      /**
       * <pre>
       * The standard deviation of the Gaussian kernel used to generate the
       * keypoint heatmap. The unit is the pixel in the output image. It is to
       * provide the flexibility of using different sizes of Gaussian kernel for
       * each keypoint class. Note that if provided, the keypoint standard
       * deviations will be overridden by the specified values here, otherwise,
       * the default value 5.0 will be used.
       * TODO(yuhuic): Update the default value once we found the best value.
       * </pre>
       *
       * <code>map&lt;string, float&gt; keypoint_label_to_std = 5;</code>
       */
      java.util.Map<java.lang.String, java.lang.Float>
      getKeypointLabelToStdMap();
      /**
       * <pre>
       * The standard deviation of the Gaussian kernel used to generate the
       * keypoint heatmap. The unit is the pixel in the output image. It is to
       * provide the flexibility of using different sizes of Gaussian kernel for
       * each keypoint class. Note that if provided, the keypoint standard
       * deviations will be overridden by the specified values here, otherwise,
       * the default value 5.0 will be used.
       * TODO(yuhuic): Update the default value once we found the best value.
       * </pre>
       *
       * <code>map&lt;string, float&gt; keypoint_label_to_std = 5;</code>
       */

      float getKeypointLabelToStdOrDefault(
          java.lang.String key,
          float defaultValue);
      /**
       * <pre>
       * The standard deviation of the Gaussian kernel used to generate the
       * keypoint heatmap. The unit is the pixel in the output image. It is to
       * provide the flexibility of using different sizes of Gaussian kernel for
       * each keypoint class. Note that if provided, the keypoint standard
       * deviations will be overridden by the specified values here, otherwise,
       * the default value 5.0 will be used.
       * TODO(yuhuic): Update the default value once we found the best value.
       * </pre>
       *
       * <code>map&lt;string, float&gt; keypoint_label_to_std = 5;</code>
       */

      float getKeypointLabelToStdOrThrow(
          java.lang.String key);

      /**
       * <pre>
       * Loss weights corresponding to different heads.
       * </pre>
       *
       * <code>optional float keypoint_regression_loss_weight = 6 [default = 1];</code>
       * @return Whether the keypointRegressionLossWeight field is set.
       */
      boolean hasKeypointRegressionLossWeight();
      /**
       * <pre>
       * Loss weights corresponding to different heads.
       * </pre>
       *
       * <code>optional float keypoint_regression_loss_weight = 6 [default = 1];</code>
       * @return The keypointRegressionLossWeight.
       */
      float getKeypointRegressionLossWeight();

      /**
       * <code>optional float keypoint_heatmap_loss_weight = 7 [default = 1];</code>
       * @return Whether the keypointHeatmapLossWeight field is set.
       */
      boolean hasKeypointHeatmapLossWeight();
      /**
       * <code>optional float keypoint_heatmap_loss_weight = 7 [default = 1];</code>
       * @return The keypointHeatmapLossWeight.
       */
      float getKeypointHeatmapLossWeight();

      /**
       * <code>optional float keypoint_offset_loss_weight = 8 [default = 1];</code>
       * @return Whether the keypointOffsetLossWeight field is set.
       */
      boolean hasKeypointOffsetLossWeight();
      /**
       * <code>optional float keypoint_offset_loss_weight = 8 [default = 1];</code>
       * @return The keypointOffsetLossWeight.
       */
      float getKeypointOffsetLossWeight();

      /**
       * <pre>
       * The initial bias value of the convolution kernel of the keypoint heatmap
       * prediction head. -2.19 corresponds to predicting foreground with
       * a probability of 0.1. See "Focal Loss for Dense Object Detection"
       * at https://arxiv.org/abs/1708.02002.
       * </pre>
       *
       * <code>optional float heatmap_bias_init = 9 [default = -2.19];</code>
       * @return Whether the heatmapBiasInit field is set.
       */
      boolean hasHeatmapBiasInit();
      /**
       * <pre>
       * The initial bias value of the convolution kernel of the keypoint heatmap
       * prediction head. -2.19 corresponds to predicting foreground with
       * a probability of 0.1. See "Focal Loss for Dense Object Detection"
       * at https://arxiv.org/abs/1708.02002.
       * </pre>
       *
       * <code>optional float heatmap_bias_init = 9 [default = -2.19];</code>
       * @return The heatmapBiasInit.
       */
      float getHeatmapBiasInit();

      /**
       * <pre>
       * The heatmap score threshold for a keypoint to become a valid candidate.
       * </pre>
       *
       * <code>optional float keypoint_candidate_score_threshold = 10 [default = 0.1];</code>
       * @return Whether the keypointCandidateScoreThreshold field is set.
       */
      boolean hasKeypointCandidateScoreThreshold();
      /**
       * <pre>
       * The heatmap score threshold for a keypoint to become a valid candidate.
       * </pre>
       *
       * <code>optional float keypoint_candidate_score_threshold = 10 [default = 0.1];</code>
       * @return The keypointCandidateScoreThreshold.
       */
      float getKeypointCandidateScoreThreshold();

      /**
       * <pre>
       * The maximum number of candidates to retrieve for each keypoint.
       * </pre>
       *
       * <code>optional int32 num_candidates_per_keypoint = 11 [default = 100];</code>
       * @return Whether the numCandidatesPerKeypoint field is set.
       */
      boolean hasNumCandidatesPerKeypoint();
      /**
       * <pre>
       * The maximum number of candidates to retrieve for each keypoint.
       * </pre>
       *
       * <code>optional int32 num_candidates_per_keypoint = 11 [default = 100];</code>
       * @return The numCandidatesPerKeypoint.
       */
      int getNumCandidatesPerKeypoint();

      /**
       * <pre>
       * Max pool kernel size to use to pull off peak score locations in a
       * neighborhood (independently for each keypoint types).
       * </pre>
       *
       * <code>optional int32 peak_max_pool_kernel_size = 12 [default = 3];</code>
       * @return Whether the peakMaxPoolKernelSize field is set.
       */
      boolean hasPeakMaxPoolKernelSize();
      /**
       * <pre>
       * Max pool kernel size to use to pull off peak score locations in a
       * neighborhood (independently for each keypoint types).
       * </pre>
       *
       * <code>optional int32 peak_max_pool_kernel_size = 12 [default = 3];</code>
       * @return The peakMaxPoolKernelSize.
       */
      int getPeakMaxPoolKernelSize();

      /**
       * <pre>
       * The default score to use for regressed keypoints that are not
       * successfully snapped to a nearby candidate.
       * </pre>
       *
       * <code>optional float unmatched_keypoint_score = 13 [default = 0.1];</code>
       * @return Whether the unmatchedKeypointScore field is set.
       */
      boolean hasUnmatchedKeypointScore();
      /**
       * <pre>
       * The default score to use for regressed keypoints that are not
       * successfully snapped to a nearby candidate.
       * </pre>
       *
       * <code>optional float unmatched_keypoint_score = 13 [default = 0.1];</code>
       * @return The unmatchedKeypointScore.
       */
      float getUnmatchedKeypointScore();

      /**
       * <pre>
       * The multiplier to expand the bounding boxes (either the provided boxes or
       * those which tightly cover the regressed keypoints). Note that new
       * expanded box for an instance becomes the feasible search window for all
       * associated keypoints.
       * </pre>
       *
       * <code>optional float box_scale = 14 [default = 1.2];</code>
       * @return Whether the boxScale field is set.
       */
      boolean hasBoxScale();
      /**
       * <pre>
       * The multiplier to expand the bounding boxes (either the provided boxes or
       * those which tightly cover the regressed keypoints). Note that new
       * expanded box for an instance becomes the feasible search window for all
       * associated keypoints.
       * </pre>
       *
       * <code>optional float box_scale = 14 [default = 1.2];</code>
       * @return The boxScale.
       */
      float getBoxScale();

      /**
       * <pre>
       * The scale parameter that multiplies the largest dimension of a bounding
       * box. The resulting distance becomes a search radius for candidates in the
       * vicinity of each regressed keypoint.
       * </pre>
       *
       * <code>optional float candidate_search_scale = 15 [default = 0.3];</code>
       * @return Whether the candidateSearchScale field is set.
       */
      boolean hasCandidateSearchScale();
      /**
       * <pre>
       * The scale parameter that multiplies the largest dimension of a bounding
       * box. The resulting distance becomes a search radius for candidates in the
       * vicinity of each regressed keypoint.
       * </pre>
       *
       * <code>optional float candidate_search_scale = 15 [default = 0.3];</code>
       * @return The candidateSearchScale.
       */
      float getCandidateSearchScale();

      /**
       * <pre>
       * One of ['min_distance', 'score_distance_ratio'] indicating how to select
       * the keypoint candidate.
       * </pre>
       *
       * <code>optional string candidate_ranking_mode = 16 [default = "min_distance"];</code>
       * @return Whether the candidateRankingMode field is set.
       */
      boolean hasCandidateRankingMode();
      /**
       * <pre>
       * One of ['min_distance', 'score_distance_ratio'] indicating how to select
       * the keypoint candidate.
       * </pre>
       *
       * <code>optional string candidate_ranking_mode = 16 [default = "min_distance"];</code>
       * @return The candidateRankingMode.
       */
      java.lang.String getCandidateRankingMode();
      /**
       * <pre>
       * One of ['min_distance', 'score_distance_ratio'] indicating how to select
       * the keypoint candidate.
       * </pre>
       *
       * <code>optional string candidate_ranking_mode = 16 [default = "min_distance"];</code>
       * @return The bytes for candidateRankingMode.
       */
      com.google.protobuf.ByteString
          getCandidateRankingModeBytes();

      /**
       * <pre>
       * The radius (in the unit of output pixel) around heatmap peak to assign
       * the offset targets. If set 0, then the offset target will only be
       * assigned to the heatmap peak (same behavior as the original paper).
       * </pre>
       *
       * <code>optional int32 offset_peak_radius = 17 [default = 0];</code>
       * @return Whether the offsetPeakRadius field is set.
       */
      boolean hasOffsetPeakRadius();
      /**
       * <pre>
       * The radius (in the unit of output pixel) around heatmap peak to assign
       * the offset targets. If set 0, then the offset target will only be
       * assigned to the heatmap peak (same behavior as the original paper).
       * </pre>
       *
       * <code>optional int32 offset_peak_radius = 17 [default = 0];</code>
       * @return The offsetPeakRadius.
       */
      int getOffsetPeakRadius();

      /**
       * <pre>
       * Indicates whether to assign offsets for each keypoint channel
       * separately. If set False, the output offset target has the shape
       * [batch_size, out_height, out_width, 2] (same behavior as the original
       * paper). If set True, the output offset target has the shape [batch_size,
       * out_height, out_width, 2 * num_keypoints] (recommended when the
       * offset_peak_radius is not zero).
       * </pre>
       *
       * <code>optional bool per_keypoint_offset = 18 [default = false];</code>
       * @return Whether the perKeypointOffset field is set.
       */
      boolean hasPerKeypointOffset();
      /**
       * <pre>
       * Indicates whether to assign offsets for each keypoint channel
       * separately. If set False, the output offset target has the shape
       * [batch_size, out_height, out_width, 2] (same behavior as the original
       * paper). If set True, the output offset target has the shape [batch_size,
       * out_height, out_width, 2 * num_keypoints] (recommended when the
       * offset_peak_radius is not zero).
       * </pre>
       *
       * <code>optional bool per_keypoint_offset = 18 [default = false];</code>
       * @return The perKeypointOffset.
       */
      boolean getPerKeypointOffset();
    }
    /**
     * <pre>
     * Parameters which are related to keypoint estimation task.
     * </pre>
     *
     * Protobuf type {@code object_detection.protos.CenterNet.KeypointEstimation}
     */
    public static final class KeypointEstimation extends
        com.google.protobuf.GeneratedMessageV3 implements
        // @@protoc_insertion_point(message_implements:object_detection.protos.CenterNet.KeypointEstimation)
        KeypointEstimationOrBuilder {
    private static final long serialVersionUID = 0L;
      // Use KeypointEstimation.newBuilder() to construct.
      private KeypointEstimation(com.google.protobuf.GeneratedMessageV3.Builder<?> builder) {
        super(builder);
      }
      private KeypointEstimation() {
        taskName_ = "";
        taskLossWeight_ = 1F;
        keypointClassName_ = "";
        keypointRegressionLossWeight_ = 1F;
        keypointHeatmapLossWeight_ = 1F;
        keypointOffsetLossWeight_ = 1F;
        heatmapBiasInit_ = -2.19F;
        keypointCandidateScoreThreshold_ = 0.1F;
        numCandidatesPerKeypoint_ = 100;
        peakMaxPoolKernelSize_ = 3;
        unmatchedKeypointScore_ = 0.1F;
        boxScale_ = 1.2F;
        candidateSearchScale_ = 0.3F;
        candidateRankingMode_ = "min_distance";
      }

      @java.lang.Override
      @SuppressWarnings({"unused"})
      protected java.lang.Object newInstance(
          UnusedPrivateParameter unused) {
        return new KeypointEstimation();
      }

      @java.lang.Override
      public final com.google.protobuf.UnknownFieldSet
      getUnknownFields() {
        return this.unknownFields;
      }
      private KeypointEstimation(
          com.google.protobuf.CodedInputStream input,
          com.google.protobuf.ExtensionRegistryLite extensionRegistry)
          throws com.google.protobuf.InvalidProtocolBufferException {
        this();
        if (extensionRegistry == null) {
          throw new java.lang.NullPointerException();
        }
        int mutable_bitField0_ = 0;
        com.google.protobuf.UnknownFieldSet.Builder unknownFields =
            com.google.protobuf.UnknownFieldSet.newBuilder();
        try {
          boolean done = false;
          while (!done) {
            int tag = input.readTag();
            switch (tag) {
              case 0:
                done = true;
                break;
              case 10: {
                com.google.protobuf.ByteString bs = input.readBytes();
                bitField0_ |= 0x00000001;
                taskName_ = bs;
                break;
              }
              case 21: {
                bitField0_ |= 0x00000002;
                taskLossWeight_ = input.readFloat();
                break;
              }
              case 26: {
                object_detection.protos.Losses.Loss.Builder subBuilder = null;
                if (((bitField0_ & 0x00000004) != 0)) {
                  subBuilder = loss_.toBuilder();
                }
                loss_ = input.readMessage(object_detection.protos.Losses.Loss.PARSER, extensionRegistry);
                if (subBuilder != null) {
                  subBuilder.mergeFrom(loss_);
                  loss_ = subBuilder.buildPartial();
                }
                bitField0_ |= 0x00000004;
                break;
              }
              case 34: {
                com.google.protobuf.ByteString bs = input.readBytes();
                bitField0_ |= 0x00000008;
                keypointClassName_ = bs;
                break;
              }
              case 42: {
                if (!((mutable_bitField0_ & 0x00000010) != 0)) {
                  keypointLabelToStd_ = com.google.protobuf.MapField.newMapField(
                      KeypointLabelToStdDefaultEntryHolder.defaultEntry);
                  mutable_bitField0_ |= 0x00000010;
                }
                com.google.protobuf.MapEntry<java.lang.String, java.lang.Float>
                keypointLabelToStd__ = input.readMessage(
                    KeypointLabelToStdDefaultEntryHolder.defaultEntry.getParserForType(), extensionRegistry);
                keypointLabelToStd_.getMutableMap().put(
                    keypointLabelToStd__.getKey(), keypointLabelToStd__.getValue());
                break;
              }
              case 53: {
                bitField0_ |= 0x00000010;
                keypointRegressionLossWeight_ = input.readFloat();
                break;
              }
              case 61: {
                bitField0_ |= 0x00000020;
                keypointHeatmapLossWeight_ = input.readFloat();
                break;
              }
              case 69: {
                bitField0_ |= 0x00000040;
                keypointOffsetLossWeight_ = input.readFloat();
                break;
              }
              case 77: {
                bitField0_ |= 0x00000080;
                heatmapBiasInit_ = input.readFloat();
                break;
              }
              case 85: {
                bitField0_ |= 0x00000100;
                keypointCandidateScoreThreshold_ = input.readFloat();
                break;
              }
              case 88: {
                bitField0_ |= 0x00000200;
                numCandidatesPerKeypoint_ = input.readInt32();
                break;
              }
              case 96: {
                bitField0_ |= 0x00000400;
                peakMaxPoolKernelSize_ = input.readInt32();
                break;
              }
              case 109: {
                bitField0_ |= 0x00000800;
                unmatchedKeypointScore_ = input.readFloat();
                break;
              }
              case 117: {
                bitField0_ |= 0x00001000;
                boxScale_ = input.readFloat();
                break;
              }
              case 125: {
                bitField0_ |= 0x00002000;
                candidateSearchScale_ = input.readFloat();
                break;
              }
              case 130: {
                com.google.protobuf.ByteString bs = input.readBytes();
                bitField0_ |= 0x00004000;
                candidateRankingMode_ = bs;
                break;
              }
              case 136: {
                bitField0_ |= 0x00008000;
                offsetPeakRadius_ = input.readInt32();
                break;
              }
              case 144: {
                bitField0_ |= 0x00010000;
                perKeypointOffset_ = input.readBool();
                break;
              }
              default: {
                if (!parseUnknownField(
                    input, unknownFields, extensionRegistry, tag)) {
                  done = true;
                }
                break;
              }
            }
          }
        } catch (com.google.protobuf.InvalidProtocolBufferException e) {
          throw e.setUnfinishedMessage(this);
        } catch (java.io.IOException e) {
          throw new com.google.protobuf.InvalidProtocolBufferException(
              e).setUnfinishedMessage(this);
        } finally {
          this.unknownFields = unknownFields.build();
          makeExtensionsImmutable();
        }
      }
      public static final com.google.protobuf.Descriptors.Descriptor
          getDescriptor() {
        return object_detection.protos.CenterNetOuterClass.internal_static_object_detection_protos_CenterNet_KeypointEstimation_descriptor;
      }

      @SuppressWarnings({"rawtypes"})
      @java.lang.Override
      protected com.google.protobuf.MapField internalGetMapField(
          int number) {
        switch (number) {
          case 5:
            return internalGetKeypointLabelToStd();
          default:
            throw new RuntimeException(
                "Invalid map field number: " + number);
        }
      }
      @java.lang.Override
      protected com.google.protobuf.GeneratedMessageV3.FieldAccessorTable
          internalGetFieldAccessorTable() {
        return object_detection.protos.CenterNetOuterClass.internal_static_object_detection_protos_CenterNet_KeypointEstimation_fieldAccessorTable
            .ensureFieldAccessorsInitialized(
                object_detection.protos.CenterNetOuterClass.CenterNet.KeypointEstimation.class, object_detection.protos.CenterNetOuterClass.CenterNet.KeypointEstimation.Builder.class);
      }

      private int bitField0_;
      public static final int TASK_NAME_FIELD_NUMBER = 1;
      private volatile java.lang.Object taskName_;
      /**
       * <pre>
       * Name of the task, e.g. "human pose". Note that the task name should be
       * unique to each keypoint task.
       * </pre>
       *
       * <code>optional string task_name = 1;</code>
       * @return Whether the taskName field is set.
       */
      @java.lang.Override
      public boolean hasTaskName() {
        return ((bitField0_ & 0x00000001) != 0);
      }
      /**
       * <pre>
       * Name of the task, e.g. "human pose". Note that the task name should be
       * unique to each keypoint task.
       * </pre>
       *
       * <code>optional string task_name = 1;</code>
       * @return The taskName.
       */
      @java.lang.Override
      public java.lang.String getTaskName() {
        java.lang.Object ref = taskName_;
        if (ref instanceof java.lang.String) {
          return (java.lang.String) ref;
        } else {
          com.google.protobuf.ByteString bs =
              (com.google.protobuf.ByteString) ref;
          java.lang.String s = bs.toStringUtf8();
          if (bs.isValidUtf8()) {
            taskName_ = s;
          }
          return s;
        }
      }
      /**
       * <pre>
       * Name of the task, e.g. "human pose". Note that the task name should be
       * unique to each keypoint task.
       * </pre>
       *
       * <code>optional string task_name = 1;</code>
       * @return The bytes for taskName.
       */
      @java.lang.Override
      public com.google.protobuf.ByteString
          getTaskNameBytes() {
        java.lang.Object ref = taskName_;
        if (ref instanceof java.lang.String) {
          com.google.protobuf.ByteString b =
              com.google.protobuf.ByteString.copyFromUtf8(
                  (java.lang.String) ref);
          taskName_ = b;
          return b;
        } else {
          return (com.google.protobuf.ByteString) ref;
        }
      }

      public static final int TASK_LOSS_WEIGHT_FIELD_NUMBER = 2;
      private float taskLossWeight_;
      /**
       * <pre>
       * Weight of the task loss. The total loss of the model will be their
       * summation of task losses weighted by the weights.
       * </pre>
       *
       * <code>optional float task_loss_weight = 2 [default = 1];</code>
       * @return Whether the taskLossWeight field is set.
       */
      @java.lang.Override
      public boolean hasTaskLossWeight() {
        return ((bitField0_ & 0x00000002) != 0);
      }
      /**
       * <pre>
       * Weight of the task loss. The total loss of the model will be their
       * summation of task losses weighted by the weights.
       * </pre>
       *
       * <code>optional float task_loss_weight = 2 [default = 1];</code>
       * @return The taskLossWeight.
       */
      @java.lang.Override
      public float getTaskLossWeight() {
        return taskLossWeight_;
      }

      public static final int LOSS_FIELD_NUMBER = 3;
      private object_detection.protos.Losses.Loss loss_;
      /**
       * <pre>
       * Loss configuration for keypoint heatmap, offset, regression losses. Note
       * that the localization loss is used for offset/regression losses and
       * classification loss is used for heatmap loss.
       * </pre>
       *
       * <code>optional .object_detection.protos.Loss loss = 3;</code>
       * @return Whether the loss field is set.
       */
      @java.lang.Override
      public boolean hasLoss() {
        return ((bitField0_ & 0x00000004) != 0);
      }
      /**
       * <pre>
       * Loss configuration for keypoint heatmap, offset, regression losses. Note
       * that the localization loss is used for offset/regression losses and
       * classification loss is used for heatmap loss.
       * </pre>
       *
       * <code>optional .object_detection.protos.Loss loss = 3;</code>
       * @return The loss.
       */
      @java.lang.Override
      public object_detection.protos.Losses.Loss getLoss() {
        return loss_ == null ? object_detection.protos.Losses.Loss.getDefaultInstance() : loss_;
      }
      /**
       * <pre>
       * Loss configuration for keypoint heatmap, offset, regression losses. Note
       * that the localization loss is used for offset/regression losses and
       * classification loss is used for heatmap loss.
       * </pre>
       *
       * <code>optional .object_detection.protos.Loss loss = 3;</code>
       */
      @java.lang.Override
      public object_detection.protos.Losses.LossOrBuilder getLossOrBuilder() {
        return loss_ == null ? object_detection.protos.Losses.Loss.getDefaultInstance() : loss_;
      }

      public static final int KEYPOINT_CLASS_NAME_FIELD_NUMBER = 4;
      private volatile java.lang.Object keypointClassName_;
      /**
       * <pre>
       * The name of the class that contains the keypoints for this task. This is
       * used to retrieve the corresponding keypoint indices from the label map.
       * Note that this corresponds to the "name" field, not "display_name".
       * </pre>
       *
       * <code>optional string keypoint_class_name = 4;</code>
       * @return Whether the keypointClassName field is set.
       */
      @java.lang.Override
      public boolean hasKeypointClassName() {
        return ((bitField0_ & 0x00000008) != 0);
      }
      /**
       * <pre>
       * The name of the class that contains the keypoints for this task. This is
       * used to retrieve the corresponding keypoint indices from the label map.
       * Note that this corresponds to the "name" field, not "display_name".
       * </pre>
       *
       * <code>optional string keypoint_class_name = 4;</code>
       * @return The keypointClassName.
       */
      @java.lang.Override
      public java.lang.String getKeypointClassName() {
        java.lang.Object ref = keypointClassName_;
        if (ref instanceof java.lang.String) {
          return (java.lang.String) ref;
        } else {
          com.google.protobuf.ByteString bs =
              (com.google.protobuf.ByteString) ref;
          java.lang.String s = bs.toStringUtf8();
          if (bs.isValidUtf8()) {
            keypointClassName_ = s;
          }
          return s;
        }
      }
      /**
       * <pre>
       * The name of the class that contains the keypoints for this task. This is
       * used to retrieve the corresponding keypoint indices from the label map.
       * Note that this corresponds to the "name" field, not "display_name".
       * </pre>
       *
       * <code>optional string keypoint_class_name = 4;</code>
       * @return The bytes for keypointClassName.
       */
      @java.lang.Override
      public com.google.protobuf.ByteString
          getKeypointClassNameBytes() {
        java.lang.Object ref = keypointClassName_;
        if (ref instanceof java.lang.String) {
          com.google.protobuf.ByteString b =
              com.google.protobuf.ByteString.copyFromUtf8(
                  (java.lang.String) ref);
          keypointClassName_ = b;
          return b;
        } else {
          return (com.google.protobuf.ByteString) ref;
        }
      }

      public static final int KEYPOINT_LABEL_TO_STD_FIELD_NUMBER = 5;
      private static final class KeypointLabelToStdDefaultEntryHolder {
        static final com.google.protobuf.MapEntry<
            java.lang.String, java.lang.Float> defaultEntry =
                com.google.protobuf.MapEntry
                .<java.lang.String, java.lang.Float>newDefaultInstance(
                    object_detection.protos.CenterNetOuterClass.internal_static_object_detection_protos_CenterNet_KeypointEstimation_KeypointLabelToStdEntry_descriptor,
                    com.google.protobuf.WireFormat.FieldType.STRING,
                    "",
                    com.google.protobuf.WireFormat.FieldType.FLOAT,
                    0F);
      }
      private com.google.protobuf.MapField<
          java.lang.String, java.lang.Float> keypointLabelToStd_;
      private com.google.protobuf.MapField<java.lang.String, java.lang.Float>
      internalGetKeypointLabelToStd() {
        if (keypointLabelToStd_ == null) {
          return com.google.protobuf.MapField.emptyMapField(
              KeypointLabelToStdDefaultEntryHolder.defaultEntry);
        }
        return keypointLabelToStd_;
      }

      public int getKeypointLabelToStdCount() {
        return internalGetKeypointLabelToStd().getMap().size();
      }
      /**
       * <pre>
       * The standard deviation of the Gaussian kernel used to generate the
       * keypoint heatmap. The unit is the pixel in the output image. It is to
       * provide the flexibility of using different sizes of Gaussian kernel for
       * each keypoint class. Note that if provided, the keypoint standard
       * deviations will be overridden by the specified values here, otherwise,
       * the default value 5.0 will be used.
       * TODO(yuhuic): Update the default value once we found the best value.
       * </pre>
       *
       * <code>map&lt;string, float&gt; keypoint_label_to_std = 5;</code>
       */

      @java.lang.Override
      public boolean containsKeypointLabelToStd(
          java.lang.String key) {
        if (key == null) { throw new java.lang.NullPointerException(); }
        return internalGetKeypointLabelToStd().getMap().containsKey(key);
      }
      /**
       * Use {@link #getKeypointLabelToStdMap()} instead.
       */
      @java.lang.Override
      @java.lang.Deprecated
      public java.util.Map<java.lang.String, java.lang.Float> getKeypointLabelToStd() {
        return getKeypointLabelToStdMap();
      }
      /**
       * <pre>
       * The standard deviation of the Gaussian kernel used to generate the
       * keypoint heatmap. The unit is the pixel in the output image. It is to
       * provide the flexibility of using different sizes of Gaussian kernel for
       * each keypoint class. Note that if provided, the keypoint standard
       * deviations will be overridden by the specified values here, otherwise,
       * the default value 5.0 will be used.
       * TODO(yuhuic): Update the default value once we found the best value.
       * </pre>
       *
       * <code>map&lt;string, float&gt; keypoint_label_to_std = 5;</code>
       */
      @java.lang.Override

      public java.util.Map<java.lang.String, java.lang.Float> getKeypointLabelToStdMap() {
        return internalGetKeypointLabelToStd().getMap();
      }
      /**
       * <pre>
       * The standard deviation of the Gaussian kernel used to generate the
       * keypoint heatmap. The unit is the pixel in the output image. It is to
       * provide the flexibility of using different sizes of Gaussian kernel for
       * each keypoint class. Note that if provided, the keypoint standard
       * deviations will be overridden by the specified values here, otherwise,
       * the default value 5.0 will be used.
       * TODO(yuhuic): Update the default value once we found the best value.
       * </pre>
       *
       * <code>map&lt;string, float&gt; keypoint_label_to_std = 5;</code>
       */
      @java.lang.Override

      public float getKeypointLabelToStdOrDefault(
          java.lang.String key,
          float defaultValue) {
        if (key == null) { throw new java.lang.NullPointerException(); }
        java.util.Map<java.lang.String, java.lang.Float> map =
            internalGetKeypointLabelToStd().getMap();
        return map.containsKey(key) ? map.get(key) : defaultValue;
      }
      /**
       * <pre>
       * The standard deviation of the Gaussian kernel used to generate the
       * keypoint heatmap. The unit is the pixel in the output image. It is to
       * provide the flexibility of using different sizes of Gaussian kernel for
       * each keypoint class. Note that if provided, the keypoint standard
       * deviations will be overridden by the specified values here, otherwise,
       * the default value 5.0 will be used.
       * TODO(yuhuic): Update the default value once we found the best value.
       * </pre>
       *
       * <code>map&lt;string, float&gt; keypoint_label_to_std = 5;</code>
       */
      @java.lang.Override

      public float getKeypointLabelToStdOrThrow(
          java.lang.String key) {
        if (key == null) { throw new java.lang.NullPointerException(); }
        java.util.Map<java.lang.String, java.lang.Float> map =
            internalGetKeypointLabelToStd().getMap();
        if (!map.containsKey(key)) {
          throw new java.lang.IllegalArgumentException();
        }
        return map.get(key);
      }

      public static final int KEYPOINT_REGRESSION_LOSS_WEIGHT_FIELD_NUMBER = 6;
      private float keypointRegressionLossWeight_;
      /**
       * <pre>
       * Loss weights corresponding to different heads.
       * </pre>
       *
       * <code>optional float keypoint_regression_loss_weight = 6 [default = 1];</code>
       * @return Whether the keypointRegressionLossWeight field is set.
       */
      @java.lang.Override
      public boolean hasKeypointRegressionLossWeight() {
        return ((bitField0_ & 0x00000010) != 0);
      }
      /**
       * <pre>
       * Loss weights corresponding to different heads.
       * </pre>
       *
       * <code>optional float keypoint_regression_loss_weight = 6 [default = 1];</code>
       * @return The keypointRegressionLossWeight.
       */
      @java.lang.Override
      public float getKeypointRegressionLossWeight() {
        return keypointRegressionLossWeight_;
      }

      public static final int KEYPOINT_HEATMAP_LOSS_WEIGHT_FIELD_NUMBER = 7;
      private float keypointHeatmapLossWeight_;
      /**
       * <code>optional float keypoint_heatmap_loss_weight = 7 [default = 1];</code>
       * @return Whether the keypointHeatmapLossWeight field is set.
       */
      @java.lang.Override
      public boolean hasKeypointHeatmapLossWeight() {
        return ((bitField0_ & 0x00000020) != 0);
      }
      /**
       * <code>optional float keypoint_heatmap_loss_weight = 7 [default = 1];</code>
       * @return The keypointHeatmapLossWeight.
       */
      @java.lang.Override
      public float getKeypointHeatmapLossWeight() {
        return keypointHeatmapLossWeight_;
      }

      public static final int KEYPOINT_OFFSET_LOSS_WEIGHT_FIELD_NUMBER = 8;
      private float keypointOffsetLossWeight_;
      /**
       * <code>optional float keypoint_offset_loss_weight = 8 [default = 1];</code>
       * @return Whether the keypointOffsetLossWeight field is set.
       */
      @java.lang.Override
      public boolean hasKeypointOffsetLossWeight() {
        return ((bitField0_ & 0x00000040) != 0);
      }
      /**
       * <code>optional float keypoint_offset_loss_weight = 8 [default = 1];</code>
       * @return The keypointOffsetLossWeight.
       */
      @java.lang.Override
      public float getKeypointOffsetLossWeight() {
        return keypointOffsetLossWeight_;
      }

      public static final int HEATMAP_BIAS_INIT_FIELD_NUMBER = 9;
      private float heatmapBiasInit_;
      /**
       * <pre>
       * The initial bias value of the convolution kernel of the keypoint heatmap
       * prediction head. -2.19 corresponds to predicting foreground with
       * a probability of 0.1. See "Focal Loss for Dense Object Detection"
       * at https://arxiv.org/abs/1708.02002.
       * </pre>
       *
       * <code>optional float heatmap_bias_init = 9 [default = -2.19];</code>
       * @return Whether the heatmapBiasInit field is set.
       */
      @java.lang.Override
      public boolean hasHeatmapBiasInit() {
        return ((bitField0_ & 0x00000080) != 0);
      }
      /**
       * <pre>
       * The initial bias value of the convolution kernel of the keypoint heatmap
       * prediction head. -2.19 corresponds to predicting foreground with
       * a probability of 0.1. See "Focal Loss for Dense Object Detection"
       * at https://arxiv.org/abs/1708.02002.
       * </pre>
       *
       * <code>optional float heatmap_bias_init = 9 [default = -2.19];</code>
       * @return The heatmapBiasInit.
       */
      @java.lang.Override
      public float getHeatmapBiasInit() {
        return heatmapBiasInit_;
      }

      public static final int KEYPOINT_CANDIDATE_SCORE_THRESHOLD_FIELD_NUMBER = 10;
      private float keypointCandidateScoreThreshold_;
      /**
       * <pre>
       * The heatmap score threshold for a keypoint to become a valid candidate.
       * </pre>
       *
       * <code>optional float keypoint_candidate_score_threshold = 10 [default = 0.1];</code>
       * @return Whether the keypointCandidateScoreThreshold field is set.
       */
      @java.lang.Override
      public boolean hasKeypointCandidateScoreThreshold() {
        return ((bitField0_ & 0x00000100) != 0);
      }
      /**
       * <pre>
       * The heatmap score threshold for a keypoint to become a valid candidate.
       * </pre>
       *
       * <code>optional float keypoint_candidate_score_threshold = 10 [default = 0.1];</code>
       * @return The keypointCandidateScoreThreshold.
       */
      @java.lang.Override
      public float getKeypointCandidateScoreThreshold() {
        return keypointCandidateScoreThreshold_;
      }

      public static final int NUM_CANDIDATES_PER_KEYPOINT_FIELD_NUMBER = 11;
      private int numCandidatesPerKeypoint_;
      /**
       * <pre>
       * The maximum number of candidates to retrieve for each keypoint.
       * </pre>
       *
       * <code>optional int32 num_candidates_per_keypoint = 11 [default = 100];</code>
       * @return Whether the numCandidatesPerKeypoint field is set.
       */
      @java.lang.Override
      public boolean hasNumCandidatesPerKeypoint() {
        return ((bitField0_ & 0x00000200) != 0);
      }
      /**
       * <pre>
       * The maximum number of candidates to retrieve for each keypoint.
       * </pre>
       *
       * <code>optional int32 num_candidates_per_keypoint = 11 [default = 100];</code>
       * @return The numCandidatesPerKeypoint.
       */
      @java.lang.Override
      public int getNumCandidatesPerKeypoint() {
        return numCandidatesPerKeypoint_;
      }

      public static final int PEAK_MAX_POOL_KERNEL_SIZE_FIELD_NUMBER = 12;
      private int peakMaxPoolKernelSize_;
      /**
       * <pre>
       * Max pool kernel size to use to pull off peak score locations in a
       * neighborhood (independently for each keypoint types).
       * </pre>
       *
       * <code>optional int32 peak_max_pool_kernel_size = 12 [default = 3];</code>
       * @return Whether the peakMaxPoolKernelSize field is set.
       */
      @java.lang.Override
      public boolean hasPeakMaxPoolKernelSize() {
        return ((bitField0_ & 0x00000400) != 0);
      }
      /**
       * <pre>
       * Max pool kernel size to use to pull off peak score locations in a
       * neighborhood (independently for each keypoint types).
       * </pre>
       *
       * <code>optional int32 peak_max_pool_kernel_size = 12 [default = 3];</code>
       * @return The peakMaxPoolKernelSize.
       */
      @java.lang.Override
      public int getPeakMaxPoolKernelSize() {
        return peakMaxPoolKernelSize_;
      }

      public static final int UNMATCHED_KEYPOINT_SCORE_FIELD_NUMBER = 13;
      private float unmatchedKeypointScore_;
      /**
       * <pre>
       * The default score to use for regressed keypoints that are not
       * successfully snapped to a nearby candidate.
       * </pre>
       *
       * <code>optional float unmatched_keypoint_score = 13 [default = 0.1];</code>
       * @return Whether the unmatchedKeypointScore field is set.
       */
      @java.lang.Override
      public boolean hasUnmatchedKeypointScore() {
        return ((bitField0_ & 0x00000800) != 0);
      }
      /**
       * <pre>
       * The default score to use for regressed keypoints that are not
       * successfully snapped to a nearby candidate.
       * </pre>
       *
       * <code>optional float unmatched_keypoint_score = 13 [default = 0.1];</code>
       * @return The unmatchedKeypointScore.
       */
      @java.lang.Override
      public float getUnmatchedKeypointScore() {
        return unmatchedKeypointScore_;
      }

      public static final int BOX_SCALE_FIELD_NUMBER = 14;
      private float boxScale_;
      /**
       * <pre>
       * The multiplier to expand the bounding boxes (either the provided boxes or
       * those which tightly cover the regressed keypoints). Note that new
       * expanded box for an instance becomes the feasible search window for all
       * associated keypoints.
       * </pre>
       *
       * <code>optional float box_scale = 14 [default = 1.2];</code>
       * @return Whether the boxScale field is set.
       */
      @java.lang.Override
      public boolean hasBoxScale() {
        return ((bitField0_ & 0x00001000) != 0);
      }
      /**
       * <pre>
       * The multiplier to expand the bounding boxes (either the provided boxes or
       * those which tightly cover the regressed keypoints). Note that new
       * expanded box for an instance becomes the feasible search window for all
       * associated keypoints.
       * </pre>
       *
       * <code>optional float box_scale = 14 [default = 1.2];</code>
       * @return The boxScale.
       */
      @java.lang.Override
      public float getBoxScale() {
        return boxScale_;
      }

      public static final int CANDIDATE_SEARCH_SCALE_FIELD_NUMBER = 15;
      private float candidateSearchScale_;
      /**
       * <pre>
       * The scale parameter that multiplies the largest dimension of a bounding
       * box. The resulting distance becomes a search radius for candidates in the
       * vicinity of each regressed keypoint.
       * </pre>
       *
       * <code>optional float candidate_search_scale = 15 [default = 0.3];</code>
       * @return Whether the candidateSearchScale field is set.
       */
      @java.lang.Override
      public boolean hasCandidateSearchScale() {
        return ((bitField0_ & 0x00002000) != 0);
      }
      /**
       * <pre>
       * The scale parameter that multiplies the largest dimension of a bounding
       * box. The resulting distance becomes a search radius for candidates in the
       * vicinity of each regressed keypoint.
       * </pre>
       *
       * <code>optional float candidate_search_scale = 15 [default = 0.3];</code>
       * @return The candidateSearchScale.
       */
      @java.lang.Override
      public float getCandidateSearchScale() {
        return candidateSearchScale_;
      }

      public static final int CANDIDATE_RANKING_MODE_FIELD_NUMBER = 16;
      private volatile java.lang.Object candidateRankingMode_;
      /**
       * <pre>
       * One of ['min_distance', 'score_distance_ratio'] indicating how to select
       * the keypoint candidate.
       * </pre>
       *
       * <code>optional string candidate_ranking_mode = 16 [default = "min_distance"];</code>
       * @return Whether the candidateRankingMode field is set.
       */
      @java.lang.Override
      public boolean hasCandidateRankingMode() {
        return ((bitField0_ & 0x00004000) != 0);
      }
      /**
       * <pre>
       * One of ['min_distance', 'score_distance_ratio'] indicating how to select
       * the keypoint candidate.
       * </pre>
       *
       * <code>optional string candidate_ranking_mode = 16 [default = "min_distance"];</code>
       * @return The candidateRankingMode.
       */
      @java.lang.Override
      public java.lang.String getCandidateRankingMode() {
        java.lang.Object ref = candidateRankingMode_;
        if (ref instanceof java.lang.String) {
          return (java.lang.String) ref;
        } else {
          com.google.protobuf.ByteString bs =
              (com.google.protobuf.ByteString) ref;
          java.lang.String s = bs.toStringUtf8();
          if (bs.isValidUtf8()) {
            candidateRankingMode_ = s;
          }
          return s;
        }
      }
      /**
       * <pre>
       * One of ['min_distance', 'score_distance_ratio'] indicating how to select
       * the keypoint candidate.
       * </pre>
       *
       * <code>optional string candidate_ranking_mode = 16 [default = "min_distance"];</code>
       * @return The bytes for candidateRankingMode.
       */
      @java.lang.Override
      public com.google.protobuf.ByteString
          getCandidateRankingModeBytes() {
        java.lang.Object ref = candidateRankingMode_;
        if (ref instanceof java.lang.String) {
          com.google.protobuf.ByteString b =
              com.google.protobuf.ByteString.copyFromUtf8(
                  (java.lang.String) ref);
          candidateRankingMode_ = b;
          return b;
        } else {
          return (com.google.protobuf.ByteString) ref;
        }
      }

      public static final int OFFSET_PEAK_RADIUS_FIELD_NUMBER = 17;
      private int offsetPeakRadius_;
      /**
       * <pre>
       * The radius (in the unit of output pixel) around heatmap peak to assign
       * the offset targets. If set 0, then the offset target will only be
       * assigned to the heatmap peak (same behavior as the original paper).
       * </pre>
       *
       * <code>optional int32 offset_peak_radius = 17 [default = 0];</code>
       * @return Whether the offsetPeakRadius field is set.
       */
      @java.lang.Override
      public boolean hasOffsetPeakRadius() {
        return ((bitField0_ & 0x00008000) != 0);
      }
      /**
       * <pre>
       * The radius (in the unit of output pixel) around heatmap peak to assign
       * the offset targets. If set 0, then the offset target will only be
       * assigned to the heatmap peak (same behavior as the original paper).
       * </pre>
       *
       * <code>optional int32 offset_peak_radius = 17 [default = 0];</code>
       * @return The offsetPeakRadius.
       */
      @java.lang.Override
      public int getOffsetPeakRadius() {
        return offsetPeakRadius_;
      }

      public static final int PER_KEYPOINT_OFFSET_FIELD_NUMBER = 18;
      private boolean perKeypointOffset_;
      /**
       * <pre>
       * Indicates whether to assign offsets for each keypoint channel
       * separately. If set False, the output offset target has the shape
       * [batch_size, out_height, out_width, 2] (same behavior as the original
       * paper). If set True, the output offset target has the shape [batch_size,
       * out_height, out_width, 2 * num_keypoints] (recommended when the
       * offset_peak_radius is not zero).
       * </pre>
       *
       * <code>optional bool per_keypoint_offset = 18 [default = false];</code>
       * @return Whether the perKeypointOffset field is set.
       */
      @java.lang.Override
      public boolean hasPerKeypointOffset() {
        return ((bitField0_ & 0x00010000) != 0);
      }
      /**
       * <pre>
       * Indicates whether to assign offsets for each keypoint channel
       * separately. If set False, the output offset target has the shape
       * [batch_size, out_height, out_width, 2] (same behavior as the original
       * paper). If set True, the output offset target has the shape [batch_size,
       * out_height, out_width, 2 * num_keypoints] (recommended when the
       * offset_peak_radius is not zero).
       * </pre>
       *
       * <code>optional bool per_keypoint_offset = 18 [default = false];</code>
       * @return The perKeypointOffset.
       */
      @java.lang.Override
      public boolean getPerKeypointOffset() {
        return perKeypointOffset_;
      }

      private byte memoizedIsInitialized = -1;
      @java.lang.Override
      public final boolean isInitialized() {
        byte isInitialized = memoizedIsInitialized;
        if (isInitialized == 1) return true;
        if (isInitialized == 0) return false;

        memoizedIsInitialized = 1;
        return true;
      }

      @java.lang.Override
      public void writeTo(com.google.protobuf.CodedOutputStream output)
                          throws java.io.IOException {
        if (((bitField0_ & 0x00000001) != 0)) {
          com.google.protobuf.GeneratedMessageV3.writeString(output, 1, taskName_);
        }
        if (((bitField0_ & 0x00000002) != 0)) {
          output.writeFloat(2, taskLossWeight_);
        }
        if (((bitField0_ & 0x00000004) != 0)) {
          output.writeMessage(3, getLoss());
        }
        if (((bitField0_ & 0x00000008) != 0)) {
          com.google.protobuf.GeneratedMessageV3.writeString(output, 4, keypointClassName_);
        }
        com.google.protobuf.GeneratedMessageV3
          .serializeStringMapTo(
            output,
            internalGetKeypointLabelToStd(),
            KeypointLabelToStdDefaultEntryHolder.defaultEntry,
            5);
        if (((bitField0_ & 0x00000010) != 0)) {
          output.writeFloat(6, keypointRegressionLossWeight_);
        }
        if (((bitField0_ & 0x00000020) != 0)) {
          output.writeFloat(7, keypointHeatmapLossWeight_);
        }
        if (((bitField0_ & 0x00000040) != 0)) {
          output.writeFloat(8, keypointOffsetLossWeight_);
        }
        if (((bitField0_ & 0x00000080) != 0)) {
          output.writeFloat(9, heatmapBiasInit_);
        }
        if (((bitField0_ & 0x00000100) != 0)) {
          output.writeFloat(10, keypointCandidateScoreThreshold_);
        }
        if (((bitField0_ & 0x00000200) != 0)) {
          output.writeInt32(11, numCandidatesPerKeypoint_);
        }
        if (((bitField0_ & 0x00000400) != 0)) {
          output.writeInt32(12, peakMaxPoolKernelSize_);
        }
        if (((bitField0_ & 0x00000800) != 0)) {
          output.writeFloat(13, unmatchedKeypointScore_);
        }
        if (((bitField0_ & 0x00001000) != 0)) {
          output.writeFloat(14, boxScale_);
        }
        if (((bitField0_ & 0x00002000) != 0)) {
          output.writeFloat(15, candidateSearchScale_);
        }
        if (((bitField0_ & 0x00004000) != 0)) {
          com.google.protobuf.GeneratedMessageV3.writeString(output, 16, candidateRankingMode_);
        }
        if (((bitField0_ & 0x00008000) != 0)) {
          output.writeInt32(17, offsetPeakRadius_);
        }
        if (((bitField0_ & 0x00010000) != 0)) {
          output.writeBool(18, perKeypointOffset_);
        }
        unknownFields.writeTo(output);
      }

      @java.lang.Override
      public int getSerializedSize() {
        int size = memoizedSize;
        if (size != -1) return size;

        size = 0;
        if (((bitField0_ & 0x00000001) != 0)) {
          size += com.google.protobuf.GeneratedMessageV3.computeStringSize(1, taskName_);
        }
        if (((bitField0_ & 0x00000002) != 0)) {
          size += com.google.protobuf.CodedOutputStream
            .computeFloatSize(2, taskLossWeight_);
        }
        if (((bitField0_ & 0x00000004) != 0)) {
          size += com.google.protobuf.CodedOutputStream
            .computeMessageSize(3, getLoss());
        }
        if (((bitField0_ & 0x00000008) != 0)) {
          size += com.google.protobuf.GeneratedMessageV3.computeStringSize(4, keypointClassName_);
        }
        for (java.util.Map.Entry<java.lang.String, java.lang.Float> entry
             : internalGetKeypointLabelToStd().getMap().entrySet()) {
          com.google.protobuf.MapEntry<java.lang.String, java.lang.Float>
          keypointLabelToStd__ = KeypointLabelToStdDefaultEntryHolder.defaultEntry.newBuilderForType()
              .setKey(entry.getKey())
              .setValue(entry.getValue())
              .build();
          size += com.google.protobuf.CodedOutputStream
              .computeMessageSize(5, keypointLabelToStd__);
        }
        if (((bitField0_ & 0x00000010) != 0)) {
          size += com.google.protobuf.CodedOutputStream
            .computeFloatSize(6, keypointRegressionLossWeight_);
        }
        if (((bitField0_ & 0x00000020) != 0)) {
          size += com.google.protobuf.CodedOutputStream
            .computeFloatSize(7, keypointHeatmapLossWeight_);
        }
        if (((bitField0_ & 0x00000040) != 0)) {
          size += com.google.protobuf.CodedOutputStream
            .computeFloatSize(8, keypointOffsetLossWeight_);
        }
        if (((bitField0_ & 0x00000080) != 0)) {
          size += com.google.protobuf.CodedOutputStream
            .computeFloatSize(9, heatmapBiasInit_);
        }
        if (((bitField0_ & 0x00000100) != 0)) {
          size += com.google.protobuf.CodedOutputStream
            .computeFloatSize(10, keypointCandidateScoreThreshold_);
        }
        if (((bitField0_ & 0x00000200) != 0)) {
          size += com.google.protobuf.CodedOutputStream
            .computeInt32Size(11, numCandidatesPerKeypoint_);
        }
        if (((bitField0_ & 0x00000400) != 0)) {
          size += com.google.protobuf.CodedOutputStream
            .computeInt32Size(12, peakMaxPoolKernelSize_);
        }
        if (((bitField0_ & 0x00000800) != 0)) {
          size += com.google.protobuf.CodedOutputStream
            .computeFloatSize(13, unmatchedKeypointScore_);
        }
        if (((bitField0_ & 0x00001000) != 0)) {
          size += com.google.protobuf.CodedOutputStream
            .computeFloatSize(14, boxScale_);
        }
        if (((bitField0_ & 0x00002000) != 0)) {
          size += com.google.protobuf.CodedOutputStream
            .computeFloatSize(15, candidateSearchScale_);
        }
        if (((bitField0_ & 0x00004000) != 0)) {
          size += com.google.protobuf.GeneratedMessageV3.computeStringSize(16, candidateRankingMode_);
        }
        if (((bitField0_ & 0x00008000) != 0)) {
          size += com.google.protobuf.CodedOutputStream
            .computeInt32Size(17, offsetPeakRadius_);
        }
        if (((bitField0_ & 0x00010000) != 0)) {
          size += com.google.protobuf.CodedOutputStream
            .computeBoolSize(18, perKeypointOffset_);
        }
        size += unknownFields.getSerializedSize();
        memoizedSize = size;
        return size;
      }

      @java.lang.Override
      public boolean equals(final java.lang.Object obj) {
        if (obj == this) {
         return true;
        }
        if (!(obj instanceof object_detection.protos.CenterNetOuterClass.CenterNet.KeypointEstimation)) {
          return super.equals(obj);
        }
        object_detection.protos.CenterNetOuterClass.CenterNet.KeypointEstimation other = (object_detection.protos.CenterNetOuterClass.CenterNet.KeypointEstimation) obj;

        if (hasTaskName() != other.hasTaskName()) return false;
        if (hasTaskName()) {
          if (!getTaskName()
              .equals(other.getTaskName())) return false;
        }
        if (hasTaskLossWeight() != other.hasTaskLossWeight()) return false;
        if (hasTaskLossWeight()) {
          if (java.lang.Float.floatToIntBits(getTaskLossWeight())
              != java.lang.Float.floatToIntBits(
                  other.getTaskLossWeight())) return false;
        }
        if (hasLoss() != other.hasLoss()) return false;
        if (hasLoss()) {
          if (!getLoss()
              .equals(other.getLoss())) return false;
        }
        if (hasKeypointClassName() != other.hasKeypointClassName()) return false;
        if (hasKeypointClassName()) {
          if (!getKeypointClassName()
              .equals(other.getKeypointClassName())) return false;
        }
        if (!internalGetKeypointLabelToStd().equals(
            other.internalGetKeypointLabelToStd())) return false;
        if (hasKeypointRegressionLossWeight() != other.hasKeypointRegressionLossWeight()) return false;
        if (hasKeypointRegressionLossWeight()) {
          if (java.lang.Float.floatToIntBits(getKeypointRegressionLossWeight())
              != java.lang.Float.floatToIntBits(
                  other.getKeypointRegressionLossWeight())) return false;
        }
        if (hasKeypointHeatmapLossWeight() != other.hasKeypointHeatmapLossWeight()) return false;
        if (hasKeypointHeatmapLossWeight()) {
          if (java.lang.Float.floatToIntBits(getKeypointHeatmapLossWeight())
              != java.lang.Float.floatToIntBits(
                  other.getKeypointHeatmapLossWeight())) return false;
        }
        if (hasKeypointOffsetLossWeight() != other.hasKeypointOffsetLossWeight()) return false;
        if (hasKeypointOffsetLossWeight()) {
          if (java.lang.Float.floatToIntBits(getKeypointOffsetLossWeight())
              != java.lang.Float.floatToIntBits(
                  other.getKeypointOffsetLossWeight())) return false;
        }
        if (hasHeatmapBiasInit() != other.hasHeatmapBiasInit()) return false;
        if (hasHeatmapBiasInit()) {
          if (java.lang.Float.floatToIntBits(getHeatmapBiasInit())
              != java.lang.Float.floatToIntBits(
                  other.getHeatmapBiasInit())) return false;
        }
        if (hasKeypointCandidateScoreThreshold() != other.hasKeypointCandidateScoreThreshold()) return false;
        if (hasKeypointCandidateScoreThreshold()) {
          if (java.lang.Float.floatToIntBits(getKeypointCandidateScoreThreshold())
              != java.lang.Float.floatToIntBits(
                  other.getKeypointCandidateScoreThreshold())) return false;
        }
        if (hasNumCandidatesPerKeypoint() != other.hasNumCandidatesPerKeypoint()) return false;
        if (hasNumCandidatesPerKeypoint()) {
          if (getNumCandidatesPerKeypoint()
              != other.getNumCandidatesPerKeypoint()) return false;
        }
        if (hasPeakMaxPoolKernelSize() != other.hasPeakMaxPoolKernelSize()) return false;
        if (hasPeakMaxPoolKernelSize()) {
          if (getPeakMaxPoolKernelSize()
              != other.getPeakMaxPoolKernelSize()) return false;
        }
        if (hasUnmatchedKeypointScore() != other.hasUnmatchedKeypointScore()) return false;
        if (hasUnmatchedKeypointScore()) {
          if (java.lang.Float.floatToIntBits(getUnmatchedKeypointScore())
              != java.lang.Float.floatToIntBits(
                  other.getUnmatchedKeypointScore())) return false;
        }
        if (hasBoxScale() != other.hasBoxScale()) return false;
        if (hasBoxScale()) {
          if (java.lang.Float.floatToIntBits(getBoxScale())
              != java.lang.Float.floatToIntBits(
                  other.getBoxScale())) return false;
        }
        if (hasCandidateSearchScale() != other.hasCandidateSearchScale()) return false;
        if (hasCandidateSearchScale()) {
          if (java.lang.Float.floatToIntBits(getCandidateSearchScale())
              != java.lang.Float.floatToIntBits(
                  other.getCandidateSearchScale())) return false;
        }
        if (hasCandidateRankingMode() != other.hasCandidateRankingMode()) return false;
        if (hasCandidateRankingMode()) {
          if (!getCandidateRankingMode()
              .equals(other.getCandidateRankingMode())) return false;
        }
        if (hasOffsetPeakRadius() != other.hasOffsetPeakRadius()) return false;
        if (hasOffsetPeakRadius()) {
          if (getOffsetPeakRadius()
              != other.getOffsetPeakRadius()) return false;
        }
        if (hasPerKeypointOffset() != other.hasPerKeypointOffset()) return false;
        if (hasPerKeypointOffset()) {
          if (getPerKeypointOffset()
              != other.getPerKeypointOffset()) return false;
        }
        if (!unknownFields.equals(other.unknownFields)) return false;
        return true;
      }

      @java.lang.Override
      public int hashCode() {
        if (memoizedHashCode != 0) {
          return memoizedHashCode;
        }
        int hash = 41;
        hash = (19 * hash) + getDescriptor().hashCode();
        if (hasTaskName()) {
          hash = (37 * hash) + TASK_NAME_FIELD_NUMBER;
          hash = (53 * hash) + getTaskName().hashCode();
        }
        if (hasTaskLossWeight()) {
          hash = (37 * hash) + TASK_LOSS_WEIGHT_FIELD_NUMBER;
          hash = (53 * hash) + java.lang.Float.floatToIntBits(
              getTaskLossWeight());
        }
        if (hasLoss()) {
          hash = (37 * hash) + LOSS_FIELD_NUMBER;
          hash = (53 * hash) + getLoss().hashCode();
        }
        if (hasKeypointClassName()) {
          hash = (37 * hash) + KEYPOINT_CLASS_NAME_FIELD_NUMBER;
          hash = (53 * hash) + getKeypointClassName().hashCode();
        }
        if (!internalGetKeypointLabelToStd().getMap().isEmpty()) {
          hash = (37 * hash) + KEYPOINT_LABEL_TO_STD_FIELD_NUMBER;
          hash = (53 * hash) + internalGetKeypointLabelToStd().hashCode();
        }
        if (hasKeypointRegressionLossWeight()) {
          hash = (37 * hash) + KEYPOINT_REGRESSION_LOSS_WEIGHT_FIELD_NUMBER;
          hash = (53 * hash) + java.lang.Float.floatToIntBits(
              getKeypointRegressionLossWeight());
        }
        if (hasKeypointHeatmapLossWeight()) {
          hash = (37 * hash) + KEYPOINT_HEATMAP_LOSS_WEIGHT_FIELD_NUMBER;
          hash = (53 * hash) + java.lang.Float.floatToIntBits(
              getKeypointHeatmapLossWeight());
        }
        if (hasKeypointOffsetLossWeight()) {
          hash = (37 * hash) + KEYPOINT_OFFSET_LOSS_WEIGHT_FIELD_NUMBER;
          hash = (53 * hash) + java.lang.Float.floatToIntBits(
              getKeypointOffsetLossWeight());
        }
        if (hasHeatmapBiasInit()) {
          hash = (37 * hash) + HEATMAP_BIAS_INIT_FIELD_NUMBER;
          hash = (53 * hash) + java.lang.Float.floatToIntBits(
              getHeatmapBiasInit());
        }
        if (hasKeypointCandidateScoreThreshold()) {
          hash = (37 * hash) + KEYPOINT_CANDIDATE_SCORE_THRESHOLD_FIELD_NUMBER;
          hash = (53 * hash) + java.lang.Float.floatToIntBits(
              getKeypointCandidateScoreThreshold());
        }
        if (hasNumCandidatesPerKeypoint()) {
          hash = (37 * hash) + NUM_CANDIDATES_PER_KEYPOINT_FIELD_NUMBER;
          hash = (53 * hash) + getNumCandidatesPerKeypoint();
        }
        if (hasPeakMaxPoolKernelSize()) {
          hash = (37 * hash) + PEAK_MAX_POOL_KERNEL_SIZE_FIELD_NUMBER;
          hash = (53 * hash) + getPeakMaxPoolKernelSize();
        }
        if (hasUnmatchedKeypointScore()) {
          hash = (37 * hash) + UNMATCHED_KEYPOINT_SCORE_FIELD_NUMBER;
          hash = (53 * hash) + java.lang.Float.floatToIntBits(
              getUnmatchedKeypointScore());
        }
        if (hasBoxScale()) {
          hash = (37 * hash) + BOX_SCALE_FIELD_NUMBER;
          hash = (53 * hash) + java.lang.Float.floatToIntBits(
              getBoxScale());
        }
        if (hasCandidateSearchScale()) {
          hash = (37 * hash) + CANDIDATE_SEARCH_SCALE_FIELD_NUMBER;
          hash = (53 * hash) + java.lang.Float.floatToIntBits(
              getCandidateSearchScale());
        }
        if (hasCandidateRankingMode()) {
          hash = (37 * hash) + CANDIDATE_RANKING_MODE_FIELD_NUMBER;
          hash = (53 * hash) + getCandidateRankingMode().hashCode();
        }
        if (hasOffsetPeakRadius()) {
          hash = (37 * hash) + OFFSET_PEAK_RADIUS_FIELD_NUMBER;
          hash = (53 * hash) + getOffsetPeakRadius();
        }
        if (hasPerKeypointOffset()) {
          hash = (37 * hash) + PER_KEYPOINT_OFFSET_FIELD_NUMBER;
          hash = (53 * hash) + com.google.protobuf.Internal.hashBoolean(
              getPerKeypointOffset());
        }
        hash = (29 * hash) + unknownFields.hashCode();
        memoizedHashCode = hash;
        return hash;
      }

      public static object_detection.protos.CenterNetOuterClass.CenterNet.KeypointEstimation parseFrom(
          java.nio.ByteBuffer data)
          throws com.google.protobuf.InvalidProtocolBufferException {
        return PARSER.parseFrom(data);
      }
      public static object_detection.protos.CenterNetOuterClass.CenterNet.KeypointEstimation parseFrom(
          java.nio.ByteBuffer data,
          com.google.protobuf.ExtensionRegistryLite extensionRegistry)
          throws com.google.protobuf.InvalidProtocolBufferException {
        return PARSER.parseFrom(data, extensionRegistry);
      }
      public static object_detection.protos.CenterNetOuterClass.CenterNet.KeypointEstimation parseFrom(
          com.google.protobuf.ByteString data)
          throws com.google.protobuf.InvalidProtocolBufferException {
        return PARSER.parseFrom(data);
      }
      public static object_detection.protos.CenterNetOuterClass.CenterNet.KeypointEstimation parseFrom(
          com.google.protobuf.ByteString data,
          com.google.protobuf.ExtensionRegistryLite extensionRegistry)
          throws com.google.protobuf.InvalidProtocolBufferException {
        return PARSER.parseFrom(data, extensionRegistry);
      }
      public static object_detection.protos.CenterNetOuterClass.CenterNet.KeypointEstimation parseFrom(byte[] data)
          throws com.google.protobuf.InvalidProtocolBufferException {
        return PARSER.parseFrom(data);
      }
      public static object_detection.protos.CenterNetOuterClass.CenterNet.KeypointEstimation parseFrom(
          byte[] data,
          com.google.protobuf.ExtensionRegistryLite extensionRegistry)
          throws com.google.protobuf.InvalidProtocolBufferException {
        return PARSER.parseFrom(data, extensionRegistry);
      }
      public static object_detection.protos.CenterNetOuterClass.CenterNet.KeypointEstimation parseFrom(java.io.InputStream input)
          throws java.io.IOException {
        return com.google.protobuf.GeneratedMessageV3
            .parseWithIOException(PARSER, input);
      }
      public static object_detection.protos.CenterNetOuterClass.CenterNet.KeypointEstimation parseFrom(
          java.io.InputStream input,
          com.google.protobuf.ExtensionRegistryLite extensionRegistry)
          throws java.io.IOException {
        return com.google.protobuf.GeneratedMessageV3
            .parseWithIOException(PARSER, input, extensionRegistry);
      }
      public static object_detection.protos.CenterNetOuterClass.CenterNet.KeypointEstimation parseDelimitedFrom(java.io.InputStream input)
          throws java.io.IOException {
        return com.google.protobuf.GeneratedMessageV3
            .parseDelimitedWithIOException(PARSER, input);
      }
      public static object_detection.protos.CenterNetOuterClass.CenterNet.KeypointEstimation parseDelimitedFrom(
          java.io.InputStream input,
          com.google.protobuf.ExtensionRegistryLite extensionRegistry)
          throws java.io.IOException {
        return com.google.protobuf.GeneratedMessageV3
            .parseDelimitedWithIOException(PARSER, input, extensionRegistry);
      }
      public static object_detection.protos.CenterNetOuterClass.CenterNet.KeypointEstimation parseFrom(
          com.google.protobuf.CodedInputStream input)
          throws java.io.IOException {
        return com.google.protobuf.GeneratedMessageV3
            .parseWithIOException(PARSER, input);
      }
      public static object_detection.protos.CenterNetOuterClass.CenterNet.KeypointEstimation parseFrom(
          com.google.protobuf.CodedInputStream input,
          com.google.protobuf.ExtensionRegistryLite extensionRegistry)
          throws java.io.IOException {
        return com.google.protobuf.GeneratedMessageV3
            .parseWithIOException(PARSER, input, extensionRegistry);
      }

      @java.lang.Override
      public Builder newBuilderForType() { return newBuilder(); }
      public static Builder newBuilder() {
        return DEFAULT_INSTANCE.toBuilder();
      }
      public static Builder newBuilder(object_detection.protos.CenterNetOuterClass.CenterNet.KeypointEstimation prototype) {
        return DEFAULT_INSTANCE.toBuilder().mergeFrom(prototype);
      }
      @java.lang.Override
      public Builder toBuilder() {
        return this == DEFAULT_INSTANCE
            ? new Builder() : new Builder().mergeFrom(this);
      }

      @java.lang.Override
      protected Builder newBuilderForType(
          com.google.protobuf.GeneratedMessageV3.BuilderParent parent) {
        Builder builder = new Builder(parent);
        return builder;
      }
      /**
       * <pre>
       * Parameters which are related to keypoint estimation task.
       * </pre>
       *
       * Protobuf type {@code object_detection.protos.CenterNet.KeypointEstimation}
       */
      public static final class Builder extends
          com.google.protobuf.GeneratedMessageV3.Builder<Builder> implements
          // @@protoc_insertion_point(builder_implements:object_detection.protos.CenterNet.KeypointEstimation)
          object_detection.protos.CenterNetOuterClass.CenterNet.KeypointEstimationOrBuilder {
        public static final com.google.protobuf.Descriptors.Descriptor
            getDescriptor() {
          return object_detection.protos.CenterNetOuterClass.internal_static_object_detection_protos_CenterNet_KeypointEstimation_descriptor;
        }

        @SuppressWarnings({"rawtypes"})
        protected com.google.protobuf.MapField internalGetMapField(
            int number) {
          switch (number) {
            case 5:
              return internalGetKeypointLabelToStd();
            default:
              throw new RuntimeException(
                  "Invalid map field number: " + number);
          }
        }
        @SuppressWarnings({"rawtypes"})
        protected com.google.protobuf.MapField internalGetMutableMapField(
            int number) {
          switch (number) {
            case 5:
              return internalGetMutableKeypointLabelToStd();
            default:
              throw new RuntimeException(
                  "Invalid map field number: " + number);
          }
        }
        @java.lang.Override
        protected com.google.protobuf.GeneratedMessageV3.FieldAccessorTable
            internalGetFieldAccessorTable() {
          return object_detection.protos.CenterNetOuterClass.internal_static_object_detection_protos_CenterNet_KeypointEstimation_fieldAccessorTable
              .ensureFieldAccessorsInitialized(
                  object_detection.protos.CenterNetOuterClass.CenterNet.KeypointEstimation.class, object_detection.protos.CenterNetOuterClass.CenterNet.KeypointEstimation.Builder.class);
        }

        // Construct using object_detection.protos.CenterNetOuterClass.CenterNet.KeypointEstimation.newBuilder()
        private Builder() {
          maybeForceBuilderInitialization();
        }

        private Builder(
            com.google.protobuf.GeneratedMessageV3.BuilderParent parent) {
          super(parent);
          maybeForceBuilderInitialization();
        }
        private void maybeForceBuilderInitialization() {
          if (com.google.protobuf.GeneratedMessageV3
                  .alwaysUseFieldBuilders) {
            getLossFieldBuilder();
          }
        }
        @java.lang.Override
        public Builder clear() {
          super.clear();
          taskName_ = "";
          bitField0_ = (bitField0_ & ~0x00000001);
          taskLossWeight_ = 1F;
          bitField0_ = (bitField0_ & ~0x00000002);
          if (lossBuilder_ == null) {
            loss_ = null;
          } else {
            lossBuilder_.clear();
          }
          bitField0_ = (bitField0_ & ~0x00000004);
          keypointClassName_ = "";
          bitField0_ = (bitField0_ & ~0x00000008);
          internalGetMutableKeypointLabelToStd().clear();
          keypointRegressionLossWeight_ = 1F;
          bitField0_ = (bitField0_ & ~0x00000020);
          keypointHeatmapLossWeight_ = 1F;
          bitField0_ = (bitField0_ & ~0x00000040);
          keypointOffsetLossWeight_ = 1F;
          bitField0_ = (bitField0_ & ~0x00000080);
          heatmapBiasInit_ = -2.19F;
          bitField0_ = (bitField0_ & ~0x00000100);
          keypointCandidateScoreThreshold_ = 0.1F;
          bitField0_ = (bitField0_ & ~0x00000200);
          numCandidatesPerKeypoint_ = 100;
          bitField0_ = (bitField0_ & ~0x00000400);
          peakMaxPoolKernelSize_ = 3;
          bitField0_ = (bitField0_ & ~0x00000800);
          unmatchedKeypointScore_ = 0.1F;
          bitField0_ = (bitField0_ & ~0x00001000);
          boxScale_ = 1.2F;
          bitField0_ = (bitField0_ & ~0x00002000);
          candidateSearchScale_ = 0.3F;
          bitField0_ = (bitField0_ & ~0x00004000);
          candidateRankingMode_ = "min_distance";
          bitField0_ = (bitField0_ & ~0x00008000);
          offsetPeakRadius_ = 0;
          bitField0_ = (bitField0_ & ~0x00010000);
          perKeypointOffset_ = false;
          bitField0_ = (bitField0_ & ~0x00020000);
          return this;
        }

        @java.lang.Override
        public com.google.protobuf.Descriptors.Descriptor
            getDescriptorForType() {
          return object_detection.protos.CenterNetOuterClass.internal_static_object_detection_protos_CenterNet_KeypointEstimation_descriptor;
        }

        @java.lang.Override
        public object_detection.protos.CenterNetOuterClass.CenterNet.KeypointEstimation getDefaultInstanceForType() {
          return object_detection.protos.CenterNetOuterClass.CenterNet.KeypointEstimation.getDefaultInstance();
        }

        @java.lang.Override
        public object_detection.protos.CenterNetOuterClass.CenterNet.KeypointEstimation build() {
          object_detection.protos.CenterNetOuterClass.CenterNet.KeypointEstimation result = buildPartial();
          if (!result.isInitialized()) {
            throw newUninitializedMessageException(result);
          }
          return result;
        }

        @java.lang.Override
        public object_detection.protos.CenterNetOuterClass.CenterNet.KeypointEstimation buildPartial() {
          object_detection.protos.CenterNetOuterClass.CenterNet.KeypointEstimation result = new object_detection.protos.CenterNetOuterClass.CenterNet.KeypointEstimation(this);
          int from_bitField0_ = bitField0_;
          int to_bitField0_ = 0;
          if (((from_bitField0_ & 0x00000001) != 0)) {
            to_bitField0_ |= 0x00000001;
          }
          result.taskName_ = taskName_;
          if (((from_bitField0_ & 0x00000002) != 0)) {
            to_bitField0_ |= 0x00000002;
          }
          result.taskLossWeight_ = taskLossWeight_;
          if (((from_bitField0_ & 0x00000004) != 0)) {
            if (lossBuilder_ == null) {
              result.loss_ = loss_;
            } else {
              result.loss_ = lossBuilder_.build();
            }
            to_bitField0_ |= 0x00000004;
          }
          if (((from_bitField0_ & 0x00000008) != 0)) {
            to_bitField0_ |= 0x00000008;
          }
          result.keypointClassName_ = keypointClassName_;
          result.keypointLabelToStd_ = internalGetKeypointLabelToStd();
          result.keypointLabelToStd_.makeImmutable();
          if (((from_bitField0_ & 0x00000020) != 0)) {
            to_bitField0_ |= 0x00000010;
          }
          result.keypointRegressionLossWeight_ = keypointRegressionLossWeight_;
          if (((from_bitField0_ & 0x00000040) != 0)) {
            to_bitField0_ |= 0x00000020;
          }
          result.keypointHeatmapLossWeight_ = keypointHeatmapLossWeight_;
          if (((from_bitField0_ & 0x00000080) != 0)) {
            to_bitField0_ |= 0x00000040;
          }
          result.keypointOffsetLossWeight_ = keypointOffsetLossWeight_;
          if (((from_bitField0_ & 0x00000100) != 0)) {
            to_bitField0_ |= 0x00000080;
          }
          result.heatmapBiasInit_ = heatmapBiasInit_;
          if (((from_bitField0_ & 0x00000200) != 0)) {
            to_bitField0_ |= 0x00000100;
          }
          result.keypointCandidateScoreThreshold_ = keypointCandidateScoreThreshold_;
          if (((from_bitField0_ & 0x00000400) != 0)) {
            to_bitField0_ |= 0x00000200;
          }
          result.numCandidatesPerKeypoint_ = numCandidatesPerKeypoint_;
          if (((from_bitField0_ & 0x00000800) != 0)) {
            to_bitField0_ |= 0x00000400;
          }
          result.peakMaxPoolKernelSize_ = peakMaxPoolKernelSize_;
          if (((from_bitField0_ & 0x00001000) != 0)) {
            to_bitField0_ |= 0x00000800;
          }
          result.unmatchedKeypointScore_ = unmatchedKeypointScore_;
          if (((from_bitField0_ & 0x00002000) != 0)) {
            to_bitField0_ |= 0x00001000;
          }
          result.boxScale_ = boxScale_;
          if (((from_bitField0_ & 0x00004000) != 0)) {
            to_bitField0_ |= 0x00002000;
          }
          result.candidateSearchScale_ = candidateSearchScale_;
          if (((from_bitField0_ & 0x00008000) != 0)) {
            to_bitField0_ |= 0x00004000;
          }
          result.candidateRankingMode_ = candidateRankingMode_;
          if (((from_bitField0_ & 0x00010000) != 0)) {
            result.offsetPeakRadius_ = offsetPeakRadius_;
            to_bitField0_ |= 0x00008000;
          }
          if (((from_bitField0_ & 0x00020000) != 0)) {
            result.perKeypointOffset_ = perKeypointOffset_;
            to_bitField0_ |= 0x00010000;
          }
          result.bitField0_ = to_bitField0_;
          onBuilt();
          return result;
        }

        @java.lang.Override
        public Builder clone() {
          return super.clone();
        }
        @java.lang.Override
        public Builder setField(
            com.google.protobuf.Descriptors.FieldDescriptor field,
            java.lang.Object value) {
          return super.setField(field, value);
        }
        @java.lang.Override
        public Builder clearField(
            com.google.protobuf.Descriptors.FieldDescriptor field) {
          return super.clearField(field);
        }
        @java.lang.Override
        public Builder clearOneof(
            com.google.protobuf.Descriptors.OneofDescriptor oneof) {
          return super.clearOneof(oneof);
        }
        @java.lang.Override
        public Builder setRepeatedField(
            com.google.protobuf.Descriptors.FieldDescriptor field,
            int index, java.lang.Object value) {
          return super.setRepeatedField(field, index, value);
        }
        @java.lang.Override
        public Builder addRepeatedField(
            com.google.protobuf.Descriptors.FieldDescriptor field,
            java.lang.Object value) {
          return super.addRepeatedField(field, value);
        }
        @java.lang.Override
        public Builder mergeFrom(com.google.protobuf.Message other) {
          if (other instanceof object_detection.protos.CenterNetOuterClass.CenterNet.KeypointEstimation) {
            return mergeFrom((object_detection.protos.CenterNetOuterClass.CenterNet.KeypointEstimation)other);
          } else {
            super.mergeFrom(other);
            return this;
          }
        }

        public Builder mergeFrom(object_detection.protos.CenterNetOuterClass.CenterNet.KeypointEstimation other) {
          if (other == object_detection.protos.CenterNetOuterClass.CenterNet.KeypointEstimation.getDefaultInstance()) return this;
          if (other.hasTaskName()) {
            bitField0_ |= 0x00000001;
            taskName_ = other.taskName_;
            onChanged();
          }
          if (other.hasTaskLossWeight()) {
            setTaskLossWeight(other.getTaskLossWeight());
          }
          if (other.hasLoss()) {
            mergeLoss(other.getLoss());
          }
          if (other.hasKeypointClassName()) {
            bitField0_ |= 0x00000008;
            keypointClassName_ = other.keypointClassName_;
            onChanged();
          }
          internalGetMutableKeypointLabelToStd().mergeFrom(
              other.internalGetKeypointLabelToStd());
          if (other.hasKeypointRegressionLossWeight()) {
            setKeypointRegressionLossWeight(other.getKeypointRegressionLossWeight());
          }
          if (other.hasKeypointHeatmapLossWeight()) {
            setKeypointHeatmapLossWeight(other.getKeypointHeatmapLossWeight());
          }
          if (other.hasKeypointOffsetLossWeight()) {
            setKeypointOffsetLossWeight(other.getKeypointOffsetLossWeight());
          }
          if (other.hasHeatmapBiasInit()) {
            setHeatmapBiasInit(other.getHeatmapBiasInit());
          }
          if (other.hasKeypointCandidateScoreThreshold()) {
            setKeypointCandidateScoreThreshold(other.getKeypointCandidateScoreThreshold());
          }
          if (other.hasNumCandidatesPerKeypoint()) {
            setNumCandidatesPerKeypoint(other.getNumCandidatesPerKeypoint());
          }
          if (other.hasPeakMaxPoolKernelSize()) {
            setPeakMaxPoolKernelSize(other.getPeakMaxPoolKernelSize());
          }
          if (other.hasUnmatchedKeypointScore()) {
            setUnmatchedKeypointScore(other.getUnmatchedKeypointScore());
          }
          if (other.hasBoxScale()) {
            setBoxScale(other.getBoxScale());
          }
          if (other.hasCandidateSearchScale()) {
            setCandidateSearchScale(other.getCandidateSearchScale());
          }
          if (other.hasCandidateRankingMode()) {
            bitField0_ |= 0x00008000;
            candidateRankingMode_ = other.candidateRankingMode_;
            onChanged();
          }
          if (other.hasOffsetPeakRadius()) {
            setOffsetPeakRadius(other.getOffsetPeakRadius());
          }
          if (other.hasPerKeypointOffset()) {
            setPerKeypointOffset(other.getPerKeypointOffset());
          }
          this.mergeUnknownFields(other.unknownFields);
          onChanged();
          return this;
        }

        @java.lang.Override
        public final boolean isInitialized() {
          return true;
        }

        @java.lang.Override
        public Builder mergeFrom(
            com.google.protobuf.CodedInputStream input,
            com.google.protobuf.ExtensionRegistryLite extensionRegistry)
            throws java.io.IOException {
          object_detection.protos.CenterNetOuterClass.CenterNet.KeypointEstimation parsedMessage = null;
          try {
            parsedMessage = PARSER.parsePartialFrom(input, extensionRegistry);
          } catch (com.google.protobuf.InvalidProtocolBufferException e) {
            parsedMessage = (object_detection.protos.CenterNetOuterClass.CenterNet.KeypointEstimation) e.getUnfinishedMessage();
            throw e.unwrapIOException();
          } finally {
            if (parsedMessage != null) {
              mergeFrom(parsedMessage);
            }
          }
          return this;
        }
        private int bitField0_;

        private java.lang.Object taskName_ = "";
        /**
         * <pre>
         * Name of the task, e.g. "human pose". Note that the task name should be
         * unique to each keypoint task.
         * </pre>
         *
         * <code>optional string task_name = 1;</code>
         * @return Whether the taskName field is set.
         */
        public boolean hasTaskName() {
          return ((bitField0_ & 0x00000001) != 0);
        }
        /**
         * <pre>
         * Name of the task, e.g. "human pose". Note that the task name should be
         * unique to each keypoint task.
         * </pre>
         *
         * <code>optional string task_name = 1;</code>
         * @return The taskName.
         */
        public java.lang.String getTaskName() {
          java.lang.Object ref = taskName_;
          if (!(ref instanceof java.lang.String)) {
            com.google.protobuf.ByteString bs =
                (com.google.protobuf.ByteString) ref;
            java.lang.String s = bs.toStringUtf8();
            if (bs.isValidUtf8()) {
              taskName_ = s;
            }
            return s;
          } else {
            return (java.lang.String) ref;
          }
        }
        /**
         * <pre>
         * Name of the task, e.g. "human pose". Note that the task name should be
         * unique to each keypoint task.
         * </pre>
         *
         * <code>optional string task_name = 1;</code>
         * @return The bytes for taskName.
         */
        public com.google.protobuf.ByteString
            getTaskNameBytes() {
          java.lang.Object ref = taskName_;
          if (ref instanceof String) {
            com.google.protobuf.ByteString b =
                com.google.protobuf.ByteString.copyFromUtf8(
                    (java.lang.String) ref);
            taskName_ = b;
            return b;
          } else {
            return (com.google.protobuf.ByteString) ref;
          }
        }
        /**
         * <pre>
         * Name of the task, e.g. "human pose". Note that the task name should be
         * unique to each keypoint task.
         * </pre>
         *
         * <code>optional string task_name = 1;</code>
         * @param value The taskName to set.
         * @return This builder for chaining.
         */
        public Builder setTaskName(
            java.lang.String value) {
          if (value == null) {
    throw new NullPointerException();
  }
  bitField0_ |= 0x00000001;
          taskName_ = value;
          onChanged();
          return this;
        }
        /**
         * <pre>
         * Name of the task, e.g. "human pose". Note that the task name should be
         * unique to each keypoint task.
         * </pre>
         *
         * <code>optional string task_name = 1;</code>
         * @return This builder for chaining.
         */
        public Builder clearTaskName() {
          bitField0_ = (bitField0_ & ~0x00000001);
          taskName_ = getDefaultInstance().getTaskName();
          onChanged();
          return this;
        }
        /**
         * <pre>
         * Name of the task, e.g. "human pose". Note that the task name should be
         * unique to each keypoint task.
         * </pre>
         *
         * <code>optional string task_name = 1;</code>
         * @param value The bytes for taskName to set.
         * @return This builder for chaining.
         */
        public Builder setTaskNameBytes(
            com.google.protobuf.ByteString value) {
          if (value == null) {
    throw new NullPointerException();
  }
  bitField0_ |= 0x00000001;
          taskName_ = value;
          onChanged();
          return this;
        }

        private float taskLossWeight_ = 1F;
        /**
         * <pre>
         * Weight of the task loss. The total loss of the model will be their
         * summation of task losses weighted by the weights.
         * </pre>
         *
         * <code>optional float task_loss_weight = 2 [default = 1];</code>
         * @return Whether the taskLossWeight field is set.
         */
        @java.lang.Override
        public boolean hasTaskLossWeight() {
          return ((bitField0_ & 0x00000002) != 0);
        }
        /**
         * <pre>
         * Weight of the task loss. The total loss of the model will be their
         * summation of task losses weighted by the weights.
         * </pre>
         *
         * <code>optional float task_loss_weight = 2 [default = 1];</code>
         * @return The taskLossWeight.
         */
        @java.lang.Override
        public float getTaskLossWeight() {
          return taskLossWeight_;
        }
        /**
         * <pre>
         * Weight of the task loss. The total loss of the model will be their
         * summation of task losses weighted by the weights.
         * </pre>
         *
         * <code>optional float task_loss_weight = 2 [default = 1];</code>
         * @param value The taskLossWeight to set.
         * @return This builder for chaining.
         */
        public Builder setTaskLossWeight(float value) {
          bitField0_ |= 0x00000002;
          taskLossWeight_ = value;
          onChanged();
          return this;
        }
        /**
         * <pre>
         * Weight of the task loss. The total loss of the model will be their
         * summation of task losses weighted by the weights.
         * </pre>
         *
         * <code>optional float task_loss_weight = 2 [default = 1];</code>
         * @return This builder for chaining.
         */
        public Builder clearTaskLossWeight() {
          bitField0_ = (bitField0_ & ~0x00000002);
          taskLossWeight_ = 1F;
          onChanged();
          return this;
        }

        private object_detection.protos.Losses.Loss loss_;
        private com.google.protobuf.SingleFieldBuilderV3<
            object_detection.protos.Losses.Loss, object_detection.protos.Losses.Loss.Builder, object_detection.protos.Losses.LossOrBuilder> lossBuilder_;
        /**
         * <pre>
         * Loss configuration for keypoint heatmap, offset, regression losses. Note
         * that the localization loss is used for offset/regression losses and
         * classification loss is used for heatmap loss.
         * </pre>
         *
         * <code>optional .object_detection.protos.Loss loss = 3;</code>
         * @return Whether the loss field is set.
         */
        public boolean hasLoss() {
          return ((bitField0_ & 0x00000004) != 0);
        }
        /**
         * <pre>
         * Loss configuration for keypoint heatmap, offset, regression losses. Note
         * that the localization loss is used for offset/regression losses and
         * classification loss is used for heatmap loss.
         * </pre>
         *
         * <code>optional .object_detection.protos.Loss loss = 3;</code>
         * @return The loss.
         */
        public object_detection.protos.Losses.Loss getLoss() {
          if (lossBuilder_ == null) {
            return loss_ == null ? object_detection.protos.Losses.Loss.getDefaultInstance() : loss_;
          } else {
            return lossBuilder_.getMessage();
          }
        }
        /**
         * <pre>
         * Loss configuration for keypoint heatmap, offset, regression losses. Note
         * that the localization loss is used for offset/regression losses and
         * classification loss is used for heatmap loss.
         * </pre>
         *
         * <code>optional .object_detection.protos.Loss loss = 3;</code>
         */
        public Builder setLoss(object_detection.protos.Losses.Loss value) {
          if (lossBuilder_ == null) {
            if (value == null) {
              throw new NullPointerException();
            }
            loss_ = value;
            onChanged();
          } else {
            lossBuilder_.setMessage(value);
          }
          bitField0_ |= 0x00000004;
          return this;
        }
        /**
         * <pre>
         * Loss configuration for keypoint heatmap, offset, regression losses. Note
         * that the localization loss is used for offset/regression losses and
         * classification loss is used for heatmap loss.
         * </pre>
         *
         * <code>optional .object_detection.protos.Loss loss = 3;</code>
         */
        public Builder setLoss(
            object_detection.protos.Losses.Loss.Builder builderForValue) {
          if (lossBuilder_ == null) {
            loss_ = builderForValue.build();
            onChanged();
          } else {
            lossBuilder_.setMessage(builderForValue.build());
          }
          bitField0_ |= 0x00000004;
          return this;
        }
        /**
         * <pre>
         * Loss configuration for keypoint heatmap, offset, regression losses. Note
         * that the localization loss is used for offset/regression losses and
         * classification loss is used for heatmap loss.
         * </pre>
         *
         * <code>optional .object_detection.protos.Loss loss = 3;</code>
         */
        public Builder mergeLoss(object_detection.protos.Losses.Loss value) {
          if (lossBuilder_ == null) {
            if (((bitField0_ & 0x00000004) != 0) &&
                loss_ != null &&
                loss_ != object_detection.protos.Losses.Loss.getDefaultInstance()) {
              loss_ =
                object_detection.protos.Losses.Loss.newBuilder(loss_).mergeFrom(value).buildPartial();
            } else {
              loss_ = value;
            }
            onChanged();
          } else {
            lossBuilder_.mergeFrom(value);
          }
          bitField0_ |= 0x00000004;
          return this;
        }
        /**
         * <pre>
         * Loss configuration for keypoint heatmap, offset, regression losses. Note
         * that the localization loss is used for offset/regression losses and
         * classification loss is used for heatmap loss.
         * </pre>
         *
         * <code>optional .object_detection.protos.Loss loss = 3;</code>
         */
        public Builder clearLoss() {
          if (lossBuilder_ == null) {
            loss_ = null;
            onChanged();
          } else {
            lossBuilder_.clear();
          }
          bitField0_ = (bitField0_ & ~0x00000004);
          return this;
        }
        /**
         * <pre>
         * Loss configuration for keypoint heatmap, offset, regression losses. Note
         * that the localization loss is used for offset/regression losses and
         * classification loss is used for heatmap loss.
         * </pre>
         *
         * <code>optional .object_detection.protos.Loss loss = 3;</code>
         */
        public object_detection.protos.Losses.Loss.Builder getLossBuilder() {
          bitField0_ |= 0x00000004;
          onChanged();
          return getLossFieldBuilder().getBuilder();
        }
        /**
         * <pre>
         * Loss configuration for keypoint heatmap, offset, regression losses. Note
         * that the localization loss is used for offset/regression losses and
         * classification loss is used for heatmap loss.
         * </pre>
         *
         * <code>optional .object_detection.protos.Loss loss = 3;</code>
         */
        public object_detection.protos.Losses.LossOrBuilder getLossOrBuilder() {
          if (lossBuilder_ != null) {
            return lossBuilder_.getMessageOrBuilder();
          } else {
            return loss_ == null ?
                object_detection.protos.Losses.Loss.getDefaultInstance() : loss_;
          }
        }
        /**
         * <pre>
         * Loss configuration for keypoint heatmap, offset, regression losses. Note
         * that the localization loss is used for offset/regression losses and
         * classification loss is used for heatmap loss.
         * </pre>
         *
         * <code>optional .object_detection.protos.Loss loss = 3;</code>
         */
        private com.google.protobuf.SingleFieldBuilderV3<
            object_detection.protos.Losses.Loss, object_detection.protos.Losses.Loss.Builder, object_detection.protos.Losses.LossOrBuilder>
            getLossFieldBuilder() {
          if (lossBuilder_ == null) {
            lossBuilder_ = new com.google.protobuf.SingleFieldBuilderV3<
                object_detection.protos.Losses.Loss, object_detection.protos.Losses.Loss.Builder, object_detection.protos.Losses.LossOrBuilder>(
                    getLoss(),
                    getParentForChildren(),
                    isClean());
            loss_ = null;
          }
          return lossBuilder_;
        }

        private java.lang.Object keypointClassName_ = "";
        /**
         * <pre>
         * The name of the class that contains the keypoints for this task. This is
         * used to retrieve the corresponding keypoint indices from the label map.
         * Note that this corresponds to the "name" field, not "display_name".
         * </pre>
         *
         * <code>optional string keypoint_class_name = 4;</code>
         * @return Whether the keypointClassName field is set.
         */
        public boolean hasKeypointClassName() {
          return ((bitField0_ & 0x00000008) != 0);
        }
        /**
         * <pre>
         * The name of the class that contains the keypoints for this task. This is
         * used to retrieve the corresponding keypoint indices from the label map.
         * Note that this corresponds to the "name" field, not "display_name".
         * </pre>
         *
         * <code>optional string keypoint_class_name = 4;</code>
         * @return The keypointClassName.
         */
        public java.lang.String getKeypointClassName() {
          java.lang.Object ref = keypointClassName_;
          if (!(ref instanceof java.lang.String)) {
            com.google.protobuf.ByteString bs =
                (com.google.protobuf.ByteString) ref;
            java.lang.String s = bs.toStringUtf8();
            if (bs.isValidUtf8()) {
              keypointClassName_ = s;
            }
            return s;
          } else {
            return (java.lang.String) ref;
          }
        }
        /**
         * <pre>
         * The name of the class that contains the keypoints for this task. This is
         * used to retrieve the corresponding keypoint indices from the label map.
         * Note that this corresponds to the "name" field, not "display_name".
         * </pre>
         *
         * <code>optional string keypoint_class_name = 4;</code>
         * @return The bytes for keypointClassName.
         */
        public com.google.protobuf.ByteString
            getKeypointClassNameBytes() {
          java.lang.Object ref = keypointClassName_;
          if (ref instanceof String) {
            com.google.protobuf.ByteString b =
                com.google.protobuf.ByteString.copyFromUtf8(
                    (java.lang.String) ref);
            keypointClassName_ = b;
            return b;
          } else {
            return (com.google.protobuf.ByteString) ref;
          }
        }
        /**
         * <pre>
         * The name of the class that contains the keypoints for this task. This is
         * used to retrieve the corresponding keypoint indices from the label map.
         * Note that this corresponds to the "name" field, not "display_name".
         * </pre>
         *
         * <code>optional string keypoint_class_name = 4;</code>
         * @param value The keypointClassName to set.
         * @return This builder for chaining.
         */
        public Builder setKeypointClassName(
            java.lang.String value) {
          if (value == null) {
    throw new NullPointerException();
  }
  bitField0_ |= 0x00000008;
          keypointClassName_ = value;
          onChanged();
          return this;
        }
        /**
         * <pre>
         * The name of the class that contains the keypoints for this task. This is
         * used to retrieve the corresponding keypoint indices from the label map.
         * Note that this corresponds to the "name" field, not "display_name".
         * </pre>
         *
         * <code>optional string keypoint_class_name = 4;</code>
         * @return This builder for chaining.
         */
        public Builder clearKeypointClassName() {
          bitField0_ = (bitField0_ & ~0x00000008);
          keypointClassName_ = getDefaultInstance().getKeypointClassName();
          onChanged();
          return this;
        }
        /**
         * <pre>
         * The name of the class that contains the keypoints for this task. This is
         * used to retrieve the corresponding keypoint indices from the label map.
         * Note that this corresponds to the "name" field, not "display_name".
         * </pre>
         *
         * <code>optional string keypoint_class_name = 4;</code>
         * @param value The bytes for keypointClassName to set.
         * @return This builder for chaining.
         */
        public Builder setKeypointClassNameBytes(
            com.google.protobuf.ByteString value) {
          if (value == null) {
    throw new NullPointerException();
  }
  bitField0_ |= 0x00000008;
          keypointClassName_ = value;
          onChanged();
          return this;
        }

        private com.google.protobuf.MapField<
            java.lang.String, java.lang.Float> keypointLabelToStd_;
        private com.google.protobuf.MapField<java.lang.String, java.lang.Float>
        internalGetKeypointLabelToStd() {
          if (keypointLabelToStd_ == null) {
            return com.google.protobuf.MapField.emptyMapField(
                KeypointLabelToStdDefaultEntryHolder.defaultEntry);
          }
          return keypointLabelToStd_;
        }
        private com.google.protobuf.MapField<java.lang.String, java.lang.Float>
        internalGetMutableKeypointLabelToStd() {
          onChanged();;
          if (keypointLabelToStd_ == null) {
            keypointLabelToStd_ = com.google.protobuf.MapField.newMapField(
                KeypointLabelToStdDefaultEntryHolder.defaultEntry);
          }
          if (!keypointLabelToStd_.isMutable()) {
            keypointLabelToStd_ = keypointLabelToStd_.copy();
          }
          return keypointLabelToStd_;
        }

        public int getKeypointLabelToStdCount() {
          return internalGetKeypointLabelToStd().getMap().size();
        }
        /**
         * <pre>
         * The standard deviation of the Gaussian kernel used to generate the
         * keypoint heatmap. The unit is the pixel in the output image. It is to
         * provide the flexibility of using different sizes of Gaussian kernel for
         * each keypoint class. Note that if provided, the keypoint standard
         * deviations will be overridden by the specified values here, otherwise,
         * the default value 5.0 will be used.
         * TODO(yuhuic): Update the default value once we found the best value.
         * </pre>
         *
         * <code>map&lt;string, float&gt; keypoint_label_to_std = 5;</code>
         */

        @java.lang.Override
        public boolean containsKeypointLabelToStd(
            java.lang.String key) {
          if (key == null) { throw new java.lang.NullPointerException(); }
          return internalGetKeypointLabelToStd().getMap().containsKey(key);
        }
        /**
         * Use {@link #getKeypointLabelToStdMap()} instead.
         */
        @java.lang.Override
        @java.lang.Deprecated
        public java.util.Map<java.lang.String, java.lang.Float> getKeypointLabelToStd() {
          return getKeypointLabelToStdMap();
        }
        /**
         * <pre>
         * The standard deviation of the Gaussian kernel used to generate the
         * keypoint heatmap. The unit is the pixel in the output image. It is to
         * provide the flexibility of using different sizes of Gaussian kernel for
         * each keypoint class. Note that if provided, the keypoint standard
         * deviations will be overridden by the specified values here, otherwise,
         * the default value 5.0 will be used.
         * TODO(yuhuic): Update the default value once we found the best value.
         * </pre>
         *
         * <code>map&lt;string, float&gt; keypoint_label_to_std = 5;</code>
         */
        @java.lang.Override

        public java.util.Map<java.lang.String, java.lang.Float> getKeypointLabelToStdMap() {
          return internalGetKeypointLabelToStd().getMap();
        }
        /**
         * <pre>
         * The standard deviation of the Gaussian kernel used to generate the
         * keypoint heatmap. The unit is the pixel in the output image. It is to
         * provide the flexibility of using different sizes of Gaussian kernel for
         * each keypoint class. Note that if provided, the keypoint standard
         * deviations will be overridden by the specified values here, otherwise,
         * the default value 5.0 will be used.
         * TODO(yuhuic): Update the default value once we found the best value.
         * </pre>
         *
         * <code>map&lt;string, float&gt; keypoint_label_to_std = 5;</code>
         */
        @java.lang.Override

        public float getKeypointLabelToStdOrDefault(
            java.lang.String key,
            float defaultValue) {
          if (key == null) { throw new java.lang.NullPointerException(); }
          java.util.Map<java.lang.String, java.lang.Float> map =
              internalGetKeypointLabelToStd().getMap();
          return map.containsKey(key) ? map.get(key) : defaultValue;
        }
        /**
         * <pre>
         * The standard deviation of the Gaussian kernel used to generate the
         * keypoint heatmap. The unit is the pixel in the output image. It is to
         * provide the flexibility of using different sizes of Gaussian kernel for
         * each keypoint class. Note that if provided, the keypoint standard
         * deviations will be overridden by the specified values here, otherwise,
         * the default value 5.0 will be used.
         * TODO(yuhuic): Update the default value once we found the best value.
         * </pre>
         *
         * <code>map&lt;string, float&gt; keypoint_label_to_std = 5;</code>
         */
        @java.lang.Override

        public float getKeypointLabelToStdOrThrow(
            java.lang.String key) {
          if (key == null) { throw new java.lang.NullPointerException(); }
          java.util.Map<java.lang.String, java.lang.Float> map =
              internalGetKeypointLabelToStd().getMap();
          if (!map.containsKey(key)) {
            throw new java.lang.IllegalArgumentException();
          }
          return map.get(key);
        }

        public Builder clearKeypointLabelToStd() {
          internalGetMutableKeypointLabelToStd().getMutableMap()
              .clear();
          return this;
        }
        /**
         * <pre>
         * The standard deviation of the Gaussian kernel used to generate the
         * keypoint heatmap. The unit is the pixel in the output image. It is to
         * provide the flexibility of using different sizes of Gaussian kernel for
         * each keypoint class. Note that if provided, the keypoint standard
         * deviations will be overridden by the specified values here, otherwise,
         * the default value 5.0 will be used.
         * TODO(yuhuic): Update the default value once we found the best value.
         * </pre>
         *
         * <code>map&lt;string, float&gt; keypoint_label_to_std = 5;</code>
         */

        public Builder removeKeypointLabelToStd(
            java.lang.String key) {
          if (key == null) { throw new java.lang.NullPointerException(); }
          internalGetMutableKeypointLabelToStd().getMutableMap()
              .remove(key);
          return this;
        }
        /**
         * Use alternate mutation accessors instead.
         */
        @java.lang.Deprecated
        public java.util.Map<java.lang.String, java.lang.Float>
        getMutableKeypointLabelToStd() {
          return internalGetMutableKeypointLabelToStd().getMutableMap();
        }
        /**
         * <pre>
         * The standard deviation of the Gaussian kernel used to generate the
         * keypoint heatmap. The unit is the pixel in the output image. It is to
         * provide the flexibility of using different sizes of Gaussian kernel for
         * each keypoint class. Note that if provided, the keypoint standard
         * deviations will be overridden by the specified values here, otherwise,
         * the default value 5.0 will be used.
         * TODO(yuhuic): Update the default value once we found the best value.
         * </pre>
         *
         * <code>map&lt;string, float&gt; keypoint_label_to_std = 5;</code>
         */
        public Builder putKeypointLabelToStd(
            java.lang.String key,
            float value) {
          if (key == null) { throw new java.lang.NullPointerException(); }

          internalGetMutableKeypointLabelToStd().getMutableMap()
              .put(key, value);
          return this;
        }
        /**
         * <pre>
         * The standard deviation of the Gaussian kernel used to generate the
         * keypoint heatmap. The unit is the pixel in the output image. It is to
         * provide the flexibility of using different sizes of Gaussian kernel for
         * each keypoint class. Note that if provided, the keypoint standard
         * deviations will be overridden by the specified values here, otherwise,
         * the default value 5.0 will be used.
         * TODO(yuhuic): Update the default value once we found the best value.
         * </pre>
         *
         * <code>map&lt;string, float&gt; keypoint_label_to_std = 5;</code>
         */

        public Builder putAllKeypointLabelToStd(
            java.util.Map<java.lang.String, java.lang.Float> values) {
          internalGetMutableKeypointLabelToStd().getMutableMap()
              .putAll(values);
          return this;
        }

        private float keypointRegressionLossWeight_ = 1F;
        /**
         * <pre>
         * Loss weights corresponding to different heads.
         * </pre>
         *
         * <code>optional float keypoint_regression_loss_weight = 6 [default = 1];</code>
         * @return Whether the keypointRegressionLossWeight field is set.
         */
        @java.lang.Override
        public boolean hasKeypointRegressionLossWeight() {
          return ((bitField0_ & 0x00000020) != 0);
        }
        /**
         * <pre>
         * Loss weights corresponding to different heads.
         * </pre>
         *
         * <code>optional float keypoint_regression_loss_weight = 6 [default = 1];</code>
         * @return The keypointRegressionLossWeight.
         */
        @java.lang.Override
        public float getKeypointRegressionLossWeight() {
          return keypointRegressionLossWeight_;
        }
        /**
         * <pre>
         * Loss weights corresponding to different heads.
         * </pre>
         *
         * <code>optional float keypoint_regression_loss_weight = 6 [default = 1];</code>
         * @param value The keypointRegressionLossWeight to set.
         * @return This builder for chaining.
         */
        public Builder setKeypointRegressionLossWeight(float value) {
          bitField0_ |= 0x00000020;
          keypointRegressionLossWeight_ = value;
          onChanged();
          return this;
        }
        /**
         * <pre>
         * Loss weights corresponding to different heads.
         * </pre>
         *
         * <code>optional float keypoint_regression_loss_weight = 6 [default = 1];</code>
         * @return This builder for chaining.
         */
        public Builder clearKeypointRegressionLossWeight() {
          bitField0_ = (bitField0_ & ~0x00000020);
          keypointRegressionLossWeight_ = 1F;
          onChanged();
          return this;
        }

        private float keypointHeatmapLossWeight_ = 1F;
        /**
         * <code>optional float keypoint_heatmap_loss_weight = 7 [default = 1];</code>
         * @return Whether the keypointHeatmapLossWeight field is set.
         */
        @java.lang.Override
        public boolean hasKeypointHeatmapLossWeight() {
          return ((bitField0_ & 0x00000040) != 0);
        }
        /**
         * <code>optional float keypoint_heatmap_loss_weight = 7 [default = 1];</code>
         * @return The keypointHeatmapLossWeight.
         */
        @java.lang.Override
        public float getKeypointHeatmapLossWeight() {
          return keypointHeatmapLossWeight_;
        }
        /**
         * <code>optional float keypoint_heatmap_loss_weight = 7 [default = 1];</code>
         * @param value The keypointHeatmapLossWeight to set.
         * @return This builder for chaining.
         */
        public Builder setKeypointHeatmapLossWeight(float value) {
          bitField0_ |= 0x00000040;
          keypointHeatmapLossWeight_ = value;
          onChanged();
          return this;
        }
        /**
         * <code>optional float keypoint_heatmap_loss_weight = 7 [default = 1];</code>
         * @return This builder for chaining.
         */
        public Builder clearKeypointHeatmapLossWeight() {
          bitField0_ = (bitField0_ & ~0x00000040);
          keypointHeatmapLossWeight_ = 1F;
          onChanged();
          return this;
        }

        private float keypointOffsetLossWeight_ = 1F;
        /**
         * <code>optional float keypoint_offset_loss_weight = 8 [default = 1];</code>
         * @return Whether the keypointOffsetLossWeight field is set.
         */
        @java.lang.Override
        public boolean hasKeypointOffsetLossWeight() {
          return ((bitField0_ & 0x00000080) != 0);
        }
        /**
         * <code>optional float keypoint_offset_loss_weight = 8 [default = 1];</code>
         * @return The keypointOffsetLossWeight.
         */
        @java.lang.Override
        public float getKeypointOffsetLossWeight() {
          return keypointOffsetLossWeight_;
        }
        /**
         * <code>optional float keypoint_offset_loss_weight = 8 [default = 1];</code>
         * @param value The keypointOffsetLossWeight to set.
         * @return This builder for chaining.
         */
        public Builder setKeypointOffsetLossWeight(float value) {
          bitField0_ |= 0x00000080;
          keypointOffsetLossWeight_ = value;
          onChanged();
          return this;
        }
        /**
         * <code>optional float keypoint_offset_loss_weight = 8 [default = 1];</code>
         * @return This builder for chaining.
         */
        public Builder clearKeypointOffsetLossWeight() {
          bitField0_ = (bitField0_ & ~0x00000080);
          keypointOffsetLossWeight_ = 1F;
          onChanged();
          return this;
        }

        private float heatmapBiasInit_ = -2.19F;
        /**
         * <pre>
         * The initial bias value of the convolution kernel of the keypoint heatmap
         * prediction head. -2.19 corresponds to predicting foreground with
         * a probability of 0.1. See "Focal Loss for Dense Object Detection"
         * at https://arxiv.org/abs/1708.02002.
         * </pre>
         *
         * <code>optional float heatmap_bias_init = 9 [default = -2.19];</code>
         * @return Whether the heatmapBiasInit field is set.
         */
        @java.lang.Override
        public boolean hasHeatmapBiasInit() {
          return ((bitField0_ & 0x00000100) != 0);
        }
        /**
         * <pre>
         * The initial bias value of the convolution kernel of the keypoint heatmap
         * prediction head. -2.19 corresponds to predicting foreground with
         * a probability of 0.1. See "Focal Loss for Dense Object Detection"
         * at https://arxiv.org/abs/1708.02002.
         * </pre>
         *
         * <code>optional float heatmap_bias_init = 9 [default = -2.19];</code>
         * @return The heatmapBiasInit.
         */
        @java.lang.Override
        public float getHeatmapBiasInit() {
          return heatmapBiasInit_;
        }
        /**
         * <pre>
         * The initial bias value of the convolution kernel of the keypoint heatmap
         * prediction head. -2.19 corresponds to predicting foreground with
         * a probability of 0.1. See "Focal Loss for Dense Object Detection"
         * at https://arxiv.org/abs/1708.02002.
         * </pre>
         *
         * <code>optional float heatmap_bias_init = 9 [default = -2.19];</code>
         * @param value The heatmapBiasInit to set.
         * @return This builder for chaining.
         */
        public Builder setHeatmapBiasInit(float value) {
          bitField0_ |= 0x00000100;
          heatmapBiasInit_ = value;
          onChanged();
          return this;
        }
        /**
         * <pre>
         * The initial bias value of the convolution kernel of the keypoint heatmap
         * prediction head. -2.19 corresponds to predicting foreground with
         * a probability of 0.1. See "Focal Loss for Dense Object Detection"
         * at https://arxiv.org/abs/1708.02002.
         * </pre>
         *
         * <code>optional float heatmap_bias_init = 9 [default = -2.19];</code>
         * @return This builder for chaining.
         */
        public Builder clearHeatmapBiasInit() {
          bitField0_ = (bitField0_ & ~0x00000100);
          heatmapBiasInit_ = -2.19F;
          onChanged();
          return this;
        }

        private float keypointCandidateScoreThreshold_ = 0.1F;
        /**
         * <pre>
         * The heatmap score threshold for a keypoint to become a valid candidate.
         * </pre>
         *
         * <code>optional float keypoint_candidate_score_threshold = 10 [default = 0.1];</code>
         * @return Whether the keypointCandidateScoreThreshold field is set.
         */
        @java.lang.Override
        public boolean hasKeypointCandidateScoreThreshold() {
          return ((bitField0_ & 0x00000200) != 0);
        }
        /**
         * <pre>
         * The heatmap score threshold for a keypoint to become a valid candidate.
         * </pre>
         *
         * <code>optional float keypoint_candidate_score_threshold = 10 [default = 0.1];</code>
         * @return The keypointCandidateScoreThreshold.
         */
        @java.lang.Override
        public float getKeypointCandidateScoreThreshold() {
          return keypointCandidateScoreThreshold_;
        }
        /**
         * <pre>
         * The heatmap score threshold for a keypoint to become a valid candidate.
         * </pre>
         *
         * <code>optional float keypoint_candidate_score_threshold = 10 [default = 0.1];</code>
         * @param value The keypointCandidateScoreThreshold to set.
         * @return This builder for chaining.
         */
        public Builder setKeypointCandidateScoreThreshold(float value) {
          bitField0_ |= 0x00000200;
          keypointCandidateScoreThreshold_ = value;
          onChanged();
          return this;
        }
        /**
         * <pre>
         * The heatmap score threshold for a keypoint to become a valid candidate.
         * </pre>
         *
         * <code>optional float keypoint_candidate_score_threshold = 10 [default = 0.1];</code>
         * @return This builder for chaining.
         */
        public Builder clearKeypointCandidateScoreThreshold() {
          bitField0_ = (bitField0_ & ~0x00000200);
          keypointCandidateScoreThreshold_ = 0.1F;
          onChanged();
          return this;
        }

        private int numCandidatesPerKeypoint_ = 100;
        /**
         * <pre>
         * The maximum number of candidates to retrieve for each keypoint.
         * </pre>
         *
         * <code>optional int32 num_candidates_per_keypoint = 11 [default = 100];</code>
         * @return Whether the numCandidatesPerKeypoint field is set.
         */
        @java.lang.Override
        public boolean hasNumCandidatesPerKeypoint() {
          return ((bitField0_ & 0x00000400) != 0);
        }
        /**
         * <pre>
         * The maximum number of candidates to retrieve for each keypoint.
         * </pre>
         *
         * <code>optional int32 num_candidates_per_keypoint = 11 [default = 100];</code>
         * @return The numCandidatesPerKeypoint.
         */
        @java.lang.Override
        public int getNumCandidatesPerKeypoint() {
          return numCandidatesPerKeypoint_;
        }
        /**
         * <pre>
         * The maximum number of candidates to retrieve for each keypoint.
         * </pre>
         *
         * <code>optional int32 num_candidates_per_keypoint = 11 [default = 100];</code>
         * @param value The numCandidatesPerKeypoint to set.
         * @return This builder for chaining.
         */
        public Builder setNumCandidatesPerKeypoint(int value) {
          bitField0_ |= 0x00000400;
          numCandidatesPerKeypoint_ = value;
          onChanged();
          return this;
        }
        /**
         * <pre>
         * The maximum number of candidates to retrieve for each keypoint.
         * </pre>
         *
         * <code>optional int32 num_candidates_per_keypoint = 11 [default = 100];</code>
         * @return This builder for chaining.
         */
        public Builder clearNumCandidatesPerKeypoint() {
          bitField0_ = (bitField0_ & ~0x00000400);
          numCandidatesPerKeypoint_ = 100;
          onChanged();
          return this;
        }

        private int peakMaxPoolKernelSize_ = 3;
        /**
         * <pre>
         * Max pool kernel size to use to pull off peak score locations in a
         * neighborhood (independently for each keypoint types).
         * </pre>
         *
         * <code>optional int32 peak_max_pool_kernel_size = 12 [default = 3];</code>
         * @return Whether the peakMaxPoolKernelSize field is set.
         */
        @java.lang.Override
        public boolean hasPeakMaxPoolKernelSize() {
          return ((bitField0_ & 0x00000800) != 0);
        }
        /**
         * <pre>
         * Max pool kernel size to use to pull off peak score locations in a
         * neighborhood (independently for each keypoint types).
         * </pre>
         *
         * <code>optional int32 peak_max_pool_kernel_size = 12 [default = 3];</code>
         * @return The peakMaxPoolKernelSize.
         */
        @java.lang.Override
        public int getPeakMaxPoolKernelSize() {
          return peakMaxPoolKernelSize_;
        }
        /**
         * <pre>
         * Max pool kernel size to use to pull off peak score locations in a
         * neighborhood (independently for each keypoint types).
         * </pre>
         *
         * <code>optional int32 peak_max_pool_kernel_size = 12 [default = 3];</code>
         * @param value The peakMaxPoolKernelSize to set.
         * @return This builder for chaining.
         */
        public Builder setPeakMaxPoolKernelSize(int value) {
          bitField0_ |= 0x00000800;
          peakMaxPoolKernelSize_ = value;
          onChanged();
          return this;
        }
        /**
         * <pre>
         * Max pool kernel size to use to pull off peak score locations in a
         * neighborhood (independently for each keypoint types).
         * </pre>
         *
         * <code>optional int32 peak_max_pool_kernel_size = 12 [default = 3];</code>
         * @return This builder for chaining.
         */
        public Builder clearPeakMaxPoolKernelSize() {
          bitField0_ = (bitField0_ & ~0x00000800);
          peakMaxPoolKernelSize_ = 3;
          onChanged();
          return this;
        }

        private float unmatchedKeypointScore_ = 0.1F;
        /**
         * <pre>
         * The default score to use for regressed keypoints that are not
         * successfully snapped to a nearby candidate.
         * </pre>
         *
         * <code>optional float unmatched_keypoint_score = 13 [default = 0.1];</code>
         * @return Whether the unmatchedKeypointScore field is set.
         */
        @java.lang.Override
        public boolean hasUnmatchedKeypointScore() {
          return ((bitField0_ & 0x00001000) != 0);
        }
        /**
         * <pre>
         * The default score to use for regressed keypoints that are not
         * successfully snapped to a nearby candidate.
         * </pre>
         *
         * <code>optional float unmatched_keypoint_score = 13 [default = 0.1];</code>
         * @return The unmatchedKeypointScore.
         */
        @java.lang.Override
        public float getUnmatchedKeypointScore() {
          return unmatchedKeypointScore_;
        }
        /**
         * <pre>
         * The default score to use for regressed keypoints that are not
         * successfully snapped to a nearby candidate.
         * </pre>
         *
         * <code>optional float unmatched_keypoint_score = 13 [default = 0.1];</code>
         * @param value The unmatchedKeypointScore to set.
         * @return This builder for chaining.
         */
        public Builder setUnmatchedKeypointScore(float value) {
          bitField0_ |= 0x00001000;
          unmatchedKeypointScore_ = value;
          onChanged();
          return this;
        }
        /**
         * <pre>
         * The default score to use for regressed keypoints that are not
         * successfully snapped to a nearby candidate.
         * </pre>
         *
         * <code>optional float unmatched_keypoint_score = 13 [default = 0.1];</code>
         * @return This builder for chaining.
         */
        public Builder clearUnmatchedKeypointScore() {
          bitField0_ = (bitField0_ & ~0x00001000);
          unmatchedKeypointScore_ = 0.1F;
          onChanged();
          return this;
        }

        private float boxScale_ = 1.2F;
        /**
         * <pre>
         * The multiplier to expand the bounding boxes (either the provided boxes or
         * those which tightly cover the regressed keypoints). Note that new
         * expanded box for an instance becomes the feasible search window for all
         * associated keypoints.
         * </pre>
         *
         * <code>optional float box_scale = 14 [default = 1.2];</code>
         * @return Whether the boxScale field is set.
         */
        @java.lang.Override
        public boolean hasBoxScale() {
          return ((bitField0_ & 0x00002000) != 0);
        }
        /**
         * <pre>
         * The multiplier to expand the bounding boxes (either the provided boxes or
         * those which tightly cover the regressed keypoints). Note that new
         * expanded box for an instance becomes the feasible search window for all
         * associated keypoints.
         * </pre>
         *
         * <code>optional float box_scale = 14 [default = 1.2];</code>
         * @return The boxScale.
         */
        @java.lang.Override
        public float getBoxScale() {
          return boxScale_;
        }
        /**
         * <pre>
         * The multiplier to expand the bounding boxes (either the provided boxes or
         * those which tightly cover the regressed keypoints). Note that new
         * expanded box for an instance becomes the feasible search window for all
         * associated keypoints.
         * </pre>
         *
         * <code>optional float box_scale = 14 [default = 1.2];</code>
         * @param value The boxScale to set.
         * @return This builder for chaining.
         */
        public Builder setBoxScale(float value) {
          bitField0_ |= 0x00002000;
          boxScale_ = value;
          onChanged();
          return this;
        }
        /**
         * <pre>
         * The multiplier to expand the bounding boxes (either the provided boxes or
         * those which tightly cover the regressed keypoints). Note that new
         * expanded box for an instance becomes the feasible search window for all
         * associated keypoints.
         * </pre>
         *
         * <code>optional float box_scale = 14 [default = 1.2];</code>
         * @return This builder for chaining.
         */
        public Builder clearBoxScale() {
          bitField0_ = (bitField0_ & ~0x00002000);
          boxScale_ = 1.2F;
          onChanged();
          return this;
        }

        private float candidateSearchScale_ = 0.3F;
        /**
         * <pre>
         * The scale parameter that multiplies the largest dimension of a bounding
         * box. The resulting distance becomes a search radius for candidates in the
         * vicinity of each regressed keypoint.
         * </pre>
         *
         * <code>optional float candidate_search_scale = 15 [default = 0.3];</code>
         * @return Whether the candidateSearchScale field is set.
         */
        @java.lang.Override
        public boolean hasCandidateSearchScale() {
          return ((bitField0_ & 0x00004000) != 0);
        }
        /**
         * <pre>
         * The scale parameter that multiplies the largest dimension of a bounding
         * box. The resulting distance becomes a search radius for candidates in the
         * vicinity of each regressed keypoint.
         * </pre>
         *
         * <code>optional float candidate_search_scale = 15 [default = 0.3];</code>
         * @return The candidateSearchScale.
         */
        @java.lang.Override
        public float getCandidateSearchScale() {
          return candidateSearchScale_;
        }
        /**
         * <pre>
         * The scale parameter that multiplies the largest dimension of a bounding
         * box. The resulting distance becomes a search radius for candidates in the
         * vicinity of each regressed keypoint.
         * </pre>
         *
         * <code>optional float candidate_search_scale = 15 [default = 0.3];</code>
         * @param value The candidateSearchScale to set.
         * @return This builder for chaining.
         */
        public Builder setCandidateSearchScale(float value) {
          bitField0_ |= 0x00004000;
          candidateSearchScale_ = value;
          onChanged();
          return this;
        }
        /**
         * <pre>
         * The scale parameter that multiplies the largest dimension of a bounding
         * box. The resulting distance becomes a search radius for candidates in the
         * vicinity of each regressed keypoint.
         * </pre>
         *
         * <code>optional float candidate_search_scale = 15 [default = 0.3];</code>
         * @return This builder for chaining.
         */
        public Builder clearCandidateSearchScale() {
          bitField0_ = (bitField0_ & ~0x00004000);
          candidateSearchScale_ = 0.3F;
          onChanged();
          return this;
        }

        private java.lang.Object candidateRankingMode_ = "min_distance";
        /**
         * <pre>
         * One of ['min_distance', 'score_distance_ratio'] indicating how to select
         * the keypoint candidate.
         * </pre>
         *
         * <code>optional string candidate_ranking_mode = 16 [default = "min_distance"];</code>
         * @return Whether the candidateRankingMode field is set.
         */
        public boolean hasCandidateRankingMode() {
          return ((bitField0_ & 0x00008000) != 0);
        }
        /**
         * <pre>
         * One of ['min_distance', 'score_distance_ratio'] indicating how to select
         * the keypoint candidate.
         * </pre>
         *
         * <code>optional string candidate_ranking_mode = 16 [default = "min_distance"];</code>
         * @return The candidateRankingMode.
         */
        public java.lang.String getCandidateRankingMode() {
          java.lang.Object ref = candidateRankingMode_;
          if (!(ref instanceof java.lang.String)) {
            com.google.protobuf.ByteString bs =
                (com.google.protobuf.ByteString) ref;
            java.lang.String s = bs.toStringUtf8();
            if (bs.isValidUtf8()) {
              candidateRankingMode_ = s;
            }
            return s;
          } else {
            return (java.lang.String) ref;
          }
        }
        /**
         * <pre>
         * One of ['min_distance', 'score_distance_ratio'] indicating how to select
         * the keypoint candidate.
         * </pre>
         *
         * <code>optional string candidate_ranking_mode = 16 [default = "min_distance"];</code>
         * @return The bytes for candidateRankingMode.
         */
        public com.google.protobuf.ByteString
            getCandidateRankingModeBytes() {
          java.lang.Object ref = candidateRankingMode_;
          if (ref instanceof String) {
            com.google.protobuf.ByteString b =
                com.google.protobuf.ByteString.copyFromUtf8(
                    (java.lang.String) ref);
            candidateRankingMode_ = b;
            return b;
          } else {
            return (com.google.protobuf.ByteString) ref;
          }
        }
        /**
         * <pre>
         * One of ['min_distance', 'score_distance_ratio'] indicating how to select
         * the keypoint candidate.
         * </pre>
         *
         * <code>optional string candidate_ranking_mode = 16 [default = "min_distance"];</code>
         * @param value The candidateRankingMode to set.
         * @return This builder for chaining.
         */
        public Builder setCandidateRankingMode(
            java.lang.String value) {
          if (value == null) {
    throw new NullPointerException();
  }
  bitField0_ |= 0x00008000;
          candidateRankingMode_ = value;
          onChanged();
          return this;
        }
        /**
         * <pre>
         * One of ['min_distance', 'score_distance_ratio'] indicating how to select
         * the keypoint candidate.
         * </pre>
         *
         * <code>optional string candidate_ranking_mode = 16 [default = "min_distance"];</code>
         * @return This builder for chaining.
         */
        public Builder clearCandidateRankingMode() {
          bitField0_ = (bitField0_ & ~0x00008000);
          candidateRankingMode_ = getDefaultInstance().getCandidateRankingMode();
          onChanged();
          return this;
        }
        /**
         * <pre>
         * One of ['min_distance', 'score_distance_ratio'] indicating how to select
         * the keypoint candidate.
         * </pre>
         *
         * <code>optional string candidate_ranking_mode = 16 [default = "min_distance"];</code>
         * @param value The bytes for candidateRankingMode to set.
         * @return This builder for chaining.
         */
        public Builder setCandidateRankingModeBytes(
            com.google.protobuf.ByteString value) {
          if (value == null) {
    throw new NullPointerException();
  }
  bitField0_ |= 0x00008000;
          candidateRankingMode_ = value;
          onChanged();
          return this;
        }

        private int offsetPeakRadius_ ;
        /**
         * <pre>
         * The radius (in the unit of output pixel) around heatmap peak to assign
         * the offset targets. If set 0, then the offset target will only be
         * assigned to the heatmap peak (same behavior as the original paper).
         * </pre>
         *
         * <code>optional int32 offset_peak_radius = 17 [default = 0];</code>
         * @return Whether the offsetPeakRadius field is set.
         */
        @java.lang.Override
        public boolean hasOffsetPeakRadius() {
          return ((bitField0_ & 0x00010000) != 0);
        }
        /**
         * <pre>
         * The radius (in the unit of output pixel) around heatmap peak to assign
         * the offset targets. If set 0, then the offset target will only be
         * assigned to the heatmap peak (same behavior as the original paper).
         * </pre>
         *
         * <code>optional int32 offset_peak_radius = 17 [default = 0];</code>
         * @return The offsetPeakRadius.
         */
        @java.lang.Override
        public int getOffsetPeakRadius() {
          return offsetPeakRadius_;
        }
        /**
         * <pre>
         * The radius (in the unit of output pixel) around heatmap peak to assign
         * the offset targets. If set 0, then the offset target will only be
         * assigned to the heatmap peak (same behavior as the original paper).
         * </pre>
         *
         * <code>optional int32 offset_peak_radius = 17 [default = 0];</code>
         * @param value The offsetPeakRadius to set.
         * @return This builder for chaining.
         */
        public Builder setOffsetPeakRadius(int value) {
          bitField0_ |= 0x00010000;
          offsetPeakRadius_ = value;
          onChanged();
          return this;
        }
        /**
         * <pre>
         * The radius (in the unit of output pixel) around heatmap peak to assign
         * the offset targets. If set 0, then the offset target will only be
         * assigned to the heatmap peak (same behavior as the original paper).
         * </pre>
         *
         * <code>optional int32 offset_peak_radius = 17 [default = 0];</code>
         * @return This builder for chaining.
         */
        public Builder clearOffsetPeakRadius() {
          bitField0_ = (bitField0_ & ~0x00010000);
          offsetPeakRadius_ = 0;
          onChanged();
          return this;
        }

        private boolean perKeypointOffset_ ;
        /**
         * <pre>
         * Indicates whether to assign offsets for each keypoint channel
         * separately. If set False, the output offset target has the shape
         * [batch_size, out_height, out_width, 2] (same behavior as the original
         * paper). If set True, the output offset target has the shape [batch_size,
         * out_height, out_width, 2 * num_keypoints] (recommended when the
         * offset_peak_radius is not zero).
         * </pre>
         *
         * <code>optional bool per_keypoint_offset = 18 [default = false];</code>
         * @return Whether the perKeypointOffset field is set.
         */
        @java.lang.Override
        public boolean hasPerKeypointOffset() {
          return ((bitField0_ & 0x00020000) != 0);
        }
        /**
         * <pre>
         * Indicates whether to assign offsets for each keypoint channel
         * separately. If set False, the output offset target has the shape
         * [batch_size, out_height, out_width, 2] (same behavior as the original
         * paper). If set True, the output offset target has the shape [batch_size,
         * out_height, out_width, 2 * num_keypoints] (recommended when the
         * offset_peak_radius is not zero).
         * </pre>
         *
         * <code>optional bool per_keypoint_offset = 18 [default = false];</code>
         * @return The perKeypointOffset.
         */
        @java.lang.Override
        public boolean getPerKeypointOffset() {
          return perKeypointOffset_;
        }
        /**
         * <pre>
         * Indicates whether to assign offsets for each keypoint channel
         * separately. If set False, the output offset target has the shape
         * [batch_size, out_height, out_width, 2] (same behavior as the original
         * paper). If set True, the output offset target has the shape [batch_size,
         * out_height, out_width, 2 * num_keypoints] (recommended when the
         * offset_peak_radius is not zero).
         * </pre>
         *
         * <code>optional bool per_keypoint_offset = 18 [default = false];</code>
         * @param value The perKeypointOffset to set.
         * @return This builder for chaining.
         */
        public Builder setPerKeypointOffset(boolean value) {
          bitField0_ |= 0x00020000;
          perKeypointOffset_ = value;
          onChanged();
          return this;
        }
        /**
         * <pre>
         * Indicates whether to assign offsets for each keypoint channel
         * separately. If set False, the output offset target has the shape
         * [batch_size, out_height, out_width, 2] (same behavior as the original
         * paper). If set True, the output offset target has the shape [batch_size,
         * out_height, out_width, 2 * num_keypoints] (recommended when the
         * offset_peak_radius is not zero).
         * </pre>
         *
         * <code>optional bool per_keypoint_offset = 18 [default = false];</code>
         * @return This builder for chaining.
         */
        public Builder clearPerKeypointOffset() {
          bitField0_ = (bitField0_ & ~0x00020000);
          perKeypointOffset_ = false;
          onChanged();
          return this;
        }
        @java.lang.Override
        public final Builder setUnknownFields(
            final com.google.protobuf.UnknownFieldSet unknownFields) {
          return super.setUnknownFields(unknownFields);
        }

        @java.lang.Override
        public final Builder mergeUnknownFields(
            final com.google.protobuf.UnknownFieldSet unknownFields) {
          return super.mergeUnknownFields(unknownFields);
        }


        // @@protoc_insertion_point(builder_scope:object_detection.protos.CenterNet.KeypointEstimation)
      }

      // @@protoc_insertion_point(class_scope:object_detection.protos.CenterNet.KeypointEstimation)
      private static final object_detection.protos.CenterNetOuterClass.CenterNet.KeypointEstimation DEFAULT_INSTANCE;
      static {
        DEFAULT_INSTANCE = new object_detection.protos.CenterNetOuterClass.CenterNet.KeypointEstimation();
      }

      public static object_detection.protos.CenterNetOuterClass.CenterNet.KeypointEstimation getDefaultInstance() {
        return DEFAULT_INSTANCE;
      }

      @java.lang.Deprecated public static final com.google.protobuf.Parser<KeypointEstimation>
          PARSER = new com.google.protobuf.AbstractParser<KeypointEstimation>() {
        @java.lang.Override
        public KeypointEstimation parsePartialFrom(
            com.google.protobuf.CodedInputStream input,
            com.google.protobuf.ExtensionRegistryLite extensionRegistry)
            throws com.google.protobuf.InvalidProtocolBufferException {
          return new KeypointEstimation(input, extensionRegistry);
        }
      };

      public static com.google.protobuf.Parser<KeypointEstimation> parser() {
        return PARSER;
      }

      @java.lang.Override
      public com.google.protobuf.Parser<KeypointEstimation> getParserForType() {
        return PARSER;
      }

      @java.lang.Override
      public object_detection.protos.CenterNetOuterClass.CenterNet.KeypointEstimation getDefaultInstanceForType() {
        return DEFAULT_INSTANCE;
      }

    }

    public interface MaskEstimationOrBuilder extends
        // @@protoc_insertion_point(interface_extends:object_detection.protos.CenterNet.MaskEstimation)
        com.google.protobuf.MessageOrBuilder {

      /**
       * <pre>
       * Weight of the task loss. The total loss of the model will be their
       * summation of task losses weighted by the weights.
       * </pre>
       *
       * <code>optional float task_loss_weight = 1 [default = 1];</code>
       * @return Whether the taskLossWeight field is set.
       */
      boolean hasTaskLossWeight();
      /**
       * <pre>
       * Weight of the task loss. The total loss of the model will be their
       * summation of task losses weighted by the weights.
       * </pre>
       *
       * <code>optional float task_loss_weight = 1 [default = 1];</code>
       * @return The taskLossWeight.
       */
      float getTaskLossWeight();

      /**
       * <pre>
       * Classification loss configuration for segmentation loss.
       * </pre>
       *
       * <code>optional .object_detection.protos.ClassificationLoss classification_loss = 2;</code>
       * @return Whether the classificationLoss field is set.
       */
      boolean hasClassificationLoss();
      /**
       * <pre>
       * Classification loss configuration for segmentation loss.
       * </pre>
       *
       * <code>optional .object_detection.protos.ClassificationLoss classification_loss = 2;</code>
       * @return The classificationLoss.
       */
      object_detection.protos.Losses.ClassificationLoss getClassificationLoss();
      /**
       * <pre>
       * Classification loss configuration for segmentation loss.
       * </pre>
       *
       * <code>optional .object_detection.protos.ClassificationLoss classification_loss = 2;</code>
       */
      object_detection.protos.Losses.ClassificationLossOrBuilder getClassificationLossOrBuilder();

      /**
       * <pre>
       * Each instance mask (one per detection) is cropped and resized (bilinear
       * resampling) from the predicted segmentation feature map. After
       * resampling, the masks are binarized with the provided score threshold.
       * </pre>
       *
       * <code>optional int32 mask_height = 4 [default = 256];</code>
       * @return Whether the maskHeight field is set.
       */
      boolean hasMaskHeight();
      /**
       * <pre>
       * Each instance mask (one per detection) is cropped and resized (bilinear
       * resampling) from the predicted segmentation feature map. After
       * resampling, the masks are binarized with the provided score threshold.
       * </pre>
       *
       * <code>optional int32 mask_height = 4 [default = 256];</code>
       * @return The maskHeight.
       */
      int getMaskHeight();

      /**
       * <code>optional int32 mask_width = 5 [default = 256];</code>
       * @return Whether the maskWidth field is set.
       */
      boolean hasMaskWidth();
      /**
       * <code>optional int32 mask_width = 5 [default = 256];</code>
       * @return The maskWidth.
       */
      int getMaskWidth();

      /**
       * <code>optional float score_threshold = 6 [default = 0.5];</code>
       * @return Whether the scoreThreshold field is set.
       */
      boolean hasScoreThreshold();
      /**
       * <code>optional float score_threshold = 6 [default = 0.5];</code>
       * @return The scoreThreshold.
       */
      float getScoreThreshold();

      /**
       * <pre>
       * The initial bias value of the convlution kernel of the class heatmap
       * prediction head. -2.19 corresponds to predicting foreground with
       * a probability of 0.1.
       * </pre>
       *
       * <code>optional float heatmap_bias_init = 3 [default = -2.19];</code>
       * @return Whether the heatmapBiasInit field is set.
       */
      boolean hasHeatmapBiasInit();
      /**
       * <pre>
       * The initial bias value of the convlution kernel of the class heatmap
       * prediction head. -2.19 corresponds to predicting foreground with
       * a probability of 0.1.
       * </pre>
       *
       * <code>optional float heatmap_bias_init = 3 [default = -2.19];</code>
       * @return The heatmapBiasInit.
       */
      float getHeatmapBiasInit();
    }
    /**
     * <pre>
     * Parameters which are related to mask estimation task.
     * Note: Currently, CenterNet supports a weak instance segmentation, where
     * semantic segmentation masks are estimated, and then cropped based on
     * bounding box detections. Therefore, it is possible for the same image
     * pixel to be assigned to multiple instances.
     * </pre>
     *
     * Protobuf type {@code object_detection.protos.CenterNet.MaskEstimation}
     */
    public static final class MaskEstimation extends
        com.google.protobuf.GeneratedMessageV3 implements
        // @@protoc_insertion_point(message_implements:object_detection.protos.CenterNet.MaskEstimation)
        MaskEstimationOrBuilder {
    private static final long serialVersionUID = 0L;
      // Use MaskEstimation.newBuilder() to construct.
      private MaskEstimation(com.google.protobuf.GeneratedMessageV3.Builder<?> builder) {
        super(builder);
      }
      private MaskEstimation() {
        taskLossWeight_ = 1F;
        maskHeight_ = 256;
        maskWidth_ = 256;
        scoreThreshold_ = 0.5F;
        heatmapBiasInit_ = -2.19F;
      }

      @java.lang.Override
      @SuppressWarnings({"unused"})
      protected java.lang.Object newInstance(
          UnusedPrivateParameter unused) {
        return new MaskEstimation();
      }

      @java.lang.Override
      public final com.google.protobuf.UnknownFieldSet
      getUnknownFields() {
        return this.unknownFields;
      }
      private MaskEstimation(
          com.google.protobuf.CodedInputStream input,
          com.google.protobuf.ExtensionRegistryLite extensionRegistry)
          throws com.google.protobuf.InvalidProtocolBufferException {
        this();
        if (extensionRegistry == null) {
          throw new java.lang.NullPointerException();
        }
        int mutable_bitField0_ = 0;
        com.google.protobuf.UnknownFieldSet.Builder unknownFields =
            com.google.protobuf.UnknownFieldSet.newBuilder();
        try {
          boolean done = false;
          while (!done) {
            int tag = input.readTag();
            switch (tag) {
              case 0:
                done = true;
                break;
              case 13: {
                bitField0_ |= 0x00000001;
                taskLossWeight_ = input.readFloat();
                break;
              }
              case 18: {
                object_detection.protos.Losses.ClassificationLoss.Builder subBuilder = null;
                if (((bitField0_ & 0x00000002) != 0)) {
                  subBuilder = classificationLoss_.toBuilder();
                }
                classificationLoss_ = input.readMessage(object_detection.protos.Losses.ClassificationLoss.PARSER, extensionRegistry);
                if (subBuilder != null) {
                  subBuilder.mergeFrom(classificationLoss_);
                  classificationLoss_ = subBuilder.buildPartial();
                }
                bitField0_ |= 0x00000002;
                break;
              }
              case 29: {
                bitField0_ |= 0x00000020;
                heatmapBiasInit_ = input.readFloat();
                break;
              }
              case 32: {
                bitField0_ |= 0x00000004;
                maskHeight_ = input.readInt32();
                break;
              }
              case 40: {
                bitField0_ |= 0x00000008;
                maskWidth_ = input.readInt32();
                break;
              }
              case 53: {
                bitField0_ |= 0x00000010;
                scoreThreshold_ = input.readFloat();
                break;
              }
              default: {
                if (!parseUnknownField(
                    input, unknownFields, extensionRegistry, tag)) {
                  done = true;
                }
                break;
              }
            }
          }
        } catch (com.google.protobuf.InvalidProtocolBufferException e) {
          throw e.setUnfinishedMessage(this);
        } catch (java.io.IOException e) {
          throw new com.google.protobuf.InvalidProtocolBufferException(
              e).setUnfinishedMessage(this);
        } finally {
          this.unknownFields = unknownFields.build();
          makeExtensionsImmutable();
        }
      }
      public static final com.google.protobuf.Descriptors.Descriptor
          getDescriptor() {
        return object_detection.protos.CenterNetOuterClass.internal_static_object_detection_protos_CenterNet_MaskEstimation_descriptor;
      }

      @java.lang.Override
      protected com.google.protobuf.GeneratedMessageV3.FieldAccessorTable
          internalGetFieldAccessorTable() {
        return object_detection.protos.CenterNetOuterClass.internal_static_object_detection_protos_CenterNet_MaskEstimation_fieldAccessorTable
            .ensureFieldAccessorsInitialized(
                object_detection.protos.CenterNetOuterClass.CenterNet.MaskEstimation.class, object_detection.protos.CenterNetOuterClass.CenterNet.MaskEstimation.Builder.class);
      }

      private int bitField0_;
      public static final int TASK_LOSS_WEIGHT_FIELD_NUMBER = 1;
      private float taskLossWeight_;
      /**
       * <pre>
       * Weight of the task loss. The total loss of the model will be their
       * summation of task losses weighted by the weights.
       * </pre>
       *
       * <code>optional float task_loss_weight = 1 [default = 1];</code>
       * @return Whether the taskLossWeight field is set.
       */
      @java.lang.Override
      public boolean hasTaskLossWeight() {
        return ((bitField0_ & 0x00000001) != 0);
      }
      /**
       * <pre>
       * Weight of the task loss. The total loss of the model will be their
       * summation of task losses weighted by the weights.
       * </pre>
       *
       * <code>optional float task_loss_weight = 1 [default = 1];</code>
       * @return The taskLossWeight.
       */
      @java.lang.Override
      public float getTaskLossWeight() {
        return taskLossWeight_;
      }

      public static final int CLASSIFICATION_LOSS_FIELD_NUMBER = 2;
      private object_detection.protos.Losses.ClassificationLoss classificationLoss_;
      /**
       * <pre>
       * Classification loss configuration for segmentation loss.
       * </pre>
       *
       * <code>optional .object_detection.protos.ClassificationLoss classification_loss = 2;</code>
       * @return Whether the classificationLoss field is set.
       */
      @java.lang.Override
      public boolean hasClassificationLoss() {
        return ((bitField0_ & 0x00000002) != 0);
      }
      /**
       * <pre>
       * Classification loss configuration for segmentation loss.
       * </pre>
       *
       * <code>optional .object_detection.protos.ClassificationLoss classification_loss = 2;</code>
       * @return The classificationLoss.
       */
      @java.lang.Override
      public object_detection.protos.Losses.ClassificationLoss getClassificationLoss() {
        return classificationLoss_ == null ? object_detection.protos.Losses.ClassificationLoss.getDefaultInstance() : classificationLoss_;
      }
      /**
       * <pre>
       * Classification loss configuration for segmentation loss.
       * </pre>
       *
       * <code>optional .object_detection.protos.ClassificationLoss classification_loss = 2;</code>
       */
      @java.lang.Override
      public object_detection.protos.Losses.ClassificationLossOrBuilder getClassificationLossOrBuilder() {
        return classificationLoss_ == null ? object_detection.protos.Losses.ClassificationLoss.getDefaultInstance() : classificationLoss_;
      }

      public static final int MASK_HEIGHT_FIELD_NUMBER = 4;
      private int maskHeight_;
      /**
       * <pre>
       * Each instance mask (one per detection) is cropped and resized (bilinear
       * resampling) from the predicted segmentation feature map. After
       * resampling, the masks are binarized with the provided score threshold.
       * </pre>
       *
       * <code>optional int32 mask_height = 4 [default = 256];</code>
       * @return Whether the maskHeight field is set.
       */
      @java.lang.Override
      public boolean hasMaskHeight() {
        return ((bitField0_ & 0x00000004) != 0);
      }
      /**
       * <pre>
       * Each instance mask (one per detection) is cropped and resized (bilinear
       * resampling) from the predicted segmentation feature map. After
       * resampling, the masks are binarized with the provided score threshold.
       * </pre>
       *
       * <code>optional int32 mask_height = 4 [default = 256];</code>
       * @return The maskHeight.
       */
      @java.lang.Override
      public int getMaskHeight() {
        return maskHeight_;
      }

      public static final int MASK_WIDTH_FIELD_NUMBER = 5;
      private int maskWidth_;
      /**
       * <code>optional int32 mask_width = 5 [default = 256];</code>
       * @return Whether the maskWidth field is set.
       */
      @java.lang.Override
      public boolean hasMaskWidth() {
        return ((bitField0_ & 0x00000008) != 0);
      }
      /**
       * <code>optional int32 mask_width = 5 [default = 256];</code>
       * @return The maskWidth.
       */
      @java.lang.Override
      public int getMaskWidth() {
        return maskWidth_;
      }

      public static final int SCORE_THRESHOLD_FIELD_NUMBER = 6;
      private float scoreThreshold_;
      /**
       * <code>optional float score_threshold = 6 [default = 0.5];</code>
       * @return Whether the scoreThreshold field is set.
       */
      @java.lang.Override
      public boolean hasScoreThreshold() {
        return ((bitField0_ & 0x00000010) != 0);
      }
      /**
       * <code>optional float score_threshold = 6 [default = 0.5];</code>
       * @return The scoreThreshold.
       */
      @java.lang.Override
      public float getScoreThreshold() {
        return scoreThreshold_;
      }

      public static final int HEATMAP_BIAS_INIT_FIELD_NUMBER = 3;
      private float heatmapBiasInit_;
      /**
       * <pre>
       * The initial bias value of the convlution kernel of the class heatmap
       * prediction head. -2.19 corresponds to predicting foreground with
       * a probability of 0.1.
       * </pre>
       *
       * <code>optional float heatmap_bias_init = 3 [default = -2.19];</code>
       * @return Whether the heatmapBiasInit field is set.
       */
      @java.lang.Override
      public boolean hasHeatmapBiasInit() {
        return ((bitField0_ & 0x00000020) != 0);
      }
      /**
       * <pre>
       * The initial bias value of the convlution kernel of the class heatmap
       * prediction head. -2.19 corresponds to predicting foreground with
       * a probability of 0.1.
       * </pre>
       *
       * <code>optional float heatmap_bias_init = 3 [default = -2.19];</code>
       * @return The heatmapBiasInit.
       */
      @java.lang.Override
      public float getHeatmapBiasInit() {
        return heatmapBiasInit_;
      }

      private byte memoizedIsInitialized = -1;
      @java.lang.Override
      public final boolean isInitialized() {
        byte isInitialized = memoizedIsInitialized;
        if (isInitialized == 1) return true;
        if (isInitialized == 0) return false;

        memoizedIsInitialized = 1;
        return true;
      }

      @java.lang.Override
      public void writeTo(com.google.protobuf.CodedOutputStream output)
                          throws java.io.IOException {
        if (((bitField0_ & 0x00000001) != 0)) {
          output.writeFloat(1, taskLossWeight_);
        }
        if (((bitField0_ & 0x00000002) != 0)) {
          output.writeMessage(2, getClassificationLoss());
        }
        if (((bitField0_ & 0x00000020) != 0)) {
          output.writeFloat(3, heatmapBiasInit_);
        }
        if (((bitField0_ & 0x00000004) != 0)) {
          output.writeInt32(4, maskHeight_);
        }
        if (((bitField0_ & 0x00000008) != 0)) {
          output.writeInt32(5, maskWidth_);
        }
        if (((bitField0_ & 0x00000010) != 0)) {
          output.writeFloat(6, scoreThreshold_);
        }
        unknownFields.writeTo(output);
      }

      @java.lang.Override
      public int getSerializedSize() {
        int size = memoizedSize;
        if (size != -1) return size;

        size = 0;
        if (((bitField0_ & 0x00000001) != 0)) {
          size += com.google.protobuf.CodedOutputStream
            .computeFloatSize(1, taskLossWeight_);
        }
        if (((bitField0_ & 0x00000002) != 0)) {
          size += com.google.protobuf.CodedOutputStream
            .computeMessageSize(2, getClassificationLoss());
        }
        if (((bitField0_ & 0x00000020) != 0)) {
          size += com.google.protobuf.CodedOutputStream
            .computeFloatSize(3, heatmapBiasInit_);
        }
        if (((bitField0_ & 0x00000004) != 0)) {
          size += com.google.protobuf.CodedOutputStream
            .computeInt32Size(4, maskHeight_);
        }
        if (((bitField0_ & 0x00000008) != 0)) {
          size += com.google.protobuf.CodedOutputStream
            .computeInt32Size(5, maskWidth_);
        }
        if (((bitField0_ & 0x00000010) != 0)) {
          size += com.google.protobuf.CodedOutputStream
            .computeFloatSize(6, scoreThreshold_);
        }
        size += unknownFields.getSerializedSize();
        memoizedSize = size;
        return size;
      }

      @java.lang.Override
      public boolean equals(final java.lang.Object obj) {
        if (obj == this) {
         return true;
        }
        if (!(obj instanceof object_detection.protos.CenterNetOuterClass.CenterNet.MaskEstimation)) {
          return super.equals(obj);
        }
        object_detection.protos.CenterNetOuterClass.CenterNet.MaskEstimation other = (object_detection.protos.CenterNetOuterClass.CenterNet.MaskEstimation) obj;

        if (hasTaskLossWeight() != other.hasTaskLossWeight()) return false;
        if (hasTaskLossWeight()) {
          if (java.lang.Float.floatToIntBits(getTaskLossWeight())
              != java.lang.Float.floatToIntBits(
                  other.getTaskLossWeight())) return false;
        }
        if (hasClassificationLoss() != other.hasClassificationLoss()) return false;
        if (hasClassificationLoss()) {
          if (!getClassificationLoss()
              .equals(other.getClassificationLoss())) return false;
        }
        if (hasMaskHeight() != other.hasMaskHeight()) return false;
        if (hasMaskHeight()) {
          if (getMaskHeight()
              != other.getMaskHeight()) return false;
        }
        if (hasMaskWidth() != other.hasMaskWidth()) return false;
        if (hasMaskWidth()) {
          if (getMaskWidth()
              != other.getMaskWidth()) return false;
        }
        if (hasScoreThreshold() != other.hasScoreThreshold()) return false;
        if (hasScoreThreshold()) {
          if (java.lang.Float.floatToIntBits(getScoreThreshold())
              != java.lang.Float.floatToIntBits(
                  other.getScoreThreshold())) return false;
        }
        if (hasHeatmapBiasInit() != other.hasHeatmapBiasInit()) return false;
        if (hasHeatmapBiasInit()) {
          if (java.lang.Float.floatToIntBits(getHeatmapBiasInit())
              != java.lang.Float.floatToIntBits(
                  other.getHeatmapBiasInit())) return false;
        }
        if (!unknownFields.equals(other.unknownFields)) return false;
        return true;
      }

      @java.lang.Override
      public int hashCode() {
        if (memoizedHashCode != 0) {
          return memoizedHashCode;
        }
        int hash = 41;
        hash = (19 * hash) + getDescriptor().hashCode();
        if (hasTaskLossWeight()) {
          hash = (37 * hash) + TASK_LOSS_WEIGHT_FIELD_NUMBER;
          hash = (53 * hash) + java.lang.Float.floatToIntBits(
              getTaskLossWeight());
        }
        if (hasClassificationLoss()) {
          hash = (37 * hash) + CLASSIFICATION_LOSS_FIELD_NUMBER;
          hash = (53 * hash) + getClassificationLoss().hashCode();
        }
        if (hasMaskHeight()) {
          hash = (37 * hash) + MASK_HEIGHT_FIELD_NUMBER;
          hash = (53 * hash) + getMaskHeight();
        }
        if (hasMaskWidth()) {
          hash = (37 * hash) + MASK_WIDTH_FIELD_NUMBER;
          hash = (53 * hash) + getMaskWidth();
        }
        if (hasScoreThreshold()) {
          hash = (37 * hash) + SCORE_THRESHOLD_FIELD_NUMBER;
          hash = (53 * hash) + java.lang.Float.floatToIntBits(
              getScoreThreshold());
        }
        if (hasHeatmapBiasInit()) {
          hash = (37 * hash) + HEATMAP_BIAS_INIT_FIELD_NUMBER;
          hash = (53 * hash) + java.lang.Float.floatToIntBits(
              getHeatmapBiasInit());
        }
        hash = (29 * hash) + unknownFields.hashCode();
        memoizedHashCode = hash;
        return hash;
      }

      public static object_detection.protos.CenterNetOuterClass.CenterNet.MaskEstimation parseFrom(
          java.nio.ByteBuffer data)
          throws com.google.protobuf.InvalidProtocolBufferException {
        return PARSER.parseFrom(data);
      }
      public static object_detection.protos.CenterNetOuterClass.CenterNet.MaskEstimation parseFrom(
          java.nio.ByteBuffer data,
          com.google.protobuf.ExtensionRegistryLite extensionRegistry)
          throws com.google.protobuf.InvalidProtocolBufferException {
        return PARSER.parseFrom(data, extensionRegistry);
      }
      public static object_detection.protos.CenterNetOuterClass.CenterNet.MaskEstimation parseFrom(
          com.google.protobuf.ByteString data)
          throws com.google.protobuf.InvalidProtocolBufferException {
        return PARSER.parseFrom(data);
      }
      public static object_detection.protos.CenterNetOuterClass.CenterNet.MaskEstimation parseFrom(
          com.google.protobuf.ByteString data,
          com.google.protobuf.ExtensionRegistryLite extensionRegistry)
          throws com.google.protobuf.InvalidProtocolBufferException {
        return PARSER.parseFrom(data, extensionRegistry);
      }
      public static object_detection.protos.CenterNetOuterClass.CenterNet.MaskEstimation parseFrom(byte[] data)
          throws com.google.protobuf.InvalidProtocolBufferException {
        return PARSER.parseFrom(data);
      }
      public static object_detection.protos.CenterNetOuterClass.CenterNet.MaskEstimation parseFrom(
          byte[] data,
          com.google.protobuf.ExtensionRegistryLite extensionRegistry)
          throws com.google.protobuf.InvalidProtocolBufferException {
        return PARSER.parseFrom(data, extensionRegistry);
      }
      public static object_detection.protos.CenterNetOuterClass.CenterNet.MaskEstimation parseFrom(java.io.InputStream input)
          throws java.io.IOException {
        return com.google.protobuf.GeneratedMessageV3
            .parseWithIOException(PARSER, input);
      }
      public static object_detection.protos.CenterNetOuterClass.CenterNet.MaskEstimation parseFrom(
          java.io.InputStream input,
          com.google.protobuf.ExtensionRegistryLite extensionRegistry)
          throws java.io.IOException {
        return com.google.protobuf.GeneratedMessageV3
            .parseWithIOException(PARSER, input, extensionRegistry);
      }
      public static object_detection.protos.CenterNetOuterClass.CenterNet.MaskEstimation parseDelimitedFrom(java.io.InputStream input)
          throws java.io.IOException {
        return com.google.protobuf.GeneratedMessageV3
            .parseDelimitedWithIOException(PARSER, input);
      }
      public static object_detection.protos.CenterNetOuterClass.CenterNet.MaskEstimation parseDelimitedFrom(
          java.io.InputStream input,
          com.google.protobuf.ExtensionRegistryLite extensionRegistry)
          throws java.io.IOException {
        return com.google.protobuf.GeneratedMessageV3
            .parseDelimitedWithIOException(PARSER, input, extensionRegistry);
      }
      public static object_detection.protos.CenterNetOuterClass.CenterNet.MaskEstimation parseFrom(
          com.google.protobuf.CodedInputStream input)
          throws java.io.IOException {
        return com.google.protobuf.GeneratedMessageV3
            .parseWithIOException(PARSER, input);
      }
      public static object_detection.protos.CenterNetOuterClass.CenterNet.MaskEstimation parseFrom(
          com.google.protobuf.CodedInputStream input,
          com.google.protobuf.ExtensionRegistryLite extensionRegistry)
          throws java.io.IOException {
        return com.google.protobuf.GeneratedMessageV3
            .parseWithIOException(PARSER, input, extensionRegistry);
      }

      @java.lang.Override
      public Builder newBuilderForType() { return newBuilder(); }
      public static Builder newBuilder() {
        return DEFAULT_INSTANCE.toBuilder();
      }
      public static Builder newBuilder(object_detection.protos.CenterNetOuterClass.CenterNet.MaskEstimation prototype) {
        return DEFAULT_INSTANCE.toBuilder().mergeFrom(prototype);
      }
      @java.lang.Override
      public Builder toBuilder() {
        return this == DEFAULT_INSTANCE
            ? new Builder() : new Builder().mergeFrom(this);
      }

      @java.lang.Override
      protected Builder newBuilderForType(
          com.google.protobuf.GeneratedMessageV3.BuilderParent parent) {
        Builder builder = new Builder(parent);
        return builder;
      }
      /**
       * <pre>
       * Parameters which are related to mask estimation task.
       * Note: Currently, CenterNet supports a weak instance segmentation, where
       * semantic segmentation masks are estimated, and then cropped based on
       * bounding box detections. Therefore, it is possible for the same image
       * pixel to be assigned to multiple instances.
       * </pre>
       *
       * Protobuf type {@code object_detection.protos.CenterNet.MaskEstimation}
       */
      public static final class Builder extends
          com.google.protobuf.GeneratedMessageV3.Builder<Builder> implements
          // @@protoc_insertion_point(builder_implements:object_detection.protos.CenterNet.MaskEstimation)
          object_detection.protos.CenterNetOuterClass.CenterNet.MaskEstimationOrBuilder {
        public static final com.google.protobuf.Descriptors.Descriptor
            getDescriptor() {
          return object_detection.protos.CenterNetOuterClass.internal_static_object_detection_protos_CenterNet_MaskEstimation_descriptor;
        }

        @java.lang.Override
        protected com.google.protobuf.GeneratedMessageV3.FieldAccessorTable
            internalGetFieldAccessorTable() {
          return object_detection.protos.CenterNetOuterClass.internal_static_object_detection_protos_CenterNet_MaskEstimation_fieldAccessorTable
              .ensureFieldAccessorsInitialized(
                  object_detection.protos.CenterNetOuterClass.CenterNet.MaskEstimation.class, object_detection.protos.CenterNetOuterClass.CenterNet.MaskEstimation.Builder.class);
        }

        // Construct using object_detection.protos.CenterNetOuterClass.CenterNet.MaskEstimation.newBuilder()
        private Builder() {
          maybeForceBuilderInitialization();
        }

        private Builder(
            com.google.protobuf.GeneratedMessageV3.BuilderParent parent) {
          super(parent);
          maybeForceBuilderInitialization();
        }
        private void maybeForceBuilderInitialization() {
          if (com.google.protobuf.GeneratedMessageV3
                  .alwaysUseFieldBuilders) {
            getClassificationLossFieldBuilder();
          }
        }
        @java.lang.Override
        public Builder clear() {
          super.clear();
          taskLossWeight_ = 1F;
          bitField0_ = (bitField0_ & ~0x00000001);
          if (classificationLossBuilder_ == null) {
            classificationLoss_ = null;
          } else {
            classificationLossBuilder_.clear();
          }
          bitField0_ = (bitField0_ & ~0x00000002);
          maskHeight_ = 256;
          bitField0_ = (bitField0_ & ~0x00000004);
          maskWidth_ = 256;
          bitField0_ = (bitField0_ & ~0x00000008);
          scoreThreshold_ = 0.5F;
          bitField0_ = (bitField0_ & ~0x00000010);
          heatmapBiasInit_ = -2.19F;
          bitField0_ = (bitField0_ & ~0x00000020);
          return this;
        }

        @java.lang.Override
        public com.google.protobuf.Descriptors.Descriptor
            getDescriptorForType() {
          return object_detection.protos.CenterNetOuterClass.internal_static_object_detection_protos_CenterNet_MaskEstimation_descriptor;
        }

        @java.lang.Override
        public object_detection.protos.CenterNetOuterClass.CenterNet.MaskEstimation getDefaultInstanceForType() {
          return object_detection.protos.CenterNetOuterClass.CenterNet.MaskEstimation.getDefaultInstance();
        }

        @java.lang.Override
        public object_detection.protos.CenterNetOuterClass.CenterNet.MaskEstimation build() {
          object_detection.protos.CenterNetOuterClass.CenterNet.MaskEstimation result = buildPartial();
          if (!result.isInitialized()) {
            throw newUninitializedMessageException(result);
          }
          return result;
        }

        @java.lang.Override
        public object_detection.protos.CenterNetOuterClass.CenterNet.MaskEstimation buildPartial() {
          object_detection.protos.CenterNetOuterClass.CenterNet.MaskEstimation result = new object_detection.protos.CenterNetOuterClass.CenterNet.MaskEstimation(this);
          int from_bitField0_ = bitField0_;
          int to_bitField0_ = 0;
          if (((from_bitField0_ & 0x00000001) != 0)) {
            to_bitField0_ |= 0x00000001;
          }
          result.taskLossWeight_ = taskLossWeight_;
          if (((from_bitField0_ & 0x00000002) != 0)) {
            if (classificationLossBuilder_ == null) {
              result.classificationLoss_ = classificationLoss_;
            } else {
              result.classificationLoss_ = classificationLossBuilder_.build();
            }
            to_bitField0_ |= 0x00000002;
          }
          if (((from_bitField0_ & 0x00000004) != 0)) {
            to_bitField0_ |= 0x00000004;
          }
          result.maskHeight_ = maskHeight_;
          if (((from_bitField0_ & 0x00000008) != 0)) {
            to_bitField0_ |= 0x00000008;
          }
          result.maskWidth_ = maskWidth_;
          if (((from_bitField0_ & 0x00000010) != 0)) {
            to_bitField0_ |= 0x00000010;
          }
          result.scoreThreshold_ = scoreThreshold_;
          if (((from_bitField0_ & 0x00000020) != 0)) {
            to_bitField0_ |= 0x00000020;
          }
          result.heatmapBiasInit_ = heatmapBiasInit_;
          result.bitField0_ = to_bitField0_;
          onBuilt();
          return result;
        }

        @java.lang.Override
        public Builder clone() {
          return super.clone();
        }
        @java.lang.Override
        public Builder setField(
            com.google.protobuf.Descriptors.FieldDescriptor field,
            java.lang.Object value) {
          return super.setField(field, value);
        }
        @java.lang.Override
        public Builder clearField(
            com.google.protobuf.Descriptors.FieldDescriptor field) {
          return super.clearField(field);
        }
        @java.lang.Override
        public Builder clearOneof(
            com.google.protobuf.Descriptors.OneofDescriptor oneof) {
          return super.clearOneof(oneof);
        }
        @java.lang.Override
        public Builder setRepeatedField(
            com.google.protobuf.Descriptors.FieldDescriptor field,
            int index, java.lang.Object value) {
          return super.setRepeatedField(field, index, value);
        }
        @java.lang.Override
        public Builder addRepeatedField(
            com.google.protobuf.Descriptors.FieldDescriptor field,
            java.lang.Object value) {
          return super.addRepeatedField(field, value);
        }
        @java.lang.Override
        public Builder mergeFrom(com.google.protobuf.Message other) {
          if (other instanceof object_detection.protos.CenterNetOuterClass.CenterNet.MaskEstimation) {
            return mergeFrom((object_detection.protos.CenterNetOuterClass.CenterNet.MaskEstimation)other);
          } else {
            super.mergeFrom(other);
            return this;
          }
        }

        public Builder mergeFrom(object_detection.protos.CenterNetOuterClass.CenterNet.MaskEstimation other) {
          if (other == object_detection.protos.CenterNetOuterClass.CenterNet.MaskEstimation.getDefaultInstance()) return this;
          if (other.hasTaskLossWeight()) {
            setTaskLossWeight(other.getTaskLossWeight());
          }
          if (other.hasClassificationLoss()) {
            mergeClassificationLoss(other.getClassificationLoss());
          }
          if (other.hasMaskHeight()) {
            setMaskHeight(other.getMaskHeight());
          }
          if (other.hasMaskWidth()) {
            setMaskWidth(other.getMaskWidth());
          }
          if (other.hasScoreThreshold()) {
            setScoreThreshold(other.getScoreThreshold());
          }
          if (other.hasHeatmapBiasInit()) {
            setHeatmapBiasInit(other.getHeatmapBiasInit());
          }
          this.mergeUnknownFields(other.unknownFields);
          onChanged();
          return this;
        }

        @java.lang.Override
        public final boolean isInitialized() {
          return true;
        }

        @java.lang.Override
        public Builder mergeFrom(
            com.google.protobuf.CodedInputStream input,
            com.google.protobuf.ExtensionRegistryLite extensionRegistry)
            throws java.io.IOException {
          object_detection.protos.CenterNetOuterClass.CenterNet.MaskEstimation parsedMessage = null;
          try {
            parsedMessage = PARSER.parsePartialFrom(input, extensionRegistry);
          } catch (com.google.protobuf.InvalidProtocolBufferException e) {
            parsedMessage = (object_detection.protos.CenterNetOuterClass.CenterNet.MaskEstimation) e.getUnfinishedMessage();
            throw e.unwrapIOException();
          } finally {
            if (parsedMessage != null) {
              mergeFrom(parsedMessage);
            }
          }
          return this;
        }
        private int bitField0_;

        private float taskLossWeight_ = 1F;
        /**
         * <pre>
         * Weight of the task loss. The total loss of the model will be their
         * summation of task losses weighted by the weights.
         * </pre>
         *
         * <code>optional float task_loss_weight = 1 [default = 1];</code>
         * @return Whether the taskLossWeight field is set.
         */
        @java.lang.Override
        public boolean hasTaskLossWeight() {
          return ((bitField0_ & 0x00000001) != 0);
        }
        /**
         * <pre>
         * Weight of the task loss. The total loss of the model will be their
         * summation of task losses weighted by the weights.
         * </pre>
         *
         * <code>optional float task_loss_weight = 1 [default = 1];</code>
         * @return The taskLossWeight.
         */
        @java.lang.Override
        public float getTaskLossWeight() {
          return taskLossWeight_;
        }
        /**
         * <pre>
         * Weight of the task loss. The total loss of the model will be their
         * summation of task losses weighted by the weights.
         * </pre>
         *
         * <code>optional float task_loss_weight = 1 [default = 1];</code>
         * @param value The taskLossWeight to set.
         * @return This builder for chaining.
         */
        public Builder setTaskLossWeight(float value) {
          bitField0_ |= 0x00000001;
          taskLossWeight_ = value;
          onChanged();
          return this;
        }
        /**
         * <pre>
         * Weight of the task loss. The total loss of the model will be their
         * summation of task losses weighted by the weights.
         * </pre>
         *
         * <code>optional float task_loss_weight = 1 [default = 1];</code>
         * @return This builder for chaining.
         */
        public Builder clearTaskLossWeight() {
          bitField0_ = (bitField0_ & ~0x00000001);
          taskLossWeight_ = 1F;
          onChanged();
          return this;
        }

        private object_detection.protos.Losses.ClassificationLoss classificationLoss_;
        private com.google.protobuf.SingleFieldBuilderV3<
            object_detection.protos.Losses.ClassificationLoss, object_detection.protos.Losses.ClassificationLoss.Builder, object_detection.protos.Losses.ClassificationLossOrBuilder> classificationLossBuilder_;
        /**
         * <pre>
         * Classification loss configuration for segmentation loss.
         * </pre>
         *
         * <code>optional .object_detection.protos.ClassificationLoss classification_loss = 2;</code>
         * @return Whether the classificationLoss field is set.
         */
        public boolean hasClassificationLoss() {
          return ((bitField0_ & 0x00000002) != 0);
        }
        /**
         * <pre>
         * Classification loss configuration for segmentation loss.
         * </pre>
         *
         * <code>optional .object_detection.protos.ClassificationLoss classification_loss = 2;</code>
         * @return The classificationLoss.
         */
        public object_detection.protos.Losses.ClassificationLoss getClassificationLoss() {
          if (classificationLossBuilder_ == null) {
            return classificationLoss_ == null ? object_detection.protos.Losses.ClassificationLoss.getDefaultInstance() : classificationLoss_;
          } else {
            return classificationLossBuilder_.getMessage();
          }
        }
        /**
         * <pre>
         * Classification loss configuration for segmentation loss.
         * </pre>
         *
         * <code>optional .object_detection.protos.ClassificationLoss classification_loss = 2;</code>
         */
        public Builder setClassificationLoss(object_detection.protos.Losses.ClassificationLoss value) {
          if (classificationLossBuilder_ == null) {
            if (value == null) {
              throw new NullPointerException();
            }
            classificationLoss_ = value;
            onChanged();
          } else {
            classificationLossBuilder_.setMessage(value);
          }
          bitField0_ |= 0x00000002;
          return this;
        }
        /**
         * <pre>
         * Classification loss configuration for segmentation loss.
         * </pre>
         *
         * <code>optional .object_detection.protos.ClassificationLoss classification_loss = 2;</code>
         */
        public Builder setClassificationLoss(
            object_detection.protos.Losses.ClassificationLoss.Builder builderForValue) {
          if (classificationLossBuilder_ == null) {
            classificationLoss_ = builderForValue.build();
            onChanged();
          } else {
            classificationLossBuilder_.setMessage(builderForValue.build());
          }
          bitField0_ |= 0x00000002;
          return this;
        }
        /**
         * <pre>
         * Classification loss configuration for segmentation loss.
         * </pre>
         *
         * <code>optional .object_detection.protos.ClassificationLoss classification_loss = 2;</code>
         */
        public Builder mergeClassificationLoss(object_detection.protos.Losses.ClassificationLoss value) {
          if (classificationLossBuilder_ == null) {
            if (((bitField0_ & 0x00000002) != 0) &&
                classificationLoss_ != null &&
                classificationLoss_ != object_detection.protos.Losses.ClassificationLoss.getDefaultInstance()) {
              classificationLoss_ =
                object_detection.protos.Losses.ClassificationLoss.newBuilder(classificationLoss_).mergeFrom(value).buildPartial();
            } else {
              classificationLoss_ = value;
            }
            onChanged();
          } else {
            classificationLossBuilder_.mergeFrom(value);
          }
          bitField0_ |= 0x00000002;
          return this;
        }
        /**
         * <pre>
         * Classification loss configuration for segmentation loss.
         * </pre>
         *
         * <code>optional .object_detection.protos.ClassificationLoss classification_loss = 2;</code>
         */
        public Builder clearClassificationLoss() {
          if (classificationLossBuilder_ == null) {
            classificationLoss_ = null;
            onChanged();
          } else {
            classificationLossBuilder_.clear();
          }
          bitField0_ = (bitField0_ & ~0x00000002);
          return this;
        }
        /**
         * <pre>
         * Classification loss configuration for segmentation loss.
         * </pre>
         *
         * <code>optional .object_detection.protos.ClassificationLoss classification_loss = 2;</code>
         */
        public object_detection.protos.Losses.ClassificationLoss.Builder getClassificationLossBuilder() {
          bitField0_ |= 0x00000002;
          onChanged();
          return getClassificationLossFieldBuilder().getBuilder();
        }
        /**
         * <pre>
         * Classification loss configuration for segmentation loss.
         * </pre>
         *
         * <code>optional .object_detection.protos.ClassificationLoss classification_loss = 2;</code>
         */
        public object_detection.protos.Losses.ClassificationLossOrBuilder getClassificationLossOrBuilder() {
          if (classificationLossBuilder_ != null) {
            return classificationLossBuilder_.getMessageOrBuilder();
          } else {
            return classificationLoss_ == null ?
                object_detection.protos.Losses.ClassificationLoss.getDefaultInstance() : classificationLoss_;
          }
        }
        /**
         * <pre>
         * Classification loss configuration for segmentation loss.
         * </pre>
         *
         * <code>optional .object_detection.protos.ClassificationLoss classification_loss = 2;</code>
         */
        private com.google.protobuf.SingleFieldBuilderV3<
            object_detection.protos.Losses.ClassificationLoss, object_detection.protos.Losses.ClassificationLoss.Builder, object_detection.protos.Losses.ClassificationLossOrBuilder>
            getClassificationLossFieldBuilder() {
          if (classificationLossBuilder_ == null) {
            classificationLossBuilder_ = new com.google.protobuf.SingleFieldBuilderV3<
                object_detection.protos.Losses.ClassificationLoss, object_detection.protos.Losses.ClassificationLoss.Builder, object_detection.protos.Losses.ClassificationLossOrBuilder>(
                    getClassificationLoss(),
                    getParentForChildren(),
                    isClean());
            classificationLoss_ = null;
          }
          return classificationLossBuilder_;
        }

        private int maskHeight_ = 256;
        /**
         * <pre>
         * Each instance mask (one per detection) is cropped and resized (bilinear
         * resampling) from the predicted segmentation feature map. After
         * resampling, the masks are binarized with the provided score threshold.
         * </pre>
         *
         * <code>optional int32 mask_height = 4 [default = 256];</code>
         * @return Whether the maskHeight field is set.
         */
        @java.lang.Override
        public boolean hasMaskHeight() {
          return ((bitField0_ & 0x00000004) != 0);
        }
        /**
         * <pre>
         * Each instance mask (one per detection) is cropped and resized (bilinear
         * resampling) from the predicted segmentation feature map. After
         * resampling, the masks are binarized with the provided score threshold.
         * </pre>
         *
         * <code>optional int32 mask_height = 4 [default = 256];</code>
         * @return The maskHeight.
         */
        @java.lang.Override
        public int getMaskHeight() {
          return maskHeight_;
        }
        /**
         * <pre>
         * Each instance mask (one per detection) is cropped and resized (bilinear
         * resampling) from the predicted segmentation feature map. After
         * resampling, the masks are binarized with the provided score threshold.
         * </pre>
         *
         * <code>optional int32 mask_height = 4 [default = 256];</code>
         * @param value The maskHeight to set.
         * @return This builder for chaining.
         */
        public Builder setMaskHeight(int value) {
          bitField0_ |= 0x00000004;
          maskHeight_ = value;
          onChanged();
          return this;
        }
        /**
         * <pre>
         * Each instance mask (one per detection) is cropped and resized (bilinear
         * resampling) from the predicted segmentation feature map. After
         * resampling, the masks are binarized with the provided score threshold.
         * </pre>
         *
         * <code>optional int32 mask_height = 4 [default = 256];</code>
         * @return This builder for chaining.
         */
        public Builder clearMaskHeight() {
          bitField0_ = (bitField0_ & ~0x00000004);
          maskHeight_ = 256;
          onChanged();
          return this;
        }

        private int maskWidth_ = 256;
        /**
         * <code>optional int32 mask_width = 5 [default = 256];</code>
         * @return Whether the maskWidth field is set.
         */
        @java.lang.Override
        public boolean hasMaskWidth() {
          return ((bitField0_ & 0x00000008) != 0);
        }
        /**
         * <code>optional int32 mask_width = 5 [default = 256];</code>
         * @return The maskWidth.
         */
        @java.lang.Override
        public int getMaskWidth() {
          return maskWidth_;
        }
        /**
         * <code>optional int32 mask_width = 5 [default = 256];</code>
         * @param value The maskWidth to set.
         * @return This builder for chaining.
         */
        public Builder setMaskWidth(int value) {
          bitField0_ |= 0x00000008;
          maskWidth_ = value;
          onChanged();
          return this;
        }
        /**
         * <code>optional int32 mask_width = 5 [default = 256];</code>
         * @return This builder for chaining.
         */
        public Builder clearMaskWidth() {
          bitField0_ = (bitField0_ & ~0x00000008);
          maskWidth_ = 256;
          onChanged();
          return this;
        }

        private float scoreThreshold_ = 0.5F;
        /**
         * <code>optional float score_threshold = 6 [default = 0.5];</code>
         * @return Whether the scoreThreshold field is set.
         */
        @java.lang.Override
        public boolean hasScoreThreshold() {
          return ((bitField0_ & 0x00000010) != 0);
        }
        /**
         * <code>optional float score_threshold = 6 [default = 0.5];</code>
         * @return The scoreThreshold.
         */
        @java.lang.Override
        public float getScoreThreshold() {
          return scoreThreshold_;
        }
        /**
         * <code>optional float score_threshold = 6 [default = 0.5];</code>
         * @param value The scoreThreshold to set.
         * @return This builder for chaining.
         */
        public Builder setScoreThreshold(float value) {
          bitField0_ |= 0x00000010;
          scoreThreshold_ = value;
          onChanged();
          return this;
        }
        /**
         * <code>optional float score_threshold = 6 [default = 0.5];</code>
         * @return This builder for chaining.
         */
        public Builder clearScoreThreshold() {
          bitField0_ = (bitField0_ & ~0x00000010);
          scoreThreshold_ = 0.5F;
          onChanged();
          return this;
        }

        private float heatmapBiasInit_ = -2.19F;
        /**
         * <pre>
         * The initial bias value of the convlution kernel of the class heatmap
         * prediction head. -2.19 corresponds to predicting foreground with
         * a probability of 0.1.
         * </pre>
         *
         * <code>optional float heatmap_bias_init = 3 [default = -2.19];</code>
         * @return Whether the heatmapBiasInit field is set.
         */
        @java.lang.Override
        public boolean hasHeatmapBiasInit() {
          return ((bitField0_ & 0x00000020) != 0);
        }
        /**
         * <pre>
         * The initial bias value of the convlution kernel of the class heatmap
         * prediction head. -2.19 corresponds to predicting foreground with
         * a probability of 0.1.
         * </pre>
         *
         * <code>optional float heatmap_bias_init = 3 [default = -2.19];</code>
         * @return The heatmapBiasInit.
         */
        @java.lang.Override
        public float getHeatmapBiasInit() {
          return heatmapBiasInit_;
        }
        /**
         * <pre>
         * The initial bias value of the convlution kernel of the class heatmap
         * prediction head. -2.19 corresponds to predicting foreground with
         * a probability of 0.1.
         * </pre>
         *
         * <code>optional float heatmap_bias_init = 3 [default = -2.19];</code>
         * @param value The heatmapBiasInit to set.
         * @return This builder for chaining.
         */
        public Builder setHeatmapBiasInit(float value) {
          bitField0_ |= 0x00000020;
          heatmapBiasInit_ = value;
          onChanged();
          return this;
        }
        /**
         * <pre>
         * The initial bias value of the convlution kernel of the class heatmap
         * prediction head. -2.19 corresponds to predicting foreground with
         * a probability of 0.1.
         * </pre>
         *
         * <code>optional float heatmap_bias_init = 3 [default = -2.19];</code>
         * @return This builder for chaining.
         */
        public Builder clearHeatmapBiasInit() {
          bitField0_ = (bitField0_ & ~0x00000020);
          heatmapBiasInit_ = -2.19F;
          onChanged();
          return this;
        }
        @java.lang.Override
        public final Builder setUnknownFields(
            final com.google.protobuf.UnknownFieldSet unknownFields) {
          return super.setUnknownFields(unknownFields);
        }

        @java.lang.Override
        public final Builder mergeUnknownFields(
            final com.google.protobuf.UnknownFieldSet unknownFields) {
          return super.mergeUnknownFields(unknownFields);
        }


        // @@protoc_insertion_point(builder_scope:object_detection.protos.CenterNet.MaskEstimation)
      }

      // @@protoc_insertion_point(class_scope:object_detection.protos.CenterNet.MaskEstimation)
      private static final object_detection.protos.CenterNetOuterClass.CenterNet.MaskEstimation DEFAULT_INSTANCE;
      static {
        DEFAULT_INSTANCE = new object_detection.protos.CenterNetOuterClass.CenterNet.MaskEstimation();
      }

      public static object_detection.protos.CenterNetOuterClass.CenterNet.MaskEstimation getDefaultInstance() {
        return DEFAULT_INSTANCE;
      }

      @java.lang.Deprecated public static final com.google.protobuf.Parser<MaskEstimation>
          PARSER = new com.google.protobuf.AbstractParser<MaskEstimation>() {
        @java.lang.Override
        public MaskEstimation parsePartialFrom(
            com.google.protobuf.CodedInputStream input,
            com.google.protobuf.ExtensionRegistryLite extensionRegistry)
            throws com.google.protobuf.InvalidProtocolBufferException {
          return new MaskEstimation(input, extensionRegistry);
        }
      };

      public static com.google.protobuf.Parser<MaskEstimation> parser() {
        return PARSER;
      }

      @java.lang.Override
      public com.google.protobuf.Parser<MaskEstimation> getParserForType() {
        return PARSER;
      }

      @java.lang.Override
      public object_detection.protos.CenterNetOuterClass.CenterNet.MaskEstimation getDefaultInstanceForType() {
        return DEFAULT_INSTANCE;
      }

    }

    public interface DensePoseEstimationOrBuilder extends
        // @@protoc_insertion_point(interface_extends:object_detection.protos.CenterNet.DensePoseEstimation)
        com.google.protobuf.MessageOrBuilder {

      /**
       * <pre>
       * Weight of the task loss. The total loss of the model will be their
       * summation of task losses weighted by the weights.
       * </pre>
       *
       * <code>optional float task_loss_weight = 1 [default = 1];</code>
       * @return Whether the taskLossWeight field is set.
       */
      boolean hasTaskLossWeight();
      /**
       * <pre>
       * Weight of the task loss. The total loss of the model will be their
       * summation of task losses weighted by the weights.
       * </pre>
       *
       * <code>optional float task_loss_weight = 1 [default = 1];</code>
       * @return The taskLossWeight.
       */
      float getTaskLossWeight();

      /**
       * <pre>
       * Class ID (0-indexed) that corresponds to the object in the label map that
       * contains DensePose data.
       * </pre>
       *
       * <code>optional int32 class_id = 2;</code>
       * @return Whether the classId field is set.
       */
      boolean hasClassId();
      /**
       * <pre>
       * Class ID (0-indexed) that corresponds to the object in the label map that
       * contains DensePose data.
       * </pre>
       *
       * <code>optional int32 class_id = 2;</code>
       * @return The classId.
       */
      int getClassId();

      /**
       * <pre>
       * Loss configuration for DensePose heatmap and regression losses. Note
       * that the localization loss is used for surface coordinate losses and
       * classification loss is used for part classification losses.
       * </pre>
       *
       * <code>optional .object_detection.protos.Loss loss = 3;</code>
       * @return Whether the loss field is set.
       */
      boolean hasLoss();
      /**
       * <pre>
       * Loss configuration for DensePose heatmap and regression losses. Note
       * that the localization loss is used for surface coordinate losses and
       * classification loss is used for part classification losses.
       * </pre>
       *
       * <code>optional .object_detection.protos.Loss loss = 3;</code>
       * @return The loss.
       */
      object_detection.protos.Losses.Loss getLoss();
      /**
       * <pre>
       * Loss configuration for DensePose heatmap and regression losses. Note
       * that the localization loss is used for surface coordinate losses and
       * classification loss is used for part classification losses.
       * </pre>
       *
       * <code>optional .object_detection.protos.Loss loss = 3;</code>
       */
      object_detection.protos.Losses.LossOrBuilder getLossOrBuilder();

      /**
       * <pre>
       * The number of body parts.
       * </pre>
       *
       * <code>optional int32 num_parts = 4 [default = 24];</code>
       * @return Whether the numParts field is set.
       */
      boolean hasNumParts();
      /**
       * <pre>
       * The number of body parts.
       * </pre>
       *
       * <code>optional int32 num_parts = 4 [default = 24];</code>
       * @return The numParts.
       */
      int getNumParts();

      /**
       * <pre>
       * Loss weights for the two DensePose heads.
       * </pre>
       *
       * <code>optional float part_loss_weight = 5 [default = 1];</code>
       * @return Whether the partLossWeight field is set.
       */
      boolean hasPartLossWeight();
      /**
       * <pre>
       * Loss weights for the two DensePose heads.
       * </pre>
       *
       * <code>optional float part_loss_weight = 5 [default = 1];</code>
       * @return The partLossWeight.
       */
      float getPartLossWeight();

      /**
       * <code>optional float coordinate_loss_weight = 6 [default = 1];</code>
       * @return Whether the coordinateLossWeight field is set.
       */
      boolean hasCoordinateLossWeight();
      /**
       * <code>optional float coordinate_loss_weight = 6 [default = 1];</code>
       * @return The coordinateLossWeight.
       */
      float getCoordinateLossWeight();

      /**
       * <pre>
       * Whether to upsample the prediction feature maps back to the original
       * input dimension prior to applying loss. This has the benefit of
       * maintaining finer groundtruth location information.
       * </pre>
       *
       * <code>optional bool upsample_to_input_res = 7 [default = true];</code>
       * @return Whether the upsampleToInputRes field is set.
       */
      boolean hasUpsampleToInputRes();
      /**
       * <pre>
       * Whether to upsample the prediction feature maps back to the original
       * input dimension prior to applying loss. This has the benefit of
       * maintaining finer groundtruth location information.
       * </pre>
       *
       * <code>optional bool upsample_to_input_res = 7 [default = true];</code>
       * @return The upsampleToInputRes.
       */
      boolean getUpsampleToInputRes();

      /**
       * <pre>
       * The initial bias value of the convlution kernel of the class heatmap
       * prediction head. -2.19 corresponds to predicting foreground with
       * a probability of 0.1.
       * </pre>
       *
       * <code>optional float heatmap_bias_init = 8 [default = -2.19];</code>
       * @return Whether the heatmapBiasInit field is set.
       */
      boolean hasHeatmapBiasInit();
      /**
       * <pre>
       * The initial bias value of the convlution kernel of the class heatmap
       * prediction head. -2.19 corresponds to predicting foreground with
       * a probability of 0.1.
       * </pre>
       *
       * <code>optional float heatmap_bias_init = 8 [default = -2.19];</code>
       * @return The heatmapBiasInit.
       */
      float getHeatmapBiasInit();
    }
    /**
     * <pre>
     * Parameters which are related to DensePose estimation task.
     * http://densepose.org/
     * </pre>
     *
     * Protobuf type {@code object_detection.protos.CenterNet.DensePoseEstimation}
     */
    public static final class DensePoseEstimation extends
        com.google.protobuf.GeneratedMessageV3 implements
        // @@protoc_insertion_point(message_implements:object_detection.protos.CenterNet.DensePoseEstimation)
        DensePoseEstimationOrBuilder {
    private static final long serialVersionUID = 0L;
      // Use DensePoseEstimation.newBuilder() to construct.
      private DensePoseEstimation(com.google.protobuf.GeneratedMessageV3.Builder<?> builder) {
        super(builder);
      }
      private DensePoseEstimation() {
        taskLossWeight_ = 1F;
        numParts_ = 24;
        partLossWeight_ = 1F;
        coordinateLossWeight_ = 1F;
        upsampleToInputRes_ = true;
        heatmapBiasInit_ = -2.19F;
      }

      @java.lang.Override
      @SuppressWarnings({"unused"})
      protected java.lang.Object newInstance(
          UnusedPrivateParameter unused) {
        return new DensePoseEstimation();
      }

      @java.lang.Override
      public final com.google.protobuf.UnknownFieldSet
      getUnknownFields() {
        return this.unknownFields;
      }
      private DensePoseEstimation(
          com.google.protobuf.CodedInputStream input,
          com.google.protobuf.ExtensionRegistryLite extensionRegistry)
          throws com.google.protobuf.InvalidProtocolBufferException {
        this();
        if (extensionRegistry == null) {
          throw new java.lang.NullPointerException();
        }
        int mutable_bitField0_ = 0;
        com.google.protobuf.UnknownFieldSet.Builder unknownFields =
            com.google.protobuf.UnknownFieldSet.newBuilder();
        try {
          boolean done = false;
          while (!done) {
            int tag = input.readTag();
            switch (tag) {
              case 0:
                done = true;
                break;
              case 13: {
                bitField0_ |= 0x00000001;
                taskLossWeight_ = input.readFloat();
                break;
              }
              case 16: {
                bitField0_ |= 0x00000002;
                classId_ = input.readInt32();
                break;
              }
              case 26: {
                object_detection.protos.Losses.Loss.Builder subBuilder = null;
                if (((bitField0_ & 0x00000004) != 0)) {
                  subBuilder = loss_.toBuilder();
                }
                loss_ = input.readMessage(object_detection.protos.Losses.Loss.PARSER, extensionRegistry);
                if (subBuilder != null) {
                  subBuilder.mergeFrom(loss_);
                  loss_ = subBuilder.buildPartial();
                }
                bitField0_ |= 0x00000004;
                break;
              }
              case 32: {
                bitField0_ |= 0x00000008;
                numParts_ = input.readInt32();
                break;
              }
              case 45: {
                bitField0_ |= 0x00000010;
                partLossWeight_ = input.readFloat();
                break;
              }
              case 53: {
                bitField0_ |= 0x00000020;
                coordinateLossWeight_ = input.readFloat();
                break;
              }
              case 56: {
                bitField0_ |= 0x00000040;
                upsampleToInputRes_ = input.readBool();
                break;
              }
              case 69: {
                bitField0_ |= 0x00000080;
                heatmapBiasInit_ = input.readFloat();
                break;
              }
              default: {
                if (!parseUnknownField(
                    input, unknownFields, extensionRegistry, tag)) {
                  done = true;
                }
                break;
              }
            }
          }
        } catch (com.google.protobuf.InvalidProtocolBufferException e) {
          throw e.setUnfinishedMessage(this);
        } catch (java.io.IOException e) {
          throw new com.google.protobuf.InvalidProtocolBufferException(
              e).setUnfinishedMessage(this);
        } finally {
          this.unknownFields = unknownFields.build();
          makeExtensionsImmutable();
        }
      }
      public static final com.google.protobuf.Descriptors.Descriptor
          getDescriptor() {
        return object_detection.protos.CenterNetOuterClass.internal_static_object_detection_protos_CenterNet_DensePoseEstimation_descriptor;
      }

      @java.lang.Override
      protected com.google.protobuf.GeneratedMessageV3.FieldAccessorTable
          internalGetFieldAccessorTable() {
        return object_detection.protos.CenterNetOuterClass.internal_static_object_detection_protos_CenterNet_DensePoseEstimation_fieldAccessorTable
            .ensureFieldAccessorsInitialized(
                object_detection.protos.CenterNetOuterClass.CenterNet.DensePoseEstimation.class, object_detection.protos.CenterNetOuterClass.CenterNet.DensePoseEstimation.Builder.class);
      }

      private int bitField0_;
      public static final int TASK_LOSS_WEIGHT_FIELD_NUMBER = 1;
      private float taskLossWeight_;
      /**
       * <pre>
       * Weight of the task loss. The total loss of the model will be their
       * summation of task losses weighted by the weights.
       * </pre>
       *
       * <code>optional float task_loss_weight = 1 [default = 1];</code>
       * @return Whether the taskLossWeight field is set.
       */
      @java.lang.Override
      public boolean hasTaskLossWeight() {
        return ((bitField0_ & 0x00000001) != 0);
      }
      /**
       * <pre>
       * Weight of the task loss. The total loss of the model will be their
       * summation of task losses weighted by the weights.
       * </pre>
       *
       * <code>optional float task_loss_weight = 1 [default = 1];</code>
       * @return The taskLossWeight.
       */
      @java.lang.Override
      public float getTaskLossWeight() {
        return taskLossWeight_;
      }

      public static final int CLASS_ID_FIELD_NUMBER = 2;
      private int classId_;
      /**
       * <pre>
       * Class ID (0-indexed) that corresponds to the object in the label map that
       * contains DensePose data.
       * </pre>
       *
       * <code>optional int32 class_id = 2;</code>
       * @return Whether the classId field is set.
       */
      @java.lang.Override
      public boolean hasClassId() {
        return ((bitField0_ & 0x00000002) != 0);
      }
      /**
       * <pre>
       * Class ID (0-indexed) that corresponds to the object in the label map that
       * contains DensePose data.
       * </pre>
       *
       * <code>optional int32 class_id = 2;</code>
       * @return The classId.
       */
      @java.lang.Override
      public int getClassId() {
        return classId_;
      }

      public static final int LOSS_FIELD_NUMBER = 3;
      private object_detection.protos.Losses.Loss loss_;
      /**
       * <pre>
       * Loss configuration for DensePose heatmap and regression losses. Note
       * that the localization loss is used for surface coordinate losses and
       * classification loss is used for part classification losses.
       * </pre>
       *
       * <code>optional .object_detection.protos.Loss loss = 3;</code>
       * @return Whether the loss field is set.
       */
      @java.lang.Override
      public boolean hasLoss() {
        return ((bitField0_ & 0x00000004) != 0);
      }
      /**
       * <pre>
       * Loss configuration for DensePose heatmap and regression losses. Note
       * that the localization loss is used for surface coordinate losses and
       * classification loss is used for part classification losses.
       * </pre>
       *
       * <code>optional .object_detection.protos.Loss loss = 3;</code>
       * @return The loss.
       */
      @java.lang.Override
      public object_detection.protos.Losses.Loss getLoss() {
        return loss_ == null ? object_detection.protos.Losses.Loss.getDefaultInstance() : loss_;
      }
      /**
       * <pre>
       * Loss configuration for DensePose heatmap and regression losses. Note
       * that the localization loss is used for surface coordinate losses and
       * classification loss is used for part classification losses.
       * </pre>
       *
       * <code>optional .object_detection.protos.Loss loss = 3;</code>
       */
      @java.lang.Override
      public object_detection.protos.Losses.LossOrBuilder getLossOrBuilder() {
        return loss_ == null ? object_detection.protos.Losses.Loss.getDefaultInstance() : loss_;
      }

      public static final int NUM_PARTS_FIELD_NUMBER = 4;
      private int numParts_;
      /**
       * <pre>
       * The number of body parts.
       * </pre>
       *
       * <code>optional int32 num_parts = 4 [default = 24];</code>
       * @return Whether the numParts field is set.
       */
      @java.lang.Override
      public boolean hasNumParts() {
        return ((bitField0_ & 0x00000008) != 0);
      }
      /**
       * <pre>
       * The number of body parts.
       * </pre>
       *
       * <code>optional int32 num_parts = 4 [default = 24];</code>
       * @return The numParts.
       */
      @java.lang.Override
      public int getNumParts() {
        return numParts_;
      }

      public static final int PART_LOSS_WEIGHT_FIELD_NUMBER = 5;
      private float partLossWeight_;
      /**
       * <pre>
       * Loss weights for the two DensePose heads.
       * </pre>
       *
       * <code>optional float part_loss_weight = 5 [default = 1];</code>
       * @return Whether the partLossWeight field is set.
       */
      @java.lang.Override
      public boolean hasPartLossWeight() {
        return ((bitField0_ & 0x00000010) != 0);
      }
      /**
       * <pre>
       * Loss weights for the two DensePose heads.
       * </pre>
       *
       * <code>optional float part_loss_weight = 5 [default = 1];</code>
       * @return The partLossWeight.
       */
      @java.lang.Override
      public float getPartLossWeight() {
        return partLossWeight_;
      }

      public static final int COORDINATE_LOSS_WEIGHT_FIELD_NUMBER = 6;
      private float coordinateLossWeight_;
      /**
       * <code>optional float coordinate_loss_weight = 6 [default = 1];</code>
       * @return Whether the coordinateLossWeight field is set.
       */
      @java.lang.Override
      public boolean hasCoordinateLossWeight() {
        return ((bitField0_ & 0x00000020) != 0);
      }
      /**
       * <code>optional float coordinate_loss_weight = 6 [default = 1];</code>
       * @return The coordinateLossWeight.
       */
      @java.lang.Override
      public float getCoordinateLossWeight() {
        return coordinateLossWeight_;
      }

      public static final int UPSAMPLE_TO_INPUT_RES_FIELD_NUMBER = 7;
      private boolean upsampleToInputRes_;
      /**
       * <pre>
       * Whether to upsample the prediction feature maps back to the original
       * input dimension prior to applying loss. This has the benefit of
       * maintaining finer groundtruth location information.
       * </pre>
       *
       * <code>optional bool upsample_to_input_res = 7 [default = true];</code>
       * @return Whether the upsampleToInputRes field is set.
       */
      @java.lang.Override
      public boolean hasUpsampleToInputRes() {
        return ((bitField0_ & 0x00000040) != 0);
      }
      /**
       * <pre>
       * Whether to upsample the prediction feature maps back to the original
       * input dimension prior to applying loss. This has the benefit of
       * maintaining finer groundtruth location information.
       * </pre>
       *
       * <code>optional bool upsample_to_input_res = 7 [default = true];</code>
       * @return The upsampleToInputRes.
       */
      @java.lang.Override
      public boolean getUpsampleToInputRes() {
        return upsampleToInputRes_;
      }

      public static final int HEATMAP_BIAS_INIT_FIELD_NUMBER = 8;
      private float heatmapBiasInit_;
      /**
       * <pre>
       * The initial bias value of the convlution kernel of the class heatmap
       * prediction head. -2.19 corresponds to predicting foreground with
       * a probability of 0.1.
       * </pre>
       *
       * <code>optional float heatmap_bias_init = 8 [default = -2.19];</code>
       * @return Whether the heatmapBiasInit field is set.
       */
      @java.lang.Override
      public boolean hasHeatmapBiasInit() {
        return ((bitField0_ & 0x00000080) != 0);
      }
      /**
       * <pre>
       * The initial bias value of the convlution kernel of the class heatmap
       * prediction head. -2.19 corresponds to predicting foreground with
       * a probability of 0.1.
       * </pre>
       *
       * <code>optional float heatmap_bias_init = 8 [default = -2.19];</code>
       * @return The heatmapBiasInit.
       */
      @java.lang.Override
      public float getHeatmapBiasInit() {
        return heatmapBiasInit_;
      }

      private byte memoizedIsInitialized = -1;
      @java.lang.Override
      public final boolean isInitialized() {
        byte isInitialized = memoizedIsInitialized;
        if (isInitialized == 1) return true;
        if (isInitialized == 0) return false;

        memoizedIsInitialized = 1;
        return true;
      }

      @java.lang.Override
      public void writeTo(com.google.protobuf.CodedOutputStream output)
                          throws java.io.IOException {
        if (((bitField0_ & 0x00000001) != 0)) {
          output.writeFloat(1, taskLossWeight_);
        }
        if (((bitField0_ & 0x00000002) != 0)) {
          output.writeInt32(2, classId_);
        }
        if (((bitField0_ & 0x00000004) != 0)) {
          output.writeMessage(3, getLoss());
        }
        if (((bitField0_ & 0x00000008) != 0)) {
          output.writeInt32(4, numParts_);
        }
        if (((bitField0_ & 0x00000010) != 0)) {
          output.writeFloat(5, partLossWeight_);
        }
        if (((bitField0_ & 0x00000020) != 0)) {
          output.writeFloat(6, coordinateLossWeight_);
        }
        if (((bitField0_ & 0x00000040) != 0)) {
          output.writeBool(7, upsampleToInputRes_);
        }
        if (((bitField0_ & 0x00000080) != 0)) {
          output.writeFloat(8, heatmapBiasInit_);
        }
        unknownFields.writeTo(output);
      }

      @java.lang.Override
      public int getSerializedSize() {
        int size = memoizedSize;
        if (size != -1) return size;

        size = 0;
        if (((bitField0_ & 0x00000001) != 0)) {
          size += com.google.protobuf.CodedOutputStream
            .computeFloatSize(1, taskLossWeight_);
        }
        if (((bitField0_ & 0x00000002) != 0)) {
          size += com.google.protobuf.CodedOutputStream
            .computeInt32Size(2, classId_);
        }
        if (((bitField0_ & 0x00000004) != 0)) {
          size += com.google.protobuf.CodedOutputStream
            .computeMessageSize(3, getLoss());
        }
        if (((bitField0_ & 0x00000008) != 0)) {
          size += com.google.protobuf.CodedOutputStream
            .computeInt32Size(4, numParts_);
        }
        if (((bitField0_ & 0x00000010) != 0)) {
          size += com.google.protobuf.CodedOutputStream
            .computeFloatSize(5, partLossWeight_);
        }
        if (((bitField0_ & 0x00000020) != 0)) {
          size += com.google.protobuf.CodedOutputStream
            .computeFloatSize(6, coordinateLossWeight_);
        }
        if (((bitField0_ & 0x00000040) != 0)) {
          size += com.google.protobuf.CodedOutputStream
            .computeBoolSize(7, upsampleToInputRes_);
        }
        if (((bitField0_ & 0x00000080) != 0)) {
          size += com.google.protobuf.CodedOutputStream
            .computeFloatSize(8, heatmapBiasInit_);
        }
        size += unknownFields.getSerializedSize();
        memoizedSize = size;
        return size;
      }

      @java.lang.Override
      public boolean equals(final java.lang.Object obj) {
        if (obj == this) {
         return true;
        }
        if (!(obj instanceof object_detection.protos.CenterNetOuterClass.CenterNet.DensePoseEstimation)) {
          return super.equals(obj);
        }
        object_detection.protos.CenterNetOuterClass.CenterNet.DensePoseEstimation other = (object_detection.protos.CenterNetOuterClass.CenterNet.DensePoseEstimation) obj;

        if (hasTaskLossWeight() != other.hasTaskLossWeight()) return false;
        if (hasTaskLossWeight()) {
          if (java.lang.Float.floatToIntBits(getTaskLossWeight())
              != java.lang.Float.floatToIntBits(
                  other.getTaskLossWeight())) return false;
        }
        if (hasClassId() != other.hasClassId()) return false;
        if (hasClassId()) {
          if (getClassId()
              != other.getClassId()) return false;
        }
        if (hasLoss() != other.hasLoss()) return false;
        if (hasLoss()) {
          if (!getLoss()
              .equals(other.getLoss())) return false;
        }
        if (hasNumParts() != other.hasNumParts()) return false;
        if (hasNumParts()) {
          if (getNumParts()
              != other.getNumParts()) return false;
        }
        if (hasPartLossWeight() != other.hasPartLossWeight()) return false;
        if (hasPartLossWeight()) {
          if (java.lang.Float.floatToIntBits(getPartLossWeight())
              != java.lang.Float.floatToIntBits(
                  other.getPartLossWeight())) return false;
        }
        if (hasCoordinateLossWeight() != other.hasCoordinateLossWeight()) return false;
        if (hasCoordinateLossWeight()) {
          if (java.lang.Float.floatToIntBits(getCoordinateLossWeight())
              != java.lang.Float.floatToIntBits(
                  other.getCoordinateLossWeight())) return false;
        }
        if (hasUpsampleToInputRes() != other.hasUpsampleToInputRes()) return false;
        if (hasUpsampleToInputRes()) {
          if (getUpsampleToInputRes()
              != other.getUpsampleToInputRes()) return false;
        }
        if (hasHeatmapBiasInit() != other.hasHeatmapBiasInit()) return false;
        if (hasHeatmapBiasInit()) {
          if (java.lang.Float.floatToIntBits(getHeatmapBiasInit())
              != java.lang.Float.floatToIntBits(
                  other.getHeatmapBiasInit())) return false;
        }
        if (!unknownFields.equals(other.unknownFields)) return false;
        return true;
      }

      @java.lang.Override
      public int hashCode() {
        if (memoizedHashCode != 0) {
          return memoizedHashCode;
        }
        int hash = 41;
        hash = (19 * hash) + getDescriptor().hashCode();
        if (hasTaskLossWeight()) {
          hash = (37 * hash) + TASK_LOSS_WEIGHT_FIELD_NUMBER;
          hash = (53 * hash) + java.lang.Float.floatToIntBits(
              getTaskLossWeight());
        }
        if (hasClassId()) {
          hash = (37 * hash) + CLASS_ID_FIELD_NUMBER;
          hash = (53 * hash) + getClassId();
        }
        if (hasLoss()) {
          hash = (37 * hash) + LOSS_FIELD_NUMBER;
          hash = (53 * hash) + getLoss().hashCode();
        }
        if (hasNumParts()) {
          hash = (37 * hash) + NUM_PARTS_FIELD_NUMBER;
          hash = (53 * hash) + getNumParts();
        }
        if (hasPartLossWeight()) {
          hash = (37 * hash) + PART_LOSS_WEIGHT_FIELD_NUMBER;
          hash = (53 * hash) + java.lang.Float.floatToIntBits(
              getPartLossWeight());
        }
        if (hasCoordinateLossWeight()) {
          hash = (37 * hash) + COORDINATE_LOSS_WEIGHT_FIELD_NUMBER;
          hash = (53 * hash) + java.lang.Float.floatToIntBits(
              getCoordinateLossWeight());
        }
        if (hasUpsampleToInputRes()) {
          hash = (37 * hash) + UPSAMPLE_TO_INPUT_RES_FIELD_NUMBER;
          hash = (53 * hash) + com.google.protobuf.Internal.hashBoolean(
              getUpsampleToInputRes());
        }
        if (hasHeatmapBiasInit()) {
          hash = (37 * hash) + HEATMAP_BIAS_INIT_FIELD_NUMBER;
          hash = (53 * hash) + java.lang.Float.floatToIntBits(
              getHeatmapBiasInit());
        }
        hash = (29 * hash) + unknownFields.hashCode();
        memoizedHashCode = hash;
        return hash;
      }

      public static object_detection.protos.CenterNetOuterClass.CenterNet.DensePoseEstimation parseFrom(
          java.nio.ByteBuffer data)
          throws com.google.protobuf.InvalidProtocolBufferException {
        return PARSER.parseFrom(data);
      }
      public static object_detection.protos.CenterNetOuterClass.CenterNet.DensePoseEstimation parseFrom(
          java.nio.ByteBuffer data,
          com.google.protobuf.ExtensionRegistryLite extensionRegistry)
          throws com.google.protobuf.InvalidProtocolBufferException {
        return PARSER.parseFrom(data, extensionRegistry);
      }
      public static object_detection.protos.CenterNetOuterClass.CenterNet.DensePoseEstimation parseFrom(
          com.google.protobuf.ByteString data)
          throws com.google.protobuf.InvalidProtocolBufferException {
        return PARSER.parseFrom(data);
      }
      public static object_detection.protos.CenterNetOuterClass.CenterNet.DensePoseEstimation parseFrom(
          com.google.protobuf.ByteString data,
          com.google.protobuf.ExtensionRegistryLite extensionRegistry)
          throws com.google.protobuf.InvalidProtocolBufferException {
        return PARSER.parseFrom(data, extensionRegistry);
      }
      public static object_detection.protos.CenterNetOuterClass.CenterNet.DensePoseEstimation parseFrom(byte[] data)
          throws com.google.protobuf.InvalidProtocolBufferException {
        return PARSER.parseFrom(data);
      }
      public static object_detection.protos.CenterNetOuterClass.CenterNet.DensePoseEstimation parseFrom(
          byte[] data,
          com.google.protobuf.ExtensionRegistryLite extensionRegistry)
          throws com.google.protobuf.InvalidProtocolBufferException {
        return PARSER.parseFrom(data, extensionRegistry);
      }
      public static object_detection.protos.CenterNetOuterClass.CenterNet.DensePoseEstimation parseFrom(java.io.InputStream input)
          throws java.io.IOException {
        return com.google.protobuf.GeneratedMessageV3
            .parseWithIOException(PARSER, input);
      }
      public static object_detection.protos.CenterNetOuterClass.CenterNet.DensePoseEstimation parseFrom(
          java.io.InputStream input,
          com.google.protobuf.ExtensionRegistryLite extensionRegistry)
          throws java.io.IOException {
        return com.google.protobuf.GeneratedMessageV3
            .parseWithIOException(PARSER, input, extensionRegistry);
      }
      public static object_detection.protos.CenterNetOuterClass.CenterNet.DensePoseEstimation parseDelimitedFrom(java.io.InputStream input)
          throws java.io.IOException {
        return com.google.protobuf.GeneratedMessageV3
            .parseDelimitedWithIOException(PARSER, input);
      }
      public static object_detection.protos.CenterNetOuterClass.CenterNet.DensePoseEstimation parseDelimitedFrom(
          java.io.InputStream input,
          com.google.protobuf.ExtensionRegistryLite extensionRegistry)
          throws java.io.IOException {
        return com.google.protobuf.GeneratedMessageV3
            .parseDelimitedWithIOException(PARSER, input, extensionRegistry);
      }
      public static object_detection.protos.CenterNetOuterClass.CenterNet.DensePoseEstimation parseFrom(
          com.google.protobuf.CodedInputStream input)
          throws java.io.IOException {
        return com.google.protobuf.GeneratedMessageV3
            .parseWithIOException(PARSER, input);
      }
      public static object_detection.protos.CenterNetOuterClass.CenterNet.DensePoseEstimation parseFrom(
          com.google.protobuf.CodedInputStream input,
          com.google.protobuf.ExtensionRegistryLite extensionRegistry)
          throws java.io.IOException {
        return com.google.protobuf.GeneratedMessageV3
            .parseWithIOException(PARSER, input, extensionRegistry);
      }

      @java.lang.Override
      public Builder newBuilderForType() { return newBuilder(); }
      public static Builder newBuilder() {
        return DEFAULT_INSTANCE.toBuilder();
      }
      public static Builder newBuilder(object_detection.protos.CenterNetOuterClass.CenterNet.DensePoseEstimation prototype) {
        return DEFAULT_INSTANCE.toBuilder().mergeFrom(prototype);
      }
      @java.lang.Override
      public Builder toBuilder() {
        return this == DEFAULT_INSTANCE
            ? new Builder() : new Builder().mergeFrom(this);
      }

      @java.lang.Override
      protected Builder newBuilderForType(
          com.google.protobuf.GeneratedMessageV3.BuilderParent parent) {
        Builder builder = new Builder(parent);
        return builder;
      }
      /**
       * <pre>
       * Parameters which are related to DensePose estimation task.
       * http://densepose.org/
       * </pre>
       *
       * Protobuf type {@code object_detection.protos.CenterNet.DensePoseEstimation}
       */
      public static final class Builder extends
          com.google.protobuf.GeneratedMessageV3.Builder<Builder> implements
          // @@protoc_insertion_point(builder_implements:object_detection.protos.CenterNet.DensePoseEstimation)
          object_detection.protos.CenterNetOuterClass.CenterNet.DensePoseEstimationOrBuilder {
        public static final com.google.protobuf.Descriptors.Descriptor
            getDescriptor() {
          return object_detection.protos.CenterNetOuterClass.internal_static_object_detection_protos_CenterNet_DensePoseEstimation_descriptor;
        }

        @java.lang.Override
        protected com.google.protobuf.GeneratedMessageV3.FieldAccessorTable
            internalGetFieldAccessorTable() {
          return object_detection.protos.CenterNetOuterClass.internal_static_object_detection_protos_CenterNet_DensePoseEstimation_fieldAccessorTable
              .ensureFieldAccessorsInitialized(
                  object_detection.protos.CenterNetOuterClass.CenterNet.DensePoseEstimation.class, object_detection.protos.CenterNetOuterClass.CenterNet.DensePoseEstimation.Builder.class);
        }

        // Construct using object_detection.protos.CenterNetOuterClass.CenterNet.DensePoseEstimation.newBuilder()
        private Builder() {
          maybeForceBuilderInitialization();
        }

        private Builder(
            com.google.protobuf.GeneratedMessageV3.BuilderParent parent) {
          super(parent);
          maybeForceBuilderInitialization();
        }
        private void maybeForceBuilderInitialization() {
          if (com.google.protobuf.GeneratedMessageV3
                  .alwaysUseFieldBuilders) {
            getLossFieldBuilder();
          }
        }
        @java.lang.Override
        public Builder clear() {
          super.clear();
          taskLossWeight_ = 1F;
          bitField0_ = (bitField0_ & ~0x00000001);
          classId_ = 0;
          bitField0_ = (bitField0_ & ~0x00000002);
          if (lossBuilder_ == null) {
            loss_ = null;
          } else {
            lossBuilder_.clear();
          }
          bitField0_ = (bitField0_ & ~0x00000004);
          numParts_ = 24;
          bitField0_ = (bitField0_ & ~0x00000008);
          partLossWeight_ = 1F;
          bitField0_ = (bitField0_ & ~0x00000010);
          coordinateLossWeight_ = 1F;
          bitField0_ = (bitField0_ & ~0x00000020);
          upsampleToInputRes_ = true;
          bitField0_ = (bitField0_ & ~0x00000040);
          heatmapBiasInit_ = -2.19F;
          bitField0_ = (bitField0_ & ~0x00000080);
          return this;
        }

        @java.lang.Override
        public com.google.protobuf.Descriptors.Descriptor
            getDescriptorForType() {
          return object_detection.protos.CenterNetOuterClass.internal_static_object_detection_protos_CenterNet_DensePoseEstimation_descriptor;
        }

        @java.lang.Override
        public object_detection.protos.CenterNetOuterClass.CenterNet.DensePoseEstimation getDefaultInstanceForType() {
          return object_detection.protos.CenterNetOuterClass.CenterNet.DensePoseEstimation.getDefaultInstance();
        }

        @java.lang.Override
        public object_detection.protos.CenterNetOuterClass.CenterNet.DensePoseEstimation build() {
          object_detection.protos.CenterNetOuterClass.CenterNet.DensePoseEstimation result = buildPartial();
          if (!result.isInitialized()) {
            throw newUninitializedMessageException(result);
          }
          return result;
        }

        @java.lang.Override
        public object_detection.protos.CenterNetOuterClass.CenterNet.DensePoseEstimation buildPartial() {
          object_detection.protos.CenterNetOuterClass.CenterNet.DensePoseEstimation result = new object_detection.protos.CenterNetOuterClass.CenterNet.DensePoseEstimation(this);
          int from_bitField0_ = bitField0_;
          int to_bitField0_ = 0;
          if (((from_bitField0_ & 0x00000001) != 0)) {
            to_bitField0_ |= 0x00000001;
          }
          result.taskLossWeight_ = taskLossWeight_;
          if (((from_bitField0_ & 0x00000002) != 0)) {
            result.classId_ = classId_;
            to_bitField0_ |= 0x00000002;
          }
          if (((from_bitField0_ & 0x00000004) != 0)) {
            if (lossBuilder_ == null) {
              result.loss_ = loss_;
            } else {
              result.loss_ = lossBuilder_.build();
            }
            to_bitField0_ |= 0x00000004;
          }
          if (((from_bitField0_ & 0x00000008) != 0)) {
            to_bitField0_ |= 0x00000008;
          }
          result.numParts_ = numParts_;
          if (((from_bitField0_ & 0x00000010) != 0)) {
            to_bitField0_ |= 0x00000010;
          }
          result.partLossWeight_ = partLossWeight_;
          if (((from_bitField0_ & 0x00000020) != 0)) {
            to_bitField0_ |= 0x00000020;
          }
          result.coordinateLossWeight_ = coordinateLossWeight_;
          if (((from_bitField0_ & 0x00000040) != 0)) {
            to_bitField0_ |= 0x00000040;
          }
          result.upsampleToInputRes_ = upsampleToInputRes_;
          if (((from_bitField0_ & 0x00000080) != 0)) {
            to_bitField0_ |= 0x00000080;
          }
          result.heatmapBiasInit_ = heatmapBiasInit_;
          result.bitField0_ = to_bitField0_;
          onBuilt();
          return result;
        }

        @java.lang.Override
        public Builder clone() {
          return super.clone();
        }
        @java.lang.Override
        public Builder setField(
            com.google.protobuf.Descriptors.FieldDescriptor field,
            java.lang.Object value) {
          return super.setField(field, value);
        }
        @java.lang.Override
        public Builder clearField(
            com.google.protobuf.Descriptors.FieldDescriptor field) {
          return super.clearField(field);
        }
        @java.lang.Override
        public Builder clearOneof(
            com.google.protobuf.Descriptors.OneofDescriptor oneof) {
          return super.clearOneof(oneof);
        }
        @java.lang.Override
        public Builder setRepeatedField(
            com.google.protobuf.Descriptors.FieldDescriptor field,
            int index, java.lang.Object value) {
          return super.setRepeatedField(field, index, value);
        }
        @java.lang.Override
        public Builder addRepeatedField(
            com.google.protobuf.Descriptors.FieldDescriptor field,
            java.lang.Object value) {
          return super.addRepeatedField(field, value);
        }
        @java.lang.Override
        public Builder mergeFrom(com.google.protobuf.Message other) {
          if (other instanceof object_detection.protos.CenterNetOuterClass.CenterNet.DensePoseEstimation) {
            return mergeFrom((object_detection.protos.CenterNetOuterClass.CenterNet.DensePoseEstimation)other);
          } else {
            super.mergeFrom(other);
            return this;
          }
        }

        public Builder mergeFrom(object_detection.protos.CenterNetOuterClass.CenterNet.DensePoseEstimation other) {
          if (other == object_detection.protos.CenterNetOuterClass.CenterNet.DensePoseEstimation.getDefaultInstance()) return this;
          if (other.hasTaskLossWeight()) {
            setTaskLossWeight(other.getTaskLossWeight());
          }
          if (other.hasClassId()) {
            setClassId(other.getClassId());
          }
          if (other.hasLoss()) {
            mergeLoss(other.getLoss());
          }
          if (other.hasNumParts()) {
            setNumParts(other.getNumParts());
          }
          if (other.hasPartLossWeight()) {
            setPartLossWeight(other.getPartLossWeight());
          }
          if (other.hasCoordinateLossWeight()) {
            setCoordinateLossWeight(other.getCoordinateLossWeight());
          }
          if (other.hasUpsampleToInputRes()) {
            setUpsampleToInputRes(other.getUpsampleToInputRes());
          }
          if (other.hasHeatmapBiasInit()) {
            setHeatmapBiasInit(other.getHeatmapBiasInit());
          }
          this.mergeUnknownFields(other.unknownFields);
          onChanged();
          return this;
        }

        @java.lang.Override
        public final boolean isInitialized() {
          return true;
        }

        @java.lang.Override
        public Builder mergeFrom(
            com.google.protobuf.CodedInputStream input,
            com.google.protobuf.ExtensionRegistryLite extensionRegistry)
            throws java.io.IOException {
          object_detection.protos.CenterNetOuterClass.CenterNet.DensePoseEstimation parsedMessage = null;
          try {
            parsedMessage = PARSER.parsePartialFrom(input, extensionRegistry);
          } catch (com.google.protobuf.InvalidProtocolBufferException e) {
            parsedMessage = (object_detection.protos.CenterNetOuterClass.CenterNet.DensePoseEstimation) e.getUnfinishedMessage();
            throw e.unwrapIOException();
          } finally {
            if (parsedMessage != null) {
              mergeFrom(parsedMessage);
            }
          }
          return this;
        }
        private int bitField0_;

        private float taskLossWeight_ = 1F;
        /**
         * <pre>
         * Weight of the task loss. The total loss of the model will be their
         * summation of task losses weighted by the weights.
         * </pre>
         *
         * <code>optional float task_loss_weight = 1 [default = 1];</code>
         * @return Whether the taskLossWeight field is set.
         */
        @java.lang.Override
        public boolean hasTaskLossWeight() {
          return ((bitField0_ & 0x00000001) != 0);
        }
        /**
         * <pre>
         * Weight of the task loss. The total loss of the model will be their
         * summation of task losses weighted by the weights.
         * </pre>
         *
         * <code>optional float task_loss_weight = 1 [default = 1];</code>
         * @return The taskLossWeight.
         */
        @java.lang.Override
        public float getTaskLossWeight() {
          return taskLossWeight_;
        }
        /**
         * <pre>
         * Weight of the task loss. The total loss of the model will be their
         * summation of task losses weighted by the weights.
         * </pre>
         *
         * <code>optional float task_loss_weight = 1 [default = 1];</code>
         * @param value The taskLossWeight to set.
         * @return This builder for chaining.
         */
        public Builder setTaskLossWeight(float value) {
          bitField0_ |= 0x00000001;
          taskLossWeight_ = value;
          onChanged();
          return this;
        }
        /**
         * <pre>
         * Weight of the task loss. The total loss of the model will be their
         * summation of task losses weighted by the weights.
         * </pre>
         *
         * <code>optional float task_loss_weight = 1 [default = 1];</code>
         * @return This builder for chaining.
         */
        public Builder clearTaskLossWeight() {
          bitField0_ = (bitField0_ & ~0x00000001);
          taskLossWeight_ = 1F;
          onChanged();
          return this;
        }

        private int classId_ ;
        /**
         * <pre>
         * Class ID (0-indexed) that corresponds to the object in the label map that
         * contains DensePose data.
         * </pre>
         *
         * <code>optional int32 class_id = 2;</code>
         * @return Whether the classId field is set.
         */
        @java.lang.Override
        public boolean hasClassId() {
          return ((bitField0_ & 0x00000002) != 0);
        }
        /**
         * <pre>
         * Class ID (0-indexed) that corresponds to the object in the label map that
         * contains DensePose data.
         * </pre>
         *
         * <code>optional int32 class_id = 2;</code>
         * @return The classId.
         */
        @java.lang.Override
        public int getClassId() {
          return classId_;
        }
        /**
         * <pre>
         * Class ID (0-indexed) that corresponds to the object in the label map that
         * contains DensePose data.
         * </pre>
         *
         * <code>optional int32 class_id = 2;</code>
         * @param value The classId to set.
         * @return This builder for chaining.
         */
        public Builder setClassId(int value) {
          bitField0_ |= 0x00000002;
          classId_ = value;
          onChanged();
          return this;
        }
        /**
         * <pre>
         * Class ID (0-indexed) that corresponds to the object in the label map that
         * contains DensePose data.
         * </pre>
         *
         * <code>optional int32 class_id = 2;</code>
         * @return This builder for chaining.
         */
        public Builder clearClassId() {
          bitField0_ = (bitField0_ & ~0x00000002);
          classId_ = 0;
          onChanged();
          return this;
        }

        private object_detection.protos.Losses.Loss loss_;
        private com.google.protobuf.SingleFieldBuilderV3<
            object_detection.protos.Losses.Loss, object_detection.protos.Losses.Loss.Builder, object_detection.protos.Losses.LossOrBuilder> lossBuilder_;
        /**
         * <pre>
         * Loss configuration for DensePose heatmap and regression losses. Note
         * that the localization loss is used for surface coordinate losses and
         * classification loss is used for part classification losses.
         * </pre>
         *
         * <code>optional .object_detection.protos.Loss loss = 3;</code>
         * @return Whether the loss field is set.
         */
        public boolean hasLoss() {
          return ((bitField0_ & 0x00000004) != 0);
        }
        /**
         * <pre>
         * Loss configuration for DensePose heatmap and regression losses. Note
         * that the localization loss is used for surface coordinate losses and
         * classification loss is used for part classification losses.
         * </pre>
         *
         * <code>optional .object_detection.protos.Loss loss = 3;</code>
         * @return The loss.
         */
        public object_detection.protos.Losses.Loss getLoss() {
          if (lossBuilder_ == null) {
            return loss_ == null ? object_detection.protos.Losses.Loss.getDefaultInstance() : loss_;
          } else {
            return lossBuilder_.getMessage();
          }
        }
        /**
         * <pre>
         * Loss configuration for DensePose heatmap and regression losses. Note
         * that the localization loss is used for surface coordinate losses and
         * classification loss is used for part classification losses.
         * </pre>
         *
         * <code>optional .object_detection.protos.Loss loss = 3;</code>
         */
        public Builder setLoss(object_detection.protos.Losses.Loss value) {
          if (lossBuilder_ == null) {
            if (value == null) {
              throw new NullPointerException();
            }
            loss_ = value;
            onChanged();
          } else {
            lossBuilder_.setMessage(value);
          }
          bitField0_ |= 0x00000004;
          return this;
        }
        /**
         * <pre>
         * Loss configuration for DensePose heatmap and regression losses. Note
         * that the localization loss is used for surface coordinate losses and
         * classification loss is used for part classification losses.
         * </pre>
         *
         * <code>optional .object_detection.protos.Loss loss = 3;</code>
         */
        public Builder setLoss(
            object_detection.protos.Losses.Loss.Builder builderForValue) {
          if (lossBuilder_ == null) {
            loss_ = builderForValue.build();
            onChanged();
          } else {
            lossBuilder_.setMessage(builderForValue.build());
          }
          bitField0_ |= 0x00000004;
          return this;
        }
        /**
         * <pre>
         * Loss configuration for DensePose heatmap and regression losses. Note
         * that the localization loss is used for surface coordinate losses and
         * classification loss is used for part classification losses.
         * </pre>
         *
         * <code>optional .object_detection.protos.Loss loss = 3;</code>
         */
        public Builder mergeLoss(object_detection.protos.Losses.Loss value) {
          if (lossBuilder_ == null) {
            if (((bitField0_ & 0x00000004) != 0) &&
                loss_ != null &&
                loss_ != object_detection.protos.Losses.Loss.getDefaultInstance()) {
              loss_ =
                object_detection.protos.Losses.Loss.newBuilder(loss_).mergeFrom(value).buildPartial();
            } else {
              loss_ = value;
            }
            onChanged();
          } else {
            lossBuilder_.mergeFrom(value);
          }
          bitField0_ |= 0x00000004;
          return this;
        }
        /**
         * <pre>
         * Loss configuration for DensePose heatmap and regression losses. Note
         * that the localization loss is used for surface coordinate losses and
         * classification loss is used for part classification losses.
         * </pre>
         *
         * <code>optional .object_detection.protos.Loss loss = 3;</code>
         */
        public Builder clearLoss() {
          if (lossBuilder_ == null) {
            loss_ = null;
            onChanged();
          } else {
            lossBuilder_.clear();
          }
          bitField0_ = (bitField0_ & ~0x00000004);
          return this;
        }
        /**
         * <pre>
         * Loss configuration for DensePose heatmap and regression losses. Note
         * that the localization loss is used for surface coordinate losses and
         * classification loss is used for part classification losses.
         * </pre>
         *
         * <code>optional .object_detection.protos.Loss loss = 3;</code>
         */
        public object_detection.protos.Losses.Loss.Builder getLossBuilder() {
          bitField0_ |= 0x00000004;
          onChanged();
          return getLossFieldBuilder().getBuilder();
        }
        /**
         * <pre>
         * Loss configuration for DensePose heatmap and regression losses. Note
         * that the localization loss is used for surface coordinate losses and
         * classification loss is used for part classification losses.
         * </pre>
         *
         * <code>optional .object_detection.protos.Loss loss = 3;</code>
         */
        public object_detection.protos.Losses.LossOrBuilder getLossOrBuilder() {
          if (lossBuilder_ != null) {
            return lossBuilder_.getMessageOrBuilder();
          } else {
            return loss_ == null ?
                object_detection.protos.Losses.Loss.getDefaultInstance() : loss_;
          }
        }
        /**
         * <pre>
         * Loss configuration for DensePose heatmap and regression losses. Note
         * that the localization loss is used for surface coordinate losses and
         * classification loss is used for part classification losses.
         * </pre>
         *
         * <code>optional .object_detection.protos.Loss loss = 3;</code>
         */
        private com.google.protobuf.SingleFieldBuilderV3<
            object_detection.protos.Losses.Loss, object_detection.protos.Losses.Loss.Builder, object_detection.protos.Losses.LossOrBuilder>
            getLossFieldBuilder() {
          if (lossBuilder_ == null) {
            lossBuilder_ = new com.google.protobuf.SingleFieldBuilderV3<
                object_detection.protos.Losses.Loss, object_detection.protos.Losses.Loss.Builder, object_detection.protos.Losses.LossOrBuilder>(
                    getLoss(),
                    getParentForChildren(),
                    isClean());
            loss_ = null;
          }
          return lossBuilder_;
        }

        private int numParts_ = 24;
        /**
         * <pre>
         * The number of body parts.
         * </pre>
         *
         * <code>optional int32 num_parts = 4 [default = 24];</code>
         * @return Whether the numParts field is set.
         */
        @java.lang.Override
        public boolean hasNumParts() {
          return ((bitField0_ & 0x00000008) != 0);
        }
        /**
         * <pre>
         * The number of body parts.
         * </pre>
         *
         * <code>optional int32 num_parts = 4 [default = 24];</code>
         * @return The numParts.
         */
        @java.lang.Override
        public int getNumParts() {
          return numParts_;
        }
        /**
         * <pre>
         * The number of body parts.
         * </pre>
         *
         * <code>optional int32 num_parts = 4 [default = 24];</code>
         * @param value The numParts to set.
         * @return This builder for chaining.
         */
        public Builder setNumParts(int value) {
          bitField0_ |= 0x00000008;
          numParts_ = value;
          onChanged();
          return this;
        }
        /**
         * <pre>
         * The number of body parts.
         * </pre>
         *
         * <code>optional int32 num_parts = 4 [default = 24];</code>
         * @return This builder for chaining.
         */
        public Builder clearNumParts() {
          bitField0_ = (bitField0_ & ~0x00000008);
          numParts_ = 24;
          onChanged();
          return this;
        }

        private float partLossWeight_ = 1F;
        /**
         * <pre>
         * Loss weights for the two DensePose heads.
         * </pre>
         *
         * <code>optional float part_loss_weight = 5 [default = 1];</code>
         * @return Whether the partLossWeight field is set.
         */
        @java.lang.Override
        public boolean hasPartLossWeight() {
          return ((bitField0_ & 0x00000010) != 0);
        }
        /**
         * <pre>
         * Loss weights for the two DensePose heads.
         * </pre>
         *
         * <code>optional float part_loss_weight = 5 [default = 1];</code>
         * @return The partLossWeight.
         */
        @java.lang.Override
        public float getPartLossWeight() {
          return partLossWeight_;
        }
        /**
         * <pre>
         * Loss weights for the two DensePose heads.
         * </pre>
         *
         * <code>optional float part_loss_weight = 5 [default = 1];</code>
         * @param value The partLossWeight to set.
         * @return This builder for chaining.
         */
        public Builder setPartLossWeight(float value) {
          bitField0_ |= 0x00000010;
          partLossWeight_ = value;
          onChanged();
          return this;
        }
        /**
         * <pre>
         * Loss weights for the two DensePose heads.
         * </pre>
         *
         * <code>optional float part_loss_weight = 5 [default = 1];</code>
         * @return This builder for chaining.
         */
        public Builder clearPartLossWeight() {
          bitField0_ = (bitField0_ & ~0x00000010);
          partLossWeight_ = 1F;
          onChanged();
          return this;
        }

        private float coordinateLossWeight_ = 1F;
        /**
         * <code>optional float coordinate_loss_weight = 6 [default = 1];</code>
         * @return Whether the coordinateLossWeight field is set.
         */
        @java.lang.Override
        public boolean hasCoordinateLossWeight() {
          return ((bitField0_ & 0x00000020) != 0);
        }
        /**
         * <code>optional float coordinate_loss_weight = 6 [default = 1];</code>
         * @return The coordinateLossWeight.
         */
        @java.lang.Override
        public float getCoordinateLossWeight() {
          return coordinateLossWeight_;
        }
        /**
         * <code>optional float coordinate_loss_weight = 6 [default = 1];</code>
         * @param value The coordinateLossWeight to set.
         * @return This builder for chaining.
         */
        public Builder setCoordinateLossWeight(float value) {
          bitField0_ |= 0x00000020;
          coordinateLossWeight_ = value;
          onChanged();
          return this;
        }
        /**
         * <code>optional float coordinate_loss_weight = 6 [default = 1];</code>
         * @return This builder for chaining.
         */
        public Builder clearCoordinateLossWeight() {
          bitField0_ = (bitField0_ & ~0x00000020);
          coordinateLossWeight_ = 1F;
          onChanged();
          return this;
        }

        private boolean upsampleToInputRes_ = true;
        /**
         * <pre>
         * Whether to upsample the prediction feature maps back to the original
         * input dimension prior to applying loss. This has the benefit of
         * maintaining finer groundtruth location information.
         * </pre>
         *
         * <code>optional bool upsample_to_input_res = 7 [default = true];</code>
         * @return Whether the upsampleToInputRes field is set.
         */
        @java.lang.Override
        public boolean hasUpsampleToInputRes() {
          return ((bitField0_ & 0x00000040) != 0);
        }
        /**
         * <pre>
         * Whether to upsample the prediction feature maps back to the original
         * input dimension prior to applying loss. This has the benefit of
         * maintaining finer groundtruth location information.
         * </pre>
         *
         * <code>optional bool upsample_to_input_res = 7 [default = true];</code>
         * @return The upsampleToInputRes.
         */
        @java.lang.Override
        public boolean getUpsampleToInputRes() {
          return upsampleToInputRes_;
        }
        /**
         * <pre>
         * Whether to upsample the prediction feature maps back to the original
         * input dimension prior to applying loss. This has the benefit of
         * maintaining finer groundtruth location information.
         * </pre>
         *
         * <code>optional bool upsample_to_input_res = 7 [default = true];</code>
         * @param value The upsampleToInputRes to set.
         * @return This builder for chaining.
         */
        public Builder setUpsampleToInputRes(boolean value) {
          bitField0_ |= 0x00000040;
          upsampleToInputRes_ = value;
          onChanged();
          return this;
        }
        /**
         * <pre>
         * Whether to upsample the prediction feature maps back to the original
         * input dimension prior to applying loss. This has the benefit of
         * maintaining finer groundtruth location information.
         * </pre>
         *
         * <code>optional bool upsample_to_input_res = 7 [default = true];</code>
         * @return This builder for chaining.
         */
        public Builder clearUpsampleToInputRes() {
          bitField0_ = (bitField0_ & ~0x00000040);
          upsampleToInputRes_ = true;
          onChanged();
          return this;
        }

        private float heatmapBiasInit_ = -2.19F;
        /**
         * <pre>
         * The initial bias value of the convlution kernel of the class heatmap
         * prediction head. -2.19 corresponds to predicting foreground with
         * a probability of 0.1.
         * </pre>
         *
         * <code>optional float heatmap_bias_init = 8 [default = -2.19];</code>
         * @return Whether the heatmapBiasInit field is set.
         */
        @java.lang.Override
        public boolean hasHeatmapBiasInit() {
          return ((bitField0_ & 0x00000080) != 0);
        }
        /**
         * <pre>
         * The initial bias value of the convlution kernel of the class heatmap
         * prediction head. -2.19 corresponds to predicting foreground with
         * a probability of 0.1.
         * </pre>
         *
         * <code>optional float heatmap_bias_init = 8 [default = -2.19];</code>
         * @return The heatmapBiasInit.
         */
        @java.lang.Override
        public float getHeatmapBiasInit() {
          return heatmapBiasInit_;
        }
        /**
         * <pre>
         * The initial bias value of the convlution kernel of the class heatmap
         * prediction head. -2.19 corresponds to predicting foreground with
         * a probability of 0.1.
         * </pre>
         *
         * <code>optional float heatmap_bias_init = 8 [default = -2.19];</code>
         * @param value The heatmapBiasInit to set.
         * @return This builder for chaining.
         */
        public Builder setHeatmapBiasInit(float value) {
          bitField0_ |= 0x00000080;
          heatmapBiasInit_ = value;
          onChanged();
          return this;
        }
        /**
         * <pre>
         * The initial bias value of the convlution kernel of the class heatmap
         * prediction head. -2.19 corresponds to predicting foreground with
         * a probability of 0.1.
         * </pre>
         *
         * <code>optional float heatmap_bias_init = 8 [default = -2.19];</code>
         * @return This builder for chaining.
         */
        public Builder clearHeatmapBiasInit() {
          bitField0_ = (bitField0_ & ~0x00000080);
          heatmapBiasInit_ = -2.19F;
          onChanged();
          return this;
        }
        @java.lang.Override
        public final Builder setUnknownFields(
            final com.google.protobuf.UnknownFieldSet unknownFields) {
          return super.setUnknownFields(unknownFields);
        }

        @java.lang.Override
        public final Builder mergeUnknownFields(
            final com.google.protobuf.UnknownFieldSet unknownFields) {
          return super.mergeUnknownFields(unknownFields);
        }


        // @@protoc_insertion_point(builder_scope:object_detection.protos.CenterNet.DensePoseEstimation)
      }

      // @@protoc_insertion_point(class_scope:object_detection.protos.CenterNet.DensePoseEstimation)
      private static final object_detection.protos.CenterNetOuterClass.CenterNet.DensePoseEstimation DEFAULT_INSTANCE;
      static {
        DEFAULT_INSTANCE = new object_detection.protos.CenterNetOuterClass.CenterNet.DensePoseEstimation();
      }

      public static object_detection.protos.CenterNetOuterClass.CenterNet.DensePoseEstimation getDefaultInstance() {
        return DEFAULT_INSTANCE;
      }

      @java.lang.Deprecated public static final com.google.protobuf.Parser<DensePoseEstimation>
          PARSER = new com.google.protobuf.AbstractParser<DensePoseEstimation>() {
        @java.lang.Override
        public DensePoseEstimation parsePartialFrom(
            com.google.protobuf.CodedInputStream input,
            com.google.protobuf.ExtensionRegistryLite extensionRegistry)
            throws com.google.protobuf.InvalidProtocolBufferException {
          return new DensePoseEstimation(input, extensionRegistry);
        }
      };

      public static com.google.protobuf.Parser<DensePoseEstimation> parser() {
        return PARSER;
      }

      @java.lang.Override
      public com.google.protobuf.Parser<DensePoseEstimation> getParserForType() {
        return PARSER;
      }

      @java.lang.Override
      public object_detection.protos.CenterNetOuterClass.CenterNet.DensePoseEstimation getDefaultInstanceForType() {
        return DEFAULT_INSTANCE;
      }

    }

    public interface TrackEstimationOrBuilder extends
        // @@protoc_insertion_point(interface_extends:object_detection.protos.CenterNet.TrackEstimation)
        com.google.protobuf.MessageOrBuilder {

      /**
       * <pre>
       * Weight of the task loss. The total loss of the model will be the
       * summation of task losses weighted by the weights.
       * </pre>
       *
       * <code>optional float task_loss_weight = 1 [default = 1];</code>
       * @return Whether the taskLossWeight field is set.
       */
      boolean hasTaskLossWeight();
      /**
       * <pre>
       * Weight of the task loss. The total loss of the model will be the
       * summation of task losses weighted by the weights.
       * </pre>
       *
       * <code>optional float task_loss_weight = 1 [default = 1];</code>
       * @return The taskLossWeight.
       */
      float getTaskLossWeight();

      /**
       * <pre>
       * The maximun track ID of the datset.
       * </pre>
       *
       * <code>optional int32 num_track_ids = 2;</code>
       * @return Whether the numTrackIds field is set.
       */
      boolean hasNumTrackIds();
      /**
       * <pre>
       * The maximun track ID of the datset.
       * </pre>
       *
       * <code>optional int32 num_track_ids = 2;</code>
       * @return The numTrackIds.
       */
      int getNumTrackIds();

      /**
       * <pre>
       * The embedding size for re-identification (ReID) task in tracking.
       * </pre>
       *
       * <code>optional int32 reid_embed_size = 3 [default = 128];</code>
       * @return Whether the reidEmbedSize field is set.
       */
      boolean hasReidEmbedSize();
      /**
       * <pre>
       * The embedding size for re-identification (ReID) task in tracking.
       * </pre>
       *
       * <code>optional int32 reid_embed_size = 3 [default = 128];</code>
       * @return The reidEmbedSize.
       */
      int getReidEmbedSize();

      /**
       * <pre>
       * The number of (fully-connected, batch-norm, relu) layers for track ID
       * classification head. The output dimension of each intermediate FC layer
       * will all be 'reid_embed_size'. The last FC layer will directly project to
       * the track ID classification space of size 'num_track_ids' without
       * batch-norm and relu layers.
       * </pre>
       *
       * <code>optional int32 num_fc_layers = 4 [default = 1];</code>
       * @return Whether the numFcLayers field is set.
       */
      boolean hasNumFcLayers();
      /**
       * <pre>
       * The number of (fully-connected, batch-norm, relu) layers for track ID
       * classification head. The output dimension of each intermediate FC layer
       * will all be 'reid_embed_size'. The last FC layer will directly project to
       * the track ID classification space of size 'num_track_ids' without
       * batch-norm and relu layers.
       * </pre>
       *
       * <code>optional int32 num_fc_layers = 4 [default = 1];</code>
       * @return The numFcLayers.
       */
      int getNumFcLayers();

      /**
       * <pre>
       * Classification loss configuration for ReID loss.
       * </pre>
       *
       * <code>optional .object_detection.protos.ClassificationLoss classification_loss = 5;</code>
       * @return Whether the classificationLoss field is set.
       */
      boolean hasClassificationLoss();
      /**
       * <pre>
       * Classification loss configuration for ReID loss.
       * </pre>
       *
       * <code>optional .object_detection.protos.ClassificationLoss classification_loss = 5;</code>
       * @return The classificationLoss.
       */
      object_detection.protos.Losses.ClassificationLoss getClassificationLoss();
      /**
       * <pre>
       * Classification loss configuration for ReID loss.
       * </pre>
       *
       * <code>optional .object_detection.protos.ClassificationLoss classification_loss = 5;</code>
       */
      object_detection.protos.Losses.ClassificationLossOrBuilder getClassificationLossOrBuilder();
    }
    /**
     * <pre>
     * Parameters which are related to tracking embedding estimation task.
     * A Simple Baseline for Multi-Object Tracking [2]
     * [2]: https://arxiv.org/abs/2004.01888
     * </pre>
     *
     * Protobuf type {@code object_detection.protos.CenterNet.TrackEstimation}
     */
    public static final class TrackEstimation extends
        com.google.protobuf.GeneratedMessageV3 implements
        // @@protoc_insertion_point(message_implements:object_detection.protos.CenterNet.TrackEstimation)
        TrackEstimationOrBuilder {
    private static final long serialVersionUID = 0L;
      // Use TrackEstimation.newBuilder() to construct.
      private TrackEstimation(com.google.protobuf.GeneratedMessageV3.Builder<?> builder) {
        super(builder);
      }
      private TrackEstimation() {
        taskLossWeight_ = 1F;
        reidEmbedSize_ = 128;
        numFcLayers_ = 1;
      }

      @java.lang.Override
      @SuppressWarnings({"unused"})
      protected java.lang.Object newInstance(
          UnusedPrivateParameter unused) {
        return new TrackEstimation();
      }

      @java.lang.Override
      public final com.google.protobuf.UnknownFieldSet
      getUnknownFields() {
        return this.unknownFields;
      }
      private TrackEstimation(
          com.google.protobuf.CodedInputStream input,
          com.google.protobuf.ExtensionRegistryLite extensionRegistry)
          throws com.google.protobuf.InvalidProtocolBufferException {
        this();
        if (extensionRegistry == null) {
          throw new java.lang.NullPointerException();
        }
        int mutable_bitField0_ = 0;
        com.google.protobuf.UnknownFieldSet.Builder unknownFields =
            com.google.protobuf.UnknownFieldSet.newBuilder();
        try {
          boolean done = false;
          while (!done) {
            int tag = input.readTag();
            switch (tag) {
              case 0:
                done = true;
                break;
              case 13: {
                bitField0_ |= 0x00000001;
                taskLossWeight_ = input.readFloat();
                break;
              }
              case 16: {
                bitField0_ |= 0x00000002;
                numTrackIds_ = input.readInt32();
                break;
              }
              case 24: {
                bitField0_ |= 0x00000004;
                reidEmbedSize_ = input.readInt32();
                break;
              }
              case 32: {
                bitField0_ |= 0x00000008;
                numFcLayers_ = input.readInt32();
                break;
              }
              case 42: {
                object_detection.protos.Losses.ClassificationLoss.Builder subBuilder = null;
                if (((bitField0_ & 0x00000010) != 0)) {
                  subBuilder = classificationLoss_.toBuilder();
                }
                classificationLoss_ = input.readMessage(object_detection.protos.Losses.ClassificationLoss.PARSER, extensionRegistry);
                if (subBuilder != null) {
                  subBuilder.mergeFrom(classificationLoss_);
                  classificationLoss_ = subBuilder.buildPartial();
                }
                bitField0_ |= 0x00000010;
                break;
              }
              default: {
                if (!parseUnknownField(
                    input, unknownFields, extensionRegistry, tag)) {
                  done = true;
                }
                break;
              }
            }
          }
        } catch (com.google.protobuf.InvalidProtocolBufferException e) {
          throw e.setUnfinishedMessage(this);
        } catch (java.io.IOException e) {
          throw new com.google.protobuf.InvalidProtocolBufferException(
              e).setUnfinishedMessage(this);
        } finally {
          this.unknownFields = unknownFields.build();
          makeExtensionsImmutable();
        }
      }
      public static final com.google.protobuf.Descriptors.Descriptor
          getDescriptor() {
        return object_detection.protos.CenterNetOuterClass.internal_static_object_detection_protos_CenterNet_TrackEstimation_descriptor;
      }

      @java.lang.Override
      protected com.google.protobuf.GeneratedMessageV3.FieldAccessorTable
          internalGetFieldAccessorTable() {
        return object_detection.protos.CenterNetOuterClass.internal_static_object_detection_protos_CenterNet_TrackEstimation_fieldAccessorTable
            .ensureFieldAccessorsInitialized(
                object_detection.protos.CenterNetOuterClass.CenterNet.TrackEstimation.class, object_detection.protos.CenterNetOuterClass.CenterNet.TrackEstimation.Builder.class);
      }

      private int bitField0_;
      public static final int TASK_LOSS_WEIGHT_FIELD_NUMBER = 1;
      private float taskLossWeight_;
      /**
       * <pre>
       * Weight of the task loss. The total loss of the model will be the
       * summation of task losses weighted by the weights.
       * </pre>
       *
       * <code>optional float task_loss_weight = 1 [default = 1];</code>
       * @return Whether the taskLossWeight field is set.
       */
      @java.lang.Override
      public boolean hasTaskLossWeight() {
        return ((bitField0_ & 0x00000001) != 0);
      }
      /**
       * <pre>
       * Weight of the task loss. The total loss of the model will be the
       * summation of task losses weighted by the weights.
       * </pre>
       *
       * <code>optional float task_loss_weight = 1 [default = 1];</code>
       * @return The taskLossWeight.
       */
      @java.lang.Override
      public float getTaskLossWeight() {
        return taskLossWeight_;
      }

      public static final int NUM_TRACK_IDS_FIELD_NUMBER = 2;
      private int numTrackIds_;
      /**
       * <pre>
       * The maximun track ID of the datset.
       * </pre>
       *
       * <code>optional int32 num_track_ids = 2;</code>
       * @return Whether the numTrackIds field is set.
       */
      @java.lang.Override
      public boolean hasNumTrackIds() {
        return ((bitField0_ & 0x00000002) != 0);
      }
      /**
       * <pre>
       * The maximun track ID of the datset.
       * </pre>
       *
       * <code>optional int32 num_track_ids = 2;</code>
       * @return The numTrackIds.
       */
      @java.lang.Override
      public int getNumTrackIds() {
        return numTrackIds_;
      }

      public static final int REID_EMBED_SIZE_FIELD_NUMBER = 3;
      private int reidEmbedSize_;
      /**
       * <pre>
       * The embedding size for re-identification (ReID) task in tracking.
       * </pre>
       *
       * <code>optional int32 reid_embed_size = 3 [default = 128];</code>
       * @return Whether the reidEmbedSize field is set.
       */
      @java.lang.Override
      public boolean hasReidEmbedSize() {
        return ((bitField0_ & 0x00000004) != 0);
      }
      /**
       * <pre>
       * The embedding size for re-identification (ReID) task in tracking.
       * </pre>
       *
       * <code>optional int32 reid_embed_size = 3 [default = 128];</code>
       * @return The reidEmbedSize.
       */
      @java.lang.Override
      public int getReidEmbedSize() {
        return reidEmbedSize_;
      }

      public static final int NUM_FC_LAYERS_FIELD_NUMBER = 4;
      private int numFcLayers_;
      /**
       * <pre>
       * The number of (fully-connected, batch-norm, relu) layers for track ID
       * classification head. The output dimension of each intermediate FC layer
       * will all be 'reid_embed_size'. The last FC layer will directly project to
       * the track ID classification space of size 'num_track_ids' without
       * batch-norm and relu layers.
       * </pre>
       *
       * <code>optional int32 num_fc_layers = 4 [default = 1];</code>
       * @return Whether the numFcLayers field is set.
       */
      @java.lang.Override
      public boolean hasNumFcLayers() {
        return ((bitField0_ & 0x00000008) != 0);
      }
      /**
       * <pre>
       * The number of (fully-connected, batch-norm, relu) layers for track ID
       * classification head. The output dimension of each intermediate FC layer
       * will all be 'reid_embed_size'. The last FC layer will directly project to
       * the track ID classification space of size 'num_track_ids' without
       * batch-norm and relu layers.
       * </pre>
       *
       * <code>optional int32 num_fc_layers = 4 [default = 1];</code>
       * @return The numFcLayers.
       */
      @java.lang.Override
      public int getNumFcLayers() {
        return numFcLayers_;
      }

      public static final int CLASSIFICATION_LOSS_FIELD_NUMBER = 5;
      private object_detection.protos.Losses.ClassificationLoss classificationLoss_;
      /**
       * <pre>
       * Classification loss configuration for ReID loss.
       * </pre>
       *
       * <code>optional .object_detection.protos.ClassificationLoss classification_loss = 5;</code>
       * @return Whether the classificationLoss field is set.
       */
      @java.lang.Override
      public boolean hasClassificationLoss() {
        return ((bitField0_ & 0x00000010) != 0);
      }
      /**
       * <pre>
       * Classification loss configuration for ReID loss.
       * </pre>
       *
       * <code>optional .object_detection.protos.ClassificationLoss classification_loss = 5;</code>
       * @return The classificationLoss.
       */
      @java.lang.Override
      public object_detection.protos.Losses.ClassificationLoss getClassificationLoss() {
        return classificationLoss_ == null ? object_detection.protos.Losses.ClassificationLoss.getDefaultInstance() : classificationLoss_;
      }
      /**
       * <pre>
       * Classification loss configuration for ReID loss.
       * </pre>
       *
       * <code>optional .object_detection.protos.ClassificationLoss classification_loss = 5;</code>
       */
      @java.lang.Override
      public object_detection.protos.Losses.ClassificationLossOrBuilder getClassificationLossOrBuilder() {
        return classificationLoss_ == null ? object_detection.protos.Losses.ClassificationLoss.getDefaultInstance() : classificationLoss_;
      }

      private byte memoizedIsInitialized = -1;
      @java.lang.Override
      public final boolean isInitialized() {
        byte isInitialized = memoizedIsInitialized;
        if (isInitialized == 1) return true;
        if (isInitialized == 0) return false;

        memoizedIsInitialized = 1;
        return true;
      }

      @java.lang.Override
      public void writeTo(com.google.protobuf.CodedOutputStream output)
                          throws java.io.IOException {
        if (((bitField0_ & 0x00000001) != 0)) {
          output.writeFloat(1, taskLossWeight_);
        }
        if (((bitField0_ & 0x00000002) != 0)) {
          output.writeInt32(2, numTrackIds_);
        }
        if (((bitField0_ & 0x00000004) != 0)) {
          output.writeInt32(3, reidEmbedSize_);
        }
        if (((bitField0_ & 0x00000008) != 0)) {
          output.writeInt32(4, numFcLayers_);
        }
        if (((bitField0_ & 0x00000010) != 0)) {
          output.writeMessage(5, getClassificationLoss());
        }
        unknownFields.writeTo(output);
      }

      @java.lang.Override
      public int getSerializedSize() {
        int size = memoizedSize;
        if (size != -1) return size;

        size = 0;
        if (((bitField0_ & 0x00000001) != 0)) {
          size += com.google.protobuf.CodedOutputStream
            .computeFloatSize(1, taskLossWeight_);
        }
        if (((bitField0_ & 0x00000002) != 0)) {
          size += com.google.protobuf.CodedOutputStream
            .computeInt32Size(2, numTrackIds_);
        }
        if (((bitField0_ & 0x00000004) != 0)) {
          size += com.google.protobuf.CodedOutputStream
            .computeInt32Size(3, reidEmbedSize_);
        }
        if (((bitField0_ & 0x00000008) != 0)) {
          size += com.google.protobuf.CodedOutputStream
            .computeInt32Size(4, numFcLayers_);
        }
        if (((bitField0_ & 0x00000010) != 0)) {
          size += com.google.protobuf.CodedOutputStream
            .computeMessageSize(5, getClassificationLoss());
        }
        size += unknownFields.getSerializedSize();
        memoizedSize = size;
        return size;
      }

      @java.lang.Override
      public boolean equals(final java.lang.Object obj) {
        if (obj == this) {
         return true;
        }
        if (!(obj instanceof object_detection.protos.CenterNetOuterClass.CenterNet.TrackEstimation)) {
          return super.equals(obj);
        }
        object_detection.protos.CenterNetOuterClass.CenterNet.TrackEstimation other = (object_detection.protos.CenterNetOuterClass.CenterNet.TrackEstimation) obj;

        if (hasTaskLossWeight() != other.hasTaskLossWeight()) return false;
        if (hasTaskLossWeight()) {
          if (java.lang.Float.floatToIntBits(getTaskLossWeight())
              != java.lang.Float.floatToIntBits(
                  other.getTaskLossWeight())) return false;
        }
        if (hasNumTrackIds() != other.hasNumTrackIds()) return false;
        if (hasNumTrackIds()) {
          if (getNumTrackIds()
              != other.getNumTrackIds()) return false;
        }
        if (hasReidEmbedSize() != other.hasReidEmbedSize()) return false;
        if (hasReidEmbedSize()) {
          if (getReidEmbedSize()
              != other.getReidEmbedSize()) return false;
        }
        if (hasNumFcLayers() != other.hasNumFcLayers()) return false;
        if (hasNumFcLayers()) {
          if (getNumFcLayers()
              != other.getNumFcLayers()) return false;
        }
        if (hasClassificationLoss() != other.hasClassificationLoss()) return false;
        if (hasClassificationLoss()) {
          if (!getClassificationLoss()
              .equals(other.getClassificationLoss())) return false;
        }
        if (!unknownFields.equals(other.unknownFields)) return false;
        return true;
      }

      @java.lang.Override
      public int hashCode() {
        if (memoizedHashCode != 0) {
          return memoizedHashCode;
        }
        int hash = 41;
        hash = (19 * hash) + getDescriptor().hashCode();
        if (hasTaskLossWeight()) {
          hash = (37 * hash) + TASK_LOSS_WEIGHT_FIELD_NUMBER;
          hash = (53 * hash) + java.lang.Float.floatToIntBits(
              getTaskLossWeight());
        }
        if (hasNumTrackIds()) {
          hash = (37 * hash) + NUM_TRACK_IDS_FIELD_NUMBER;
          hash = (53 * hash) + getNumTrackIds();
        }
        if (hasReidEmbedSize()) {
          hash = (37 * hash) + REID_EMBED_SIZE_FIELD_NUMBER;
          hash = (53 * hash) + getReidEmbedSize();
        }
        if (hasNumFcLayers()) {
          hash = (37 * hash) + NUM_FC_LAYERS_FIELD_NUMBER;
          hash = (53 * hash) + getNumFcLayers();
        }
        if (hasClassificationLoss()) {
          hash = (37 * hash) + CLASSIFICATION_LOSS_FIELD_NUMBER;
          hash = (53 * hash) + getClassificationLoss().hashCode();
        }
        hash = (29 * hash) + unknownFields.hashCode();
        memoizedHashCode = hash;
        return hash;
      }

      public static object_detection.protos.CenterNetOuterClass.CenterNet.TrackEstimation parseFrom(
          java.nio.ByteBuffer data)
          throws com.google.protobuf.InvalidProtocolBufferException {
        return PARSER.parseFrom(data);
      }
      public static object_detection.protos.CenterNetOuterClass.CenterNet.TrackEstimation parseFrom(
          java.nio.ByteBuffer data,
          com.google.protobuf.ExtensionRegistryLite extensionRegistry)
          throws com.google.protobuf.InvalidProtocolBufferException {
        return PARSER.parseFrom(data, extensionRegistry);
      }
      public static object_detection.protos.CenterNetOuterClass.CenterNet.TrackEstimation parseFrom(
          com.google.protobuf.ByteString data)
          throws com.google.protobuf.InvalidProtocolBufferException {
        return PARSER.parseFrom(data);
      }
      public static object_detection.protos.CenterNetOuterClass.CenterNet.TrackEstimation parseFrom(
          com.google.protobuf.ByteString data,
          com.google.protobuf.ExtensionRegistryLite extensionRegistry)
          throws com.google.protobuf.InvalidProtocolBufferException {
        return PARSER.parseFrom(data, extensionRegistry);
      }
      public static object_detection.protos.CenterNetOuterClass.CenterNet.TrackEstimation parseFrom(byte[] data)
          throws com.google.protobuf.InvalidProtocolBufferException {
        return PARSER.parseFrom(data);
      }
      public static object_detection.protos.CenterNetOuterClass.CenterNet.TrackEstimation parseFrom(
          byte[] data,
          com.google.protobuf.ExtensionRegistryLite extensionRegistry)
          throws com.google.protobuf.InvalidProtocolBufferException {
        return PARSER.parseFrom(data, extensionRegistry);
      }
      public static object_detection.protos.CenterNetOuterClass.CenterNet.TrackEstimation parseFrom(java.io.InputStream input)
          throws java.io.IOException {
        return com.google.protobuf.GeneratedMessageV3
            .parseWithIOException(PARSER, input);
      }
      public static object_detection.protos.CenterNetOuterClass.CenterNet.TrackEstimation parseFrom(
          java.io.InputStream input,
          com.google.protobuf.ExtensionRegistryLite extensionRegistry)
          throws java.io.IOException {
        return com.google.protobuf.GeneratedMessageV3
            .parseWithIOException(PARSER, input, extensionRegistry);
      }
      public static object_detection.protos.CenterNetOuterClass.CenterNet.TrackEstimation parseDelimitedFrom(java.io.InputStream input)
          throws java.io.IOException {
        return com.google.protobuf.GeneratedMessageV3
            .parseDelimitedWithIOException(PARSER, input);
      }
      public static object_detection.protos.CenterNetOuterClass.CenterNet.TrackEstimation parseDelimitedFrom(
          java.io.InputStream input,
          com.google.protobuf.ExtensionRegistryLite extensionRegistry)
          throws java.io.IOException {
        return com.google.protobuf.GeneratedMessageV3
            .parseDelimitedWithIOException(PARSER, input, extensionRegistry);
      }
      public static object_detection.protos.CenterNetOuterClass.CenterNet.TrackEstimation parseFrom(
          com.google.protobuf.CodedInputStream input)
          throws java.io.IOException {
        return com.google.protobuf.GeneratedMessageV3
            .parseWithIOException(PARSER, input);
      }
      public static object_detection.protos.CenterNetOuterClass.CenterNet.TrackEstimation parseFrom(
          com.google.protobuf.CodedInputStream input,
          com.google.protobuf.ExtensionRegistryLite extensionRegistry)
          throws java.io.IOException {
        return com.google.protobuf.GeneratedMessageV3
            .parseWithIOException(PARSER, input, extensionRegistry);
      }

      @java.lang.Override
      public Builder newBuilderForType() { return newBuilder(); }
      public static Builder newBuilder() {
        return DEFAULT_INSTANCE.toBuilder();
      }
      public static Builder newBuilder(object_detection.protos.CenterNetOuterClass.CenterNet.TrackEstimation prototype) {
        return DEFAULT_INSTANCE.toBuilder().mergeFrom(prototype);
      }
      @java.lang.Override
      public Builder toBuilder() {
        return this == DEFAULT_INSTANCE
            ? new Builder() : new Builder().mergeFrom(this);
      }

      @java.lang.Override
      protected Builder newBuilderForType(
          com.google.protobuf.GeneratedMessageV3.BuilderParent parent) {
        Builder builder = new Builder(parent);
        return builder;
      }
      /**
       * <pre>
       * Parameters which are related to tracking embedding estimation task.
       * A Simple Baseline for Multi-Object Tracking [2]
       * [2]: https://arxiv.org/abs/2004.01888
       * </pre>
       *
       * Protobuf type {@code object_detection.protos.CenterNet.TrackEstimation}
       */
      public static final class Builder extends
          com.google.protobuf.GeneratedMessageV3.Builder<Builder> implements
          // @@protoc_insertion_point(builder_implements:object_detection.protos.CenterNet.TrackEstimation)
          object_detection.protos.CenterNetOuterClass.CenterNet.TrackEstimationOrBuilder {
        public static final com.google.protobuf.Descriptors.Descriptor
            getDescriptor() {
          return object_detection.protos.CenterNetOuterClass.internal_static_object_detection_protos_CenterNet_TrackEstimation_descriptor;
        }

        @java.lang.Override
        protected com.google.protobuf.GeneratedMessageV3.FieldAccessorTable
            internalGetFieldAccessorTable() {
          return object_detection.protos.CenterNetOuterClass.internal_static_object_detection_protos_CenterNet_TrackEstimation_fieldAccessorTable
              .ensureFieldAccessorsInitialized(
                  object_detection.protos.CenterNetOuterClass.CenterNet.TrackEstimation.class, object_detection.protos.CenterNetOuterClass.CenterNet.TrackEstimation.Builder.class);
        }

        // Construct using object_detection.protos.CenterNetOuterClass.CenterNet.TrackEstimation.newBuilder()
        private Builder() {
          maybeForceBuilderInitialization();
        }

        private Builder(
            com.google.protobuf.GeneratedMessageV3.BuilderParent parent) {
          super(parent);
          maybeForceBuilderInitialization();
        }
        private void maybeForceBuilderInitialization() {
          if (com.google.protobuf.GeneratedMessageV3
                  .alwaysUseFieldBuilders) {
            getClassificationLossFieldBuilder();
          }
        }
        @java.lang.Override
        public Builder clear() {
          super.clear();
          taskLossWeight_ = 1F;
          bitField0_ = (bitField0_ & ~0x00000001);
          numTrackIds_ = 0;
          bitField0_ = (bitField0_ & ~0x00000002);
          reidEmbedSize_ = 128;
          bitField0_ = (bitField0_ & ~0x00000004);
          numFcLayers_ = 1;
          bitField0_ = (bitField0_ & ~0x00000008);
          if (classificationLossBuilder_ == null) {
            classificationLoss_ = null;
          } else {
            classificationLossBuilder_.clear();
          }
          bitField0_ = (bitField0_ & ~0x00000010);
          return this;
        }

        @java.lang.Override
        public com.google.protobuf.Descriptors.Descriptor
            getDescriptorForType() {
          return object_detection.protos.CenterNetOuterClass.internal_static_object_detection_protos_CenterNet_TrackEstimation_descriptor;
        }

        @java.lang.Override
        public object_detection.protos.CenterNetOuterClass.CenterNet.TrackEstimation getDefaultInstanceForType() {
          return object_detection.protos.CenterNetOuterClass.CenterNet.TrackEstimation.getDefaultInstance();
        }

        @java.lang.Override
        public object_detection.protos.CenterNetOuterClass.CenterNet.TrackEstimation build() {
          object_detection.protos.CenterNetOuterClass.CenterNet.TrackEstimation result = buildPartial();
          if (!result.isInitialized()) {
            throw newUninitializedMessageException(result);
          }
          return result;
        }

        @java.lang.Override
        public object_detection.protos.CenterNetOuterClass.CenterNet.TrackEstimation buildPartial() {
          object_detection.protos.CenterNetOuterClass.CenterNet.TrackEstimation result = new object_detection.protos.CenterNetOuterClass.CenterNet.TrackEstimation(this);
          int from_bitField0_ = bitField0_;
          int to_bitField0_ = 0;
          if (((from_bitField0_ & 0x00000001) != 0)) {
            to_bitField0_ |= 0x00000001;
          }
          result.taskLossWeight_ = taskLossWeight_;
          if (((from_bitField0_ & 0x00000002) != 0)) {
            result.numTrackIds_ = numTrackIds_;
            to_bitField0_ |= 0x00000002;
          }
          if (((from_bitField0_ & 0x00000004) != 0)) {
            to_bitField0_ |= 0x00000004;
          }
          result.reidEmbedSize_ = reidEmbedSize_;
          if (((from_bitField0_ & 0x00000008) != 0)) {
            to_bitField0_ |= 0x00000008;
          }
          result.numFcLayers_ = numFcLayers_;
          if (((from_bitField0_ & 0x00000010) != 0)) {
            if (classificationLossBuilder_ == null) {
              result.classificationLoss_ = classificationLoss_;
            } else {
              result.classificationLoss_ = classificationLossBuilder_.build();
            }
            to_bitField0_ |= 0x00000010;
          }
          result.bitField0_ = to_bitField0_;
          onBuilt();
          return result;
        }

        @java.lang.Override
        public Builder clone() {
          return super.clone();
        }
        @java.lang.Override
        public Builder setField(
            com.google.protobuf.Descriptors.FieldDescriptor field,
            java.lang.Object value) {
          return super.setField(field, value);
        }
        @java.lang.Override
        public Builder clearField(
            com.google.protobuf.Descriptors.FieldDescriptor field) {
          return super.clearField(field);
        }
        @java.lang.Override
        public Builder clearOneof(
            com.google.protobuf.Descriptors.OneofDescriptor oneof) {
          return super.clearOneof(oneof);
        }
        @java.lang.Override
        public Builder setRepeatedField(
            com.google.protobuf.Descriptors.FieldDescriptor field,
            int index, java.lang.Object value) {
          return super.setRepeatedField(field, index, value);
        }
        @java.lang.Override
        public Builder addRepeatedField(
            com.google.protobuf.Descriptors.FieldDescriptor field,
            java.lang.Object value) {
          return super.addRepeatedField(field, value);
        }
        @java.lang.Override
        public Builder mergeFrom(com.google.protobuf.Message other) {
          if (other instanceof object_detection.protos.CenterNetOuterClass.CenterNet.TrackEstimation) {
            return mergeFrom((object_detection.protos.CenterNetOuterClass.CenterNet.TrackEstimation)other);
          } else {
            super.mergeFrom(other);
            return this;
          }
        }

        public Builder mergeFrom(object_detection.protos.CenterNetOuterClass.CenterNet.TrackEstimation other) {
          if (other == object_detection.protos.CenterNetOuterClass.CenterNet.TrackEstimation.getDefaultInstance()) return this;
          if (other.hasTaskLossWeight()) {
            setTaskLossWeight(other.getTaskLossWeight());
          }
          if (other.hasNumTrackIds()) {
            setNumTrackIds(other.getNumTrackIds());
          }
          if (other.hasReidEmbedSize()) {
            setReidEmbedSize(other.getReidEmbedSize());
          }
          if (other.hasNumFcLayers()) {
            setNumFcLayers(other.getNumFcLayers());
          }
          if (other.hasClassificationLoss()) {
            mergeClassificationLoss(other.getClassificationLoss());
          }
          this.mergeUnknownFields(other.unknownFields);
          onChanged();
          return this;
        }

        @java.lang.Override
        public final boolean isInitialized() {
          return true;
        }

        @java.lang.Override
        public Builder mergeFrom(
            com.google.protobuf.CodedInputStream input,
            com.google.protobuf.ExtensionRegistryLite extensionRegistry)
            throws java.io.IOException {
          object_detection.protos.CenterNetOuterClass.CenterNet.TrackEstimation parsedMessage = null;
          try {
            parsedMessage = PARSER.parsePartialFrom(input, extensionRegistry);
          } catch (com.google.protobuf.InvalidProtocolBufferException e) {
            parsedMessage = (object_detection.protos.CenterNetOuterClass.CenterNet.TrackEstimation) e.getUnfinishedMessage();
            throw e.unwrapIOException();
          } finally {
            if (parsedMessage != null) {
              mergeFrom(parsedMessage);
            }
          }
          return this;
        }
        private int bitField0_;

        private float taskLossWeight_ = 1F;
        /**
         * <pre>
         * Weight of the task loss. The total loss of the model will be the
         * summation of task losses weighted by the weights.
         * </pre>
         *
         * <code>optional float task_loss_weight = 1 [default = 1];</code>
         * @return Whether the taskLossWeight field is set.
         */
        @java.lang.Override
        public boolean hasTaskLossWeight() {
          return ((bitField0_ & 0x00000001) != 0);
        }
        /**
         * <pre>
         * Weight of the task loss. The total loss of the model will be the
         * summation of task losses weighted by the weights.
         * </pre>
         *
         * <code>optional float task_loss_weight = 1 [default = 1];</code>
         * @return The taskLossWeight.
         */
        @java.lang.Override
        public float getTaskLossWeight() {
          return taskLossWeight_;
        }
        /**
         * <pre>
         * Weight of the task loss. The total loss of the model will be the
         * summation of task losses weighted by the weights.
         * </pre>
         *
         * <code>optional float task_loss_weight = 1 [default = 1];</code>
         * @param value The taskLossWeight to set.
         * @return This builder for chaining.
         */
        public Builder setTaskLossWeight(float value) {
          bitField0_ |= 0x00000001;
          taskLossWeight_ = value;
          onChanged();
          return this;
        }
        /**
         * <pre>
         * Weight of the task loss. The total loss of the model will be the
         * summation of task losses weighted by the weights.
         * </pre>
         *
         * <code>optional float task_loss_weight = 1 [default = 1];</code>
         * @return This builder for chaining.
         */
        public Builder clearTaskLossWeight() {
          bitField0_ = (bitField0_ & ~0x00000001);
          taskLossWeight_ = 1F;
          onChanged();
          return this;
        }

        private int numTrackIds_ ;
        /**
         * <pre>
         * The maximun track ID of the datset.
         * </pre>
         *
         * <code>optional int32 num_track_ids = 2;</code>
         * @return Whether the numTrackIds field is set.
         */
        @java.lang.Override
        public boolean hasNumTrackIds() {
          return ((bitField0_ & 0x00000002) != 0);
        }
        /**
         * <pre>
         * The maximun track ID of the datset.
         * </pre>
         *
         * <code>optional int32 num_track_ids = 2;</code>
         * @return The numTrackIds.
         */
        @java.lang.Override
        public int getNumTrackIds() {
          return numTrackIds_;
        }
        /**
         * <pre>
         * The maximun track ID of the datset.
         * </pre>
         *
         * <code>optional int32 num_track_ids = 2;</code>
         * @param value The numTrackIds to set.
         * @return This builder for chaining.
         */
        public Builder setNumTrackIds(int value) {
          bitField0_ |= 0x00000002;
          numTrackIds_ = value;
          onChanged();
          return this;
        }
        /**
         * <pre>
         * The maximun track ID of the datset.
         * </pre>
         *
         * <code>optional int32 num_track_ids = 2;</code>
         * @return This builder for chaining.
         */
        public Builder clearNumTrackIds() {
          bitField0_ = (bitField0_ & ~0x00000002);
          numTrackIds_ = 0;
          onChanged();
          return this;
        }

        private int reidEmbedSize_ = 128;
        /**
         * <pre>
         * The embedding size for re-identification (ReID) task in tracking.
         * </pre>
         *
         * <code>optional int32 reid_embed_size = 3 [default = 128];</code>
         * @return Whether the reidEmbedSize field is set.
         */
        @java.lang.Override
        public boolean hasReidEmbedSize() {
          return ((bitField0_ & 0x00000004) != 0);
        }
        /**
         * <pre>
         * The embedding size for re-identification (ReID) task in tracking.
         * </pre>
         *
         * <code>optional int32 reid_embed_size = 3 [default = 128];</code>
         * @return The reidEmbedSize.
         */
        @java.lang.Override
        public int getReidEmbedSize() {
          return reidEmbedSize_;
        }
        /**
         * <pre>
         * The embedding size for re-identification (ReID) task in tracking.
         * </pre>
         *
         * <code>optional int32 reid_embed_size = 3 [default = 128];</code>
         * @param value The reidEmbedSize to set.
         * @return This builder for chaining.
         */
        public Builder setReidEmbedSize(int value) {
          bitField0_ |= 0x00000004;
          reidEmbedSize_ = value;
          onChanged();
          return this;
        }
        /**
         * <pre>
         * The embedding size for re-identification (ReID) task in tracking.
         * </pre>
         *
         * <code>optional int32 reid_embed_size = 3 [default = 128];</code>
         * @return This builder for chaining.
         */
        public Builder clearReidEmbedSize() {
          bitField0_ = (bitField0_ & ~0x00000004);
          reidEmbedSize_ = 128;
          onChanged();
          return this;
        }

        private int numFcLayers_ = 1;
        /**
         * <pre>
         * The number of (fully-connected, batch-norm, relu) layers for track ID
         * classification head. The output dimension of each intermediate FC layer
         * will all be 'reid_embed_size'. The last FC layer will directly project to
         * the track ID classification space of size 'num_track_ids' without
         * batch-norm and relu layers.
         * </pre>
         *
         * <code>optional int32 num_fc_layers = 4 [default = 1];</code>
         * @return Whether the numFcLayers field is set.
         */
        @java.lang.Override
        public boolean hasNumFcLayers() {
          return ((bitField0_ & 0x00000008) != 0);
        }
        /**
         * <pre>
         * The number of (fully-connected, batch-norm, relu) layers for track ID
         * classification head. The output dimension of each intermediate FC layer
         * will all be 'reid_embed_size'. The last FC layer will directly project to
         * the track ID classification space of size 'num_track_ids' without
         * batch-norm and relu layers.
         * </pre>
         *
         * <code>optional int32 num_fc_layers = 4 [default = 1];</code>
         * @return The numFcLayers.
         */
        @java.lang.Override
        public int getNumFcLayers() {
          return numFcLayers_;
        }
        /**
         * <pre>
         * The number of (fully-connected, batch-norm, relu) layers for track ID
         * classification head. The output dimension of each intermediate FC layer
         * will all be 'reid_embed_size'. The last FC layer will directly project to
         * the track ID classification space of size 'num_track_ids' without
         * batch-norm and relu layers.
         * </pre>
         *
         * <code>optional int32 num_fc_layers = 4 [default = 1];</code>
         * @param value The numFcLayers to set.
         * @return This builder for chaining.
         */
        public Builder setNumFcLayers(int value) {
          bitField0_ |= 0x00000008;
          numFcLayers_ = value;
          onChanged();
          return this;
        }
        /**
         * <pre>
         * The number of (fully-connected, batch-norm, relu) layers for track ID
         * classification head. The output dimension of each intermediate FC layer
         * will all be 'reid_embed_size'. The last FC layer will directly project to
         * the track ID classification space of size 'num_track_ids' without
         * batch-norm and relu layers.
         * </pre>
         *
         * <code>optional int32 num_fc_layers = 4 [default = 1];</code>
         * @return This builder for chaining.
         */
        public Builder clearNumFcLayers() {
          bitField0_ = (bitField0_ & ~0x00000008);
          numFcLayers_ = 1;
          onChanged();
          return this;
        }

        private object_detection.protos.Losses.ClassificationLoss classificationLoss_;
        private com.google.protobuf.SingleFieldBuilderV3<
            object_detection.protos.Losses.ClassificationLoss, object_detection.protos.Losses.ClassificationLoss.Builder, object_detection.protos.Losses.ClassificationLossOrBuilder> classificationLossBuilder_;
        /**
         * <pre>
         * Classification loss configuration for ReID loss.
         * </pre>
         *
         * <code>optional .object_detection.protos.ClassificationLoss classification_loss = 5;</code>
         * @return Whether the classificationLoss field is set.
         */
        public boolean hasClassificationLoss() {
          return ((bitField0_ & 0x00000010) != 0);
        }
        /**
         * <pre>
         * Classification loss configuration for ReID loss.
         * </pre>
         *
         * <code>optional .object_detection.protos.ClassificationLoss classification_loss = 5;</code>
         * @return The classificationLoss.
         */
        public object_detection.protos.Losses.ClassificationLoss getClassificationLoss() {
          if (classificationLossBuilder_ == null) {
            return classificationLoss_ == null ? object_detection.protos.Losses.ClassificationLoss.getDefaultInstance() : classificationLoss_;
          } else {
            return classificationLossBuilder_.getMessage();
          }
        }
        /**
         * <pre>
         * Classification loss configuration for ReID loss.
         * </pre>
         *
         * <code>optional .object_detection.protos.ClassificationLoss classification_loss = 5;</code>
         */
        public Builder setClassificationLoss(object_detection.protos.Losses.ClassificationLoss value) {
          if (classificationLossBuilder_ == null) {
            if (value == null) {
              throw new NullPointerException();
            }
            classificationLoss_ = value;
            onChanged();
          } else {
            classificationLossBuilder_.setMessage(value);
          }
          bitField0_ |= 0x00000010;
          return this;
        }
        /**
         * <pre>
         * Classification loss configuration for ReID loss.
         * </pre>
         *
         * <code>optional .object_detection.protos.ClassificationLoss classification_loss = 5;</code>
         */
        public Builder setClassificationLoss(
            object_detection.protos.Losses.ClassificationLoss.Builder builderForValue) {
          if (classificationLossBuilder_ == null) {
            classificationLoss_ = builderForValue.build();
            onChanged();
          } else {
            classificationLossBuilder_.setMessage(builderForValue.build());
          }
          bitField0_ |= 0x00000010;
          return this;
        }
        /**
         * <pre>
         * Classification loss configuration for ReID loss.
         * </pre>
         *
         * <code>optional .object_detection.protos.ClassificationLoss classification_loss = 5;</code>
         */
        public Builder mergeClassificationLoss(object_detection.protos.Losses.ClassificationLoss value) {
          if (classificationLossBuilder_ == null) {
            if (((bitField0_ & 0x00000010) != 0) &&
                classificationLoss_ != null &&
                classificationLoss_ != object_detection.protos.Losses.ClassificationLoss.getDefaultInstance()) {
              classificationLoss_ =
                object_detection.protos.Losses.ClassificationLoss.newBuilder(classificationLoss_).mergeFrom(value).buildPartial();
            } else {
              classificationLoss_ = value;
            }
            onChanged();
          } else {
            classificationLossBuilder_.mergeFrom(value);
          }
          bitField0_ |= 0x00000010;
          return this;
        }
        /**
         * <pre>
         * Classification loss configuration for ReID loss.
         * </pre>
         *
         * <code>optional .object_detection.protos.ClassificationLoss classification_loss = 5;</code>
         */
        public Builder clearClassificationLoss() {
          if (classificationLossBuilder_ == null) {
            classificationLoss_ = null;
            onChanged();
          } else {
            classificationLossBuilder_.clear();
          }
          bitField0_ = (bitField0_ & ~0x00000010);
          return this;
        }
        /**
         * <pre>
         * Classification loss configuration for ReID loss.
         * </pre>
         *
         * <code>optional .object_detection.protos.ClassificationLoss classification_loss = 5;</code>
         */
        public object_detection.protos.Losses.ClassificationLoss.Builder getClassificationLossBuilder() {
          bitField0_ |= 0x00000010;
          onChanged();
          return getClassificationLossFieldBuilder().getBuilder();
        }
        /**
         * <pre>
         * Classification loss configuration for ReID loss.
         * </pre>
         *
         * <code>optional .object_detection.protos.ClassificationLoss classification_loss = 5;</code>
         */
        public object_detection.protos.Losses.ClassificationLossOrBuilder getClassificationLossOrBuilder() {
          if (classificationLossBuilder_ != null) {
            return classificationLossBuilder_.getMessageOrBuilder();
          } else {
            return classificationLoss_ == null ?
                object_detection.protos.Losses.ClassificationLoss.getDefaultInstance() : classificationLoss_;
          }
        }
        /**
         * <pre>
         * Classification loss configuration for ReID loss.
         * </pre>
         *
         * <code>optional .object_detection.protos.ClassificationLoss classification_loss = 5;</code>
         */
        private com.google.protobuf.SingleFieldBuilderV3<
            object_detection.protos.Losses.ClassificationLoss, object_detection.protos.Losses.ClassificationLoss.Builder, object_detection.protos.Losses.ClassificationLossOrBuilder>
            getClassificationLossFieldBuilder() {
          if (classificationLossBuilder_ == null) {
            classificationLossBuilder_ = new com.google.protobuf.SingleFieldBuilderV3<
                object_detection.protos.Losses.ClassificationLoss, object_detection.protos.Losses.ClassificationLoss.Builder, object_detection.protos.Losses.ClassificationLossOrBuilder>(
                    getClassificationLoss(),
                    getParentForChildren(),
                    isClean());
            classificationLoss_ = null;
          }
          return classificationLossBuilder_;
        }
        @java.lang.Override
        public final Builder setUnknownFields(
            final com.google.protobuf.UnknownFieldSet unknownFields) {
          return super.setUnknownFields(unknownFields);
        }

        @java.lang.Override
        public final Builder mergeUnknownFields(
            final com.google.protobuf.UnknownFieldSet unknownFields) {
          return super.mergeUnknownFields(unknownFields);
        }


        // @@protoc_insertion_point(builder_scope:object_detection.protos.CenterNet.TrackEstimation)
      }

      // @@protoc_insertion_point(class_scope:object_detection.protos.CenterNet.TrackEstimation)
      private static final object_detection.protos.CenterNetOuterClass.CenterNet.TrackEstimation DEFAULT_INSTANCE;
      static {
        DEFAULT_INSTANCE = new object_detection.protos.CenterNetOuterClass.CenterNet.TrackEstimation();
      }

      public static object_detection.protos.CenterNetOuterClass.CenterNet.TrackEstimation getDefaultInstance() {
        return DEFAULT_INSTANCE;
      }

      @java.lang.Deprecated public static final com.google.protobuf.Parser<TrackEstimation>
          PARSER = new com.google.protobuf.AbstractParser<TrackEstimation>() {
        @java.lang.Override
        public TrackEstimation parsePartialFrom(
            com.google.protobuf.CodedInputStream input,
            com.google.protobuf.ExtensionRegistryLite extensionRegistry)
            throws com.google.protobuf.InvalidProtocolBufferException {
          return new TrackEstimation(input, extensionRegistry);
        }
      };

      public static com.google.protobuf.Parser<TrackEstimation> parser() {
        return PARSER;
      }

      @java.lang.Override
      public com.google.protobuf.Parser<TrackEstimation> getParserForType() {
        return PARSER;
      }

      @java.lang.Override
      public object_detection.protos.CenterNetOuterClass.CenterNet.TrackEstimation getDefaultInstanceForType() {
        return DEFAULT_INSTANCE;
      }

    }

    public interface TemporalOffsetEstimationOrBuilder extends
        // @@protoc_insertion_point(interface_extends:object_detection.protos.CenterNet.TemporalOffsetEstimation)
        com.google.protobuf.MessageOrBuilder {

      /**
       * <pre>
       * Weight of the task loss. The total loss of the model will be the
       * summation of task losses weighted by the weights.
       * </pre>
       *
       * <code>optional float task_loss_weight = 1 [default = 1];</code>
       * @return Whether the taskLossWeight field is set.
       */
      boolean hasTaskLossWeight();
      /**
       * <pre>
       * Weight of the task loss. The total loss of the model will be the
       * summation of task losses weighted by the weights.
       * </pre>
       *
       * <code>optional float task_loss_weight = 1 [default = 1];</code>
       * @return The taskLossWeight.
       */
      float getTaskLossWeight();

      /**
       * <pre>
       * Localization loss configuration for offset loss.
       * </pre>
       *
       * <code>optional .object_detection.protos.LocalizationLoss localization_loss = 2;</code>
       * @return Whether the localizationLoss field is set.
       */
      boolean hasLocalizationLoss();
      /**
       * <pre>
       * Localization loss configuration for offset loss.
       * </pre>
       *
       * <code>optional .object_detection.protos.LocalizationLoss localization_loss = 2;</code>
       * @return The localizationLoss.
       */
      object_detection.protos.Losses.LocalizationLoss getLocalizationLoss();
      /**
       * <pre>
       * Localization loss configuration for offset loss.
       * </pre>
       *
       * <code>optional .object_detection.protos.LocalizationLoss localization_loss = 2;</code>
       */
      object_detection.protos.Losses.LocalizationLossOrBuilder getLocalizationLossOrBuilder();
    }
    /**
     * <pre>
     * Temporal offset prediction head similar to CenterTrack.
     * Currently our implementation adopts LSTM, different from original paper.
     * See go/lstd-centernet for more details.
     * Tracking Objects as Points [3]
     * [3]: https://arxiv.org/abs/2004.01177
     * </pre>
     *
     * Protobuf type {@code object_detection.protos.CenterNet.TemporalOffsetEstimation}
     */
    public static final class TemporalOffsetEstimation extends
        com.google.protobuf.GeneratedMessageV3 implements
        // @@protoc_insertion_point(message_implements:object_detection.protos.CenterNet.TemporalOffsetEstimation)
        TemporalOffsetEstimationOrBuilder {
    private static final long serialVersionUID = 0L;
      // Use TemporalOffsetEstimation.newBuilder() to construct.
      private TemporalOffsetEstimation(com.google.protobuf.GeneratedMessageV3.Builder<?> builder) {
        super(builder);
      }
      private TemporalOffsetEstimation() {
        taskLossWeight_ = 1F;
      }

      @java.lang.Override
      @SuppressWarnings({"unused"})
      protected java.lang.Object newInstance(
          UnusedPrivateParameter unused) {
        return new TemporalOffsetEstimation();
      }

      @java.lang.Override
      public final com.google.protobuf.UnknownFieldSet
      getUnknownFields() {
        return this.unknownFields;
      }
      private TemporalOffsetEstimation(
          com.google.protobuf.CodedInputStream input,
          com.google.protobuf.ExtensionRegistryLite extensionRegistry)
          throws com.google.protobuf.InvalidProtocolBufferException {
        this();
        if (extensionRegistry == null) {
          throw new java.lang.NullPointerException();
        }
        int mutable_bitField0_ = 0;
        com.google.protobuf.UnknownFieldSet.Builder unknownFields =
            com.google.protobuf.UnknownFieldSet.newBuilder();
        try {
          boolean done = false;
          while (!done) {
            int tag = input.readTag();
            switch (tag) {
              case 0:
                done = true;
                break;
              case 13: {
                bitField0_ |= 0x00000001;
                taskLossWeight_ = input.readFloat();
                break;
              }
              case 18: {
                object_detection.protos.Losses.LocalizationLoss.Builder subBuilder = null;
                if (((bitField0_ & 0x00000002) != 0)) {
                  subBuilder = localizationLoss_.toBuilder();
                }
                localizationLoss_ = input.readMessage(object_detection.protos.Losses.LocalizationLoss.PARSER, extensionRegistry);
                if (subBuilder != null) {
                  subBuilder.mergeFrom(localizationLoss_);
                  localizationLoss_ = subBuilder.buildPartial();
                }
                bitField0_ |= 0x00000002;
                break;
              }
              default: {
                if (!parseUnknownField(
                    input, unknownFields, extensionRegistry, tag)) {
                  done = true;
                }
                break;
              }
            }
          }
        } catch (com.google.protobuf.InvalidProtocolBufferException e) {
          throw e.setUnfinishedMessage(this);
        } catch (java.io.IOException e) {
          throw new com.google.protobuf.InvalidProtocolBufferException(
              e).setUnfinishedMessage(this);
        } finally {
          this.unknownFields = unknownFields.build();
          makeExtensionsImmutable();
        }
      }
      public static final com.google.protobuf.Descriptors.Descriptor
          getDescriptor() {
        return object_detection.protos.CenterNetOuterClass.internal_static_object_detection_protos_CenterNet_TemporalOffsetEstimation_descriptor;
      }

      @java.lang.Override
      protected com.google.protobuf.GeneratedMessageV3.FieldAccessorTable
          internalGetFieldAccessorTable() {
        return object_detection.protos.CenterNetOuterClass.internal_static_object_detection_protos_CenterNet_TemporalOffsetEstimation_fieldAccessorTable
            .ensureFieldAccessorsInitialized(
                object_detection.protos.CenterNetOuterClass.CenterNet.TemporalOffsetEstimation.class, object_detection.protos.CenterNetOuterClass.CenterNet.TemporalOffsetEstimation.Builder.class);
      }

      private int bitField0_;
      public static final int TASK_LOSS_WEIGHT_FIELD_NUMBER = 1;
      private float taskLossWeight_;
      /**
       * <pre>
       * Weight of the task loss. The total loss of the model will be the
       * summation of task losses weighted by the weights.
       * </pre>
       *
       * <code>optional float task_loss_weight = 1 [default = 1];</code>
       * @return Whether the taskLossWeight field is set.
       */
      @java.lang.Override
      public boolean hasTaskLossWeight() {
        return ((bitField0_ & 0x00000001) != 0);
      }
      /**
       * <pre>
       * Weight of the task loss. The total loss of the model will be the
       * summation of task losses weighted by the weights.
       * </pre>
       *
       * <code>optional float task_loss_weight = 1 [default = 1];</code>
       * @return The taskLossWeight.
       */
      @java.lang.Override
      public float getTaskLossWeight() {
        return taskLossWeight_;
      }

      public static final int LOCALIZATION_LOSS_FIELD_NUMBER = 2;
      private object_detection.protos.Losses.LocalizationLoss localizationLoss_;
      /**
       * <pre>
       * Localization loss configuration for offset loss.
       * </pre>
       *
       * <code>optional .object_detection.protos.LocalizationLoss localization_loss = 2;</code>
       * @return Whether the localizationLoss field is set.
       */
      @java.lang.Override
      public boolean hasLocalizationLoss() {
        return ((bitField0_ & 0x00000002) != 0);
      }
      /**
       * <pre>
       * Localization loss configuration for offset loss.
       * </pre>
       *
       * <code>optional .object_detection.protos.LocalizationLoss localization_loss = 2;</code>
       * @return The localizationLoss.
       */
      @java.lang.Override
      public object_detection.protos.Losses.LocalizationLoss getLocalizationLoss() {
        return localizationLoss_ == null ? object_detection.protos.Losses.LocalizationLoss.getDefaultInstance() : localizationLoss_;
      }
      /**
       * <pre>
       * Localization loss configuration for offset loss.
       * </pre>
       *
       * <code>optional .object_detection.protos.LocalizationLoss localization_loss = 2;</code>
       */
      @java.lang.Override
      public object_detection.protos.Losses.LocalizationLossOrBuilder getLocalizationLossOrBuilder() {
        return localizationLoss_ == null ? object_detection.protos.Losses.LocalizationLoss.getDefaultInstance() : localizationLoss_;
      }

      private byte memoizedIsInitialized = -1;
      @java.lang.Override
      public final boolean isInitialized() {
        byte isInitialized = memoizedIsInitialized;
        if (isInitialized == 1) return true;
        if (isInitialized == 0) return false;

        memoizedIsInitialized = 1;
        return true;
      }

      @java.lang.Override
      public void writeTo(com.google.protobuf.CodedOutputStream output)
                          throws java.io.IOException {
        if (((bitField0_ & 0x00000001) != 0)) {
          output.writeFloat(1, taskLossWeight_);
        }
        if (((bitField0_ & 0x00000002) != 0)) {
          output.writeMessage(2, getLocalizationLoss());
        }
        unknownFields.writeTo(output);
      }

      @java.lang.Override
      public int getSerializedSize() {
        int size = memoizedSize;
        if (size != -1) return size;

        size = 0;
        if (((bitField0_ & 0x00000001) != 0)) {
          size += com.google.protobuf.CodedOutputStream
            .computeFloatSize(1, taskLossWeight_);
        }
        if (((bitField0_ & 0x00000002) != 0)) {
          size += com.google.protobuf.CodedOutputStream
            .computeMessageSize(2, getLocalizationLoss());
        }
        size += unknownFields.getSerializedSize();
        memoizedSize = size;
        return size;
      }

      @java.lang.Override
      public boolean equals(final java.lang.Object obj) {
        if (obj == this) {
         return true;
        }
        if (!(obj instanceof object_detection.protos.CenterNetOuterClass.CenterNet.TemporalOffsetEstimation)) {
          return super.equals(obj);
        }
        object_detection.protos.CenterNetOuterClass.CenterNet.TemporalOffsetEstimation other = (object_detection.protos.CenterNetOuterClass.CenterNet.TemporalOffsetEstimation) obj;

        if (hasTaskLossWeight() != other.hasTaskLossWeight()) return false;
        if (hasTaskLossWeight()) {
          if (java.lang.Float.floatToIntBits(getTaskLossWeight())
              != java.lang.Float.floatToIntBits(
                  other.getTaskLossWeight())) return false;
        }
        if (hasLocalizationLoss() != other.hasLocalizationLoss()) return false;
        if (hasLocalizationLoss()) {
          if (!getLocalizationLoss()
              .equals(other.getLocalizationLoss())) return false;
        }
        if (!unknownFields.equals(other.unknownFields)) return false;
        return true;
      }

      @java.lang.Override
      public int hashCode() {
        if (memoizedHashCode != 0) {
          return memoizedHashCode;
        }
        int hash = 41;
        hash = (19 * hash) + getDescriptor().hashCode();
        if (hasTaskLossWeight()) {
          hash = (37 * hash) + TASK_LOSS_WEIGHT_FIELD_NUMBER;
          hash = (53 * hash) + java.lang.Float.floatToIntBits(
              getTaskLossWeight());
        }
        if (hasLocalizationLoss()) {
          hash = (37 * hash) + LOCALIZATION_LOSS_FIELD_NUMBER;
          hash = (53 * hash) + getLocalizationLoss().hashCode();
        }
        hash = (29 * hash) + unknownFields.hashCode();
        memoizedHashCode = hash;
        return hash;
      }

      public static object_detection.protos.CenterNetOuterClass.CenterNet.TemporalOffsetEstimation parseFrom(
          java.nio.ByteBuffer data)
          throws com.google.protobuf.InvalidProtocolBufferException {
        return PARSER.parseFrom(data);
      }
      public static object_detection.protos.CenterNetOuterClass.CenterNet.TemporalOffsetEstimation parseFrom(
          java.nio.ByteBuffer data,
          com.google.protobuf.ExtensionRegistryLite extensionRegistry)
          throws com.google.protobuf.InvalidProtocolBufferException {
        return PARSER.parseFrom(data, extensionRegistry);
      }
      public static object_detection.protos.CenterNetOuterClass.CenterNet.TemporalOffsetEstimation parseFrom(
          com.google.protobuf.ByteString data)
          throws com.google.protobuf.InvalidProtocolBufferException {
        return PARSER.parseFrom(data);
      }
      public static object_detection.protos.CenterNetOuterClass.CenterNet.TemporalOffsetEstimation parseFrom(
          com.google.protobuf.ByteString data,
          com.google.protobuf.ExtensionRegistryLite extensionRegistry)
          throws com.google.protobuf.InvalidProtocolBufferException {
        return PARSER.parseFrom(data, extensionRegistry);
      }
      public static object_detection.protos.CenterNetOuterClass.CenterNet.TemporalOffsetEstimation parseFrom(byte[] data)
          throws com.google.protobuf.InvalidProtocolBufferException {
        return PARSER.parseFrom(data);
      }
      public static object_detection.protos.CenterNetOuterClass.CenterNet.TemporalOffsetEstimation parseFrom(
          byte[] data,
          com.google.protobuf.ExtensionRegistryLite extensionRegistry)
          throws com.google.protobuf.InvalidProtocolBufferException {
        return PARSER.parseFrom(data, extensionRegistry);
      }
      public static object_detection.protos.CenterNetOuterClass.CenterNet.TemporalOffsetEstimation parseFrom(java.io.InputStream input)
          throws java.io.IOException {
        return com.google.protobuf.GeneratedMessageV3
            .parseWithIOException(PARSER, input);
      }
      public static object_detection.protos.CenterNetOuterClass.CenterNet.TemporalOffsetEstimation parseFrom(
          java.io.InputStream input,
          com.google.protobuf.ExtensionRegistryLite extensionRegistry)
          throws java.io.IOException {
        return com.google.protobuf.GeneratedMessageV3
            .parseWithIOException(PARSER, input, extensionRegistry);
      }
      public static object_detection.protos.CenterNetOuterClass.CenterNet.TemporalOffsetEstimation parseDelimitedFrom(java.io.InputStream input)
          throws java.io.IOException {
        return com.google.protobuf.GeneratedMessageV3
            .parseDelimitedWithIOException(PARSER, input);
      }
      public static object_detection.protos.CenterNetOuterClass.CenterNet.TemporalOffsetEstimation parseDelimitedFrom(
          java.io.InputStream input,
          com.google.protobuf.ExtensionRegistryLite extensionRegistry)
          throws java.io.IOException {
        return com.google.protobuf.GeneratedMessageV3
            .parseDelimitedWithIOException(PARSER, input, extensionRegistry);
      }
      public static object_detection.protos.CenterNetOuterClass.CenterNet.TemporalOffsetEstimation parseFrom(
          com.google.protobuf.CodedInputStream input)
          throws java.io.IOException {
        return com.google.protobuf.GeneratedMessageV3
            .parseWithIOException(PARSER, input);
      }
      public static object_detection.protos.CenterNetOuterClass.CenterNet.TemporalOffsetEstimation parseFrom(
          com.google.protobuf.CodedInputStream input,
          com.google.protobuf.ExtensionRegistryLite extensionRegistry)
          throws java.io.IOException {
        return com.google.protobuf.GeneratedMessageV3
            .parseWithIOException(PARSER, input, extensionRegistry);
      }

      @java.lang.Override
      public Builder newBuilderForType() { return newBuilder(); }
      public static Builder newBuilder() {
        return DEFAULT_INSTANCE.toBuilder();
      }
      public static Builder newBuilder(object_detection.protos.CenterNetOuterClass.CenterNet.TemporalOffsetEstimation prototype) {
        return DEFAULT_INSTANCE.toBuilder().mergeFrom(prototype);
      }
      @java.lang.Override
      public Builder toBuilder() {
        return this == DEFAULT_INSTANCE
            ? new Builder() : new Builder().mergeFrom(this);
      }

      @java.lang.Override
      protected Builder newBuilderForType(
          com.google.protobuf.GeneratedMessageV3.BuilderParent parent) {
        Builder builder = new Builder(parent);
        return builder;
      }
      /**
       * <pre>
       * Temporal offset prediction head similar to CenterTrack.
       * Currently our implementation adopts LSTM, different from original paper.
       * See go/lstd-centernet for more details.
       * Tracking Objects as Points [3]
       * [3]: https://arxiv.org/abs/2004.01177
       * </pre>
       *
       * Protobuf type {@code object_detection.protos.CenterNet.TemporalOffsetEstimation}
       */
      public static final class Builder extends
          com.google.protobuf.GeneratedMessageV3.Builder<Builder> implements
          // @@protoc_insertion_point(builder_implements:object_detection.protos.CenterNet.TemporalOffsetEstimation)
          object_detection.protos.CenterNetOuterClass.CenterNet.TemporalOffsetEstimationOrBuilder {
        public static final com.google.protobuf.Descriptors.Descriptor
            getDescriptor() {
          return object_detection.protos.CenterNetOuterClass.internal_static_object_detection_protos_CenterNet_TemporalOffsetEstimation_descriptor;
        }

        @java.lang.Override
        protected com.google.protobuf.GeneratedMessageV3.FieldAccessorTable
            internalGetFieldAccessorTable() {
          return object_detection.protos.CenterNetOuterClass.internal_static_object_detection_protos_CenterNet_TemporalOffsetEstimation_fieldAccessorTable
              .ensureFieldAccessorsInitialized(
                  object_detection.protos.CenterNetOuterClass.CenterNet.TemporalOffsetEstimation.class, object_detection.protos.CenterNetOuterClass.CenterNet.TemporalOffsetEstimation.Builder.class);
        }

        // Construct using object_detection.protos.CenterNetOuterClass.CenterNet.TemporalOffsetEstimation.newBuilder()
        private Builder() {
          maybeForceBuilderInitialization();
        }

        private Builder(
            com.google.protobuf.GeneratedMessageV3.BuilderParent parent) {
          super(parent);
          maybeForceBuilderInitialization();
        }
        private void maybeForceBuilderInitialization() {
          if (com.google.protobuf.GeneratedMessageV3
                  .alwaysUseFieldBuilders) {
            getLocalizationLossFieldBuilder();
          }
        }
        @java.lang.Override
        public Builder clear() {
          super.clear();
          taskLossWeight_ = 1F;
          bitField0_ = (bitField0_ & ~0x00000001);
          if (localizationLossBuilder_ == null) {
            localizationLoss_ = null;
          } else {
            localizationLossBuilder_.clear();
          }
          bitField0_ = (bitField0_ & ~0x00000002);
          return this;
        }

        @java.lang.Override
        public com.google.protobuf.Descriptors.Descriptor
            getDescriptorForType() {
          return object_detection.protos.CenterNetOuterClass.internal_static_object_detection_protos_CenterNet_TemporalOffsetEstimation_descriptor;
        }

        @java.lang.Override
        public object_detection.protos.CenterNetOuterClass.CenterNet.TemporalOffsetEstimation getDefaultInstanceForType() {
          return object_detection.protos.CenterNetOuterClass.CenterNet.TemporalOffsetEstimation.getDefaultInstance();
        }

        @java.lang.Override
        public object_detection.protos.CenterNetOuterClass.CenterNet.TemporalOffsetEstimation build() {
          object_detection.protos.CenterNetOuterClass.CenterNet.TemporalOffsetEstimation result = buildPartial();
          if (!result.isInitialized()) {
            throw newUninitializedMessageException(result);
          }
          return result;
        }

        @java.lang.Override
        public object_detection.protos.CenterNetOuterClass.CenterNet.TemporalOffsetEstimation buildPartial() {
          object_detection.protos.CenterNetOuterClass.CenterNet.TemporalOffsetEstimation result = new object_detection.protos.CenterNetOuterClass.CenterNet.TemporalOffsetEstimation(this);
          int from_bitField0_ = bitField0_;
          int to_bitField0_ = 0;
          if (((from_bitField0_ & 0x00000001) != 0)) {
            to_bitField0_ |= 0x00000001;
          }
          result.taskLossWeight_ = taskLossWeight_;
          if (((from_bitField0_ & 0x00000002) != 0)) {
            if (localizationLossBuilder_ == null) {
              result.localizationLoss_ = localizationLoss_;
            } else {
              result.localizationLoss_ = localizationLossBuilder_.build();
            }
            to_bitField0_ |= 0x00000002;
          }
          result.bitField0_ = to_bitField0_;
          onBuilt();
          return result;
        }

        @java.lang.Override
        public Builder clone() {
          return super.clone();
        }
        @java.lang.Override
        public Builder setField(
            com.google.protobuf.Descriptors.FieldDescriptor field,
            java.lang.Object value) {
          return super.setField(field, value);
        }
        @java.lang.Override
        public Builder clearField(
            com.google.protobuf.Descriptors.FieldDescriptor field) {
          return super.clearField(field);
        }
        @java.lang.Override
        public Builder clearOneof(
            com.google.protobuf.Descriptors.OneofDescriptor oneof) {
          return super.clearOneof(oneof);
        }
        @java.lang.Override
        public Builder setRepeatedField(
            com.google.protobuf.Descriptors.FieldDescriptor field,
            int index, java.lang.Object value) {
          return super.setRepeatedField(field, index, value);
        }
        @java.lang.Override
        public Builder addRepeatedField(
            com.google.protobuf.Descriptors.FieldDescriptor field,
            java.lang.Object value) {
          return super.addRepeatedField(field, value);
        }
        @java.lang.Override
        public Builder mergeFrom(com.google.protobuf.Message other) {
          if (other instanceof object_detection.protos.CenterNetOuterClass.CenterNet.TemporalOffsetEstimation) {
            return mergeFrom((object_detection.protos.CenterNetOuterClass.CenterNet.TemporalOffsetEstimation)other);
          } else {
            super.mergeFrom(other);
            return this;
          }
        }

        public Builder mergeFrom(object_detection.protos.CenterNetOuterClass.CenterNet.TemporalOffsetEstimation other) {
          if (other == object_detection.protos.CenterNetOuterClass.CenterNet.TemporalOffsetEstimation.getDefaultInstance()) return this;
          if (other.hasTaskLossWeight()) {
            setTaskLossWeight(other.getTaskLossWeight());
          }
          if (other.hasLocalizationLoss()) {
            mergeLocalizationLoss(other.getLocalizationLoss());
          }
          this.mergeUnknownFields(other.unknownFields);
          onChanged();
          return this;
        }

        @java.lang.Override
        public final boolean isInitialized() {
          return true;
        }

        @java.lang.Override
        public Builder mergeFrom(
            com.google.protobuf.CodedInputStream input,
            com.google.protobuf.ExtensionRegistryLite extensionRegistry)
            throws java.io.IOException {
          object_detection.protos.CenterNetOuterClass.CenterNet.TemporalOffsetEstimation parsedMessage = null;
          try {
            parsedMessage = PARSER.parsePartialFrom(input, extensionRegistry);
          } catch (com.google.protobuf.InvalidProtocolBufferException e) {
            parsedMessage = (object_detection.protos.CenterNetOuterClass.CenterNet.TemporalOffsetEstimation) e.getUnfinishedMessage();
            throw e.unwrapIOException();
          } finally {
            if (parsedMessage != null) {
              mergeFrom(parsedMessage);
            }
          }
          return this;
        }
        private int bitField0_;

        private float taskLossWeight_ = 1F;
        /**
         * <pre>
         * Weight of the task loss. The total loss of the model will be the
         * summation of task losses weighted by the weights.
         * </pre>
         *
         * <code>optional float task_loss_weight = 1 [default = 1];</code>
         * @return Whether the taskLossWeight field is set.
         */
        @java.lang.Override
        public boolean hasTaskLossWeight() {
          return ((bitField0_ & 0x00000001) != 0);
        }
        /**
         * <pre>
         * Weight of the task loss. The total loss of the model will be the
         * summation of task losses weighted by the weights.
         * </pre>
         *
         * <code>optional float task_loss_weight = 1 [default = 1];</code>
         * @return The taskLossWeight.
         */
        @java.lang.Override
        public float getTaskLossWeight() {
          return taskLossWeight_;
        }
        /**
         * <pre>
         * Weight of the task loss. The total loss of the model will be the
         * summation of task losses weighted by the weights.
         * </pre>
         *
         * <code>optional float task_loss_weight = 1 [default = 1];</code>
         * @param value The taskLossWeight to set.
         * @return This builder for chaining.
         */
        public Builder setTaskLossWeight(float value) {
          bitField0_ |= 0x00000001;
          taskLossWeight_ = value;
          onChanged();
          return this;
        }
        /**
         * <pre>
         * Weight of the task loss. The total loss of the model will be the
         * summation of task losses weighted by the weights.
         * </pre>
         *
         * <code>optional float task_loss_weight = 1 [default = 1];</code>
         * @return This builder for chaining.
         */
        public Builder clearTaskLossWeight() {
          bitField0_ = (bitField0_ & ~0x00000001);
          taskLossWeight_ = 1F;
          onChanged();
          return this;
        }

        private object_detection.protos.Losses.LocalizationLoss localizationLoss_;
        private com.google.protobuf.SingleFieldBuilderV3<
            object_detection.protos.Losses.LocalizationLoss, object_detection.protos.Losses.LocalizationLoss.Builder, object_detection.protos.Losses.LocalizationLossOrBuilder> localizationLossBuilder_;
        /**
         * <pre>
         * Localization loss configuration for offset loss.
         * </pre>
         *
         * <code>optional .object_detection.protos.LocalizationLoss localization_loss = 2;</code>
         * @return Whether the localizationLoss field is set.
         */
        public boolean hasLocalizationLoss() {
          return ((bitField0_ & 0x00000002) != 0);
        }
        /**
         * <pre>
         * Localization loss configuration for offset loss.
         * </pre>
         *
         * <code>optional .object_detection.protos.LocalizationLoss localization_loss = 2;</code>
         * @return The localizationLoss.
         */
        public object_detection.protos.Losses.LocalizationLoss getLocalizationLoss() {
          if (localizationLossBuilder_ == null) {
            return localizationLoss_ == null ? object_detection.protos.Losses.LocalizationLoss.getDefaultInstance() : localizationLoss_;
          } else {
            return localizationLossBuilder_.getMessage();
          }
        }
        /**
         * <pre>
         * Localization loss configuration for offset loss.
         * </pre>
         *
         * <code>optional .object_detection.protos.LocalizationLoss localization_loss = 2;</code>
         */
        public Builder setLocalizationLoss(object_detection.protos.Losses.LocalizationLoss value) {
          if (localizationLossBuilder_ == null) {
            if (value == null) {
              throw new NullPointerException();
            }
            localizationLoss_ = value;
            onChanged();
          } else {
            localizationLossBuilder_.setMessage(value);
          }
          bitField0_ |= 0x00000002;
          return this;
        }
        /**
         * <pre>
         * Localization loss configuration for offset loss.
         * </pre>
         *
         * <code>optional .object_detection.protos.LocalizationLoss localization_loss = 2;</code>
         */
        public Builder setLocalizationLoss(
            object_detection.protos.Losses.LocalizationLoss.Builder builderForValue) {
          if (localizationLossBuilder_ == null) {
            localizationLoss_ = builderForValue.build();
            onChanged();
          } else {
            localizationLossBuilder_.setMessage(builderForValue.build());
          }
          bitField0_ |= 0x00000002;
          return this;
        }
        /**
         * <pre>
         * Localization loss configuration for offset loss.
         * </pre>
         *
         * <code>optional .object_detection.protos.LocalizationLoss localization_loss = 2;</code>
         */
        public Builder mergeLocalizationLoss(object_detection.protos.Losses.LocalizationLoss value) {
          if (localizationLossBuilder_ == null) {
            if (((bitField0_ & 0x00000002) != 0) &&
                localizationLoss_ != null &&
                localizationLoss_ != object_detection.protos.Losses.LocalizationLoss.getDefaultInstance()) {
              localizationLoss_ =
                object_detection.protos.Losses.LocalizationLoss.newBuilder(localizationLoss_).mergeFrom(value).buildPartial();
            } else {
              localizationLoss_ = value;
            }
            onChanged();
          } else {
            localizationLossBuilder_.mergeFrom(value);
          }
          bitField0_ |= 0x00000002;
          return this;
        }
        /**
         * <pre>
         * Localization loss configuration for offset loss.
         * </pre>
         *
         * <code>optional .object_detection.protos.LocalizationLoss localization_loss = 2;</code>
         */
        public Builder clearLocalizationLoss() {
          if (localizationLossBuilder_ == null) {
            localizationLoss_ = null;
            onChanged();
          } else {
            localizationLossBuilder_.clear();
          }
          bitField0_ = (bitField0_ & ~0x00000002);
          return this;
        }
        /**
         * <pre>
         * Localization loss configuration for offset loss.
         * </pre>
         *
         * <code>optional .object_detection.protos.LocalizationLoss localization_loss = 2;</code>
         */
        public object_detection.protos.Losses.LocalizationLoss.Builder getLocalizationLossBuilder() {
          bitField0_ |= 0x00000002;
          onChanged();
          return getLocalizationLossFieldBuilder().getBuilder();
        }
        /**
         * <pre>
         * Localization loss configuration for offset loss.
         * </pre>
         *
         * <code>optional .object_detection.protos.LocalizationLoss localization_loss = 2;</code>
         */
        public object_detection.protos.Losses.LocalizationLossOrBuilder getLocalizationLossOrBuilder() {
          if (localizationLossBuilder_ != null) {
            return localizationLossBuilder_.getMessageOrBuilder();
          } else {
            return localizationLoss_ == null ?
                object_detection.protos.Losses.LocalizationLoss.getDefaultInstance() : localizationLoss_;
          }
        }
        /**
         * <pre>
         * Localization loss configuration for offset loss.
         * </pre>
         *
         * <code>optional .object_detection.protos.LocalizationLoss localization_loss = 2;</code>
         */
        private com.google.protobuf.SingleFieldBuilderV3<
            object_detection.protos.Losses.LocalizationLoss, object_detection.protos.Losses.LocalizationLoss.Builder, object_detection.protos.Losses.LocalizationLossOrBuilder>
            getLocalizationLossFieldBuilder() {
          if (localizationLossBuilder_ == null) {
            localizationLossBuilder_ = new com.google.protobuf.SingleFieldBuilderV3<
                object_detection.protos.Losses.LocalizationLoss, object_detection.protos.Losses.LocalizationLoss.Builder, object_detection.protos.Losses.LocalizationLossOrBuilder>(
                    getLocalizationLoss(),
                    getParentForChildren(),
                    isClean());
            localizationLoss_ = null;
          }
          return localizationLossBuilder_;
        }
        @java.lang.Override
        public final Builder setUnknownFields(
            final com.google.protobuf.UnknownFieldSet unknownFields) {
          return super.setUnknownFields(unknownFields);
        }

        @java.lang.Override
        public final Builder mergeUnknownFields(
            final com.google.protobuf.UnknownFieldSet unknownFields) {
          return super.mergeUnknownFields(unknownFields);
        }


        // @@protoc_insertion_point(builder_scope:object_detection.protos.CenterNet.TemporalOffsetEstimation)
      }

      // @@protoc_insertion_point(class_scope:object_detection.protos.CenterNet.TemporalOffsetEstimation)
      private static final object_detection.protos.CenterNetOuterClass.CenterNet.TemporalOffsetEstimation DEFAULT_INSTANCE;
      static {
        DEFAULT_INSTANCE = new object_detection.protos.CenterNetOuterClass.CenterNet.TemporalOffsetEstimation();
      }

      public static object_detection.protos.CenterNetOuterClass.CenterNet.TemporalOffsetEstimation getDefaultInstance() {
        return DEFAULT_INSTANCE;
      }

      @java.lang.Deprecated public static final com.google.protobuf.Parser<TemporalOffsetEstimation>
          PARSER = new com.google.protobuf.AbstractParser<TemporalOffsetEstimation>() {
        @java.lang.Override
        public TemporalOffsetEstimation parsePartialFrom(
            com.google.protobuf.CodedInputStream input,
            com.google.protobuf.ExtensionRegistryLite extensionRegistry)
            throws com.google.protobuf.InvalidProtocolBufferException {
          return new TemporalOffsetEstimation(input, extensionRegistry);
        }
      };

      public static com.google.protobuf.Parser<TemporalOffsetEstimation> parser() {
        return PARSER;
      }

      @java.lang.Override
      public com.google.protobuf.Parser<TemporalOffsetEstimation> getParserForType() {
        return PARSER;
      }

      @java.lang.Override
      public object_detection.protos.CenterNetOuterClass.CenterNet.TemporalOffsetEstimation getDefaultInstanceForType() {
        return DEFAULT_INSTANCE;
      }

    }

    private int bitField0_;
    public static final int NUM_CLASSES_FIELD_NUMBER = 1;
    private int numClasses_;
    /**
     * <pre>
     * Number of classes to predict.
     * </pre>
     *
     * <code>optional int32 num_classes = 1;</code>
     * @return Whether the numClasses field is set.
     */
    @java.lang.Override
    public boolean hasNumClasses() {
      return ((bitField0_ & 0x00000001) != 0);
    }
    /**
     * <pre>
     * Number of classes to predict.
     * </pre>
     *
     * <code>optional int32 num_classes = 1;</code>
     * @return The numClasses.
     */
    @java.lang.Override
    public int getNumClasses() {
      return numClasses_;
    }

    public static final int FEATURE_EXTRACTOR_FIELD_NUMBER = 2;
    private object_detection.protos.CenterNetOuterClass.CenterNetFeatureExtractor featureExtractor_;
    /**
     * <pre>
     * Feature extractor config.
     * </pre>
     *
     * <code>optional .object_detection.protos.CenterNetFeatureExtractor feature_extractor = 2;</code>
     * @return Whether the featureExtractor field is set.
     */
    @java.lang.Override
    public boolean hasFeatureExtractor() {
      return ((bitField0_ & 0x00000002) != 0);
    }
    /**
     * <pre>
     * Feature extractor config.
     * </pre>
     *
     * <code>optional .object_detection.protos.CenterNetFeatureExtractor feature_extractor = 2;</code>
     * @return The featureExtractor.
     */
    @java.lang.Override
    public object_detection.protos.CenterNetOuterClass.CenterNetFeatureExtractor getFeatureExtractor() {
      return featureExtractor_ == null ? object_detection.protos.CenterNetOuterClass.CenterNetFeatureExtractor.getDefaultInstance() : featureExtractor_;
    }
    /**
     * <pre>
     * Feature extractor config.
     * </pre>
     *
     * <code>optional .object_detection.protos.CenterNetFeatureExtractor feature_extractor = 2;</code>
     */
    @java.lang.Override
    public object_detection.protos.CenterNetOuterClass.CenterNetFeatureExtractorOrBuilder getFeatureExtractorOrBuilder() {
      return featureExtractor_ == null ? object_detection.protos.CenterNetOuterClass.CenterNetFeatureExtractor.getDefaultInstance() : featureExtractor_;
    }

    public static final int IMAGE_RESIZER_FIELD_NUMBER = 3;
    private object_detection.protos.ImageResizerOuterClass.ImageResizer imageResizer_;
    /**
     * <pre>
     * Image resizer for preprocessing the input image.
     * </pre>
     *
     * <code>optional .object_detection.protos.ImageResizer image_resizer = 3;</code>
     * @return Whether the imageResizer field is set.
     */
    @java.lang.Override
    public boolean hasImageResizer() {
      return ((bitField0_ & 0x00000004) != 0);
    }
    /**
     * <pre>
     * Image resizer for preprocessing the input image.
     * </pre>
     *
     * <code>optional .object_detection.protos.ImageResizer image_resizer = 3;</code>
     * @return The imageResizer.
     */
    @java.lang.Override
    public object_detection.protos.ImageResizerOuterClass.ImageResizer getImageResizer() {
      return imageResizer_ == null ? object_detection.protos.ImageResizerOuterClass.ImageResizer.getDefaultInstance() : imageResizer_;
    }
    /**
     * <pre>
     * Image resizer for preprocessing the input image.
     * </pre>
     *
     * <code>optional .object_detection.protos.ImageResizer image_resizer = 3;</code>
     */
    @java.lang.Override
    public object_detection.protos.ImageResizerOuterClass.ImageResizerOrBuilder getImageResizerOrBuilder() {
      return imageResizer_ == null ? object_detection.protos.ImageResizerOuterClass.ImageResizer.getDefaultInstance() : imageResizer_;
    }

    public static final int USE_DEPTHWISE_FIELD_NUMBER = 13;
    private boolean useDepthwise_;
    /**
     * <pre>
     * If set, all task heads will be constructed with separable convolutions.
     * </pre>
     *
     * <code>optional bool use_depthwise = 13 [default = false];</code>
     * @return Whether the useDepthwise field is set.
     */
    @java.lang.Override
    public boolean hasUseDepthwise() {
      return ((bitField0_ & 0x00000008) != 0);
    }
    /**
     * <pre>
     * If set, all task heads will be constructed with separable convolutions.
     * </pre>
     *
     * <code>optional bool use_depthwise = 13 [default = false];</code>
     * @return The useDepthwise.
     */
    @java.lang.Override
    public boolean getUseDepthwise() {
      return useDepthwise_;
    }

    public static final int COMPUTE_HEATMAP_SPARSE_FIELD_NUMBER = 15;
    private boolean computeHeatmapSparse_;
    /**
     * <pre>
     * Indicates whether or not to use the sparse version of the Op that computes
     * the center heatmaps. The sparse version scales better with number of
     * channels in the heatmap, but in some cases is known to cause an OOM error.
     * TODO(b/170989061) When bug is fixed, make this the default behavior.
     * </pre>
     *
     * <code>optional bool compute_heatmap_sparse = 15 [default = false];</code>
     * @return Whether the computeHeatmapSparse field is set.
     */
    @java.lang.Override
    public boolean hasComputeHeatmapSparse() {
      return ((bitField0_ & 0x00000010) != 0);
    }
    /**
     * <pre>
     * Indicates whether or not to use the sparse version of the Op that computes
     * the center heatmaps. The sparse version scales better with number of
     * channels in the heatmap, but in some cases is known to cause an OOM error.
     * TODO(b/170989061) When bug is fixed, make this the default behavior.
     * </pre>
     *
     * <code>optional bool compute_heatmap_sparse = 15 [default = false];</code>
     * @return The computeHeatmapSparse.
     */
    @java.lang.Override
    public boolean getComputeHeatmapSparse() {
      return computeHeatmapSparse_;
    }

    public static final int OBJECT_DETECTION_TASK_FIELD_NUMBER = 4;
    private object_detection.protos.CenterNetOuterClass.CenterNet.ObjectDetection objectDetectionTask_;
    /**
     * <code>optional .object_detection.protos.CenterNet.ObjectDetection object_detection_task = 4;</code>
     * @return Whether the objectDetectionTask field is set.
     */
    @java.lang.Override
    public boolean hasObjectDetectionTask() {
      return ((bitField0_ & 0x00000020) != 0);
    }
    /**
     * <code>optional .object_detection.protos.CenterNet.ObjectDetection object_detection_task = 4;</code>
     * @return The objectDetectionTask.
     */
    @java.lang.Override
    public object_detection.protos.CenterNetOuterClass.CenterNet.ObjectDetection getObjectDetectionTask() {
      return objectDetectionTask_ == null ? object_detection.protos.CenterNetOuterClass.CenterNet.ObjectDetection.getDefaultInstance() : objectDetectionTask_;
    }
    /**
     * <code>optional .object_detection.protos.CenterNet.ObjectDetection object_detection_task = 4;</code>
     */
    @java.lang.Override
    public object_detection.protos.CenterNetOuterClass.CenterNet.ObjectDetectionOrBuilder getObjectDetectionTaskOrBuilder() {
      return objectDetectionTask_ == null ? object_detection.protos.CenterNetOuterClass.CenterNet.ObjectDetection.getDefaultInstance() : objectDetectionTask_;
    }

    public static final int OBJECT_CENTER_PARAMS_FIELD_NUMBER = 5;
    private object_detection.protos.CenterNetOuterClass.CenterNet.ObjectCenterParams objectCenterParams_;
    /**
     * <code>optional .object_detection.protos.CenterNet.ObjectCenterParams object_center_params = 5;</code>
     * @return Whether the objectCenterParams field is set.
     */
    @java.lang.Override
    public boolean hasObjectCenterParams() {
      return ((bitField0_ & 0x00000040) != 0);
    }
    /**
     * <code>optional .object_detection.protos.CenterNet.ObjectCenterParams object_center_params = 5;</code>
     * @return The objectCenterParams.
     */
    @java.lang.Override
    public object_detection.protos.CenterNetOuterClass.CenterNet.ObjectCenterParams getObjectCenterParams() {
      return objectCenterParams_ == null ? object_detection.protos.CenterNetOuterClass.CenterNet.ObjectCenterParams.getDefaultInstance() : objectCenterParams_;
    }
    /**
     * <code>optional .object_detection.protos.CenterNet.ObjectCenterParams object_center_params = 5;</code>
     */
    @java.lang.Override
    public object_detection.protos.CenterNetOuterClass.CenterNet.ObjectCenterParamsOrBuilder getObjectCenterParamsOrBuilder() {
      return objectCenterParams_ == null ? object_detection.protos.CenterNetOuterClass.CenterNet.ObjectCenterParams.getDefaultInstance() : objectCenterParams_;
    }

    public static final int KEYPOINT_LABEL_MAP_PATH_FIELD_NUMBER = 6;
    private volatile java.lang.Object keypointLabelMapPath_;
    /**
     * <pre>
     * Path of the file that conatins the label map along with the keypoint
     * information, including the keypoint indices, corresponding labels, and the
     * corresponding class. The file should be the same one as used in the input
     * pipeline. Note that a plain text of StringIntLabelMap proto is expected in
     * this file.
     * It is required only if the keypoint estimation task is specified.
     * </pre>
     *
     * <code>optional string keypoint_label_map_path = 6;</code>
     * @return Whether the keypointLabelMapPath field is set.
     */
    @java.lang.Override
    public boolean hasKeypointLabelMapPath() {
      return ((bitField0_ & 0x00000080) != 0);
    }
    /**
     * <pre>
     * Path of the file that conatins the label map along with the keypoint
     * information, including the keypoint indices, corresponding labels, and the
     * corresponding class. The file should be the same one as used in the input
     * pipeline. Note that a plain text of StringIntLabelMap proto is expected in
     * this file.
     * It is required only if the keypoint estimation task is specified.
     * </pre>
     *
     * <code>optional string keypoint_label_map_path = 6;</code>
     * @return The keypointLabelMapPath.
     */
    @java.lang.Override
    public java.lang.String getKeypointLabelMapPath() {
      java.lang.Object ref = keypointLabelMapPath_;
      if (ref instanceof java.lang.String) {
        return (java.lang.String) ref;
      } else {
        com.google.protobuf.ByteString bs =
            (com.google.protobuf.ByteString) ref;
        java.lang.String s = bs.toStringUtf8();
        if (bs.isValidUtf8()) {
          keypointLabelMapPath_ = s;
        }
        return s;
      }
    }
    /**
     * <pre>
     * Path of the file that conatins the label map along with the keypoint
     * information, including the keypoint indices, corresponding labels, and the
     * corresponding class. The file should be the same one as used in the input
     * pipeline. Note that a plain text of StringIntLabelMap proto is expected in
     * this file.
     * It is required only if the keypoint estimation task is specified.
     * </pre>
     *
     * <code>optional string keypoint_label_map_path = 6;</code>
     * @return The bytes for keypointLabelMapPath.
     */
    @java.lang.Override
    public com.google.protobuf.ByteString
        getKeypointLabelMapPathBytes() {
      java.lang.Object ref = keypointLabelMapPath_;
      if (ref instanceof java.lang.String) {
        com.google.protobuf.ByteString b =
            com.google.protobuf.ByteString.copyFromUtf8(
                (java.lang.String) ref);
        keypointLabelMapPath_ = b;
        return b;
      } else {
        return (com.google.protobuf.ByteString) ref;
      }
    }

    public static final int KEYPOINT_ESTIMATION_TASK_FIELD_NUMBER = 7;
    private java.util.List<object_detection.protos.CenterNetOuterClass.CenterNet.KeypointEstimation> keypointEstimationTask_;
    /**
     * <code>repeated .object_detection.protos.CenterNet.KeypointEstimation keypoint_estimation_task = 7;</code>
     */
    @java.lang.Override
    public java.util.List<object_detection.protos.CenterNetOuterClass.CenterNet.KeypointEstimation> getKeypointEstimationTaskList() {
      return keypointEstimationTask_;
    }
    /**
     * <code>repeated .object_detection.protos.CenterNet.KeypointEstimation keypoint_estimation_task = 7;</code>
     */
    @java.lang.Override
    public java.util.List<? extends object_detection.protos.CenterNetOuterClass.CenterNet.KeypointEstimationOrBuilder>
        getKeypointEstimationTaskOrBuilderList() {
      return keypointEstimationTask_;
    }
    /**
     * <code>repeated .object_detection.protos.CenterNet.KeypointEstimation keypoint_estimation_task = 7;</code>
     */
    @java.lang.Override
    public int getKeypointEstimationTaskCount() {
      return keypointEstimationTask_.size();
    }
    /**
     * <code>repeated .object_detection.protos.CenterNet.KeypointEstimation keypoint_estimation_task = 7;</code>
     */
    @java.lang.Override
    public object_detection.protos.CenterNetOuterClass.CenterNet.KeypointEstimation getKeypointEstimationTask(int index) {
      return keypointEstimationTask_.get(index);
    }
    /**
     * <code>repeated .object_detection.protos.CenterNet.KeypointEstimation keypoint_estimation_task = 7;</code>
     */
    @java.lang.Override
    public object_detection.protos.CenterNetOuterClass.CenterNet.KeypointEstimationOrBuilder getKeypointEstimationTaskOrBuilder(
        int index) {
      return keypointEstimationTask_.get(index);
    }

    public static final int MASK_ESTIMATION_TASK_FIELD_NUMBER = 8;
    private object_detection.protos.CenterNetOuterClass.CenterNet.MaskEstimation maskEstimationTask_;
    /**
     * <code>optional .object_detection.protos.CenterNet.MaskEstimation mask_estimation_task = 8;</code>
     * @return Whether the maskEstimationTask field is set.
     */
    @java.lang.Override
    public boolean hasMaskEstimationTask() {
      return ((bitField0_ & 0x00000100) != 0);
    }
    /**
     * <code>optional .object_detection.protos.CenterNet.MaskEstimation mask_estimation_task = 8;</code>
     * @return The maskEstimationTask.
     */
    @java.lang.Override
    public object_detection.protos.CenterNetOuterClass.CenterNet.MaskEstimation getMaskEstimationTask() {
      return maskEstimationTask_ == null ? object_detection.protos.CenterNetOuterClass.CenterNet.MaskEstimation.getDefaultInstance() : maskEstimationTask_;
    }
    /**
     * <code>optional .object_detection.protos.CenterNet.MaskEstimation mask_estimation_task = 8;</code>
     */
    @java.lang.Override
    public object_detection.protos.CenterNetOuterClass.CenterNet.MaskEstimationOrBuilder getMaskEstimationTaskOrBuilder() {
      return maskEstimationTask_ == null ? object_detection.protos.CenterNetOuterClass.CenterNet.MaskEstimation.getDefaultInstance() : maskEstimationTask_;
    }

    public static final int DENSEPOSE_ESTIMATION_TASK_FIELD_NUMBER = 9;
    private object_detection.protos.CenterNetOuterClass.CenterNet.DensePoseEstimation denseposeEstimationTask_;
    /**
     * <code>optional .object_detection.protos.CenterNet.DensePoseEstimation densepose_estimation_task = 9;</code>
     * @return Whether the denseposeEstimationTask field is set.
     */
    @java.lang.Override
    public boolean hasDenseposeEstimationTask() {
      return ((bitField0_ & 0x00000200) != 0);
    }
    /**
     * <code>optional .object_detection.protos.CenterNet.DensePoseEstimation densepose_estimation_task = 9;</code>
     * @return The denseposeEstimationTask.
     */
    @java.lang.Override
    public object_detection.protos.CenterNetOuterClass.CenterNet.DensePoseEstimation getDenseposeEstimationTask() {
      return denseposeEstimationTask_ == null ? object_detection.protos.CenterNetOuterClass.CenterNet.DensePoseEstimation.getDefaultInstance() : denseposeEstimationTask_;
    }
    /**
     * <code>optional .object_detection.protos.CenterNet.DensePoseEstimation densepose_estimation_task = 9;</code>
     */
    @java.lang.Override
    public object_detection.protos.CenterNetOuterClass.CenterNet.DensePoseEstimationOrBuilder getDenseposeEstimationTaskOrBuilder() {
      return denseposeEstimationTask_ == null ? object_detection.protos.CenterNetOuterClass.CenterNet.DensePoseEstimation.getDefaultInstance() : denseposeEstimationTask_;
    }

    public static final int TRACK_ESTIMATION_TASK_FIELD_NUMBER = 10;
    private object_detection.protos.CenterNetOuterClass.CenterNet.TrackEstimation trackEstimationTask_;
    /**
     * <code>optional .object_detection.protos.CenterNet.TrackEstimation track_estimation_task = 10;</code>
     * @return Whether the trackEstimationTask field is set.
     */
    @java.lang.Override
    public boolean hasTrackEstimationTask() {
      return ((bitField0_ & 0x00000400) != 0);
    }
    /**
     * <code>optional .object_detection.protos.CenterNet.TrackEstimation track_estimation_task = 10;</code>
     * @return The trackEstimationTask.
     */
    @java.lang.Override
    public object_detection.protos.CenterNetOuterClass.CenterNet.TrackEstimation getTrackEstimationTask() {
      return trackEstimationTask_ == null ? object_detection.protos.CenterNetOuterClass.CenterNet.TrackEstimation.getDefaultInstance() : trackEstimationTask_;
    }
    /**
     * <code>optional .object_detection.protos.CenterNet.TrackEstimation track_estimation_task = 10;</code>
     */
    @java.lang.Override
    public object_detection.protos.CenterNetOuterClass.CenterNet.TrackEstimationOrBuilder getTrackEstimationTaskOrBuilder() {
      return trackEstimationTask_ == null ? object_detection.protos.CenterNetOuterClass.CenterNet.TrackEstimation.getDefaultInstance() : trackEstimationTask_;
    }

    public static final int TEMPORAL_OFFSET_TASK_FIELD_NUMBER = 12;
    private object_detection.protos.CenterNetOuterClass.CenterNet.TemporalOffsetEstimation temporalOffsetTask_;
    /**
     * <code>optional .object_detection.protos.CenterNet.TemporalOffsetEstimation temporal_offset_task = 12;</code>
     * @return Whether the temporalOffsetTask field is set.
     */
    @java.lang.Override
    public boolean hasTemporalOffsetTask() {
      return ((bitField0_ & 0x00000800) != 0);
    }
    /**
     * <code>optional .object_detection.protos.CenterNet.TemporalOffsetEstimation temporal_offset_task = 12;</code>
     * @return The temporalOffsetTask.
     */
    @java.lang.Override
    public object_detection.protos.CenterNetOuterClass.CenterNet.TemporalOffsetEstimation getTemporalOffsetTask() {
      return temporalOffsetTask_ == null ? object_detection.protos.CenterNetOuterClass.CenterNet.TemporalOffsetEstimation.getDefaultInstance() : temporalOffsetTask_;
    }
    /**
     * <code>optional .object_detection.protos.CenterNet.TemporalOffsetEstimation temporal_offset_task = 12;</code>
     */
    @java.lang.Override
    public object_detection.protos.CenterNetOuterClass.CenterNet.TemporalOffsetEstimationOrBuilder getTemporalOffsetTaskOrBuilder() {
      return temporalOffsetTask_ == null ? object_detection.protos.CenterNetOuterClass.CenterNet.TemporalOffsetEstimation.getDefaultInstance() : temporalOffsetTask_;
    }

    private byte memoizedIsInitialized = -1;
    @java.lang.Override
    public final boolean isInitialized() {
      byte isInitialized = memoizedIsInitialized;
      if (isInitialized == 1) return true;
      if (isInitialized == 0) return false;

      memoizedIsInitialized = 1;
      return true;
    }

    @java.lang.Override
    public void writeTo(com.google.protobuf.CodedOutputStream output)
                        throws java.io.IOException {
      if (((bitField0_ & 0x00000001) != 0)) {
        output.writeInt32(1, numClasses_);
      }
      if (((bitField0_ & 0x00000002) != 0)) {
        output.writeMessage(2, getFeatureExtractor());
      }
      if (((bitField0_ & 0x00000004) != 0)) {
        output.writeMessage(3, getImageResizer());
      }
      if (((bitField0_ & 0x00000020) != 0)) {
        output.writeMessage(4, getObjectDetectionTask());
      }
      if (((bitField0_ & 0x00000040) != 0)) {
        output.writeMessage(5, getObjectCenterParams());
      }
      if (((bitField0_ & 0x00000080) != 0)) {
        com.google.protobuf.GeneratedMessageV3.writeString(output, 6, keypointLabelMapPath_);
      }
      for (int i = 0; i < keypointEstimationTask_.size(); i++) {
        output.writeMessage(7, keypointEstimationTask_.get(i));
      }
      if (((bitField0_ & 0x00000100) != 0)) {
        output.writeMessage(8, getMaskEstimationTask());
      }
      if (((bitField0_ & 0x00000200) != 0)) {
        output.writeMessage(9, getDenseposeEstimationTask());
      }
      if (((bitField0_ & 0x00000400) != 0)) {
        output.writeMessage(10, getTrackEstimationTask());
      }
      if (((bitField0_ & 0x00000800) != 0)) {
        output.writeMessage(12, getTemporalOffsetTask());
      }
      if (((bitField0_ & 0x00000008) != 0)) {
        output.writeBool(13, useDepthwise_);
      }
      if (((bitField0_ & 0x00000010) != 0)) {
        output.writeBool(15, computeHeatmapSparse_);
      }
      unknownFields.writeTo(output);
    }

    @java.lang.Override
    public int getSerializedSize() {
      int size = memoizedSize;
      if (size != -1) return size;

      size = 0;
      if (((bitField0_ & 0x00000001) != 0)) {
        size += com.google.protobuf.CodedOutputStream
          .computeInt32Size(1, numClasses_);
      }
      if (((bitField0_ & 0x00000002) != 0)) {
        size += com.google.protobuf.CodedOutputStream
          .computeMessageSize(2, getFeatureExtractor());
      }
      if (((bitField0_ & 0x00000004) != 0)) {
        size += com.google.protobuf.CodedOutputStream
          .computeMessageSize(3, getImageResizer());
      }
      if (((bitField0_ & 0x00000020) != 0)) {
        size += com.google.protobuf.CodedOutputStream
          .computeMessageSize(4, getObjectDetectionTask());
      }
      if (((bitField0_ & 0x00000040) != 0)) {
        size += com.google.protobuf.CodedOutputStream
          .computeMessageSize(5, getObjectCenterParams());
      }
      if (((bitField0_ & 0x00000080) != 0)) {
        size += com.google.protobuf.GeneratedMessageV3.computeStringSize(6, keypointLabelMapPath_);
      }
      for (int i = 0; i < keypointEstimationTask_.size(); i++) {
        size += com.google.protobuf.CodedOutputStream
          .computeMessageSize(7, keypointEstimationTask_.get(i));
      }
      if (((bitField0_ & 0x00000100) != 0)) {
        size += com.google.protobuf.CodedOutputStream
          .computeMessageSize(8, getMaskEstimationTask());
      }
      if (((bitField0_ & 0x00000200) != 0)) {
        size += com.google.protobuf.CodedOutputStream
          .computeMessageSize(9, getDenseposeEstimationTask());
      }
      if (((bitField0_ & 0x00000400) != 0)) {
        size += com.google.protobuf.CodedOutputStream
          .computeMessageSize(10, getTrackEstimationTask());
      }
      if (((bitField0_ & 0x00000800) != 0)) {
        size += com.google.protobuf.CodedOutputStream
          .computeMessageSize(12, getTemporalOffsetTask());
      }
      if (((bitField0_ & 0x00000008) != 0)) {
        size += com.google.protobuf.CodedOutputStream
          .computeBoolSize(13, useDepthwise_);
      }
      if (((bitField0_ & 0x00000010) != 0)) {
        size += com.google.protobuf.CodedOutputStream
          .computeBoolSize(15, computeHeatmapSparse_);
      }
      size += unknownFields.getSerializedSize();
      memoizedSize = size;
      return size;
    }

    @java.lang.Override
    public boolean equals(final java.lang.Object obj) {
      if (obj == this) {
       return true;
      }
      if (!(obj instanceof object_detection.protos.CenterNetOuterClass.CenterNet)) {
        return super.equals(obj);
      }
      object_detection.protos.CenterNetOuterClass.CenterNet other = (object_detection.protos.CenterNetOuterClass.CenterNet) obj;

      if (hasNumClasses() != other.hasNumClasses()) return false;
      if (hasNumClasses()) {
        if (getNumClasses()
            != other.getNumClasses()) return false;
      }
      if (hasFeatureExtractor() != other.hasFeatureExtractor()) return false;
      if (hasFeatureExtractor()) {
        if (!getFeatureExtractor()
            .equals(other.getFeatureExtractor())) return false;
      }
      if (hasImageResizer() != other.hasImageResizer()) return false;
      if (hasImageResizer()) {
        if (!getImageResizer()
            .equals(other.getImageResizer())) return false;
      }
      if (hasUseDepthwise() != other.hasUseDepthwise()) return false;
      if (hasUseDepthwise()) {
        if (getUseDepthwise()
            != other.getUseDepthwise()) return false;
      }
      if (hasComputeHeatmapSparse() != other.hasComputeHeatmapSparse()) return false;
      if (hasComputeHeatmapSparse()) {
        if (getComputeHeatmapSparse()
            != other.getComputeHeatmapSparse()) return false;
      }
      if (hasObjectDetectionTask() != other.hasObjectDetectionTask()) return false;
      if (hasObjectDetectionTask()) {
        if (!getObjectDetectionTask()
            .equals(other.getObjectDetectionTask())) return false;
      }
      if (hasObjectCenterParams() != other.hasObjectCenterParams()) return false;
      if (hasObjectCenterParams()) {
        if (!getObjectCenterParams()
            .equals(other.getObjectCenterParams())) return false;
      }
      if (hasKeypointLabelMapPath() != other.hasKeypointLabelMapPath()) return false;
      if (hasKeypointLabelMapPath()) {
        if (!getKeypointLabelMapPath()
            .equals(other.getKeypointLabelMapPath())) return false;
      }
      if (!getKeypointEstimationTaskList()
          .equals(other.getKeypointEstimationTaskList())) return false;
      if (hasMaskEstimationTask() != other.hasMaskEstimationTask()) return false;
      if (hasMaskEstimationTask()) {
        if (!getMaskEstimationTask()
            .equals(other.getMaskEstimationTask())) return false;
      }
      if (hasDenseposeEstimationTask() != other.hasDenseposeEstimationTask()) return false;
      if (hasDenseposeEstimationTask()) {
        if (!getDenseposeEstimationTask()
            .equals(other.getDenseposeEstimationTask())) return false;
      }
      if (hasTrackEstimationTask() != other.hasTrackEstimationTask()) return false;
      if (hasTrackEstimationTask()) {
        if (!getTrackEstimationTask()
            .equals(other.getTrackEstimationTask())) return false;
      }
      if (hasTemporalOffsetTask() != other.hasTemporalOffsetTask()) return false;
      if (hasTemporalOffsetTask()) {
        if (!getTemporalOffsetTask()
            .equals(other.getTemporalOffsetTask())) return false;
      }
      if (!unknownFields.equals(other.unknownFields)) return false;
      return true;
    }

    @java.lang.Override
    public int hashCode() {
      if (memoizedHashCode != 0) {
        return memoizedHashCode;
      }
      int hash = 41;
      hash = (19 * hash) + getDescriptor().hashCode();
      if (hasNumClasses()) {
        hash = (37 * hash) + NUM_CLASSES_FIELD_NUMBER;
        hash = (53 * hash) + getNumClasses();
      }
      if (hasFeatureExtractor()) {
        hash = (37 * hash) + FEATURE_EXTRACTOR_FIELD_NUMBER;
        hash = (53 * hash) + getFeatureExtractor().hashCode();
      }
      if (hasImageResizer()) {
        hash = (37 * hash) + IMAGE_RESIZER_FIELD_NUMBER;
        hash = (53 * hash) + getImageResizer().hashCode();
      }
      if (hasUseDepthwise()) {
        hash = (37 * hash) + USE_DEPTHWISE_FIELD_NUMBER;
        hash = (53 * hash) + com.google.protobuf.Internal.hashBoolean(
            getUseDepthwise());
      }
      if (hasComputeHeatmapSparse()) {
        hash = (37 * hash) + COMPUTE_HEATMAP_SPARSE_FIELD_NUMBER;
        hash = (53 * hash) + com.google.protobuf.Internal.hashBoolean(
            getComputeHeatmapSparse());
      }
      if (hasObjectDetectionTask()) {
        hash = (37 * hash) + OBJECT_DETECTION_TASK_FIELD_NUMBER;
        hash = (53 * hash) + getObjectDetectionTask().hashCode();
      }
      if (hasObjectCenterParams()) {
        hash = (37 * hash) + OBJECT_CENTER_PARAMS_FIELD_NUMBER;
        hash = (53 * hash) + getObjectCenterParams().hashCode();
      }
      if (hasKeypointLabelMapPath()) {
        hash = (37 * hash) + KEYPOINT_LABEL_MAP_PATH_FIELD_NUMBER;
        hash = (53 * hash) + getKeypointLabelMapPath().hashCode();
      }
      if (getKeypointEstimationTaskCount() > 0) {
        hash = (37 * hash) + KEYPOINT_ESTIMATION_TASK_FIELD_NUMBER;
        hash = (53 * hash) + getKeypointEstimationTaskList().hashCode();
      }
      if (hasMaskEstimationTask()) {
        hash = (37 * hash) + MASK_ESTIMATION_TASK_FIELD_NUMBER;
        hash = (53 * hash) + getMaskEstimationTask().hashCode();
      }
      if (hasDenseposeEstimationTask()) {
        hash = (37 * hash) + DENSEPOSE_ESTIMATION_TASK_FIELD_NUMBER;
        hash = (53 * hash) + getDenseposeEstimationTask().hashCode();
      }
      if (hasTrackEstimationTask()) {
        hash = (37 * hash) + TRACK_ESTIMATION_TASK_FIELD_NUMBER;
        hash = (53 * hash) + getTrackEstimationTask().hashCode();
      }
      if (hasTemporalOffsetTask()) {
        hash = (37 * hash) + TEMPORAL_OFFSET_TASK_FIELD_NUMBER;
        hash = (53 * hash) + getTemporalOffsetTask().hashCode();
      }
      hash = (29 * hash) + unknownFields.hashCode();
      memoizedHashCode = hash;
      return hash;
    }

    public static object_detection.protos.CenterNetOuterClass.CenterNet parseFrom(
        java.nio.ByteBuffer data)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return PARSER.parseFrom(data);
    }
    public static object_detection.protos.CenterNetOuterClass.CenterNet parseFrom(
        java.nio.ByteBuffer data,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return PARSER.parseFrom(data, extensionRegistry);
    }
    public static object_detection.protos.CenterNetOuterClass.CenterNet parseFrom(
        com.google.protobuf.ByteString data)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return PARSER.parseFrom(data);
    }
    public static object_detection.protos.CenterNetOuterClass.CenterNet parseFrom(
        com.google.protobuf.ByteString data,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return PARSER.parseFrom(data, extensionRegistry);
    }
    public static object_detection.protos.CenterNetOuterClass.CenterNet parseFrom(byte[] data)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return PARSER.parseFrom(data);
    }
    public static object_detection.protos.CenterNetOuterClass.CenterNet parseFrom(
        byte[] data,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return PARSER.parseFrom(data, extensionRegistry);
    }
    public static object_detection.protos.CenterNetOuterClass.CenterNet parseFrom(java.io.InputStream input)
        throws java.io.IOException {
      return com.google.protobuf.GeneratedMessageV3
          .parseWithIOException(PARSER, input);
    }
    public static object_detection.protos.CenterNetOuterClass.CenterNet parseFrom(
        java.io.InputStream input,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws java.io.IOException {
      return com.google.protobuf.GeneratedMessageV3
          .parseWithIOException(PARSER, input, extensionRegistry);
    }
    public static object_detection.protos.CenterNetOuterClass.CenterNet parseDelimitedFrom(java.io.InputStream input)
        throws java.io.IOException {
      return com.google.protobuf.GeneratedMessageV3
          .parseDelimitedWithIOException(PARSER, input);
    }
    public static object_detection.protos.CenterNetOuterClass.CenterNet parseDelimitedFrom(
        java.io.InputStream input,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws java.io.IOException {
      return com.google.protobuf.GeneratedMessageV3
          .parseDelimitedWithIOException(PARSER, input, extensionRegistry);
    }
    public static object_detection.protos.CenterNetOuterClass.CenterNet parseFrom(
        com.google.protobuf.CodedInputStream input)
        throws java.io.IOException {
      return com.google.protobuf.GeneratedMessageV3
          .parseWithIOException(PARSER, input);
    }
    public static object_detection.protos.CenterNetOuterClass.CenterNet parseFrom(
        com.google.protobuf.CodedInputStream input,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws java.io.IOException {
      return com.google.protobuf.GeneratedMessageV3
          .parseWithIOException(PARSER, input, extensionRegistry);
    }

    @java.lang.Override
    public Builder newBuilderForType() { return newBuilder(); }
    public static Builder newBuilder() {
      return DEFAULT_INSTANCE.toBuilder();
    }
    public static Builder newBuilder(object_detection.protos.CenterNetOuterClass.CenterNet prototype) {
      return DEFAULT_INSTANCE.toBuilder().mergeFrom(prototype);
    }
    @java.lang.Override
    public Builder toBuilder() {
      return this == DEFAULT_INSTANCE
          ? new Builder() : new Builder().mergeFrom(this);
    }

    @java.lang.Override
    protected Builder newBuilderForType(
        com.google.protobuf.GeneratedMessageV3.BuilderParent parent) {
      Builder builder = new Builder(parent);
      return builder;
    }
    /**
     * <pre>
     * Next Id = 16
     * </pre>
     *
     * Protobuf type {@code object_detection.protos.CenterNet}
     */
    public static final class Builder extends
        com.google.protobuf.GeneratedMessageV3.Builder<Builder> implements
        // @@protoc_insertion_point(builder_implements:object_detection.protos.CenterNet)
        object_detection.protos.CenterNetOuterClass.CenterNetOrBuilder {
      public static final com.google.protobuf.Descriptors.Descriptor
          getDescriptor() {
        return object_detection.protos.CenterNetOuterClass.internal_static_object_detection_protos_CenterNet_descriptor;
      }

      @java.lang.Override
      protected com.google.protobuf.GeneratedMessageV3.FieldAccessorTable
          internalGetFieldAccessorTable() {
        return object_detection.protos.CenterNetOuterClass.internal_static_object_detection_protos_CenterNet_fieldAccessorTable
            .ensureFieldAccessorsInitialized(
                object_detection.protos.CenterNetOuterClass.CenterNet.class, object_detection.protos.CenterNetOuterClass.CenterNet.Builder.class);
      }

      // Construct using object_detection.protos.CenterNetOuterClass.CenterNet.newBuilder()
      private Builder() {
        maybeForceBuilderInitialization();
      }

      private Builder(
          com.google.protobuf.GeneratedMessageV3.BuilderParent parent) {
        super(parent);
        maybeForceBuilderInitialization();
      }
      private void maybeForceBuilderInitialization() {
        if (com.google.protobuf.GeneratedMessageV3
                .alwaysUseFieldBuilders) {
          getFeatureExtractorFieldBuilder();
          getImageResizerFieldBuilder();
          getObjectDetectionTaskFieldBuilder();
          getObjectCenterParamsFieldBuilder();
          getKeypointEstimationTaskFieldBuilder();
          getMaskEstimationTaskFieldBuilder();
          getDenseposeEstimationTaskFieldBuilder();
          getTrackEstimationTaskFieldBuilder();
          getTemporalOffsetTaskFieldBuilder();
        }
      }
      @java.lang.Override
      public Builder clear() {
        super.clear();
        numClasses_ = 0;
        bitField0_ = (bitField0_ & ~0x00000001);
        if (featureExtractorBuilder_ == null) {
          featureExtractor_ = null;
        } else {
          featureExtractorBuilder_.clear();
        }
        bitField0_ = (bitField0_ & ~0x00000002);
        if (imageResizerBuilder_ == null) {
          imageResizer_ = null;
        } else {
          imageResizerBuilder_.clear();
        }
        bitField0_ = (bitField0_ & ~0x00000004);
        useDepthwise_ = false;
        bitField0_ = (bitField0_ & ~0x00000008);
        computeHeatmapSparse_ = false;
        bitField0_ = (bitField0_ & ~0x00000010);
        if (objectDetectionTaskBuilder_ == null) {
          objectDetectionTask_ = null;
        } else {
          objectDetectionTaskBuilder_.clear();
        }
        bitField0_ = (bitField0_ & ~0x00000020);
        if (objectCenterParamsBuilder_ == null) {
          objectCenterParams_ = null;
        } else {
          objectCenterParamsBuilder_.clear();
        }
        bitField0_ = (bitField0_ & ~0x00000040);
        keypointLabelMapPath_ = "";
        bitField0_ = (bitField0_ & ~0x00000080);
        if (keypointEstimationTaskBuilder_ == null) {
          keypointEstimationTask_ = java.util.Collections.emptyList();
          bitField0_ = (bitField0_ & ~0x00000100);
        } else {
          keypointEstimationTaskBuilder_.clear();
        }
        if (maskEstimationTaskBuilder_ == null) {
          maskEstimationTask_ = null;
        } else {
          maskEstimationTaskBuilder_.clear();
        }
        bitField0_ = (bitField0_ & ~0x00000200);
        if (denseposeEstimationTaskBuilder_ == null) {
          denseposeEstimationTask_ = null;
        } else {
          denseposeEstimationTaskBuilder_.clear();
        }
        bitField0_ = (bitField0_ & ~0x00000400);
        if (trackEstimationTaskBuilder_ == null) {
          trackEstimationTask_ = null;
        } else {
          trackEstimationTaskBuilder_.clear();
        }
        bitField0_ = (bitField0_ & ~0x00000800);
        if (temporalOffsetTaskBuilder_ == null) {
          temporalOffsetTask_ = null;
        } else {
          temporalOffsetTaskBuilder_.clear();
        }
        bitField0_ = (bitField0_ & ~0x00001000);
        return this;
      }

      @java.lang.Override
      public com.google.protobuf.Descriptors.Descriptor
          getDescriptorForType() {
        return object_detection.protos.CenterNetOuterClass.internal_static_object_detection_protos_CenterNet_descriptor;
      }

      @java.lang.Override
      public object_detection.protos.CenterNetOuterClass.CenterNet getDefaultInstanceForType() {
        return object_detection.protos.CenterNetOuterClass.CenterNet.getDefaultInstance();
      }

      @java.lang.Override
      public object_detection.protos.CenterNetOuterClass.CenterNet build() {
        object_detection.protos.CenterNetOuterClass.CenterNet result = buildPartial();
        if (!result.isInitialized()) {
          throw newUninitializedMessageException(result);
        }
        return result;
      }

      @java.lang.Override
      public object_detection.protos.CenterNetOuterClass.CenterNet buildPartial() {
        object_detection.protos.CenterNetOuterClass.CenterNet result = new object_detection.protos.CenterNetOuterClass.CenterNet(this);
        int from_bitField0_ = bitField0_;
        int to_bitField0_ = 0;
        if (((from_bitField0_ & 0x00000001) != 0)) {
          result.numClasses_ = numClasses_;
          to_bitField0_ |= 0x00000001;
        }
        if (((from_bitField0_ & 0x00000002) != 0)) {
          if (featureExtractorBuilder_ == null) {
            result.featureExtractor_ = featureExtractor_;
          } else {
            result.featureExtractor_ = featureExtractorBuilder_.build();
          }
          to_bitField0_ |= 0x00000002;
        }
        if (((from_bitField0_ & 0x00000004) != 0)) {
          if (imageResizerBuilder_ == null) {
            result.imageResizer_ = imageResizer_;
          } else {
            result.imageResizer_ = imageResizerBuilder_.build();
          }
          to_bitField0_ |= 0x00000004;
        }
        if (((from_bitField0_ & 0x00000008) != 0)) {
          result.useDepthwise_ = useDepthwise_;
          to_bitField0_ |= 0x00000008;
        }
        if (((from_bitField0_ & 0x00000010) != 0)) {
          result.computeHeatmapSparse_ = computeHeatmapSparse_;
          to_bitField0_ |= 0x00000010;
        }
        if (((from_bitField0_ & 0x00000020) != 0)) {
          if (objectDetectionTaskBuilder_ == null) {
            result.objectDetectionTask_ = objectDetectionTask_;
          } else {
            result.objectDetectionTask_ = objectDetectionTaskBuilder_.build();
          }
          to_bitField0_ |= 0x00000020;
        }
        if (((from_bitField0_ & 0x00000040) != 0)) {
          if (objectCenterParamsBuilder_ == null) {
            result.objectCenterParams_ = objectCenterParams_;
          } else {
            result.objectCenterParams_ = objectCenterParamsBuilder_.build();
          }
          to_bitField0_ |= 0x00000040;
        }
        if (((from_bitField0_ & 0x00000080) != 0)) {
          to_bitField0_ |= 0x00000080;
        }
        result.keypointLabelMapPath_ = keypointLabelMapPath_;
        if (keypointEstimationTaskBuilder_ == null) {
          if (((bitField0_ & 0x00000100) != 0)) {
            keypointEstimationTask_ = java.util.Collections.unmodifiableList(keypointEstimationTask_);
            bitField0_ = (bitField0_ & ~0x00000100);
          }
          result.keypointEstimationTask_ = keypointEstimationTask_;
        } else {
          result.keypointEstimationTask_ = keypointEstimationTaskBuilder_.build();
        }
        if (((from_bitField0_ & 0x00000200) != 0)) {
          if (maskEstimationTaskBuilder_ == null) {
            result.maskEstimationTask_ = maskEstimationTask_;
          } else {
            result.maskEstimationTask_ = maskEstimationTaskBuilder_.build();
          }
          to_bitField0_ |= 0x00000100;
        }
        if (((from_bitField0_ & 0x00000400) != 0)) {
          if (denseposeEstimationTaskBuilder_ == null) {
            result.denseposeEstimationTask_ = denseposeEstimationTask_;
          } else {
            result.denseposeEstimationTask_ = denseposeEstimationTaskBuilder_.build();
          }
          to_bitField0_ |= 0x00000200;
        }
        if (((from_bitField0_ & 0x00000800) != 0)) {
          if (trackEstimationTaskBuilder_ == null) {
            result.trackEstimationTask_ = trackEstimationTask_;
          } else {
            result.trackEstimationTask_ = trackEstimationTaskBuilder_.build();
          }
          to_bitField0_ |= 0x00000400;
        }
        if (((from_bitField0_ & 0x00001000) != 0)) {
          if (temporalOffsetTaskBuilder_ == null) {
            result.temporalOffsetTask_ = temporalOffsetTask_;
          } else {
            result.temporalOffsetTask_ = temporalOffsetTaskBuilder_.build();
          }
          to_bitField0_ |= 0x00000800;
        }
        result.bitField0_ = to_bitField0_;
        onBuilt();
        return result;
      }

      @java.lang.Override
      public Builder clone() {
        return super.clone();
      }
      @java.lang.Override
      public Builder setField(
          com.google.protobuf.Descriptors.FieldDescriptor field,
          java.lang.Object value) {
        return super.setField(field, value);
      }
      @java.lang.Override
      public Builder clearField(
          com.google.protobuf.Descriptors.FieldDescriptor field) {
        return super.clearField(field);
      }
      @java.lang.Override
      public Builder clearOneof(
          com.google.protobuf.Descriptors.OneofDescriptor oneof) {
        return super.clearOneof(oneof);
      }
      @java.lang.Override
      public Builder setRepeatedField(
          com.google.protobuf.Descriptors.FieldDescriptor field,
          int index, java.lang.Object value) {
        return super.setRepeatedField(field, index, value);
      }
      @java.lang.Override
      public Builder addRepeatedField(
          com.google.protobuf.Descriptors.FieldDescriptor field,
          java.lang.Object value) {
        return super.addRepeatedField(field, value);
      }
      @java.lang.Override
      public Builder mergeFrom(com.google.protobuf.Message other) {
        if (other instanceof object_detection.protos.CenterNetOuterClass.CenterNet) {
          return mergeFrom((object_detection.protos.CenterNetOuterClass.CenterNet)other);
        } else {
          super.mergeFrom(other);
          return this;
        }
      }

      public Builder mergeFrom(object_detection.protos.CenterNetOuterClass.CenterNet other) {
        if (other == object_detection.protos.CenterNetOuterClass.CenterNet.getDefaultInstance()) return this;
        if (other.hasNumClasses()) {
          setNumClasses(other.getNumClasses());
        }
        if (other.hasFeatureExtractor()) {
          mergeFeatureExtractor(other.getFeatureExtractor());
        }
        if (other.hasImageResizer()) {
          mergeImageResizer(other.getImageResizer());
        }
        if (other.hasUseDepthwise()) {
          setUseDepthwise(other.getUseDepthwise());
        }
        if (other.hasComputeHeatmapSparse()) {
          setComputeHeatmapSparse(other.getComputeHeatmapSparse());
        }
        if (other.hasObjectDetectionTask()) {
          mergeObjectDetectionTask(other.getObjectDetectionTask());
        }
        if (other.hasObjectCenterParams()) {
          mergeObjectCenterParams(other.getObjectCenterParams());
        }
        if (other.hasKeypointLabelMapPath()) {
          bitField0_ |= 0x00000080;
          keypointLabelMapPath_ = other.keypointLabelMapPath_;
          onChanged();
        }
        if (keypointEstimationTaskBuilder_ == null) {
          if (!other.keypointEstimationTask_.isEmpty()) {
            if (keypointEstimationTask_.isEmpty()) {
              keypointEstimationTask_ = other.keypointEstimationTask_;
              bitField0_ = (bitField0_ & ~0x00000100);
            } else {
              ensureKeypointEstimationTaskIsMutable();
              keypointEstimationTask_.addAll(other.keypointEstimationTask_);
            }
            onChanged();
          }
        } else {
          if (!other.keypointEstimationTask_.isEmpty()) {
            if (keypointEstimationTaskBuilder_.isEmpty()) {
              keypointEstimationTaskBuilder_.dispose();
              keypointEstimationTaskBuilder_ = null;
              keypointEstimationTask_ = other.keypointEstimationTask_;
              bitField0_ = (bitField0_ & ~0x00000100);
              keypointEstimationTaskBuilder_ =
                com.google.protobuf.GeneratedMessageV3.alwaysUseFieldBuilders ?
                   getKeypointEstimationTaskFieldBuilder() : null;
            } else {
              keypointEstimationTaskBuilder_.addAllMessages(other.keypointEstimationTask_);
            }
          }
        }
        if (other.hasMaskEstimationTask()) {
          mergeMaskEstimationTask(other.getMaskEstimationTask());
        }
        if (other.hasDenseposeEstimationTask()) {
          mergeDenseposeEstimationTask(other.getDenseposeEstimationTask());
        }
        if (other.hasTrackEstimationTask()) {
          mergeTrackEstimationTask(other.getTrackEstimationTask());
        }
        if (other.hasTemporalOffsetTask()) {
          mergeTemporalOffsetTask(other.getTemporalOffsetTask());
        }
        this.mergeUnknownFields(other.unknownFields);
        onChanged();
        return this;
      }

      @java.lang.Override
      public final boolean isInitialized() {
        return true;
      }

      @java.lang.Override
      public Builder mergeFrom(
          com.google.protobuf.CodedInputStream input,
          com.google.protobuf.ExtensionRegistryLite extensionRegistry)
          throws java.io.IOException {
        object_detection.protos.CenterNetOuterClass.CenterNet parsedMessage = null;
        try {
          parsedMessage = PARSER.parsePartialFrom(input, extensionRegistry);
        } catch (com.google.protobuf.InvalidProtocolBufferException e) {
          parsedMessage = (object_detection.protos.CenterNetOuterClass.CenterNet) e.getUnfinishedMessage();
          throw e.unwrapIOException();
        } finally {
          if (parsedMessage != null) {
            mergeFrom(parsedMessage);
          }
        }
        return this;
      }
      private int bitField0_;

      private int numClasses_ ;
      /**
       * <pre>
       * Number of classes to predict.
       * </pre>
       *
       * <code>optional int32 num_classes = 1;</code>
       * @return Whether the numClasses field is set.
       */
      @java.lang.Override
      public boolean hasNumClasses() {
        return ((bitField0_ & 0x00000001) != 0);
      }
      /**
       * <pre>
       * Number of classes to predict.
       * </pre>
       *
       * <code>optional int32 num_classes = 1;</code>
       * @return The numClasses.
       */
      @java.lang.Override
      public int getNumClasses() {
        return numClasses_;
      }
      /**
       * <pre>
       * Number of classes to predict.
       * </pre>
       *
       * <code>optional int32 num_classes = 1;</code>
       * @param value The numClasses to set.
       * @return This builder for chaining.
       */
      public Builder setNumClasses(int value) {
        bitField0_ |= 0x00000001;
        numClasses_ = value;
        onChanged();
        return this;
      }
      /**
       * <pre>
       * Number of classes to predict.
       * </pre>
       *
       * <code>optional int32 num_classes = 1;</code>
       * @return This builder for chaining.
       */
      public Builder clearNumClasses() {
        bitField0_ = (bitField0_ & ~0x00000001);
        numClasses_ = 0;
        onChanged();
        return this;
      }

      private object_detection.protos.CenterNetOuterClass.CenterNetFeatureExtractor featureExtractor_;
      private com.google.protobuf.SingleFieldBuilderV3<
          object_detection.protos.CenterNetOuterClass.CenterNetFeatureExtractor, object_detection.protos.CenterNetOuterClass.CenterNetFeatureExtractor.Builder, object_detection.protos.CenterNetOuterClass.CenterNetFeatureExtractorOrBuilder> featureExtractorBuilder_;
      /**
       * <pre>
       * Feature extractor config.
       * </pre>
       *
       * <code>optional .object_detection.protos.CenterNetFeatureExtractor feature_extractor = 2;</code>
       * @return Whether the featureExtractor field is set.
       */
      public boolean hasFeatureExtractor() {
        return ((bitField0_ & 0x00000002) != 0);
      }
      /**
       * <pre>
       * Feature extractor config.
       * </pre>
       *
       * <code>optional .object_detection.protos.CenterNetFeatureExtractor feature_extractor = 2;</code>
       * @return The featureExtractor.
       */
      public object_detection.protos.CenterNetOuterClass.CenterNetFeatureExtractor getFeatureExtractor() {
        if (featureExtractorBuilder_ == null) {
          return featureExtractor_ == null ? object_detection.protos.CenterNetOuterClass.CenterNetFeatureExtractor.getDefaultInstance() : featureExtractor_;
        } else {
          return featureExtractorBuilder_.getMessage();
        }
      }
      /**
       * <pre>
       * Feature extractor config.
       * </pre>
       *
       * <code>optional .object_detection.protos.CenterNetFeatureExtractor feature_extractor = 2;</code>
       */
      public Builder setFeatureExtractor(object_detection.protos.CenterNetOuterClass.CenterNetFeatureExtractor value) {
        if (featureExtractorBuilder_ == null) {
          if (value == null) {
            throw new NullPointerException();
          }
          featureExtractor_ = value;
          onChanged();
        } else {
          featureExtractorBuilder_.setMessage(value);
        }
        bitField0_ |= 0x00000002;
        return this;
      }
      /**
       * <pre>
       * Feature extractor config.
       * </pre>
       *
       * <code>optional .object_detection.protos.CenterNetFeatureExtractor feature_extractor = 2;</code>
       */
      public Builder setFeatureExtractor(
          object_detection.protos.CenterNetOuterClass.CenterNetFeatureExtractor.Builder builderForValue) {
        if (featureExtractorBuilder_ == null) {
          featureExtractor_ = builderForValue.build();
          onChanged();
        } else {
          featureExtractorBuilder_.setMessage(builderForValue.build());
        }
        bitField0_ |= 0x00000002;
        return this;
      }
      /**
       * <pre>
       * Feature extractor config.
       * </pre>
       *
       * <code>optional .object_detection.protos.CenterNetFeatureExtractor feature_extractor = 2;</code>
       */
      public Builder mergeFeatureExtractor(object_detection.protos.CenterNetOuterClass.CenterNetFeatureExtractor value) {
        if (featureExtractorBuilder_ == null) {
          if (((bitField0_ & 0x00000002) != 0) &&
              featureExtractor_ != null &&
              featureExtractor_ != object_detection.protos.CenterNetOuterClass.CenterNetFeatureExtractor.getDefaultInstance()) {
            featureExtractor_ =
              object_detection.protos.CenterNetOuterClass.CenterNetFeatureExtractor.newBuilder(featureExtractor_).mergeFrom(value).buildPartial();
          } else {
            featureExtractor_ = value;
          }
          onChanged();
        } else {
          featureExtractorBuilder_.mergeFrom(value);
        }
        bitField0_ |= 0x00000002;
        return this;
      }
      /**
       * <pre>
       * Feature extractor config.
       * </pre>
       *
       * <code>optional .object_detection.protos.CenterNetFeatureExtractor feature_extractor = 2;</code>
       */
      public Builder clearFeatureExtractor() {
        if (featureExtractorBuilder_ == null) {
          featureExtractor_ = null;
          onChanged();
        } else {
          featureExtractorBuilder_.clear();
        }
        bitField0_ = (bitField0_ & ~0x00000002);
        return this;
      }
      /**
       * <pre>
       * Feature extractor config.
       * </pre>
       *
       * <code>optional .object_detection.protos.CenterNetFeatureExtractor feature_extractor = 2;</code>
       */
      public object_detection.protos.CenterNetOuterClass.CenterNetFeatureExtractor.Builder getFeatureExtractorBuilder() {
        bitField0_ |= 0x00000002;
        onChanged();
        return getFeatureExtractorFieldBuilder().getBuilder();
      }
      /**
       * <pre>
       * Feature extractor config.
       * </pre>
       *
       * <code>optional .object_detection.protos.CenterNetFeatureExtractor feature_extractor = 2;</code>
       */
      public object_detection.protos.CenterNetOuterClass.CenterNetFeatureExtractorOrBuilder getFeatureExtractorOrBuilder() {
        if (featureExtractorBuilder_ != null) {
          return featureExtractorBuilder_.getMessageOrBuilder();
        } else {
          return featureExtractor_ == null ?
              object_detection.protos.CenterNetOuterClass.CenterNetFeatureExtractor.getDefaultInstance() : featureExtractor_;
        }
      }
      /**
       * <pre>
       * Feature extractor config.
       * </pre>
       *
       * <code>optional .object_detection.protos.CenterNetFeatureExtractor feature_extractor = 2;</code>
       */
      private com.google.protobuf.SingleFieldBuilderV3<
          object_detection.protos.CenterNetOuterClass.CenterNetFeatureExtractor, object_detection.protos.CenterNetOuterClass.CenterNetFeatureExtractor.Builder, object_detection.protos.CenterNetOuterClass.CenterNetFeatureExtractorOrBuilder>
          getFeatureExtractorFieldBuilder() {
        if (featureExtractorBuilder_ == null) {
          featureExtractorBuilder_ = new com.google.protobuf.SingleFieldBuilderV3<
              object_detection.protos.CenterNetOuterClass.CenterNetFeatureExtractor, object_detection.protos.CenterNetOuterClass.CenterNetFeatureExtractor.Builder, object_detection.protos.CenterNetOuterClass.CenterNetFeatureExtractorOrBuilder>(
                  getFeatureExtractor(),
                  getParentForChildren(),
                  isClean());
          featureExtractor_ = null;
        }
        return featureExtractorBuilder_;
      }

      private object_detection.protos.ImageResizerOuterClass.ImageResizer imageResizer_;
      private com.google.protobuf.SingleFieldBuilderV3<
          object_detection.protos.ImageResizerOuterClass.ImageResizer, object_detection.protos.ImageResizerOuterClass.ImageResizer.Builder, object_detection.protos.ImageResizerOuterClass.ImageResizerOrBuilder> imageResizerBuilder_;
      /**
       * <pre>
       * Image resizer for preprocessing the input image.
       * </pre>
       *
       * <code>optional .object_detection.protos.ImageResizer image_resizer = 3;</code>
       * @return Whether the imageResizer field is set.
       */
      public boolean hasImageResizer() {
        return ((bitField0_ & 0x00000004) != 0);
      }
      /**
       * <pre>
       * Image resizer for preprocessing the input image.
       * </pre>
       *
       * <code>optional .object_detection.protos.ImageResizer image_resizer = 3;</code>
       * @return The imageResizer.
       */
      public object_detection.protos.ImageResizerOuterClass.ImageResizer getImageResizer() {
        if (imageResizerBuilder_ == null) {
          return imageResizer_ == null ? object_detection.protos.ImageResizerOuterClass.ImageResizer.getDefaultInstance() : imageResizer_;
        } else {
          return imageResizerBuilder_.getMessage();
        }
      }
      /**
       * <pre>
       * Image resizer for preprocessing the input image.
       * </pre>
       *
       * <code>optional .object_detection.protos.ImageResizer image_resizer = 3;</code>
       */
      public Builder setImageResizer(object_detection.protos.ImageResizerOuterClass.ImageResizer value) {
        if (imageResizerBuilder_ == null) {
          if (value == null) {
            throw new NullPointerException();
          }
          imageResizer_ = value;
          onChanged();
        } else {
          imageResizerBuilder_.setMessage(value);
        }
        bitField0_ |= 0x00000004;
        return this;
      }
      /**
       * <pre>
       * Image resizer for preprocessing the input image.
       * </pre>
       *
       * <code>optional .object_detection.protos.ImageResizer image_resizer = 3;</code>
       */
      public Builder setImageResizer(
          object_detection.protos.ImageResizerOuterClass.ImageResizer.Builder builderForValue) {
        if (imageResizerBuilder_ == null) {
          imageResizer_ = builderForValue.build();
          onChanged();
        } else {
          imageResizerBuilder_.setMessage(builderForValue.build());
        }
        bitField0_ |= 0x00000004;
        return this;
      }
      /**
       * <pre>
       * Image resizer for preprocessing the input image.
       * </pre>
       *
       * <code>optional .object_detection.protos.ImageResizer image_resizer = 3;</code>
       */
      public Builder mergeImageResizer(object_detection.protos.ImageResizerOuterClass.ImageResizer value) {
        if (imageResizerBuilder_ == null) {
          if (((bitField0_ & 0x00000004) != 0) &&
              imageResizer_ != null &&
              imageResizer_ != object_detection.protos.ImageResizerOuterClass.ImageResizer.getDefaultInstance()) {
            imageResizer_ =
              object_detection.protos.ImageResizerOuterClass.ImageResizer.newBuilder(imageResizer_).mergeFrom(value).buildPartial();
          } else {
            imageResizer_ = value;
          }
          onChanged();
        } else {
          imageResizerBuilder_.mergeFrom(value);
        }
        bitField0_ |= 0x00000004;
        return this;
      }
      /**
       * <pre>
       * Image resizer for preprocessing the input image.
       * </pre>
       *
       * <code>optional .object_detection.protos.ImageResizer image_resizer = 3;</code>
       */
      public Builder clearImageResizer() {
        if (imageResizerBuilder_ == null) {
          imageResizer_ = null;
          onChanged();
        } else {
          imageResizerBuilder_.clear();
        }
        bitField0_ = (bitField0_ & ~0x00000004);
        return this;
      }
      /**
       * <pre>
       * Image resizer for preprocessing the input image.
       * </pre>
       *
       * <code>optional .object_detection.protos.ImageResizer image_resizer = 3;</code>
       */
      public object_detection.protos.ImageResizerOuterClass.ImageResizer.Builder getImageResizerBuilder() {
        bitField0_ |= 0x00000004;
        onChanged();
        return getImageResizerFieldBuilder().getBuilder();
      }
      /**
       * <pre>
       * Image resizer for preprocessing the input image.
       * </pre>
       *
       * <code>optional .object_detection.protos.ImageResizer image_resizer = 3;</code>
       */
      public object_detection.protos.ImageResizerOuterClass.ImageResizerOrBuilder getImageResizerOrBuilder() {
        if (imageResizerBuilder_ != null) {
          return imageResizerBuilder_.getMessageOrBuilder();
        } else {
          return imageResizer_ == null ?
              object_detection.protos.ImageResizerOuterClass.ImageResizer.getDefaultInstance() : imageResizer_;
        }
      }
      /**
       * <pre>
       * Image resizer for preprocessing the input image.
       * </pre>
       *
       * <code>optional .object_detection.protos.ImageResizer image_resizer = 3;</code>
       */
      private com.google.protobuf.SingleFieldBuilderV3<
          object_detection.protos.ImageResizerOuterClass.ImageResizer, object_detection.protos.ImageResizerOuterClass.ImageResizer.Builder, object_detection.protos.ImageResizerOuterClass.ImageResizerOrBuilder>
          getImageResizerFieldBuilder() {
        if (imageResizerBuilder_ == null) {
          imageResizerBuilder_ = new com.google.protobuf.SingleFieldBuilderV3<
              object_detection.protos.ImageResizerOuterClass.ImageResizer, object_detection.protos.ImageResizerOuterClass.ImageResizer.Builder, object_detection.protos.ImageResizerOuterClass.ImageResizerOrBuilder>(
                  getImageResizer(),
                  getParentForChildren(),
                  isClean());
          imageResizer_ = null;
        }
        return imageResizerBuilder_;
      }

      private boolean useDepthwise_ ;
      /**
       * <pre>
       * If set, all task heads will be constructed with separable convolutions.
       * </pre>
       *
       * <code>optional bool use_depthwise = 13 [default = false];</code>
       * @return Whether the useDepthwise field is set.
       */
      @java.lang.Override
      public boolean hasUseDepthwise() {
        return ((bitField0_ & 0x00000008) != 0);
      }
      /**
       * <pre>
       * If set, all task heads will be constructed with separable convolutions.
       * </pre>
       *
       * <code>optional bool use_depthwise = 13 [default = false];</code>
       * @return The useDepthwise.
       */
      @java.lang.Override
      public boolean getUseDepthwise() {
        return useDepthwise_;
      }
      /**
       * <pre>
       * If set, all task heads will be constructed with separable convolutions.
       * </pre>
       *
       * <code>optional bool use_depthwise = 13 [default = false];</code>
       * @param value The useDepthwise to set.
       * @return This builder for chaining.
       */
      public Builder setUseDepthwise(boolean value) {
        bitField0_ |= 0x00000008;
        useDepthwise_ = value;
        onChanged();
        return this;
      }
      /**
       * <pre>
       * If set, all task heads will be constructed with separable convolutions.
       * </pre>
       *
       * <code>optional bool use_depthwise = 13 [default = false];</code>
       * @return This builder for chaining.
       */
      public Builder clearUseDepthwise() {
        bitField0_ = (bitField0_ & ~0x00000008);
        useDepthwise_ = false;
        onChanged();
        return this;
      }

      private boolean computeHeatmapSparse_ ;
      /**
       * <pre>
       * Indicates whether or not to use the sparse version of the Op that computes
       * the center heatmaps. The sparse version scales better with number of
       * channels in the heatmap, but in some cases is known to cause an OOM error.
       * TODO(b/170989061) When bug is fixed, make this the default behavior.
       * </pre>
       *
       * <code>optional bool compute_heatmap_sparse = 15 [default = false];</code>
       * @return Whether the computeHeatmapSparse field is set.
       */
      @java.lang.Override
      public boolean hasComputeHeatmapSparse() {
        return ((bitField0_ & 0x00000010) != 0);
      }
      /**
       * <pre>
       * Indicates whether or not to use the sparse version of the Op that computes
       * the center heatmaps. The sparse version scales better with number of
       * channels in the heatmap, but in some cases is known to cause an OOM error.
       * TODO(b/170989061) When bug is fixed, make this the default behavior.
       * </pre>
       *
       * <code>optional bool compute_heatmap_sparse = 15 [default = false];</code>
       * @return The computeHeatmapSparse.
       */
      @java.lang.Override
      public boolean getComputeHeatmapSparse() {
        return computeHeatmapSparse_;
      }
      /**
       * <pre>
       * Indicates whether or not to use the sparse version of the Op that computes
       * the center heatmaps. The sparse version scales better with number of
       * channels in the heatmap, but in some cases is known to cause an OOM error.
       * TODO(b/170989061) When bug is fixed, make this the default behavior.
       * </pre>
       *
       * <code>optional bool compute_heatmap_sparse = 15 [default = false];</code>
       * @param value The computeHeatmapSparse to set.
       * @return This builder for chaining.
       */
      public Builder setComputeHeatmapSparse(boolean value) {
        bitField0_ |= 0x00000010;
        computeHeatmapSparse_ = value;
        onChanged();
        return this;
      }
      /**
       * <pre>
       * Indicates whether or not to use the sparse version of the Op that computes
       * the center heatmaps. The sparse version scales better with number of
       * channels in the heatmap, but in some cases is known to cause an OOM error.
       * TODO(b/170989061) When bug is fixed, make this the default behavior.
       * </pre>
       *
       * <code>optional bool compute_heatmap_sparse = 15 [default = false];</code>
       * @return This builder for chaining.
       */
      public Builder clearComputeHeatmapSparse() {
        bitField0_ = (bitField0_ & ~0x00000010);
        computeHeatmapSparse_ = false;
        onChanged();
        return this;
      }

      private object_detection.protos.CenterNetOuterClass.CenterNet.ObjectDetection objectDetectionTask_;
      private com.google.protobuf.SingleFieldBuilderV3<
          object_detection.protos.CenterNetOuterClass.CenterNet.ObjectDetection, object_detection.protos.CenterNetOuterClass.CenterNet.ObjectDetection.Builder, object_detection.protos.CenterNetOuterClass.CenterNet.ObjectDetectionOrBuilder> objectDetectionTaskBuilder_;
      /**
       * <code>optional .object_detection.protos.CenterNet.ObjectDetection object_detection_task = 4;</code>
       * @return Whether the objectDetectionTask field is set.
       */
      public boolean hasObjectDetectionTask() {
        return ((bitField0_ & 0x00000020) != 0);
      }
      /**
       * <code>optional .object_detection.protos.CenterNet.ObjectDetection object_detection_task = 4;</code>
       * @return The objectDetectionTask.
       */
      public object_detection.protos.CenterNetOuterClass.CenterNet.ObjectDetection getObjectDetectionTask() {
        if (objectDetectionTaskBuilder_ == null) {
          return objectDetectionTask_ == null ? object_detection.protos.CenterNetOuterClass.CenterNet.ObjectDetection.getDefaultInstance() : objectDetectionTask_;
        } else {
          return objectDetectionTaskBuilder_.getMessage();
        }
      }
      /**
       * <code>optional .object_detection.protos.CenterNet.ObjectDetection object_detection_task = 4;</code>
       */
      public Builder setObjectDetectionTask(object_detection.protos.CenterNetOuterClass.CenterNet.ObjectDetection value) {
        if (objectDetectionTaskBuilder_ == null) {
          if (value == null) {
            throw new NullPointerException();
          }
          objectDetectionTask_ = value;
          onChanged();
        } else {
          objectDetectionTaskBuilder_.setMessage(value);
        }
        bitField0_ |= 0x00000020;
        return this;
      }
      /**
       * <code>optional .object_detection.protos.CenterNet.ObjectDetection object_detection_task = 4;</code>
       */
      public Builder setObjectDetectionTask(
          object_detection.protos.CenterNetOuterClass.CenterNet.ObjectDetection.Builder builderForValue) {
        if (objectDetectionTaskBuilder_ == null) {
          objectDetectionTask_ = builderForValue.build();
          onChanged();
        } else {
          objectDetectionTaskBuilder_.setMessage(builderForValue.build());
        }
        bitField0_ |= 0x00000020;
        return this;
      }
      /**
       * <code>optional .object_detection.protos.CenterNet.ObjectDetection object_detection_task = 4;</code>
       */
      public Builder mergeObjectDetectionTask(object_detection.protos.CenterNetOuterClass.CenterNet.ObjectDetection value) {
        if (objectDetectionTaskBuilder_ == null) {
          if (((bitField0_ & 0x00000020) != 0) &&
              objectDetectionTask_ != null &&
              objectDetectionTask_ != object_detection.protos.CenterNetOuterClass.CenterNet.ObjectDetection.getDefaultInstance()) {
            objectDetectionTask_ =
              object_detection.protos.CenterNetOuterClass.CenterNet.ObjectDetection.newBuilder(objectDetectionTask_).mergeFrom(value).buildPartial();
          } else {
            objectDetectionTask_ = value;
          }
          onChanged();
        } else {
          objectDetectionTaskBuilder_.mergeFrom(value);
        }
        bitField0_ |= 0x00000020;
        return this;
      }
      /**
       * <code>optional .object_detection.protos.CenterNet.ObjectDetection object_detection_task = 4;</code>
       */
      public Builder clearObjectDetectionTask() {
        if (objectDetectionTaskBuilder_ == null) {
          objectDetectionTask_ = null;
          onChanged();
        } else {
          objectDetectionTaskBuilder_.clear();
        }
        bitField0_ = (bitField0_ & ~0x00000020);
        return this;
      }
      /**
       * <code>optional .object_detection.protos.CenterNet.ObjectDetection object_detection_task = 4;</code>
       */
      public object_detection.protos.CenterNetOuterClass.CenterNet.ObjectDetection.Builder getObjectDetectionTaskBuilder() {
        bitField0_ |= 0x00000020;
        onChanged();
        return getObjectDetectionTaskFieldBuilder().getBuilder();
      }
      /**
       * <code>optional .object_detection.protos.CenterNet.ObjectDetection object_detection_task = 4;</code>
       */
      public object_detection.protos.CenterNetOuterClass.CenterNet.ObjectDetectionOrBuilder getObjectDetectionTaskOrBuilder() {
        if (objectDetectionTaskBuilder_ != null) {
          return objectDetectionTaskBuilder_.getMessageOrBuilder();
        } else {
          return objectDetectionTask_ == null ?
              object_detection.protos.CenterNetOuterClass.CenterNet.ObjectDetection.getDefaultInstance() : objectDetectionTask_;
        }
      }
      /**
       * <code>optional .object_detection.protos.CenterNet.ObjectDetection object_detection_task = 4;</code>
       */
      private com.google.protobuf.SingleFieldBuilderV3<
          object_detection.protos.CenterNetOuterClass.CenterNet.ObjectDetection, object_detection.protos.CenterNetOuterClass.CenterNet.ObjectDetection.Builder, object_detection.protos.CenterNetOuterClass.CenterNet.ObjectDetectionOrBuilder>
          getObjectDetectionTaskFieldBuilder() {
        if (objectDetectionTaskBuilder_ == null) {
          objectDetectionTaskBuilder_ = new com.google.protobuf.SingleFieldBuilderV3<
              object_detection.protos.CenterNetOuterClass.CenterNet.ObjectDetection, object_detection.protos.CenterNetOuterClass.CenterNet.ObjectDetection.Builder, object_detection.protos.CenterNetOuterClass.CenterNet.ObjectDetectionOrBuilder>(
                  getObjectDetectionTask(),
                  getParentForChildren(),
                  isClean());
          objectDetectionTask_ = null;
        }
        return objectDetectionTaskBuilder_;
      }

      private object_detection.protos.CenterNetOuterClass.CenterNet.ObjectCenterParams objectCenterParams_;
      private com.google.protobuf.SingleFieldBuilderV3<
          object_detection.protos.CenterNetOuterClass.CenterNet.ObjectCenterParams, object_detection.protos.CenterNetOuterClass.CenterNet.ObjectCenterParams.Builder, object_detection.protos.CenterNetOuterClass.CenterNet.ObjectCenterParamsOrBuilder> objectCenterParamsBuilder_;
      /**
       * <code>optional .object_detection.protos.CenterNet.ObjectCenterParams object_center_params = 5;</code>
       * @return Whether the objectCenterParams field is set.
       */
      public boolean hasObjectCenterParams() {
        return ((bitField0_ & 0x00000040) != 0);
      }
      /**
       * <code>optional .object_detection.protos.CenterNet.ObjectCenterParams object_center_params = 5;</code>
       * @return The objectCenterParams.
       */
      public object_detection.protos.CenterNetOuterClass.CenterNet.ObjectCenterParams getObjectCenterParams() {
        if (objectCenterParamsBuilder_ == null) {
          return objectCenterParams_ == null ? object_detection.protos.CenterNetOuterClass.CenterNet.ObjectCenterParams.getDefaultInstance() : objectCenterParams_;
        } else {
          return objectCenterParamsBuilder_.getMessage();
        }
      }
      /**
       * <code>optional .object_detection.protos.CenterNet.ObjectCenterParams object_center_params = 5;</code>
       */
      public Builder setObjectCenterParams(object_detection.protos.CenterNetOuterClass.CenterNet.ObjectCenterParams value) {
        if (objectCenterParamsBuilder_ == null) {
          if (value == null) {
            throw new NullPointerException();
          }
          objectCenterParams_ = value;
          onChanged();
        } else {
          objectCenterParamsBuilder_.setMessage(value);
        }
        bitField0_ |= 0x00000040;
        return this;
      }
      /**
       * <code>optional .object_detection.protos.CenterNet.ObjectCenterParams object_center_params = 5;</code>
       */
      public Builder setObjectCenterParams(
          object_detection.protos.CenterNetOuterClass.CenterNet.ObjectCenterParams.Builder builderForValue) {
        if (objectCenterParamsBuilder_ == null) {
          objectCenterParams_ = builderForValue.build();
          onChanged();
        } else {
          objectCenterParamsBuilder_.setMessage(builderForValue.build());
        }
        bitField0_ |= 0x00000040;
        return this;
      }
      /**
       * <code>optional .object_detection.protos.CenterNet.ObjectCenterParams object_center_params = 5;</code>
       */
      public Builder mergeObjectCenterParams(object_detection.protos.CenterNetOuterClass.CenterNet.ObjectCenterParams value) {
        if (objectCenterParamsBuilder_ == null) {
          if (((bitField0_ & 0x00000040) != 0) &&
              objectCenterParams_ != null &&
              objectCenterParams_ != object_detection.protos.CenterNetOuterClass.CenterNet.ObjectCenterParams.getDefaultInstance()) {
            objectCenterParams_ =
              object_detection.protos.CenterNetOuterClass.CenterNet.ObjectCenterParams.newBuilder(objectCenterParams_).mergeFrom(value).buildPartial();
          } else {
            objectCenterParams_ = value;
          }
          onChanged();
        } else {
          objectCenterParamsBuilder_.mergeFrom(value);
        }
        bitField0_ |= 0x00000040;
        return this;
      }
      /**
       * <code>optional .object_detection.protos.CenterNet.ObjectCenterParams object_center_params = 5;</code>
       */
      public Builder clearObjectCenterParams() {
        if (objectCenterParamsBuilder_ == null) {
          objectCenterParams_ = null;
          onChanged();
        } else {
          objectCenterParamsBuilder_.clear();
        }
        bitField0_ = (bitField0_ & ~0x00000040);
        return this;
      }
      /**
       * <code>optional .object_detection.protos.CenterNet.ObjectCenterParams object_center_params = 5;</code>
       */
      public object_detection.protos.CenterNetOuterClass.CenterNet.ObjectCenterParams.Builder getObjectCenterParamsBuilder() {
        bitField0_ |= 0x00000040;
        onChanged();
        return getObjectCenterParamsFieldBuilder().getBuilder();
      }
      /**
       * <code>optional .object_detection.protos.CenterNet.ObjectCenterParams object_center_params = 5;</code>
       */
      public object_detection.protos.CenterNetOuterClass.CenterNet.ObjectCenterParamsOrBuilder getObjectCenterParamsOrBuilder() {
        if (objectCenterParamsBuilder_ != null) {
          return objectCenterParamsBuilder_.getMessageOrBuilder();
        } else {
          return objectCenterParams_ == null ?
              object_detection.protos.CenterNetOuterClass.CenterNet.ObjectCenterParams.getDefaultInstance() : objectCenterParams_;
        }
      }
      /**
       * <code>optional .object_detection.protos.CenterNet.ObjectCenterParams object_center_params = 5;</code>
       */
      private com.google.protobuf.SingleFieldBuilderV3<
          object_detection.protos.CenterNetOuterClass.CenterNet.ObjectCenterParams, object_detection.protos.CenterNetOuterClass.CenterNet.ObjectCenterParams.Builder, object_detection.protos.CenterNetOuterClass.CenterNet.ObjectCenterParamsOrBuilder>
          getObjectCenterParamsFieldBuilder() {
        if (objectCenterParamsBuilder_ == null) {
          objectCenterParamsBuilder_ = new com.google.protobuf.SingleFieldBuilderV3<
              object_detection.protos.CenterNetOuterClass.CenterNet.ObjectCenterParams, object_detection.protos.CenterNetOuterClass.CenterNet.ObjectCenterParams.Builder, object_detection.protos.CenterNetOuterClass.CenterNet.ObjectCenterParamsOrBuilder>(
                  getObjectCenterParams(),
                  getParentForChildren(),
                  isClean());
          objectCenterParams_ = null;
        }
        return objectCenterParamsBuilder_;
      }

      private java.lang.Object keypointLabelMapPath_ = "";
      /**
       * <pre>
       * Path of the file that conatins the label map along with the keypoint
       * information, including the keypoint indices, corresponding labels, and the
       * corresponding class. The file should be the same one as used in the input
       * pipeline. Note that a plain text of StringIntLabelMap proto is expected in
       * this file.
       * It is required only if the keypoint estimation task is specified.
       * </pre>
       *
       * <code>optional string keypoint_label_map_path = 6;</code>
       * @return Whether the keypointLabelMapPath field is set.
       */
      public boolean hasKeypointLabelMapPath() {
        return ((bitField0_ & 0x00000080) != 0);
      }
      /**
       * <pre>
       * Path of the file that conatins the label map along with the keypoint
       * information, including the keypoint indices, corresponding labels, and the
       * corresponding class. The file should be the same one as used in the input
       * pipeline. Note that a plain text of StringIntLabelMap proto is expected in
       * this file.
       * It is required only if the keypoint estimation task is specified.
       * </pre>
       *
       * <code>optional string keypoint_label_map_path = 6;</code>
       * @return The keypointLabelMapPath.
       */
      public java.lang.String getKeypointLabelMapPath() {
        java.lang.Object ref = keypointLabelMapPath_;
        if (!(ref instanceof java.lang.String)) {
          com.google.protobuf.ByteString bs =
              (com.google.protobuf.ByteString) ref;
          java.lang.String s = bs.toStringUtf8();
          if (bs.isValidUtf8()) {
            keypointLabelMapPath_ = s;
          }
          return s;
        } else {
          return (java.lang.String) ref;
        }
      }
      /**
       * <pre>
       * Path of the file that conatins the label map along with the keypoint
       * information, including the keypoint indices, corresponding labels, and the
       * corresponding class. The file should be the same one as used in the input
       * pipeline. Note that a plain text of StringIntLabelMap proto is expected in
       * this file.
       * It is required only if the keypoint estimation task is specified.
       * </pre>
       *
       * <code>optional string keypoint_label_map_path = 6;</code>
       * @return The bytes for keypointLabelMapPath.
       */
      public com.google.protobuf.ByteString
          getKeypointLabelMapPathBytes() {
        java.lang.Object ref = keypointLabelMapPath_;
        if (ref instanceof String) {
          com.google.protobuf.ByteString b =
              com.google.protobuf.ByteString.copyFromUtf8(
                  (java.lang.String) ref);
          keypointLabelMapPath_ = b;
          return b;
        } else {
          return (com.google.protobuf.ByteString) ref;
        }
      }
      /**
       * <pre>
       * Path of the file that conatins the label map along with the keypoint
       * information, including the keypoint indices, corresponding labels, and the
       * corresponding class. The file should be the same one as used in the input
       * pipeline. Note that a plain text of StringIntLabelMap proto is expected in
       * this file.
       * It is required only if the keypoint estimation task is specified.
       * </pre>
       *
       * <code>optional string keypoint_label_map_path = 6;</code>
       * @param value The keypointLabelMapPath to set.
       * @return This builder for chaining.
       */
      public Builder setKeypointLabelMapPath(
          java.lang.String value) {
        if (value == null) {
    throw new NullPointerException();
  }
  bitField0_ |= 0x00000080;
        keypointLabelMapPath_ = value;
        onChanged();
        return this;
      }
      /**
       * <pre>
       * Path of the file that conatins the label map along with the keypoint
       * information, including the keypoint indices, corresponding labels, and the
       * corresponding class. The file should be the same one as used in the input
       * pipeline. Note that a plain text of StringIntLabelMap proto is expected in
       * this file.
       * It is required only if the keypoint estimation task is specified.
       * </pre>
       *
       * <code>optional string keypoint_label_map_path = 6;</code>
       * @return This builder for chaining.
       */
      public Builder clearKeypointLabelMapPath() {
        bitField0_ = (bitField0_ & ~0x00000080);
        keypointLabelMapPath_ = getDefaultInstance().getKeypointLabelMapPath();
        onChanged();
        return this;
      }
      /**
       * <pre>
       * Path of the file that conatins the label map along with the keypoint
       * information, including the keypoint indices, corresponding labels, and the
       * corresponding class. The file should be the same one as used in the input
       * pipeline. Note that a plain text of StringIntLabelMap proto is expected in
       * this file.
       * It is required only if the keypoint estimation task is specified.
       * </pre>
       *
       * <code>optional string keypoint_label_map_path = 6;</code>
       * @param value The bytes for keypointLabelMapPath to set.
       * @return This builder for chaining.
       */
      public Builder setKeypointLabelMapPathBytes(
          com.google.protobuf.ByteString value) {
        if (value == null) {
    throw new NullPointerException();
  }
  bitField0_ |= 0x00000080;
        keypointLabelMapPath_ = value;
        onChanged();
        return this;
      }

      private java.util.List<object_detection.protos.CenterNetOuterClass.CenterNet.KeypointEstimation> keypointEstimationTask_ =
        java.util.Collections.emptyList();
      private void ensureKeypointEstimationTaskIsMutable() {
        if (!((bitField0_ & 0x00000100) != 0)) {
          keypointEstimationTask_ = new java.util.ArrayList<object_detection.protos.CenterNetOuterClass.CenterNet.KeypointEstimation>(keypointEstimationTask_);
          bitField0_ |= 0x00000100;
         }
      }

      private com.google.protobuf.RepeatedFieldBuilderV3<
          object_detection.protos.CenterNetOuterClass.CenterNet.KeypointEstimation, object_detection.protos.CenterNetOuterClass.CenterNet.KeypointEstimation.Builder, object_detection.protos.CenterNetOuterClass.CenterNet.KeypointEstimationOrBuilder> keypointEstimationTaskBuilder_;

      /**
       * <code>repeated .object_detection.protos.CenterNet.KeypointEstimation keypoint_estimation_task = 7;</code>
       */
      public java.util.List<object_detection.protos.CenterNetOuterClass.CenterNet.KeypointEstimation> getKeypointEstimationTaskList() {
        if (keypointEstimationTaskBuilder_ == null) {
          return java.util.Collections.unmodifiableList(keypointEstimationTask_);
        } else {
          return keypointEstimationTaskBuilder_.getMessageList();
        }
      }
      /**
       * <code>repeated .object_detection.protos.CenterNet.KeypointEstimation keypoint_estimation_task = 7;</code>
       */
      public int getKeypointEstimationTaskCount() {
        if (keypointEstimationTaskBuilder_ == null) {
          return keypointEstimationTask_.size();
        } else {
          return keypointEstimationTaskBuilder_.getCount();
        }
      }
      /**
       * <code>repeated .object_detection.protos.CenterNet.KeypointEstimation keypoint_estimation_task = 7;</code>
       */
      public object_detection.protos.CenterNetOuterClass.CenterNet.KeypointEstimation getKeypointEstimationTask(int index) {
        if (keypointEstimationTaskBuilder_ == null) {
          return keypointEstimationTask_.get(index);
        } else {
          return keypointEstimationTaskBuilder_.getMessage(index);
        }
      }
      /**
       * <code>repeated .object_detection.protos.CenterNet.KeypointEstimation keypoint_estimation_task = 7;</code>
       */
      public Builder setKeypointEstimationTask(
          int index, object_detection.protos.CenterNetOuterClass.CenterNet.KeypointEstimation value) {
        if (keypointEstimationTaskBuilder_ == null) {
          if (value == null) {
            throw new NullPointerException();
          }
          ensureKeypointEstimationTaskIsMutable();
          keypointEstimationTask_.set(index, value);
          onChanged();
        } else {
          keypointEstimationTaskBuilder_.setMessage(index, value);
        }
        return this;
      }
      /**
       * <code>repeated .object_detection.protos.CenterNet.KeypointEstimation keypoint_estimation_task = 7;</code>
       */
      public Builder setKeypointEstimationTask(
          int index, object_detection.protos.CenterNetOuterClass.CenterNet.KeypointEstimation.Builder builderForValue) {
        if (keypointEstimationTaskBuilder_ == null) {
          ensureKeypointEstimationTaskIsMutable();
          keypointEstimationTask_.set(index, builderForValue.build());
          onChanged();
        } else {
          keypointEstimationTaskBuilder_.setMessage(index, builderForValue.build());
        }
        return this;
      }
      /**
       * <code>repeated .object_detection.protos.CenterNet.KeypointEstimation keypoint_estimation_task = 7;</code>
       */
      public Builder addKeypointEstimationTask(object_detection.protos.CenterNetOuterClass.CenterNet.KeypointEstimation value) {
        if (keypointEstimationTaskBuilder_ == null) {
          if (value == null) {
            throw new NullPointerException();
          }
          ensureKeypointEstimationTaskIsMutable();
          keypointEstimationTask_.add(value);
          onChanged();
        } else {
          keypointEstimationTaskBuilder_.addMessage(value);
        }
        return this;
      }
      /**
       * <code>repeated .object_detection.protos.CenterNet.KeypointEstimation keypoint_estimation_task = 7;</code>
       */
      public Builder addKeypointEstimationTask(
          int index, object_detection.protos.CenterNetOuterClass.CenterNet.KeypointEstimation value) {
        if (keypointEstimationTaskBuilder_ == null) {
          if (value == null) {
            throw new NullPointerException();
          }
          ensureKeypointEstimationTaskIsMutable();
          keypointEstimationTask_.add(index, value);
          onChanged();
        } else {
          keypointEstimationTaskBuilder_.addMessage(index, value);
        }
        return this;
      }
      /**
       * <code>repeated .object_detection.protos.CenterNet.KeypointEstimation keypoint_estimation_task = 7;</code>
       */
      public Builder addKeypointEstimationTask(
          object_detection.protos.CenterNetOuterClass.CenterNet.KeypointEstimation.Builder builderForValue) {
        if (keypointEstimationTaskBuilder_ == null) {
          ensureKeypointEstimationTaskIsMutable();
          keypointEstimationTask_.add(builderForValue.build());
          onChanged();
        } else {
          keypointEstimationTaskBuilder_.addMessage(builderForValue.build());
        }
        return this;
      }
      /**
       * <code>repeated .object_detection.protos.CenterNet.KeypointEstimation keypoint_estimation_task = 7;</code>
       */
      public Builder addKeypointEstimationTask(
          int index, object_detection.protos.CenterNetOuterClass.CenterNet.KeypointEstimation.Builder builderForValue) {
        if (keypointEstimationTaskBuilder_ == null) {
          ensureKeypointEstimationTaskIsMutable();
          keypointEstimationTask_.add(index, builderForValue.build());
          onChanged();
        } else {
          keypointEstimationTaskBuilder_.addMessage(index, builderForValue.build());
        }
        return this;
      }
      /**
       * <code>repeated .object_detection.protos.CenterNet.KeypointEstimation keypoint_estimation_task = 7;</code>
       */
      public Builder addAllKeypointEstimationTask(
          java.lang.Iterable<? extends object_detection.protos.CenterNetOuterClass.CenterNet.KeypointEstimation> values) {
        if (keypointEstimationTaskBuilder_ == null) {
          ensureKeypointEstimationTaskIsMutable();
          com.google.protobuf.AbstractMessageLite.Builder.addAll(
              values, keypointEstimationTask_);
          onChanged();
        } else {
          keypointEstimationTaskBuilder_.addAllMessages(values);
        }
        return this;
      }
      /**
       * <code>repeated .object_detection.protos.CenterNet.KeypointEstimation keypoint_estimation_task = 7;</code>
       */
      public Builder clearKeypointEstimationTask() {
        if (keypointEstimationTaskBuilder_ == null) {
          keypointEstimationTask_ = java.util.Collections.emptyList();
          bitField0_ = (bitField0_ & ~0x00000100);
          onChanged();
        } else {
          keypointEstimationTaskBuilder_.clear();
        }
        return this;
      }
      /**
       * <code>repeated .object_detection.protos.CenterNet.KeypointEstimation keypoint_estimation_task = 7;</code>
       */
      public Builder removeKeypointEstimationTask(int index) {
        if (keypointEstimationTaskBuilder_ == null) {
          ensureKeypointEstimationTaskIsMutable();
          keypointEstimationTask_.remove(index);
          onChanged();
        } else {
          keypointEstimationTaskBuilder_.remove(index);
        }
        return this;
      }
      /**
       * <code>repeated .object_detection.protos.CenterNet.KeypointEstimation keypoint_estimation_task = 7;</code>
       */
      public object_detection.protos.CenterNetOuterClass.CenterNet.KeypointEstimation.Builder getKeypointEstimationTaskBuilder(
          int index) {
        return getKeypointEstimationTaskFieldBuilder().getBuilder(index);
      }
      /**
       * <code>repeated .object_detection.protos.CenterNet.KeypointEstimation keypoint_estimation_task = 7;</code>
       */
      public object_detection.protos.CenterNetOuterClass.CenterNet.KeypointEstimationOrBuilder getKeypointEstimationTaskOrBuilder(
          int index) {
        if (keypointEstimationTaskBuilder_ == null) {
          return keypointEstimationTask_.get(index);  } else {
          return keypointEstimationTaskBuilder_.getMessageOrBuilder(index);
        }
      }
      /**
       * <code>repeated .object_detection.protos.CenterNet.KeypointEstimation keypoint_estimation_task = 7;</code>
       */
      public java.util.List<? extends object_detection.protos.CenterNetOuterClass.CenterNet.KeypointEstimationOrBuilder>
           getKeypointEstimationTaskOrBuilderList() {
        if (keypointEstimationTaskBuilder_ != null) {
          return keypointEstimationTaskBuilder_.getMessageOrBuilderList();
        } else {
          return java.util.Collections.unmodifiableList(keypointEstimationTask_);
        }
      }
      /**
       * <code>repeated .object_detection.protos.CenterNet.KeypointEstimation keypoint_estimation_task = 7;</code>
       */
      public object_detection.protos.CenterNetOuterClass.CenterNet.KeypointEstimation.Builder addKeypointEstimationTaskBuilder() {
        return getKeypointEstimationTaskFieldBuilder().addBuilder(
            object_detection.protos.CenterNetOuterClass.CenterNet.KeypointEstimation.getDefaultInstance());
      }
      /**
       * <code>repeated .object_detection.protos.CenterNet.KeypointEstimation keypoint_estimation_task = 7;</code>
       */
      public object_detection.protos.CenterNetOuterClass.CenterNet.KeypointEstimation.Builder addKeypointEstimationTaskBuilder(
          int index) {
        return getKeypointEstimationTaskFieldBuilder().addBuilder(
            index, object_detection.protos.CenterNetOuterClass.CenterNet.KeypointEstimation.getDefaultInstance());
      }
      /**
       * <code>repeated .object_detection.protos.CenterNet.KeypointEstimation keypoint_estimation_task = 7;</code>
       */
      public java.util.List<object_detection.protos.CenterNetOuterClass.CenterNet.KeypointEstimation.Builder>
           getKeypointEstimationTaskBuilderList() {
        return getKeypointEstimationTaskFieldBuilder().getBuilderList();
      }
      private com.google.protobuf.RepeatedFieldBuilderV3<
          object_detection.protos.CenterNetOuterClass.CenterNet.KeypointEstimation, object_detection.protos.CenterNetOuterClass.CenterNet.KeypointEstimation.Builder, object_detection.protos.CenterNetOuterClass.CenterNet.KeypointEstimationOrBuilder>
          getKeypointEstimationTaskFieldBuilder() {
        if (keypointEstimationTaskBuilder_ == null) {
          keypointEstimationTaskBuilder_ = new com.google.protobuf.RepeatedFieldBuilderV3<
              object_detection.protos.CenterNetOuterClass.CenterNet.KeypointEstimation, object_detection.protos.CenterNetOuterClass.CenterNet.KeypointEstimation.Builder, object_detection.protos.CenterNetOuterClass.CenterNet.KeypointEstimationOrBuilder>(
                  keypointEstimationTask_,
                  ((bitField0_ & 0x00000100) != 0),
                  getParentForChildren(),
                  isClean());
          keypointEstimationTask_ = null;
        }
        return keypointEstimationTaskBuilder_;
      }

      private object_detection.protos.CenterNetOuterClass.CenterNet.MaskEstimation maskEstimationTask_;
      private com.google.protobuf.SingleFieldBuilderV3<
          object_detection.protos.CenterNetOuterClass.CenterNet.MaskEstimation, object_detection.protos.CenterNetOuterClass.CenterNet.MaskEstimation.Builder, object_detection.protos.CenterNetOuterClass.CenterNet.MaskEstimationOrBuilder> maskEstimationTaskBuilder_;
      /**
       * <code>optional .object_detection.protos.CenterNet.MaskEstimation mask_estimation_task = 8;</code>
       * @return Whether the maskEstimationTask field is set.
       */
      public boolean hasMaskEstimationTask() {
        return ((bitField0_ & 0x00000200) != 0);
      }
      /**
       * <code>optional .object_detection.protos.CenterNet.MaskEstimation mask_estimation_task = 8;</code>
       * @return The maskEstimationTask.
       */
      public object_detection.protos.CenterNetOuterClass.CenterNet.MaskEstimation getMaskEstimationTask() {
        if (maskEstimationTaskBuilder_ == null) {
          return maskEstimationTask_ == null ? object_detection.protos.CenterNetOuterClass.CenterNet.MaskEstimation.getDefaultInstance() : maskEstimationTask_;
        } else {
          return maskEstimationTaskBuilder_.getMessage();
        }
      }
      /**
       * <code>optional .object_detection.protos.CenterNet.MaskEstimation mask_estimation_task = 8;</code>
       */
      public Builder setMaskEstimationTask(object_detection.protos.CenterNetOuterClass.CenterNet.MaskEstimation value) {
        if (maskEstimationTaskBuilder_ == null) {
          if (value == null) {
            throw new NullPointerException();
          }
          maskEstimationTask_ = value;
          onChanged();
        } else {
          maskEstimationTaskBuilder_.setMessage(value);
        }
        bitField0_ |= 0x00000200;
        return this;
      }
      /**
       * <code>optional .object_detection.protos.CenterNet.MaskEstimation mask_estimation_task = 8;</code>
       */
      public Builder setMaskEstimationTask(
          object_detection.protos.CenterNetOuterClass.CenterNet.MaskEstimation.Builder builderForValue) {
        if (maskEstimationTaskBuilder_ == null) {
          maskEstimationTask_ = builderForValue.build();
          onChanged();
        } else {
          maskEstimationTaskBuilder_.setMessage(builderForValue.build());
        }
        bitField0_ |= 0x00000200;
        return this;
      }
      /**
       * <code>optional .object_detection.protos.CenterNet.MaskEstimation mask_estimation_task = 8;</code>
       */
      public Builder mergeMaskEstimationTask(object_detection.protos.CenterNetOuterClass.CenterNet.MaskEstimation value) {
        if (maskEstimationTaskBuilder_ == null) {
          if (((bitField0_ & 0x00000200) != 0) &&
              maskEstimationTask_ != null &&
              maskEstimationTask_ != object_detection.protos.CenterNetOuterClass.CenterNet.MaskEstimation.getDefaultInstance()) {
            maskEstimationTask_ =
              object_detection.protos.CenterNetOuterClass.CenterNet.MaskEstimation.newBuilder(maskEstimationTask_).mergeFrom(value).buildPartial();
          } else {
            maskEstimationTask_ = value;
          }
          onChanged();
        } else {
          maskEstimationTaskBuilder_.mergeFrom(value);
        }
        bitField0_ |= 0x00000200;
        return this;
      }
      /**
       * <code>optional .object_detection.protos.CenterNet.MaskEstimation mask_estimation_task = 8;</code>
       */
      public Builder clearMaskEstimationTask() {
        if (maskEstimationTaskBuilder_ == null) {
          maskEstimationTask_ = null;
          onChanged();
        } else {
          maskEstimationTaskBuilder_.clear();
        }
        bitField0_ = (bitField0_ & ~0x00000200);
        return this;
      }
      /**
       * <code>optional .object_detection.protos.CenterNet.MaskEstimation mask_estimation_task = 8;</code>
       */
      public object_detection.protos.CenterNetOuterClass.CenterNet.MaskEstimation.Builder getMaskEstimationTaskBuilder() {
        bitField0_ |= 0x00000200;
        onChanged();
        return getMaskEstimationTaskFieldBuilder().getBuilder();
      }
      /**
       * <code>optional .object_detection.protos.CenterNet.MaskEstimation mask_estimation_task = 8;</code>
       */
      public object_detection.protos.CenterNetOuterClass.CenterNet.MaskEstimationOrBuilder getMaskEstimationTaskOrBuilder() {
        if (maskEstimationTaskBuilder_ != null) {
          return maskEstimationTaskBuilder_.getMessageOrBuilder();
        } else {
          return maskEstimationTask_ == null ?
              object_detection.protos.CenterNetOuterClass.CenterNet.MaskEstimation.getDefaultInstance() : maskEstimationTask_;
        }
      }
      /**
       * <code>optional .object_detection.protos.CenterNet.MaskEstimation mask_estimation_task = 8;</code>
       */
      private com.google.protobuf.SingleFieldBuilderV3<
          object_detection.protos.CenterNetOuterClass.CenterNet.MaskEstimation, object_detection.protos.CenterNetOuterClass.CenterNet.MaskEstimation.Builder, object_detection.protos.CenterNetOuterClass.CenterNet.MaskEstimationOrBuilder>
          getMaskEstimationTaskFieldBuilder() {
        if (maskEstimationTaskBuilder_ == null) {
          maskEstimationTaskBuilder_ = new com.google.protobuf.SingleFieldBuilderV3<
              object_detection.protos.CenterNetOuterClass.CenterNet.MaskEstimation, object_detection.protos.CenterNetOuterClass.CenterNet.MaskEstimation.Builder, object_detection.protos.CenterNetOuterClass.CenterNet.MaskEstimationOrBuilder>(
                  getMaskEstimationTask(),
                  getParentForChildren(),
                  isClean());
          maskEstimationTask_ = null;
        }
        return maskEstimationTaskBuilder_;
      }

      private object_detection.protos.CenterNetOuterClass.CenterNet.DensePoseEstimation denseposeEstimationTask_;
      private com.google.protobuf.SingleFieldBuilderV3<
          object_detection.protos.CenterNetOuterClass.CenterNet.DensePoseEstimation, object_detection.protos.CenterNetOuterClass.CenterNet.DensePoseEstimation.Builder, object_detection.protos.CenterNetOuterClass.CenterNet.DensePoseEstimationOrBuilder> denseposeEstimationTaskBuilder_;
      /**
       * <code>optional .object_detection.protos.CenterNet.DensePoseEstimation densepose_estimation_task = 9;</code>
       * @return Whether the denseposeEstimationTask field is set.
       */
      public boolean hasDenseposeEstimationTask() {
        return ((bitField0_ & 0x00000400) != 0);
      }
      /**
       * <code>optional .object_detection.protos.CenterNet.DensePoseEstimation densepose_estimation_task = 9;</code>
       * @return The denseposeEstimationTask.
       */
      public object_detection.protos.CenterNetOuterClass.CenterNet.DensePoseEstimation getDenseposeEstimationTask() {
        if (denseposeEstimationTaskBuilder_ == null) {
          return denseposeEstimationTask_ == null ? object_detection.protos.CenterNetOuterClass.CenterNet.DensePoseEstimation.getDefaultInstance() : denseposeEstimationTask_;
        } else {
          return denseposeEstimationTaskBuilder_.getMessage();
        }
      }
      /**
       * <code>optional .object_detection.protos.CenterNet.DensePoseEstimation densepose_estimation_task = 9;</code>
       */
      public Builder setDenseposeEstimationTask(object_detection.protos.CenterNetOuterClass.CenterNet.DensePoseEstimation value) {
        if (denseposeEstimationTaskBuilder_ == null) {
          if (value == null) {
            throw new NullPointerException();
          }
          denseposeEstimationTask_ = value;
          onChanged();
        } else {
          denseposeEstimationTaskBuilder_.setMessage(value);
        }
        bitField0_ |= 0x00000400;
        return this;
      }
      /**
       * <code>optional .object_detection.protos.CenterNet.DensePoseEstimation densepose_estimation_task = 9;</code>
       */
      public Builder setDenseposeEstimationTask(
          object_detection.protos.CenterNetOuterClass.CenterNet.DensePoseEstimation.Builder builderForValue) {
        if (denseposeEstimationTaskBuilder_ == null) {
          denseposeEstimationTask_ = builderForValue.build();
          onChanged();
        } else {
          denseposeEstimationTaskBuilder_.setMessage(builderForValue.build());
        }
        bitField0_ |= 0x00000400;
        return this;
      }
      /**
       * <code>optional .object_detection.protos.CenterNet.DensePoseEstimation densepose_estimation_task = 9;</code>
       */
      public Builder mergeDenseposeEstimationTask(object_detection.protos.CenterNetOuterClass.CenterNet.DensePoseEstimation value) {
        if (denseposeEstimationTaskBuilder_ == null) {
          if (((bitField0_ & 0x00000400) != 0) &&
              denseposeEstimationTask_ != null &&
              denseposeEstimationTask_ != object_detection.protos.CenterNetOuterClass.CenterNet.DensePoseEstimation.getDefaultInstance()) {
            denseposeEstimationTask_ =
              object_detection.protos.CenterNetOuterClass.CenterNet.DensePoseEstimation.newBuilder(denseposeEstimationTask_).mergeFrom(value).buildPartial();
          } else {
            denseposeEstimationTask_ = value;
          }
          onChanged();
        } else {
          denseposeEstimationTaskBuilder_.mergeFrom(value);
        }
        bitField0_ |= 0x00000400;
        return this;
      }
      /**
       * <code>optional .object_detection.protos.CenterNet.DensePoseEstimation densepose_estimation_task = 9;</code>
       */
      public Builder clearDenseposeEstimationTask() {
        if (denseposeEstimationTaskBuilder_ == null) {
          denseposeEstimationTask_ = null;
          onChanged();
        } else {
          denseposeEstimationTaskBuilder_.clear();
        }
        bitField0_ = (bitField0_ & ~0x00000400);
        return this;
      }
      /**
       * <code>optional .object_detection.protos.CenterNet.DensePoseEstimation densepose_estimation_task = 9;</code>
       */
      public object_detection.protos.CenterNetOuterClass.CenterNet.DensePoseEstimation.Builder getDenseposeEstimationTaskBuilder() {
        bitField0_ |= 0x00000400;
        onChanged();
        return getDenseposeEstimationTaskFieldBuilder().getBuilder();
      }
      /**
       * <code>optional .object_detection.protos.CenterNet.DensePoseEstimation densepose_estimation_task = 9;</code>
       */
      public object_detection.protos.CenterNetOuterClass.CenterNet.DensePoseEstimationOrBuilder getDenseposeEstimationTaskOrBuilder() {
        if (denseposeEstimationTaskBuilder_ != null) {
          return denseposeEstimationTaskBuilder_.getMessageOrBuilder();
        } else {
          return denseposeEstimationTask_ == null ?
              object_detection.protos.CenterNetOuterClass.CenterNet.DensePoseEstimation.getDefaultInstance() : denseposeEstimationTask_;
        }
      }
      /**
       * <code>optional .object_detection.protos.CenterNet.DensePoseEstimation densepose_estimation_task = 9;</code>
       */
      private com.google.protobuf.SingleFieldBuilderV3<
          object_detection.protos.CenterNetOuterClass.CenterNet.DensePoseEstimation, object_detection.protos.CenterNetOuterClass.CenterNet.DensePoseEstimation.Builder, object_detection.protos.CenterNetOuterClass.CenterNet.DensePoseEstimationOrBuilder>
          getDenseposeEstimationTaskFieldBuilder() {
        if (denseposeEstimationTaskBuilder_ == null) {
          denseposeEstimationTaskBuilder_ = new com.google.protobuf.SingleFieldBuilderV3<
              object_detection.protos.CenterNetOuterClass.CenterNet.DensePoseEstimation, object_detection.protos.CenterNetOuterClass.CenterNet.DensePoseEstimation.Builder, object_detection.protos.CenterNetOuterClass.CenterNet.DensePoseEstimationOrBuilder>(
                  getDenseposeEstimationTask(),
                  getParentForChildren(),
                  isClean());
          denseposeEstimationTask_ = null;
        }
        return denseposeEstimationTaskBuilder_;
      }

      private object_detection.protos.CenterNetOuterClass.CenterNet.TrackEstimation trackEstimationTask_;
      private com.google.protobuf.SingleFieldBuilderV3<
          object_detection.protos.CenterNetOuterClass.CenterNet.TrackEstimation, object_detection.protos.CenterNetOuterClass.CenterNet.TrackEstimation.Builder, object_detection.protos.CenterNetOuterClass.CenterNet.TrackEstimationOrBuilder> trackEstimationTaskBuilder_;
      /**
       * <code>optional .object_detection.protos.CenterNet.TrackEstimation track_estimation_task = 10;</code>
       * @return Whether the trackEstimationTask field is set.
       */
      public boolean hasTrackEstimationTask() {
        return ((bitField0_ & 0x00000800) != 0);
      }
      /**
       * <code>optional .object_detection.protos.CenterNet.TrackEstimation track_estimation_task = 10;</code>
       * @return The trackEstimationTask.
       */
      public object_detection.protos.CenterNetOuterClass.CenterNet.TrackEstimation getTrackEstimationTask() {
        if (trackEstimationTaskBuilder_ == null) {
          return trackEstimationTask_ == null ? object_detection.protos.CenterNetOuterClass.CenterNet.TrackEstimation.getDefaultInstance() : trackEstimationTask_;
        } else {
          return trackEstimationTaskBuilder_.getMessage();
        }
      }
      /**
       * <code>optional .object_detection.protos.CenterNet.TrackEstimation track_estimation_task = 10;</code>
       */
      public Builder setTrackEstimationTask(object_detection.protos.CenterNetOuterClass.CenterNet.TrackEstimation value) {
        if (trackEstimationTaskBuilder_ == null) {
          if (value == null) {
            throw new NullPointerException();
          }
          trackEstimationTask_ = value;
          onChanged();
        } else {
          trackEstimationTaskBuilder_.setMessage(value);
        }
        bitField0_ |= 0x00000800;
        return this;
      }
      /**
       * <code>optional .object_detection.protos.CenterNet.TrackEstimation track_estimation_task = 10;</code>
       */
      public Builder setTrackEstimationTask(
          object_detection.protos.CenterNetOuterClass.CenterNet.TrackEstimation.Builder builderForValue) {
        if (trackEstimationTaskBuilder_ == null) {
          trackEstimationTask_ = builderForValue.build();
          onChanged();
        } else {
          trackEstimationTaskBuilder_.setMessage(builderForValue.build());
        }
        bitField0_ |= 0x00000800;
        return this;
      }
      /**
       * <code>optional .object_detection.protos.CenterNet.TrackEstimation track_estimation_task = 10;</code>
       */
      public Builder mergeTrackEstimationTask(object_detection.protos.CenterNetOuterClass.CenterNet.TrackEstimation value) {
        if (trackEstimationTaskBuilder_ == null) {
          if (((bitField0_ & 0x00000800) != 0) &&
              trackEstimationTask_ != null &&
              trackEstimationTask_ != object_detection.protos.CenterNetOuterClass.CenterNet.TrackEstimation.getDefaultInstance()) {
            trackEstimationTask_ =
              object_detection.protos.CenterNetOuterClass.CenterNet.TrackEstimation.newBuilder(trackEstimationTask_).mergeFrom(value).buildPartial();
          } else {
            trackEstimationTask_ = value;
          }
          onChanged();
        } else {
          trackEstimationTaskBuilder_.mergeFrom(value);
        }
        bitField0_ |= 0x00000800;
        return this;
      }
      /**
       * <code>optional .object_detection.protos.CenterNet.TrackEstimation track_estimation_task = 10;</code>
       */
      public Builder clearTrackEstimationTask() {
        if (trackEstimationTaskBuilder_ == null) {
          trackEstimationTask_ = null;
          onChanged();
        } else {
          trackEstimationTaskBuilder_.clear();
        }
        bitField0_ = (bitField0_ & ~0x00000800);
        return this;
      }
      /**
       * <code>optional .object_detection.protos.CenterNet.TrackEstimation track_estimation_task = 10;</code>
       */
      public object_detection.protos.CenterNetOuterClass.CenterNet.TrackEstimation.Builder getTrackEstimationTaskBuilder() {
        bitField0_ |= 0x00000800;
        onChanged();
        return getTrackEstimationTaskFieldBuilder().getBuilder();
      }
      /**
       * <code>optional .object_detection.protos.CenterNet.TrackEstimation track_estimation_task = 10;</code>
       */
      public object_detection.protos.CenterNetOuterClass.CenterNet.TrackEstimationOrBuilder getTrackEstimationTaskOrBuilder() {
        if (trackEstimationTaskBuilder_ != null) {
          return trackEstimationTaskBuilder_.getMessageOrBuilder();
        } else {
          return trackEstimationTask_ == null ?
              object_detection.protos.CenterNetOuterClass.CenterNet.TrackEstimation.getDefaultInstance() : trackEstimationTask_;
        }
      }
      /**
       * <code>optional .object_detection.protos.CenterNet.TrackEstimation track_estimation_task = 10;</code>
       */
      private com.google.protobuf.SingleFieldBuilderV3<
          object_detection.protos.CenterNetOuterClass.CenterNet.TrackEstimation, object_detection.protos.CenterNetOuterClass.CenterNet.TrackEstimation.Builder, object_detection.protos.CenterNetOuterClass.CenterNet.TrackEstimationOrBuilder>
          getTrackEstimationTaskFieldBuilder() {
        if (trackEstimationTaskBuilder_ == null) {
          trackEstimationTaskBuilder_ = new com.google.protobuf.SingleFieldBuilderV3<
              object_detection.protos.CenterNetOuterClass.CenterNet.TrackEstimation, object_detection.protos.CenterNetOuterClass.CenterNet.TrackEstimation.Builder, object_detection.protos.CenterNetOuterClass.CenterNet.TrackEstimationOrBuilder>(
                  getTrackEstimationTask(),
                  getParentForChildren(),
                  isClean());
          trackEstimationTask_ = null;
        }
        return trackEstimationTaskBuilder_;
      }

      private object_detection.protos.CenterNetOuterClass.CenterNet.TemporalOffsetEstimation temporalOffsetTask_;
      private com.google.protobuf.SingleFieldBuilderV3<
          object_detection.protos.CenterNetOuterClass.CenterNet.TemporalOffsetEstimation, object_detection.protos.CenterNetOuterClass.CenterNet.TemporalOffsetEstimation.Builder, object_detection.protos.CenterNetOuterClass.CenterNet.TemporalOffsetEstimationOrBuilder> temporalOffsetTaskBuilder_;
      /**
       * <code>optional .object_detection.protos.CenterNet.TemporalOffsetEstimation temporal_offset_task = 12;</code>
       * @return Whether the temporalOffsetTask field is set.
       */
      public boolean hasTemporalOffsetTask() {
        return ((bitField0_ & 0x00001000) != 0);
      }
      /**
       * <code>optional .object_detection.protos.CenterNet.TemporalOffsetEstimation temporal_offset_task = 12;</code>
       * @return The temporalOffsetTask.
       */
      public object_detection.protos.CenterNetOuterClass.CenterNet.TemporalOffsetEstimation getTemporalOffsetTask() {
        if (temporalOffsetTaskBuilder_ == null) {
          return temporalOffsetTask_ == null ? object_detection.protos.CenterNetOuterClass.CenterNet.TemporalOffsetEstimation.getDefaultInstance() : temporalOffsetTask_;
        } else {
          return temporalOffsetTaskBuilder_.getMessage();
        }
      }
      /**
       * <code>optional .object_detection.protos.CenterNet.TemporalOffsetEstimation temporal_offset_task = 12;</code>
       */
      public Builder setTemporalOffsetTask(object_detection.protos.CenterNetOuterClass.CenterNet.TemporalOffsetEstimation value) {
        if (temporalOffsetTaskBuilder_ == null) {
          if (value == null) {
            throw new NullPointerException();
          }
          temporalOffsetTask_ = value;
          onChanged();
        } else {
          temporalOffsetTaskBuilder_.setMessage(value);
        }
        bitField0_ |= 0x00001000;
        return this;
      }
      /**
       * <code>optional .object_detection.protos.CenterNet.TemporalOffsetEstimation temporal_offset_task = 12;</code>
       */
      public Builder setTemporalOffsetTask(
          object_detection.protos.CenterNetOuterClass.CenterNet.TemporalOffsetEstimation.Builder builderForValue) {
        if (temporalOffsetTaskBuilder_ == null) {
          temporalOffsetTask_ = builderForValue.build();
          onChanged();
        } else {
          temporalOffsetTaskBuilder_.setMessage(builderForValue.build());
        }
        bitField0_ |= 0x00001000;
        return this;
      }
      /**
       * <code>optional .object_detection.protos.CenterNet.TemporalOffsetEstimation temporal_offset_task = 12;</code>
       */
      public Builder mergeTemporalOffsetTask(object_detection.protos.CenterNetOuterClass.CenterNet.TemporalOffsetEstimation value) {
        if (temporalOffsetTaskBuilder_ == null) {
          if (((bitField0_ & 0x00001000) != 0) &&
              temporalOffsetTask_ != null &&
              temporalOffsetTask_ != object_detection.protos.CenterNetOuterClass.CenterNet.TemporalOffsetEstimation.getDefaultInstance()) {
            temporalOffsetTask_ =
              object_detection.protos.CenterNetOuterClass.CenterNet.TemporalOffsetEstimation.newBuilder(temporalOffsetTask_).mergeFrom(value).buildPartial();
          } else {
            temporalOffsetTask_ = value;
          }
          onChanged();
        } else {
          temporalOffsetTaskBuilder_.mergeFrom(value);
        }
        bitField0_ |= 0x00001000;
        return this;
      }
      /**
       * <code>optional .object_detection.protos.CenterNet.TemporalOffsetEstimation temporal_offset_task = 12;</code>
       */
      public Builder clearTemporalOffsetTask() {
        if (temporalOffsetTaskBuilder_ == null) {
          temporalOffsetTask_ = null;
          onChanged();
        } else {
          temporalOffsetTaskBuilder_.clear();
        }
        bitField0_ = (bitField0_ & ~0x00001000);
        return this;
      }
      /**
       * <code>optional .object_detection.protos.CenterNet.TemporalOffsetEstimation temporal_offset_task = 12;</code>
       */
      public object_detection.protos.CenterNetOuterClass.CenterNet.TemporalOffsetEstimation.Builder getTemporalOffsetTaskBuilder() {
        bitField0_ |= 0x00001000;
        onChanged();
        return getTemporalOffsetTaskFieldBuilder().getBuilder();
      }
      /**
       * <code>optional .object_detection.protos.CenterNet.TemporalOffsetEstimation temporal_offset_task = 12;</code>
       */
      public object_detection.protos.CenterNetOuterClass.CenterNet.TemporalOffsetEstimationOrBuilder getTemporalOffsetTaskOrBuilder() {
        if (temporalOffsetTaskBuilder_ != null) {
          return temporalOffsetTaskBuilder_.getMessageOrBuilder();
        } else {
          return temporalOffsetTask_ == null ?
              object_detection.protos.CenterNetOuterClass.CenterNet.TemporalOffsetEstimation.getDefaultInstance() : temporalOffsetTask_;
        }
      }
      /**
       * <code>optional .object_detection.protos.CenterNet.TemporalOffsetEstimation temporal_offset_task = 12;</code>
       */
      private com.google.protobuf.SingleFieldBuilderV3<
          object_detection.protos.CenterNetOuterClass.CenterNet.TemporalOffsetEstimation, object_detection.protos.CenterNetOuterClass.CenterNet.TemporalOffsetEstimation.Builder, object_detection.protos.CenterNetOuterClass.CenterNet.TemporalOffsetEstimationOrBuilder>
          getTemporalOffsetTaskFieldBuilder() {
        if (temporalOffsetTaskBuilder_ == null) {
          temporalOffsetTaskBuilder_ = new com.google.protobuf.SingleFieldBuilderV3<
              object_detection.protos.CenterNetOuterClass.CenterNet.TemporalOffsetEstimation, object_detection.protos.CenterNetOuterClass.CenterNet.TemporalOffsetEstimation.Builder, object_detection.protos.CenterNetOuterClass.CenterNet.TemporalOffsetEstimationOrBuilder>(
                  getTemporalOffsetTask(),
                  getParentForChildren(),
                  isClean());
          temporalOffsetTask_ = null;
        }
        return temporalOffsetTaskBuilder_;
      }
      @java.lang.Override
      public final Builder setUnknownFields(
          final com.google.protobuf.UnknownFieldSet unknownFields) {
        return super.setUnknownFields(unknownFields);
      }

      @java.lang.Override
      public final Builder mergeUnknownFields(
          final com.google.protobuf.UnknownFieldSet unknownFields) {
        return super.mergeUnknownFields(unknownFields);
      }


      // @@protoc_insertion_point(builder_scope:object_detection.protos.CenterNet)
    }

    // @@protoc_insertion_point(class_scope:object_detection.protos.CenterNet)
    private static final object_detection.protos.CenterNetOuterClass.CenterNet DEFAULT_INSTANCE;
    static {
      DEFAULT_INSTANCE = new object_detection.protos.CenterNetOuterClass.CenterNet();
    }

    public static object_detection.protos.CenterNetOuterClass.CenterNet getDefaultInstance() {
      return DEFAULT_INSTANCE;
    }

    @java.lang.Deprecated public static final com.google.protobuf.Parser<CenterNet>
        PARSER = new com.google.protobuf.AbstractParser<CenterNet>() {
      @java.lang.Override
      public CenterNet parsePartialFrom(
          com.google.protobuf.CodedInputStream input,
          com.google.protobuf.ExtensionRegistryLite extensionRegistry)
          throws com.google.protobuf.InvalidProtocolBufferException {
        return new CenterNet(input, extensionRegistry);
      }
    };

    public static com.google.protobuf.Parser<CenterNet> parser() {
      return PARSER;
    }

    @java.lang.Override
    public com.google.protobuf.Parser<CenterNet> getParserForType() {
      return PARSER;
    }

    @java.lang.Override
    public object_detection.protos.CenterNetOuterClass.CenterNet getDefaultInstanceForType() {
      return DEFAULT_INSTANCE;
    }

  }

  public interface CenterNetFeatureExtractorOrBuilder extends
      // @@protoc_insertion_point(interface_extends:object_detection.protos.CenterNetFeatureExtractor)
      com.google.protobuf.MessageOrBuilder {

    /**
     * <code>optional string type = 1;</code>
     * @return Whether the type field is set.
     */
    boolean hasType();
    /**
     * <code>optional string type = 1;</code>
     * @return The type.
     */
    java.lang.String getType();
    /**
     * <code>optional string type = 1;</code>
     * @return The bytes for type.
     */
    com.google.protobuf.ByteString
        getTypeBytes();

    /**
     * <pre>
     * Channel means to be subtracted from each image channel. If not specified,
     * we use a default value of 0.
     * </pre>
     *
     * <code>repeated float channel_means = 2;</code>
     * @return A list containing the channelMeans.
     */
    java.util.List<java.lang.Float> getChannelMeansList();
    /**
     * <pre>
     * Channel means to be subtracted from each image channel. If not specified,
     * we use a default value of 0.
     * </pre>
     *
     * <code>repeated float channel_means = 2;</code>
     * @return The count of channelMeans.
     */
    int getChannelMeansCount();
    /**
     * <pre>
     * Channel means to be subtracted from each image channel. If not specified,
     * we use a default value of 0.
     * </pre>
     *
     * <code>repeated float channel_means = 2;</code>
     * @param index The index of the element to return.
     * @return The channelMeans at the given index.
     */
    float getChannelMeans(int index);

    /**
     * <pre>
     * Channel standard deviations. Each channel will be normalized by dividing
     * it by its standard deviation. If not specified, we use a default value
     * of 1.
     * </pre>
     *
     * <code>repeated float channel_stds = 3;</code>
     * @return A list containing the channelStds.
     */
    java.util.List<java.lang.Float> getChannelStdsList();
    /**
     * <pre>
     * Channel standard deviations. Each channel will be normalized by dividing
     * it by its standard deviation. If not specified, we use a default value
     * of 1.
     * </pre>
     *
     * <code>repeated float channel_stds = 3;</code>
     * @return The count of channelStds.
     */
    int getChannelStdsCount();
    /**
     * <pre>
     * Channel standard deviations. Each channel will be normalized by dividing
     * it by its standard deviation. If not specified, we use a default value
     * of 1.
     * </pre>
     *
     * <code>repeated float channel_stds = 3;</code>
     * @param index The index of the element to return.
     * @return The channelStds at the given index.
     */
    float getChannelStds(int index);

    /**
     * <pre>
     * If set, will change channel order to be [blue, green, red]. This can be
     * useful to be compatible with some pre-trained feature extractors.
     * </pre>
     *
     * <code>optional bool bgr_ordering = 4 [default = false];</code>
     * @return Whether the bgrOrdering field is set.
     */
    boolean hasBgrOrdering();
    /**
     * <pre>
     * If set, will change channel order to be [blue, green, red]. This can be
     * useful to be compatible with some pre-trained feature extractors.
     * </pre>
     *
     * <code>optional bool bgr_ordering = 4 [default = false];</code>
     * @return The bgrOrdering.
     */
    boolean getBgrOrdering();

    /**
     * <pre>
     * If set, the feature upsampling layers will be constructed with
     * separable convolutions. This is typically applied to feature pyramid
     * network if any.
     * </pre>
     *
     * <code>optional bool use_depthwise = 5 [default = false];</code>
     * @return Whether the useDepthwise field is set.
     */
    boolean hasUseDepthwise();
    /**
     * <pre>
     * If set, the feature upsampling layers will be constructed with
     * separable convolutions. This is typically applied to feature pyramid
     * network if any.
     * </pre>
     *
     * <code>optional bool use_depthwise = 5 [default = false];</code>
     * @return The useDepthwise.
     */
    boolean getUseDepthwise();
  }
  /**
   * Protobuf type {@code object_detection.protos.CenterNetFeatureExtractor}
   */
  public static final class CenterNetFeatureExtractor extends
      com.google.protobuf.GeneratedMessageV3 implements
      // @@protoc_insertion_point(message_implements:object_detection.protos.CenterNetFeatureExtractor)
      CenterNetFeatureExtractorOrBuilder {
  private static final long serialVersionUID = 0L;
    // Use CenterNetFeatureExtractor.newBuilder() to construct.
    private CenterNetFeatureExtractor(com.google.protobuf.GeneratedMessageV3.Builder<?> builder) {
      super(builder);
    }
    private CenterNetFeatureExtractor() {
      type_ = "";
      channelMeans_ = emptyFloatList();
      channelStds_ = emptyFloatList();
    }

    @java.lang.Override
    @SuppressWarnings({"unused"})
    protected java.lang.Object newInstance(
        UnusedPrivateParameter unused) {
      return new CenterNetFeatureExtractor();
    }

    @java.lang.Override
    public final com.google.protobuf.UnknownFieldSet
    getUnknownFields() {
      return this.unknownFields;
    }
    private CenterNetFeatureExtractor(
        com.google.protobuf.CodedInputStream input,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws com.google.protobuf.InvalidProtocolBufferException {
      this();
      if (extensionRegistry == null) {
        throw new java.lang.NullPointerException();
      }
      int mutable_bitField0_ = 0;
      com.google.protobuf.UnknownFieldSet.Builder unknownFields =
          com.google.protobuf.UnknownFieldSet.newBuilder();
      try {
        boolean done = false;
        while (!done) {
          int tag = input.readTag();
          switch (tag) {
            case 0:
              done = true;
              break;
            case 10: {
              com.google.protobuf.ByteString bs = input.readBytes();
              bitField0_ |= 0x00000001;
              type_ = bs;
              break;
            }
            case 21: {
              if (!((mutable_bitField0_ & 0x00000002) != 0)) {
                channelMeans_ = newFloatList();
                mutable_bitField0_ |= 0x00000002;
              }
              channelMeans_.addFloat(input.readFloat());
              break;
            }
            case 18: {
              int length = input.readRawVarint32();
              int limit = input.pushLimit(length);
              if (!((mutable_bitField0_ & 0x00000002) != 0) && input.getBytesUntilLimit() > 0) {
                channelMeans_ = newFloatList();
                mutable_bitField0_ |= 0x00000002;
              }
              while (input.getBytesUntilLimit() > 0) {
                channelMeans_.addFloat(input.readFloat());
              }
              input.popLimit(limit);
              break;
            }
            case 29: {
              if (!((mutable_bitField0_ & 0x00000004) != 0)) {
                channelStds_ = newFloatList();
                mutable_bitField0_ |= 0x00000004;
              }
              channelStds_.addFloat(input.readFloat());
              break;
            }
            case 26: {
              int length = input.readRawVarint32();
              int limit = input.pushLimit(length);
              if (!((mutable_bitField0_ & 0x00000004) != 0) && input.getBytesUntilLimit() > 0) {
                channelStds_ = newFloatList();
                mutable_bitField0_ |= 0x00000004;
              }
              while (input.getBytesUntilLimit() > 0) {
                channelStds_.addFloat(input.readFloat());
              }
              input.popLimit(limit);
              break;
            }
            case 32: {
              bitField0_ |= 0x00000002;
              bgrOrdering_ = input.readBool();
              break;
            }
            case 40: {
              bitField0_ |= 0x00000004;
              useDepthwise_ = input.readBool();
              break;
            }
            default: {
              if (!parseUnknownField(
                  input, unknownFields, extensionRegistry, tag)) {
                done = true;
              }
              break;
            }
          }
        }
      } catch (com.google.protobuf.InvalidProtocolBufferException e) {
        throw e.setUnfinishedMessage(this);
      } catch (java.io.IOException e) {
        throw new com.google.protobuf.InvalidProtocolBufferException(
            e).setUnfinishedMessage(this);
      } finally {
        if (((mutable_bitField0_ & 0x00000002) != 0)) {
          channelMeans_.makeImmutable(); // C
        }
        if (((mutable_bitField0_ & 0x00000004) != 0)) {
          channelStds_.makeImmutable(); // C
        }
        this.unknownFields = unknownFields.build();
        makeExtensionsImmutable();
      }
    }
    public static final com.google.protobuf.Descriptors.Descriptor
        getDescriptor() {
      return object_detection.protos.CenterNetOuterClass.internal_static_object_detection_protos_CenterNetFeatureExtractor_descriptor;
    }

    @java.lang.Override
    protected com.google.protobuf.GeneratedMessageV3.FieldAccessorTable
        internalGetFieldAccessorTable() {
      return object_detection.protos.CenterNetOuterClass.internal_static_object_detection_protos_CenterNetFeatureExtractor_fieldAccessorTable
          .ensureFieldAccessorsInitialized(
              object_detection.protos.CenterNetOuterClass.CenterNetFeatureExtractor.class, object_detection.protos.CenterNetOuterClass.CenterNetFeatureExtractor.Builder.class);
    }

    private int bitField0_;
    public static final int TYPE_FIELD_NUMBER = 1;
    private volatile java.lang.Object type_;
    /**
     * <code>optional string type = 1;</code>
     * @return Whether the type field is set.
     */
    @java.lang.Override
    public boolean hasType() {
      return ((bitField0_ & 0x00000001) != 0);
    }
    /**
     * <code>optional string type = 1;</code>
     * @return The type.
     */
    @java.lang.Override
    public java.lang.String getType() {
      java.lang.Object ref = type_;
      if (ref instanceof java.lang.String) {
        return (java.lang.String) ref;
      } else {
        com.google.protobuf.ByteString bs =
            (com.google.protobuf.ByteString) ref;
        java.lang.String s = bs.toStringUtf8();
        if (bs.isValidUtf8()) {
          type_ = s;
        }
        return s;
      }
    }
    /**
     * <code>optional string type = 1;</code>
     * @return The bytes for type.
     */
    @java.lang.Override
    public com.google.protobuf.ByteString
        getTypeBytes() {
      java.lang.Object ref = type_;
      if (ref instanceof java.lang.String) {
        com.google.protobuf.ByteString b =
            com.google.protobuf.ByteString.copyFromUtf8(
                (java.lang.String) ref);
        type_ = b;
        return b;
      } else {
        return (com.google.protobuf.ByteString) ref;
      }
    }

    public static final int CHANNEL_MEANS_FIELD_NUMBER = 2;
    private com.google.protobuf.Internal.FloatList channelMeans_;
    /**
     * <pre>
     * Channel means to be subtracted from each image channel. If not specified,
     * we use a default value of 0.
     * </pre>
     *
     * <code>repeated float channel_means = 2;</code>
     * @return A list containing the channelMeans.
     */
    @java.lang.Override
    public java.util.List<java.lang.Float>
        getChannelMeansList() {
      return channelMeans_;
    }
    /**
     * <pre>
     * Channel means to be subtracted from each image channel. If not specified,
     * we use a default value of 0.
     * </pre>
     *
     * <code>repeated float channel_means = 2;</code>
     * @return The count of channelMeans.
     */
    public int getChannelMeansCount() {
      return channelMeans_.size();
    }
    /**
     * <pre>
     * Channel means to be subtracted from each image channel. If not specified,
     * we use a default value of 0.
     * </pre>
     *
     * <code>repeated float channel_means = 2;</code>
     * @param index The index of the element to return.
     * @return The channelMeans at the given index.
     */
    public float getChannelMeans(int index) {
      return channelMeans_.getFloat(index);
    }

    public static final int CHANNEL_STDS_FIELD_NUMBER = 3;
    private com.google.protobuf.Internal.FloatList channelStds_;
    /**
     * <pre>
     * Channel standard deviations. Each channel will be normalized by dividing
     * it by its standard deviation. If not specified, we use a default value
     * of 1.
     * </pre>
     *
     * <code>repeated float channel_stds = 3;</code>
     * @return A list containing the channelStds.
     */
    @java.lang.Override
    public java.util.List<java.lang.Float>
        getChannelStdsList() {
      return channelStds_;
    }
    /**
     * <pre>
     * Channel standard deviations. Each channel will be normalized by dividing
     * it by its standard deviation. If not specified, we use a default value
     * of 1.
     * </pre>
     *
     * <code>repeated float channel_stds = 3;</code>
     * @return The count of channelStds.
     */
    public int getChannelStdsCount() {
      return channelStds_.size();
    }
    /**
     * <pre>
     * Channel standard deviations. Each channel will be normalized by dividing
     * it by its standard deviation. If not specified, we use a default value
     * of 1.
     * </pre>
     *
     * <code>repeated float channel_stds = 3;</code>
     * @param index The index of the element to return.
     * @return The channelStds at the given index.
     */
    public float getChannelStds(int index) {
      return channelStds_.getFloat(index);
    }

    public static final int BGR_ORDERING_FIELD_NUMBER = 4;
    private boolean bgrOrdering_;
    /**
     * <pre>
     * If set, will change channel order to be [blue, green, red]. This can be
     * useful to be compatible with some pre-trained feature extractors.
     * </pre>
     *
     * <code>optional bool bgr_ordering = 4 [default = false];</code>
     * @return Whether the bgrOrdering field is set.
     */
    @java.lang.Override
    public boolean hasBgrOrdering() {
      return ((bitField0_ & 0x00000002) != 0);
    }
    /**
     * <pre>
     * If set, will change channel order to be [blue, green, red]. This can be
     * useful to be compatible with some pre-trained feature extractors.
     * </pre>
     *
     * <code>optional bool bgr_ordering = 4 [default = false];</code>
     * @return The bgrOrdering.
     */
    @java.lang.Override
    public boolean getBgrOrdering() {
      return bgrOrdering_;
    }

    public static final int USE_DEPTHWISE_FIELD_NUMBER = 5;
    private boolean useDepthwise_;
    /**
     * <pre>
     * If set, the feature upsampling layers will be constructed with
     * separable convolutions. This is typically applied to feature pyramid
     * network if any.
     * </pre>
     *
     * <code>optional bool use_depthwise = 5 [default = false];</code>
     * @return Whether the useDepthwise field is set.
     */
    @java.lang.Override
    public boolean hasUseDepthwise() {
      return ((bitField0_ & 0x00000004) != 0);
    }
    /**
     * <pre>
     * If set, the feature upsampling layers will be constructed with
     * separable convolutions. This is typically applied to feature pyramid
     * network if any.
     * </pre>
     *
     * <code>optional bool use_depthwise = 5 [default = false];</code>
     * @return The useDepthwise.
     */
    @java.lang.Override
    public boolean getUseDepthwise() {
      return useDepthwise_;
    }

    private byte memoizedIsInitialized = -1;
    @java.lang.Override
    public final boolean isInitialized() {
      byte isInitialized = memoizedIsInitialized;
      if (isInitialized == 1) return true;
      if (isInitialized == 0) return false;

      memoizedIsInitialized = 1;
      return true;
    }

    @java.lang.Override
    public void writeTo(com.google.protobuf.CodedOutputStream output)
                        throws java.io.IOException {
      if (((bitField0_ & 0x00000001) != 0)) {
        com.google.protobuf.GeneratedMessageV3.writeString(output, 1, type_);
      }
      for (int i = 0; i < channelMeans_.size(); i++) {
        output.writeFloat(2, channelMeans_.getFloat(i));
      }
      for (int i = 0; i < channelStds_.size(); i++) {
        output.writeFloat(3, channelStds_.getFloat(i));
      }
      if (((bitField0_ & 0x00000002) != 0)) {
        output.writeBool(4, bgrOrdering_);
      }
      if (((bitField0_ & 0x00000004) != 0)) {
        output.writeBool(5, useDepthwise_);
      }
      unknownFields.writeTo(output);
    }

    @java.lang.Override
    public int getSerializedSize() {
      int size = memoizedSize;
      if (size != -1) return size;

      size = 0;
      if (((bitField0_ & 0x00000001) != 0)) {
        size += com.google.protobuf.GeneratedMessageV3.computeStringSize(1, type_);
      }
      {
        int dataSize = 0;
        dataSize = 4 * getChannelMeansList().size();
        size += dataSize;
        size += 1 * getChannelMeansList().size();
      }
      {
        int dataSize = 0;
        dataSize = 4 * getChannelStdsList().size();
        size += dataSize;
        size += 1 * getChannelStdsList().size();
      }
      if (((bitField0_ & 0x00000002) != 0)) {
        size += com.google.protobuf.CodedOutputStream
          .computeBoolSize(4, bgrOrdering_);
      }
      if (((bitField0_ & 0x00000004) != 0)) {
        size += com.google.protobuf.CodedOutputStream
          .computeBoolSize(5, useDepthwise_);
      }
      size += unknownFields.getSerializedSize();
      memoizedSize = size;
      return size;
    }

    @java.lang.Override
    public boolean equals(final java.lang.Object obj) {
      if (obj == this) {
       return true;
      }
      if (!(obj instanceof object_detection.protos.CenterNetOuterClass.CenterNetFeatureExtractor)) {
        return super.equals(obj);
      }
      object_detection.protos.CenterNetOuterClass.CenterNetFeatureExtractor other = (object_detection.protos.CenterNetOuterClass.CenterNetFeatureExtractor) obj;

      if (hasType() != other.hasType()) return false;
      if (hasType()) {
        if (!getType()
            .equals(other.getType())) return false;
      }
      if (!getChannelMeansList()
          .equals(other.getChannelMeansList())) return false;
      if (!getChannelStdsList()
          .equals(other.getChannelStdsList())) return false;
      if (hasBgrOrdering() != other.hasBgrOrdering()) return false;
      if (hasBgrOrdering()) {
        if (getBgrOrdering()
            != other.getBgrOrdering()) return false;
      }
      if (hasUseDepthwise() != other.hasUseDepthwise()) return false;
      if (hasUseDepthwise()) {
        if (getUseDepthwise()
            != other.getUseDepthwise()) return false;
      }
      if (!unknownFields.equals(other.unknownFields)) return false;
      return true;
    }

    @java.lang.Override
    public int hashCode() {
      if (memoizedHashCode != 0) {
        return memoizedHashCode;
      }
      int hash = 41;
      hash = (19 * hash) + getDescriptor().hashCode();
      if (hasType()) {
        hash = (37 * hash) + TYPE_FIELD_NUMBER;
        hash = (53 * hash) + getType().hashCode();
      }
      if (getChannelMeansCount() > 0) {
        hash = (37 * hash) + CHANNEL_MEANS_FIELD_NUMBER;
        hash = (53 * hash) + getChannelMeansList().hashCode();
      }
      if (getChannelStdsCount() > 0) {
        hash = (37 * hash) + CHANNEL_STDS_FIELD_NUMBER;
        hash = (53 * hash) + getChannelStdsList().hashCode();
      }
      if (hasBgrOrdering()) {
        hash = (37 * hash) + BGR_ORDERING_FIELD_NUMBER;
        hash = (53 * hash) + com.google.protobuf.Internal.hashBoolean(
            getBgrOrdering());
      }
      if (hasUseDepthwise()) {
        hash = (37 * hash) + USE_DEPTHWISE_FIELD_NUMBER;
        hash = (53 * hash) + com.google.protobuf.Internal.hashBoolean(
            getUseDepthwise());
      }
      hash = (29 * hash) + unknownFields.hashCode();
      memoizedHashCode = hash;
      return hash;
    }

    public static object_detection.protos.CenterNetOuterClass.CenterNetFeatureExtractor parseFrom(
        java.nio.ByteBuffer data)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return PARSER.parseFrom(data);
    }
    public static object_detection.protos.CenterNetOuterClass.CenterNetFeatureExtractor parseFrom(
        java.nio.ByteBuffer data,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return PARSER.parseFrom(data, extensionRegistry);
    }
    public static object_detection.protos.CenterNetOuterClass.CenterNetFeatureExtractor parseFrom(
        com.google.protobuf.ByteString data)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return PARSER.parseFrom(data);
    }
    public static object_detection.protos.CenterNetOuterClass.CenterNetFeatureExtractor parseFrom(
        com.google.protobuf.ByteString data,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return PARSER.parseFrom(data, extensionRegistry);
    }
    public static object_detection.protos.CenterNetOuterClass.CenterNetFeatureExtractor parseFrom(byte[] data)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return PARSER.parseFrom(data);
    }
    public static object_detection.protos.CenterNetOuterClass.CenterNetFeatureExtractor parseFrom(
        byte[] data,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return PARSER.parseFrom(data, extensionRegistry);
    }
    public static object_detection.protos.CenterNetOuterClass.CenterNetFeatureExtractor parseFrom(java.io.InputStream input)
        throws java.io.IOException {
      return com.google.protobuf.GeneratedMessageV3
          .parseWithIOException(PARSER, input);
    }
    public static object_detection.protos.CenterNetOuterClass.CenterNetFeatureExtractor parseFrom(
        java.io.InputStream input,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws java.io.IOException {
      return com.google.protobuf.GeneratedMessageV3
          .parseWithIOException(PARSER, input, extensionRegistry);
    }
    public static object_detection.protos.CenterNetOuterClass.CenterNetFeatureExtractor parseDelimitedFrom(java.io.InputStream input)
        throws java.io.IOException {
      return com.google.protobuf.GeneratedMessageV3
          .parseDelimitedWithIOException(PARSER, input);
    }
    public static object_detection.protos.CenterNetOuterClass.CenterNetFeatureExtractor parseDelimitedFrom(
        java.io.InputStream input,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws java.io.IOException {
      return com.google.protobuf.GeneratedMessageV3
          .parseDelimitedWithIOException(PARSER, input, extensionRegistry);
    }
    public static object_detection.protos.CenterNetOuterClass.CenterNetFeatureExtractor parseFrom(
        com.google.protobuf.CodedInputStream input)
        throws java.io.IOException {
      return com.google.protobuf.GeneratedMessageV3
          .parseWithIOException(PARSER, input);
    }
    public static object_detection.protos.CenterNetOuterClass.CenterNetFeatureExtractor parseFrom(
        com.google.protobuf.CodedInputStream input,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws java.io.IOException {
      return com.google.protobuf.GeneratedMessageV3
          .parseWithIOException(PARSER, input, extensionRegistry);
    }

    @java.lang.Override
    public Builder newBuilderForType() { return newBuilder(); }
    public static Builder newBuilder() {
      return DEFAULT_INSTANCE.toBuilder();
    }
    public static Builder newBuilder(object_detection.protos.CenterNetOuterClass.CenterNetFeatureExtractor prototype) {
      return DEFAULT_INSTANCE.toBuilder().mergeFrom(prototype);
    }
    @java.lang.Override
    public Builder toBuilder() {
      return this == DEFAULT_INSTANCE
          ? new Builder() : new Builder().mergeFrom(this);
    }

    @java.lang.Override
    protected Builder newBuilderForType(
        com.google.protobuf.GeneratedMessageV3.BuilderParent parent) {
      Builder builder = new Builder(parent);
      return builder;
    }
    /**
     * Protobuf type {@code object_detection.protos.CenterNetFeatureExtractor}
     */
    public static final class Builder extends
        com.google.protobuf.GeneratedMessageV3.Builder<Builder> implements
        // @@protoc_insertion_point(builder_implements:object_detection.protos.CenterNetFeatureExtractor)
        object_detection.protos.CenterNetOuterClass.CenterNetFeatureExtractorOrBuilder {
      public static final com.google.protobuf.Descriptors.Descriptor
          getDescriptor() {
        return object_detection.protos.CenterNetOuterClass.internal_static_object_detection_protos_CenterNetFeatureExtractor_descriptor;
      }

      @java.lang.Override
      protected com.google.protobuf.GeneratedMessageV3.FieldAccessorTable
          internalGetFieldAccessorTable() {
        return object_detection.protos.CenterNetOuterClass.internal_static_object_detection_protos_CenterNetFeatureExtractor_fieldAccessorTable
            .ensureFieldAccessorsInitialized(
                object_detection.protos.CenterNetOuterClass.CenterNetFeatureExtractor.class, object_detection.protos.CenterNetOuterClass.CenterNetFeatureExtractor.Builder.class);
      }

      // Construct using object_detection.protos.CenterNetOuterClass.CenterNetFeatureExtractor.newBuilder()
      private Builder() {
        maybeForceBuilderInitialization();
      }

      private Builder(
          com.google.protobuf.GeneratedMessageV3.BuilderParent parent) {
        super(parent);
        maybeForceBuilderInitialization();
      }
      private void maybeForceBuilderInitialization() {
        if (com.google.protobuf.GeneratedMessageV3
                .alwaysUseFieldBuilders) {
        }
      }
      @java.lang.Override
      public Builder clear() {
        super.clear();
        type_ = "";
        bitField0_ = (bitField0_ & ~0x00000001);
        channelMeans_ = emptyFloatList();
        bitField0_ = (bitField0_ & ~0x00000002);
        channelStds_ = emptyFloatList();
        bitField0_ = (bitField0_ & ~0x00000004);
        bgrOrdering_ = false;
        bitField0_ = (bitField0_ & ~0x00000008);
        useDepthwise_ = false;
        bitField0_ = (bitField0_ & ~0x00000010);
        return this;
      }

      @java.lang.Override
      public com.google.protobuf.Descriptors.Descriptor
          getDescriptorForType() {
        return object_detection.protos.CenterNetOuterClass.internal_static_object_detection_protos_CenterNetFeatureExtractor_descriptor;
      }

      @java.lang.Override
      public object_detection.protos.CenterNetOuterClass.CenterNetFeatureExtractor getDefaultInstanceForType() {
        return object_detection.protos.CenterNetOuterClass.CenterNetFeatureExtractor.getDefaultInstance();
      }

      @java.lang.Override
      public object_detection.protos.CenterNetOuterClass.CenterNetFeatureExtractor build() {
        object_detection.protos.CenterNetOuterClass.CenterNetFeatureExtractor result = buildPartial();
        if (!result.isInitialized()) {
          throw newUninitializedMessageException(result);
        }
        return result;
      }

      @java.lang.Override
      public object_detection.protos.CenterNetOuterClass.CenterNetFeatureExtractor buildPartial() {
        object_detection.protos.CenterNetOuterClass.CenterNetFeatureExtractor result = new object_detection.protos.CenterNetOuterClass.CenterNetFeatureExtractor(this);
        int from_bitField0_ = bitField0_;
        int to_bitField0_ = 0;
        if (((from_bitField0_ & 0x00000001) != 0)) {
          to_bitField0_ |= 0x00000001;
        }
        result.type_ = type_;
        if (((bitField0_ & 0x00000002) != 0)) {
          channelMeans_.makeImmutable();
          bitField0_ = (bitField0_ & ~0x00000002);
        }
        result.channelMeans_ = channelMeans_;
        if (((bitField0_ & 0x00000004) != 0)) {
          channelStds_.makeImmutable();
          bitField0_ = (bitField0_ & ~0x00000004);
        }
        result.channelStds_ = channelStds_;
        if (((from_bitField0_ & 0x00000008) != 0)) {
          result.bgrOrdering_ = bgrOrdering_;
          to_bitField0_ |= 0x00000002;
        }
        if (((from_bitField0_ & 0x00000010) != 0)) {
          result.useDepthwise_ = useDepthwise_;
          to_bitField0_ |= 0x00000004;
        }
        result.bitField0_ = to_bitField0_;
        onBuilt();
        return result;
      }

      @java.lang.Override
      public Builder clone() {
        return super.clone();
      }
      @java.lang.Override
      public Builder setField(
          com.google.protobuf.Descriptors.FieldDescriptor field,
          java.lang.Object value) {
        return super.setField(field, value);
      }
      @java.lang.Override
      public Builder clearField(
          com.google.protobuf.Descriptors.FieldDescriptor field) {
        return super.clearField(field);
      }
      @java.lang.Override
      public Builder clearOneof(
          com.google.protobuf.Descriptors.OneofDescriptor oneof) {
        return super.clearOneof(oneof);
      }
      @java.lang.Override
      public Builder setRepeatedField(
          com.google.protobuf.Descriptors.FieldDescriptor field,
          int index, java.lang.Object value) {
        return super.setRepeatedField(field, index, value);
      }
      @java.lang.Override
      public Builder addRepeatedField(
          com.google.protobuf.Descriptors.FieldDescriptor field,
          java.lang.Object value) {
        return super.addRepeatedField(field, value);
      }
      @java.lang.Override
      public Builder mergeFrom(com.google.protobuf.Message other) {
        if (other instanceof object_detection.protos.CenterNetOuterClass.CenterNetFeatureExtractor) {
          return mergeFrom((object_detection.protos.CenterNetOuterClass.CenterNetFeatureExtractor)other);
        } else {
          super.mergeFrom(other);
          return this;
        }
      }

      public Builder mergeFrom(object_detection.protos.CenterNetOuterClass.CenterNetFeatureExtractor other) {
        if (other == object_detection.protos.CenterNetOuterClass.CenterNetFeatureExtractor.getDefaultInstance()) return this;
        if (other.hasType()) {
          bitField0_ |= 0x00000001;
          type_ = other.type_;
          onChanged();
        }
        if (!other.channelMeans_.isEmpty()) {
          if (channelMeans_.isEmpty()) {
            channelMeans_ = other.channelMeans_;
            bitField0_ = (bitField0_ & ~0x00000002);
          } else {
            ensureChannelMeansIsMutable();
            channelMeans_.addAll(other.channelMeans_);
          }
          onChanged();
        }
        if (!other.channelStds_.isEmpty()) {
          if (channelStds_.isEmpty()) {
            channelStds_ = other.channelStds_;
            bitField0_ = (bitField0_ & ~0x00000004);
          } else {
            ensureChannelStdsIsMutable();
            channelStds_.addAll(other.channelStds_);
          }
          onChanged();
        }
        if (other.hasBgrOrdering()) {
          setBgrOrdering(other.getBgrOrdering());
        }
        if (other.hasUseDepthwise()) {
          setUseDepthwise(other.getUseDepthwise());
        }
        this.mergeUnknownFields(other.unknownFields);
        onChanged();
        return this;
      }

      @java.lang.Override
      public final boolean isInitialized() {
        return true;
      }

      @java.lang.Override
      public Builder mergeFrom(
          com.google.protobuf.CodedInputStream input,
          com.google.protobuf.ExtensionRegistryLite extensionRegistry)
          throws java.io.IOException {
        object_detection.protos.CenterNetOuterClass.CenterNetFeatureExtractor parsedMessage = null;
        try {
          parsedMessage = PARSER.parsePartialFrom(input, extensionRegistry);
        } catch (com.google.protobuf.InvalidProtocolBufferException e) {
          parsedMessage = (object_detection.protos.CenterNetOuterClass.CenterNetFeatureExtractor) e.getUnfinishedMessage();
          throw e.unwrapIOException();
        } finally {
          if (parsedMessage != null) {
            mergeFrom(parsedMessage);
          }
        }
        return this;
      }
      private int bitField0_;

      private java.lang.Object type_ = "";
      /**
       * <code>optional string type = 1;</code>
       * @return Whether the type field is set.
       */
      public boolean hasType() {
        return ((bitField0_ & 0x00000001) != 0);
      }
      /**
       * <code>optional string type = 1;</code>
       * @return The type.
       */
      public java.lang.String getType() {
        java.lang.Object ref = type_;
        if (!(ref instanceof java.lang.String)) {
          com.google.protobuf.ByteString bs =
              (com.google.protobuf.ByteString) ref;
          java.lang.String s = bs.toStringUtf8();
          if (bs.isValidUtf8()) {
            type_ = s;
          }
          return s;
        } else {
          return (java.lang.String) ref;
        }
      }
      /**
       * <code>optional string type = 1;</code>
       * @return The bytes for type.
       */
      public com.google.protobuf.ByteString
          getTypeBytes() {
        java.lang.Object ref = type_;
        if (ref instanceof String) {
          com.google.protobuf.ByteString b =
              com.google.protobuf.ByteString.copyFromUtf8(
                  (java.lang.String) ref);
          type_ = b;
          return b;
        } else {
          return (com.google.protobuf.ByteString) ref;
        }
      }
      /**
       * <code>optional string type = 1;</code>
       * @param value The type to set.
       * @return This builder for chaining.
       */
      public Builder setType(
          java.lang.String value) {
        if (value == null) {
    throw new NullPointerException();
  }
  bitField0_ |= 0x00000001;
        type_ = value;
        onChanged();
        return this;
      }
      /**
       * <code>optional string type = 1;</code>
       * @return This builder for chaining.
       */
      public Builder clearType() {
        bitField0_ = (bitField0_ & ~0x00000001);
        type_ = getDefaultInstance().getType();
        onChanged();
        return this;
      }
      /**
       * <code>optional string type = 1;</code>
       * @param value The bytes for type to set.
       * @return This builder for chaining.
       */
      public Builder setTypeBytes(
          com.google.protobuf.ByteString value) {
        if (value == null) {
    throw new NullPointerException();
  }
  bitField0_ |= 0x00000001;
        type_ = value;
        onChanged();
        return this;
      }

      private com.google.protobuf.Internal.FloatList channelMeans_ = emptyFloatList();
      private void ensureChannelMeansIsMutable() {
        if (!((bitField0_ & 0x00000002) != 0)) {
          channelMeans_ = mutableCopy(channelMeans_);
          bitField0_ |= 0x00000002;
         }
      }
      /**
       * <pre>
       * Channel means to be subtracted from each image channel. If not specified,
       * we use a default value of 0.
       * </pre>
       *
       * <code>repeated float channel_means = 2;</code>
       * @return A list containing the channelMeans.
       */
      public java.util.List<java.lang.Float>
          getChannelMeansList() {
        return ((bitField0_ & 0x00000002) != 0) ?
                 java.util.Collections.unmodifiableList(channelMeans_) : channelMeans_;
      }
      /**
       * <pre>
       * Channel means to be subtracted from each image channel. If not specified,
       * we use a default value of 0.
       * </pre>
       *
       * <code>repeated float channel_means = 2;</code>
       * @return The count of channelMeans.
       */
      public int getChannelMeansCount() {
        return channelMeans_.size();
      }
      /**
       * <pre>
       * Channel means to be subtracted from each image channel. If not specified,
       * we use a default value of 0.
       * </pre>
       *
       * <code>repeated float channel_means = 2;</code>
       * @param index The index of the element to return.
       * @return The channelMeans at the given index.
       */
      public float getChannelMeans(int index) {
        return channelMeans_.getFloat(index);
      }
      /**
       * <pre>
       * Channel means to be subtracted from each image channel. If not specified,
       * we use a default value of 0.
       * </pre>
       *
       * <code>repeated float channel_means = 2;</code>
       * @param index The index to set the value at.
       * @param value The channelMeans to set.
       * @return This builder for chaining.
       */
      public Builder setChannelMeans(
          int index, float value) {
        ensureChannelMeansIsMutable();
        channelMeans_.setFloat(index, value);
        onChanged();
        return this;
      }
      /**
       * <pre>
       * Channel means to be subtracted from each image channel. If not specified,
       * we use a default value of 0.
       * </pre>
       *
       * <code>repeated float channel_means = 2;</code>
       * @param value The channelMeans to add.
       * @return This builder for chaining.
       */
      public Builder addChannelMeans(float value) {
        ensureChannelMeansIsMutable();
        channelMeans_.addFloat(value);
        onChanged();
        return this;
      }
      /**
       * <pre>
       * Channel means to be subtracted from each image channel. If not specified,
       * we use a default value of 0.
       * </pre>
       *
       * <code>repeated float channel_means = 2;</code>
       * @param values The channelMeans to add.
       * @return This builder for chaining.
       */
      public Builder addAllChannelMeans(
          java.lang.Iterable<? extends java.lang.Float> values) {
        ensureChannelMeansIsMutable();
        com.google.protobuf.AbstractMessageLite.Builder.addAll(
            values, channelMeans_);
        onChanged();
        return this;
      }
      /**
       * <pre>
       * Channel means to be subtracted from each image channel. If not specified,
       * we use a default value of 0.
       * </pre>
       *
       * <code>repeated float channel_means = 2;</code>
       * @return This builder for chaining.
       */
      public Builder clearChannelMeans() {
        channelMeans_ = emptyFloatList();
        bitField0_ = (bitField0_ & ~0x00000002);
        onChanged();
        return this;
      }

      private com.google.protobuf.Internal.FloatList channelStds_ = emptyFloatList();
      private void ensureChannelStdsIsMutable() {
        if (!((bitField0_ & 0x00000004) != 0)) {
          channelStds_ = mutableCopy(channelStds_);
          bitField0_ |= 0x00000004;
         }
      }
      /**
       * <pre>
       * Channel standard deviations. Each channel will be normalized by dividing
       * it by its standard deviation. If not specified, we use a default value
       * of 1.
       * </pre>
       *
       * <code>repeated float channel_stds = 3;</code>
       * @return A list containing the channelStds.
       */
      public java.util.List<java.lang.Float>
          getChannelStdsList() {
        return ((bitField0_ & 0x00000004) != 0) ?
                 java.util.Collections.unmodifiableList(channelStds_) : channelStds_;
      }
      /**
       * <pre>
       * Channel standard deviations. Each channel will be normalized by dividing
       * it by its standard deviation. If not specified, we use a default value
       * of 1.
       * </pre>
       *
       * <code>repeated float channel_stds = 3;</code>
       * @return The count of channelStds.
       */
      public int getChannelStdsCount() {
        return channelStds_.size();
      }
      /**
       * <pre>
       * Channel standard deviations. Each channel will be normalized by dividing
       * it by its standard deviation. If not specified, we use a default value
       * of 1.
       * </pre>
       *
       * <code>repeated float channel_stds = 3;</code>
       * @param index The index of the element to return.
       * @return The channelStds at the given index.
       */
      public float getChannelStds(int index) {
        return channelStds_.getFloat(index);
      }
      /**
       * <pre>
       * Channel standard deviations. Each channel will be normalized by dividing
       * it by its standard deviation. If not specified, we use a default value
       * of 1.
       * </pre>
       *
       * <code>repeated float channel_stds = 3;</code>
       * @param index The index to set the value at.
       * @param value The channelStds to set.
       * @return This builder for chaining.
       */
      public Builder setChannelStds(
          int index, float value) {
        ensureChannelStdsIsMutable();
        channelStds_.setFloat(index, value);
        onChanged();
        return this;
      }
      /**
       * <pre>
       * Channel standard deviations. Each channel will be normalized by dividing
       * it by its standard deviation. If not specified, we use a default value
       * of 1.
       * </pre>
       *
       * <code>repeated float channel_stds = 3;</code>
       * @param value The channelStds to add.
       * @return This builder for chaining.
       */
      public Builder addChannelStds(float value) {
        ensureChannelStdsIsMutable();
        channelStds_.addFloat(value);
        onChanged();
        return this;
      }
      /**
       * <pre>
       * Channel standard deviations. Each channel will be normalized by dividing
       * it by its standard deviation. If not specified, we use a default value
       * of 1.
       * </pre>
       *
       * <code>repeated float channel_stds = 3;</code>
       * @param values The channelStds to add.
       * @return This builder for chaining.
       */
      public Builder addAllChannelStds(
          java.lang.Iterable<? extends java.lang.Float> values) {
        ensureChannelStdsIsMutable();
        com.google.protobuf.AbstractMessageLite.Builder.addAll(
            values, channelStds_);
        onChanged();
        return this;
      }
      /**
       * <pre>
       * Channel standard deviations. Each channel will be normalized by dividing
       * it by its standard deviation. If not specified, we use a default value
       * of 1.
       * </pre>
       *
       * <code>repeated float channel_stds = 3;</code>
       * @return This builder for chaining.
       */
      public Builder clearChannelStds() {
        channelStds_ = emptyFloatList();
        bitField0_ = (bitField0_ & ~0x00000004);
        onChanged();
        return this;
      }

      private boolean bgrOrdering_ ;
      /**
       * <pre>
       * If set, will change channel order to be [blue, green, red]. This can be
       * useful to be compatible with some pre-trained feature extractors.
       * </pre>
       *
       * <code>optional bool bgr_ordering = 4 [default = false];</code>
       * @return Whether the bgrOrdering field is set.
       */
      @java.lang.Override
      public boolean hasBgrOrdering() {
        return ((bitField0_ & 0x00000008) != 0);
      }
      /**
       * <pre>
       * If set, will change channel order to be [blue, green, red]. This can be
       * useful to be compatible with some pre-trained feature extractors.
       * </pre>
       *
       * <code>optional bool bgr_ordering = 4 [default = false];</code>
       * @return The bgrOrdering.
       */
      @java.lang.Override
      public boolean getBgrOrdering() {
        return bgrOrdering_;
      }
      /**
       * <pre>
       * If set, will change channel order to be [blue, green, red]. This can be
       * useful to be compatible with some pre-trained feature extractors.
       * </pre>
       *
       * <code>optional bool bgr_ordering = 4 [default = false];</code>
       * @param value The bgrOrdering to set.
       * @return This builder for chaining.
       */
      public Builder setBgrOrdering(boolean value) {
        bitField0_ |= 0x00000008;
        bgrOrdering_ = value;
        onChanged();
        return this;
      }
      /**
       * <pre>
       * If set, will change channel order to be [blue, green, red]. This can be
       * useful to be compatible with some pre-trained feature extractors.
       * </pre>
       *
       * <code>optional bool bgr_ordering = 4 [default = false];</code>
       * @return This builder for chaining.
       */
      public Builder clearBgrOrdering() {
        bitField0_ = (bitField0_ & ~0x00000008);
        bgrOrdering_ = false;
        onChanged();
        return this;
      }

      private boolean useDepthwise_ ;
      /**
       * <pre>
       * If set, the feature upsampling layers will be constructed with
       * separable convolutions. This is typically applied to feature pyramid
       * network if any.
       * </pre>
       *
       * <code>optional bool use_depthwise = 5 [default = false];</code>
       * @return Whether the useDepthwise field is set.
       */
      @java.lang.Override
      public boolean hasUseDepthwise() {
        return ((bitField0_ & 0x00000010) != 0);
      }
      /**
       * <pre>
       * If set, the feature upsampling layers will be constructed with
       * separable convolutions. This is typically applied to feature pyramid
       * network if any.
       * </pre>
       *
       * <code>optional bool use_depthwise = 5 [default = false];</code>
       * @return The useDepthwise.
       */
      @java.lang.Override
      public boolean getUseDepthwise() {
        return useDepthwise_;
      }
      /**
       * <pre>
       * If set, the feature upsampling layers will be constructed with
       * separable convolutions. This is typically applied to feature pyramid
       * network if any.
       * </pre>
       *
       * <code>optional bool use_depthwise = 5 [default = false];</code>
       * @param value The useDepthwise to set.
       * @return This builder for chaining.
       */
      public Builder setUseDepthwise(boolean value) {
        bitField0_ |= 0x00000010;
        useDepthwise_ = value;
        onChanged();
        return this;
      }
      /**
       * <pre>
       * If set, the feature upsampling layers will be constructed with
       * separable convolutions. This is typically applied to feature pyramid
       * network if any.
       * </pre>
       *
       * <code>optional bool use_depthwise = 5 [default = false];</code>
       * @return This builder for chaining.
       */
      public Builder clearUseDepthwise() {
        bitField0_ = (bitField0_ & ~0x00000010);
        useDepthwise_ = false;
        onChanged();
        return this;
      }
      @java.lang.Override
      public final Builder setUnknownFields(
          final com.google.protobuf.UnknownFieldSet unknownFields) {
        return super.setUnknownFields(unknownFields);
      }

      @java.lang.Override
      public final Builder mergeUnknownFields(
          final com.google.protobuf.UnknownFieldSet unknownFields) {
        return super.mergeUnknownFields(unknownFields);
      }


      // @@protoc_insertion_point(builder_scope:object_detection.protos.CenterNetFeatureExtractor)
    }

    // @@protoc_insertion_point(class_scope:object_detection.protos.CenterNetFeatureExtractor)
    private static final object_detection.protos.CenterNetOuterClass.CenterNetFeatureExtractor DEFAULT_INSTANCE;
    static {
      DEFAULT_INSTANCE = new object_detection.protos.CenterNetOuterClass.CenterNetFeatureExtractor();
    }

    public static object_detection.protos.CenterNetOuterClass.CenterNetFeatureExtractor getDefaultInstance() {
      return DEFAULT_INSTANCE;
    }

    @java.lang.Deprecated public static final com.google.protobuf.Parser<CenterNetFeatureExtractor>
        PARSER = new com.google.protobuf.AbstractParser<CenterNetFeatureExtractor>() {
      @java.lang.Override
      public CenterNetFeatureExtractor parsePartialFrom(
          com.google.protobuf.CodedInputStream input,
          com.google.protobuf.ExtensionRegistryLite extensionRegistry)
          throws com.google.protobuf.InvalidProtocolBufferException {
        return new CenterNetFeatureExtractor(input, extensionRegistry);
      }
    };

    public static com.google.protobuf.Parser<CenterNetFeatureExtractor> parser() {
      return PARSER;
    }

    @java.lang.Override
    public com.google.protobuf.Parser<CenterNetFeatureExtractor> getParserForType() {
      return PARSER;
    }

    @java.lang.Override
    public object_detection.protos.CenterNetOuterClass.CenterNetFeatureExtractor getDefaultInstanceForType() {
      return DEFAULT_INSTANCE;
    }

  }

  private static final com.google.protobuf.Descriptors.Descriptor
    internal_static_object_detection_protos_CenterNet_descriptor;
  private static final
    com.google.protobuf.GeneratedMessageV3.FieldAccessorTable
      internal_static_object_detection_protos_CenterNet_fieldAccessorTable;
  private static final com.google.protobuf.Descriptors.Descriptor
    internal_static_object_detection_protos_CenterNet_ObjectDetection_descriptor;
  private static final
    com.google.protobuf.GeneratedMessageV3.FieldAccessorTable
      internal_static_object_detection_protos_CenterNet_ObjectDetection_fieldAccessorTable;
  private static final com.google.protobuf.Descriptors.Descriptor
    internal_static_object_detection_protos_CenterNet_ObjectCenterParams_descriptor;
  private static final
    com.google.protobuf.GeneratedMessageV3.FieldAccessorTable
      internal_static_object_detection_protos_CenterNet_ObjectCenterParams_fieldAccessorTable;
  private static final com.google.protobuf.Descriptors.Descriptor
    internal_static_object_detection_protos_CenterNet_KeypointEstimation_descriptor;
  private static final
    com.google.protobuf.GeneratedMessageV3.FieldAccessorTable
      internal_static_object_detection_protos_CenterNet_KeypointEstimation_fieldAccessorTable;
  private static final com.google.protobuf.Descriptors.Descriptor
    internal_static_object_detection_protos_CenterNet_KeypointEstimation_KeypointLabelToStdEntry_descriptor;
  private static final
    com.google.protobuf.GeneratedMessageV3.FieldAccessorTable
      internal_static_object_detection_protos_CenterNet_KeypointEstimation_KeypointLabelToStdEntry_fieldAccessorTable;
  private static final com.google.protobuf.Descriptors.Descriptor
    internal_static_object_detection_protos_CenterNet_MaskEstimation_descriptor;
  private static final
    com.google.protobuf.GeneratedMessageV3.FieldAccessorTable
      internal_static_object_detection_protos_CenterNet_MaskEstimation_fieldAccessorTable;
  private static final com.google.protobuf.Descriptors.Descriptor
    internal_static_object_detection_protos_CenterNet_DensePoseEstimation_descriptor;
  private static final
    com.google.protobuf.GeneratedMessageV3.FieldAccessorTable
      internal_static_object_detection_protos_CenterNet_DensePoseEstimation_fieldAccessorTable;
  private static final com.google.protobuf.Descriptors.Descriptor
    internal_static_object_detection_protos_CenterNet_TrackEstimation_descriptor;
  private static final
    com.google.protobuf.GeneratedMessageV3.FieldAccessorTable
      internal_static_object_detection_protos_CenterNet_TrackEstimation_fieldAccessorTable;
  private static final com.google.protobuf.Descriptors.Descriptor
    internal_static_object_detection_protos_CenterNet_TemporalOffsetEstimation_descriptor;
  private static final
    com.google.protobuf.GeneratedMessageV3.FieldAccessorTable
      internal_static_object_detection_protos_CenterNet_TemporalOffsetEstimation_fieldAccessorTable;
  private static final com.google.protobuf.Descriptors.Descriptor
    internal_static_object_detection_protos_CenterNetFeatureExtractor_descriptor;
  private static final
    com.google.protobuf.GeneratedMessageV3.FieldAccessorTable
      internal_static_object_detection_protos_CenterNetFeatureExtractor_fieldAccessorTable;

  public static com.google.protobuf.Descriptors.FileDescriptor
      getDescriptor() {
    return descriptor;
  }
  private static  com.google.protobuf.Descriptors.FileDescriptor
      descriptor;
  static {
    java.lang.String[] descriptorData = {
      "\n(object_detection/protos/center_net.pro" +
      "to\022\027object_detection.protos\032+object_dete" +
      "ction/protos/image_resizer.proto\032$object" +
      "_detection/protos/losses.proto\"\304\027\n\tCente" +
      "rNet\022\023\n\013num_classes\030\001 \001(\005\022M\n\021feature_ext" +
      "ractor\030\002 \001(\01322.object_detection.protos.C" +
      "enterNetFeatureExtractor\022<\n\rimage_resize" +
      "r\030\003 \001(\0132%.object_detection.protos.ImageR" +
      "esizer\022\034\n\ruse_depthwise\030\r \001(\010:\005false\022%\n\026" +
      "compute_heatmap_sparse\030\017 \001(\010:\005false\022Q\n\025o" +
      "bject_detection_task\030\004 \001(\01322.object_dete" +
      "ction.protos.CenterNet.ObjectDetection\022S" +
      "\n\024object_center_params\030\005 \001(\01325.object_de" +
      "tection.protos.CenterNet.ObjectCenterPar" +
      "ams\022\037\n\027keypoint_label_map_path\030\006 \001(\t\022W\n\030" +
      "keypoint_estimation_task\030\007 \003(\01325.object_" +
      "detection.protos.CenterNet.KeypointEstim" +
      "ation\022O\n\024mask_estimation_task\030\010 \001(\01321.ob" +
      "ject_detection.protos.CenterNet.MaskEsti" +
      "mation\022Y\n\031densepose_estimation_task\030\t \001(" +
      "\01326.object_detection.protos.CenterNet.De" +
      "nsePoseEstimation\022Q\n\025track_estimation_ta" +
      "sk\030\n \001(\01322.object_detection.protos.Cente" +
      "rNet.TrackEstimation\022Y\n\024temporal_offset_" +
      "task\030\014 \001(\0132;.object_detection.protos.Cen" +
      "terNet.TemporalOffsetEstimation\032\313\001\n\017Obje" +
      "ctDetection\022\033\n\020task_loss_weight\030\001 \001(\002:\0011" +
      "\022\035\n\022offset_loss_weight\030\003 \001(\002:\0011\022\036\n\021scale" +
      "_loss_weight\030\004 \001(\002:\0030.1\022D\n\021localization_" +
      "loss\030\010 \001(\0132).object_detection.protos.Loc" +
      "alizationLossJ\004\010\002\020\003J\004\010\005\020\006J\004\010\006\020\007J\004\010\007\020\010\032\216\002" +
      "\n\022ObjectCenterParams\022$\n\031object_center_lo" +
      "ss_weight\030\001 \001(\002:\0011\022H\n\023classification_los" +
      "s\030\002 \001(\0132+.object_detection.protos.Classi" +
      "ficationLoss\022 \n\021heatmap_bias_init\030\003 \001(\002:" +
      "\005-2.19\022 \n\023min_box_overlap_iou\030\004 \001(\002:\0030.7" +
      "\022 \n\023max_box_predictions\030\005 \001(\005:\003100\022\"\n\023us" +
      "e_labeled_classes\030\006 \001(\010:\005false\032\254\006\n\022Keypo" +
      "intEstimation\022\021\n\ttask_name\030\001 \001(\t\022\033\n\020task" +
      "_loss_weight\030\002 \001(\002:\0011\022+\n\004loss\030\003 \001(\0132\035.ob" +
      "ject_detection.protos.Loss\022\033\n\023keypoint_c" +
      "lass_name\030\004 \001(\t\022l\n\025keypoint_label_to_std" +
      "\030\005 \003(\0132M.object_detection.protos.CenterN" +
      "et.KeypointEstimation.KeypointLabelToStd" +
      "Entry\022*\n\037keypoint_regression_loss_weight" +
      "\030\006 \001(\002:\0011\022\'\n\034keypoint_heatmap_loss_weigh" +
      "t\030\007 \001(\002:\0011\022&\n\033keypoint_offset_loss_weigh" +
      "t\030\010 \001(\002:\0011\022 \n\021heatmap_bias_init\030\t \001(\002:\005-" +
      "2.19\022/\n\"keypoint_candidate_score_thresho" +
      "ld\030\n \001(\002:\0030.1\022(\n\033num_candidates_per_keyp" +
      "oint\030\013 \001(\005:\003100\022$\n\031peak_max_pool_kernel_" +
      "size\030\014 \001(\005:\0013\022%\n\030unmatched_keypoint_scor" +
      "e\030\r \001(\002:\0030.1\022\026\n\tbox_scale\030\016 \001(\002:\0031.2\022#\n\026" +
      "candidate_search_scale\030\017 \001(\002:\0030.3\022,\n\026can" +
      "didate_ranking_mode\030\020 \001(\t:\014min_distance\022" +
      "\035\n\022offset_peak_radius\030\021 \001(\005:\0010\022\"\n\023per_ke" +
      "ypoint_offset\030\022 \001(\010:\005false\0329\n\027KeypointLa" +
      "belToStdEntry\022\013\n\003key\030\001 \001(\t\022\r\n\005value\030\002 \001(" +
      "\002:\0028\001\032\352\001\n\016MaskEstimation\022\033\n\020task_loss_we" +
      "ight\030\001 \001(\002:\0011\022H\n\023classification_loss\030\002 \001" +
      "(\0132+.object_detection.protos.Classificat" +
      "ionLoss\022\030\n\013mask_height\030\004 \001(\005:\003256\022\027\n\nmas" +
      "k_width\030\005 \001(\005:\003256\022\034\n\017score_threshold\030\006 " +
      "\001(\002:\0030.5\022 \n\021heatmap_bias_init\030\003 \001(\002:\005-2." +
      "19\032\217\002\n\023DensePoseEstimation\022\033\n\020task_loss_" +
      "weight\030\001 \001(\002:\0011\022\020\n\010class_id\030\002 \001(\005\022+\n\004los" +
      "s\030\003 \001(\0132\035.object_detection.protos.Loss\022\025" +
      "\n\tnum_parts\030\004 \001(\005:\00224\022\033\n\020part_loss_weigh" +
      "t\030\005 \001(\002:\0011\022!\n\026coordinate_loss_weight\030\006 \001" +
      "(\002:\0011\022#\n\025upsample_to_input_res\030\007 \001(\010:\004tr" +
      "ue\022 \n\021heatmap_bias_init\030\010 \001(\002:\005-2.19\032\307\001\n" +
      "\017TrackEstimation\022\033\n\020task_loss_weight\030\001 \001" +
      "(\002:\0011\022\025\n\rnum_track_ids\030\002 \001(\005\022\034\n\017reid_emb" +
      "ed_size\030\003 \001(\005:\003128\022\030\n\rnum_fc_layers\030\004 \001(" +
      "\005:\0011\022H\n\023classification_loss\030\005 \001(\0132+.obje" +
      "ct_detection.protos.ClassificationLoss\032}" +
      "\n\030TemporalOffsetEstimation\022\033\n\020task_loss_" +
      "weight\030\001 \001(\002:\0011\022D\n\021localization_loss\030\002 \001" +
      "(\0132).object_detection.protos.Localizatio" +
      "nLoss\"\221\001\n\031CenterNetFeatureExtractor\022\014\n\004t" +
      "ype\030\001 \001(\t\022\025\n\rchannel_means\030\002 \003(\002\022\024\n\014chan" +
      "nel_stds\030\003 \003(\002\022\033\n\014bgr_ordering\030\004 \001(\010:\005fa" +
      "lse\022\034\n\ruse_depthwise\030\005 \001(\010:\005false"
    };
    descriptor = com.google.protobuf.Descriptors.FileDescriptor
      .internalBuildGeneratedFileFrom(descriptorData,
        new com.google.protobuf.Descriptors.FileDescriptor[] {
          object_detection.protos.ImageResizerOuterClass.getDescriptor(),
          object_detection.protos.Losses.getDescriptor(),
        });
    internal_static_object_detection_protos_CenterNet_descriptor =
      getDescriptor().getMessageTypes().get(0);
    internal_static_object_detection_protos_CenterNet_fieldAccessorTable = new
      com.google.protobuf.GeneratedMessageV3.FieldAccessorTable(
        internal_static_object_detection_protos_CenterNet_descriptor,
        new java.lang.String[] { "NumClasses", "FeatureExtractor", "ImageResizer", "UseDepthwise", "ComputeHeatmapSparse", "ObjectDetectionTask", "ObjectCenterParams", "KeypointLabelMapPath", "KeypointEstimationTask", "MaskEstimationTask", "DenseposeEstimationTask", "TrackEstimationTask", "TemporalOffsetTask", });
    internal_static_object_detection_protos_CenterNet_ObjectDetection_descriptor =
      internal_static_object_detection_protos_CenterNet_descriptor.getNestedTypes().get(0);
    internal_static_object_detection_protos_CenterNet_ObjectDetection_fieldAccessorTable = new
      com.google.protobuf.GeneratedMessageV3.FieldAccessorTable(
        internal_static_object_detection_protos_CenterNet_ObjectDetection_descriptor,
        new java.lang.String[] { "TaskLossWeight", "OffsetLossWeight", "ScaleLossWeight", "LocalizationLoss", });
    internal_static_object_detection_protos_CenterNet_ObjectCenterParams_descriptor =
      internal_static_object_detection_protos_CenterNet_descriptor.getNestedTypes().get(1);
    internal_static_object_detection_protos_CenterNet_ObjectCenterParams_fieldAccessorTable = new
      com.google.protobuf.GeneratedMessageV3.FieldAccessorTable(
        internal_static_object_detection_protos_CenterNet_ObjectCenterParams_descriptor,
        new java.lang.String[] { "ObjectCenterLossWeight", "ClassificationLoss", "HeatmapBiasInit", "MinBoxOverlapIou", "MaxBoxPredictions", "UseLabeledClasses", });
    internal_static_object_detection_protos_CenterNet_KeypointEstimation_descriptor =
      internal_static_object_detection_protos_CenterNet_descriptor.getNestedTypes().get(2);
    internal_static_object_detection_protos_CenterNet_KeypointEstimation_fieldAccessorTable = new
      com.google.protobuf.GeneratedMessageV3.FieldAccessorTable(
        internal_static_object_detection_protos_CenterNet_KeypointEstimation_descriptor,
        new java.lang.String[] { "TaskName", "TaskLossWeight", "Loss", "KeypointClassName", "KeypointLabelToStd", "KeypointRegressionLossWeight", "KeypointHeatmapLossWeight", "KeypointOffsetLossWeight", "HeatmapBiasInit", "KeypointCandidateScoreThreshold", "NumCandidatesPerKeypoint", "PeakMaxPoolKernelSize", "UnmatchedKeypointScore", "BoxScale", "CandidateSearchScale", "CandidateRankingMode", "OffsetPeakRadius", "PerKeypointOffset", });
    internal_static_object_detection_protos_CenterNet_KeypointEstimation_KeypointLabelToStdEntry_descriptor =
      internal_static_object_detection_protos_CenterNet_KeypointEstimation_descriptor.getNestedTypes().get(0);
    internal_static_object_detection_protos_CenterNet_KeypointEstimation_KeypointLabelToStdEntry_fieldAccessorTable = new
      com.google.protobuf.GeneratedMessageV3.FieldAccessorTable(
        internal_static_object_detection_protos_CenterNet_KeypointEstimation_KeypointLabelToStdEntry_descriptor,
        new java.lang.String[] { "Key", "Value", });
    internal_static_object_detection_protos_CenterNet_MaskEstimation_descriptor =
      internal_static_object_detection_protos_CenterNet_descriptor.getNestedTypes().get(3);
    internal_static_object_detection_protos_CenterNet_MaskEstimation_fieldAccessorTable = new
      com.google.protobuf.GeneratedMessageV3.FieldAccessorTable(
        internal_static_object_detection_protos_CenterNet_MaskEstimation_descriptor,
        new java.lang.String[] { "TaskLossWeight", "ClassificationLoss", "MaskHeight", "MaskWidth", "ScoreThreshold", "HeatmapBiasInit", });
    internal_static_object_detection_protos_CenterNet_DensePoseEstimation_descriptor =
      internal_static_object_detection_protos_CenterNet_descriptor.getNestedTypes().get(4);
    internal_static_object_detection_protos_CenterNet_DensePoseEstimation_fieldAccessorTable = new
      com.google.protobuf.GeneratedMessageV3.FieldAccessorTable(
        internal_static_object_detection_protos_CenterNet_DensePoseEstimation_descriptor,
        new java.lang.String[] { "TaskLossWeight", "ClassId", "Loss", "NumParts", "PartLossWeight", "CoordinateLossWeight", "UpsampleToInputRes", "HeatmapBiasInit", });
    internal_static_object_detection_protos_CenterNet_TrackEstimation_descriptor =
      internal_static_object_detection_protos_CenterNet_descriptor.getNestedTypes().get(5);
    internal_static_object_detection_protos_CenterNet_TrackEstimation_fieldAccessorTable = new
      com.google.protobuf.GeneratedMessageV3.FieldAccessorTable(
        internal_static_object_detection_protos_CenterNet_TrackEstimation_descriptor,
        new java.lang.String[] { "TaskLossWeight", "NumTrackIds", "ReidEmbedSize", "NumFcLayers", "ClassificationLoss", });
    internal_static_object_detection_protos_CenterNet_TemporalOffsetEstimation_descriptor =
      internal_static_object_detection_protos_CenterNet_descriptor.getNestedTypes().get(6);
    internal_static_object_detection_protos_CenterNet_TemporalOffsetEstimation_fieldAccessorTable = new
      com.google.protobuf.GeneratedMessageV3.FieldAccessorTable(
        internal_static_object_detection_protos_CenterNet_TemporalOffsetEstimation_descriptor,
        new java.lang.String[] { "TaskLossWeight", "LocalizationLoss", });
    internal_static_object_detection_protos_CenterNetFeatureExtractor_descriptor =
      getDescriptor().getMessageTypes().get(1);
    internal_static_object_detection_protos_CenterNetFeatureExtractor_fieldAccessorTable = new
      com.google.protobuf.GeneratedMessageV3.FieldAccessorTable(
        internal_static_object_detection_protos_CenterNetFeatureExtractor_descriptor,
        new java.lang.String[] { "Type", "ChannelMeans", "ChannelStds", "BgrOrdering", "UseDepthwise", });
    object_detection.protos.ImageResizerOuterClass.getDescriptor();
    object_detection.protos.Losses.getDescriptor();
  }

  // @@protoc_insertion_point(outer_class_scope)
}
