/*
 * Copyright (c) 2020. Kin-Hong Wong. All Rights Reserved.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

// Generated by the protocol buffer compiler.  DO NOT EDIT!
// source: object_detection/protos/eval.proto

package object_detection.protos;

public final class Eval {
  private Eval() {}
  public static void registerAllExtensions(
      com.google.protobuf.ExtensionRegistryLite registry) {
  }

  public static void registerAllExtensions(
      com.google.protobuf.ExtensionRegistry registry) {
    registerAllExtensions(
        (com.google.protobuf.ExtensionRegistryLite) registry);
  }
  public interface EvalConfigOrBuilder extends
      // @@protoc_insertion_point(interface_extends:object_detection.protos.EvalConfig)
      com.google.protobuf.MessageOrBuilder {

    /**
     * <code>optional uint32 batch_size = 25 [default = 1];</code>
     * @return Whether the batchSize field is set.
     */
    boolean hasBatchSize();
    /**
     * <code>optional uint32 batch_size = 25 [default = 1];</code>
     * @return The batchSize.
     */
    int getBatchSize();

    /**
     * <pre>
     * Number of visualization images to generate.
     * </pre>
     *
     * <code>optional uint32 num_visualizations = 1 [default = 10];</code>
     * @return Whether the numVisualizations field is set.
     */
    boolean hasNumVisualizations();
    /**
     * <pre>
     * Number of visualization images to generate.
     * </pre>
     *
     * <code>optional uint32 num_visualizations = 1 [default = 10];</code>
     * @return The numVisualizations.
     */
    int getNumVisualizations();

    /**
     * <pre>
     * Number of examples to process of evaluation.
     * </pre>
     *
     * <code>optional uint32 num_examples = 2 [default = 5000, deprecated = true];</code>
     * @return Whether the numExamples field is set.
     */
    @java.lang.Deprecated boolean hasNumExamples();
    /**
     * <pre>
     * Number of examples to process of evaluation.
     * </pre>
     *
     * <code>optional uint32 num_examples = 2 [default = 5000, deprecated = true];</code>
     * @return The numExamples.
     */
    @java.lang.Deprecated int getNumExamples();

    /**
     * <pre>
     * How often to run evaluation.
     * </pre>
     *
     * <code>optional uint32 eval_interval_secs = 3 [default = 300];</code>
     * @return Whether the evalIntervalSecs field is set.
     */
    boolean hasEvalIntervalSecs();
    /**
     * <pre>
     * How often to run evaluation.
     * </pre>
     *
     * <code>optional uint32 eval_interval_secs = 3 [default = 300];</code>
     * @return The evalIntervalSecs.
     */
    int getEvalIntervalSecs();

    /**
     * <pre>
     * Maximum number of times to run evaluation. If set to 0, will run forever.
     * </pre>
     *
     * <code>optional uint32 max_evals = 4 [default = 0, deprecated = true];</code>
     * @return Whether the maxEvals field is set.
     */
    @java.lang.Deprecated boolean hasMaxEvals();
    /**
     * <pre>
     * Maximum number of times to run evaluation. If set to 0, will run forever.
     * </pre>
     *
     * <code>optional uint32 max_evals = 4 [default = 0, deprecated = true];</code>
     * @return The maxEvals.
     */
    @java.lang.Deprecated int getMaxEvals();

    /**
     * <pre>
     * Whether the TensorFlow graph used for evaluation should be saved to disk.
     * </pre>
     *
     * <code>optional bool save_graph = 5 [default = false];</code>
     * @return Whether the saveGraph field is set.
     */
    boolean hasSaveGraph();
    /**
     * <pre>
     * Whether the TensorFlow graph used for evaluation should be saved to disk.
     * </pre>
     *
     * <code>optional bool save_graph = 5 [default = false];</code>
     * @return The saveGraph.
     */
    boolean getSaveGraph();

    /**
     * <pre>
     * Path to directory to store visualizations in. If empty, visualization
     * images are not exported (only shown on Tensorboard).
     * </pre>
     *
     * <code>optional string visualization_export_dir = 6 [default = ""];</code>
     * @return Whether the visualizationExportDir field is set.
     */
    boolean hasVisualizationExportDir();
    /**
     * <pre>
     * Path to directory to store visualizations in. If empty, visualization
     * images are not exported (only shown on Tensorboard).
     * </pre>
     *
     * <code>optional string visualization_export_dir = 6 [default = ""];</code>
     * @return The visualizationExportDir.
     */
    java.lang.String getVisualizationExportDir();
    /**
     * <pre>
     * Path to directory to store visualizations in. If empty, visualization
     * images are not exported (only shown on Tensorboard).
     * </pre>
     *
     * <code>optional string visualization_export_dir = 6 [default = ""];</code>
     * @return The bytes for visualizationExportDir.
     */
    com.google.protobuf.ByteString
        getVisualizationExportDirBytes();

    /**
     * <pre>
     * BNS name of the TensorFlow master.
     * </pre>
     *
     * <code>optional string eval_master = 7 [default = ""];</code>
     * @return Whether the evalMaster field is set.
     */
    boolean hasEvalMaster();
    /**
     * <pre>
     * BNS name of the TensorFlow master.
     * </pre>
     *
     * <code>optional string eval_master = 7 [default = ""];</code>
     * @return The evalMaster.
     */
    java.lang.String getEvalMaster();
    /**
     * <pre>
     * BNS name of the TensorFlow master.
     * </pre>
     *
     * <code>optional string eval_master = 7 [default = ""];</code>
     * @return The bytes for evalMaster.
     */
    com.google.protobuf.ByteString
        getEvalMasterBytes();

    /**
     * <pre>
     * Type of metrics to use for evaluation.
     * </pre>
     *
     * <code>repeated string metrics_set = 8;</code>
     * @return A list containing the metricsSet.
     */
    java.util.List<java.lang.String>
        getMetricsSetList();
    /**
     * <pre>
     * Type of metrics to use for evaluation.
     * </pre>
     *
     * <code>repeated string metrics_set = 8;</code>
     * @return The count of metricsSet.
     */
    int getMetricsSetCount();
    /**
     * <pre>
     * Type of metrics to use for evaluation.
     * </pre>
     *
     * <code>repeated string metrics_set = 8;</code>
     * @param index The index of the element to return.
     * @return The metricsSet at the given index.
     */
    java.lang.String getMetricsSet(int index);
    /**
     * <pre>
     * Type of metrics to use for evaluation.
     * </pre>
     *
     * <code>repeated string metrics_set = 8;</code>
     * @param index The index of the value to return.
     * @return The bytes of the metricsSet at the given index.
     */
    com.google.protobuf.ByteString
        getMetricsSetBytes(int index);

    /**
     * <pre>
     * Type of metrics to use for evaluation. Unlike `metrics_set` above, this
     * field allows configuring evaluation metric through config files.
     * </pre>
     *
     * <code>repeated .object_detection.protos.ParameterizedMetric parameterized_metric = 31;</code>
     */
    java.util.List<object_detection.protos.Eval.ParameterizedMetric>
        getParameterizedMetricList();
    /**
     * <pre>
     * Type of metrics to use for evaluation. Unlike `metrics_set` above, this
     * field allows configuring evaluation metric through config files.
     * </pre>
     *
     * <code>repeated .object_detection.protos.ParameterizedMetric parameterized_metric = 31;</code>
     */
    object_detection.protos.Eval.ParameterizedMetric getParameterizedMetric(int index);
    /**
     * <pre>
     * Type of metrics to use for evaluation. Unlike `metrics_set` above, this
     * field allows configuring evaluation metric through config files.
     * </pre>
     *
     * <code>repeated .object_detection.protos.ParameterizedMetric parameterized_metric = 31;</code>
     */
    int getParameterizedMetricCount();
    /**
     * <pre>
     * Type of metrics to use for evaluation. Unlike `metrics_set` above, this
     * field allows configuring evaluation metric through config files.
     * </pre>
     *
     * <code>repeated .object_detection.protos.ParameterizedMetric parameterized_metric = 31;</code>
     */
    java.util.List<? extends object_detection.protos.Eval.ParameterizedMetricOrBuilder>
        getParameterizedMetricOrBuilderList();
    /**
     * <pre>
     * Type of metrics to use for evaluation. Unlike `metrics_set` above, this
     * field allows configuring evaluation metric through config files.
     * </pre>
     *
     * <code>repeated .object_detection.protos.ParameterizedMetric parameterized_metric = 31;</code>
     */
    object_detection.protos.Eval.ParameterizedMetricOrBuilder getParameterizedMetricOrBuilder(
        int index);

    /**
     * <pre>
     * Path to export detections to COCO compatible JSON format.
     * </pre>
     *
     * <code>optional string export_path = 9 [default = ""];</code>
     * @return Whether the exportPath field is set.
     */
    boolean hasExportPath();
    /**
     * <pre>
     * Path to export detections to COCO compatible JSON format.
     * </pre>
     *
     * <code>optional string export_path = 9 [default = ""];</code>
     * @return The exportPath.
     */
    java.lang.String getExportPath();
    /**
     * <pre>
     * Path to export detections to COCO compatible JSON format.
     * </pre>
     *
     * <code>optional string export_path = 9 [default = ""];</code>
     * @return The bytes for exportPath.
     */
    com.google.protobuf.ByteString
        getExportPathBytes();

    /**
     * <pre>
     * Option to not read groundtruth labels and only export detections to
     * COCO-compatible JSON file.
     * </pre>
     *
     * <code>optional bool ignore_groundtruth = 10 [default = false];</code>
     * @return Whether the ignoreGroundtruth field is set.
     */
    boolean hasIgnoreGroundtruth();
    /**
     * <pre>
     * Option to not read groundtruth labels and only export detections to
     * COCO-compatible JSON file.
     * </pre>
     *
     * <code>optional bool ignore_groundtruth = 10 [default = false];</code>
     * @return The ignoreGroundtruth.
     */
    boolean getIgnoreGroundtruth();

    /**
     * <pre>
     * Use exponential moving averages of variables for evaluation.
     * TODO(rathodv): When this is false make sure the model is constructed
     * without moving averages in restore_fn.
     * </pre>
     *
     * <code>optional bool use_moving_averages = 11 [default = false];</code>
     * @return Whether the useMovingAverages field is set.
     */
    boolean hasUseMovingAverages();
    /**
     * <pre>
     * Use exponential moving averages of variables for evaluation.
     * TODO(rathodv): When this is false make sure the model is constructed
     * without moving averages in restore_fn.
     * </pre>
     *
     * <code>optional bool use_moving_averages = 11 [default = false];</code>
     * @return The useMovingAverages.
     */
    boolean getUseMovingAverages();

    /**
     * <pre>
     * Whether to evaluate instance masks.
     * Note that since there is no evaluation code currently for instance
     * segmentation this option is unused.
     * </pre>
     *
     * <code>optional bool eval_instance_masks = 12 [default = false];</code>
     * @return Whether the evalInstanceMasks field is set.
     */
    boolean hasEvalInstanceMasks();
    /**
     * <pre>
     * Whether to evaluate instance masks.
     * Note that since there is no evaluation code currently for instance
     * segmentation this option is unused.
     * </pre>
     *
     * <code>optional bool eval_instance_masks = 12 [default = false];</code>
     * @return The evalInstanceMasks.
     */
    boolean getEvalInstanceMasks();

    /**
     * <pre>
     * Minimum score threshold for a detected object box to be visualized
     * </pre>
     *
     * <code>optional float min_score_threshold = 13 [default = 0.5];</code>
     * @return Whether the minScoreThreshold field is set.
     */
    boolean hasMinScoreThreshold();
    /**
     * <pre>
     * Minimum score threshold for a detected object box to be visualized
     * </pre>
     *
     * <code>optional float min_score_threshold = 13 [default = 0.5];</code>
     * @return The minScoreThreshold.
     */
    float getMinScoreThreshold();

    /**
     * <pre>
     * Maximum number of detections to visualize
     * </pre>
     *
     * <code>optional int32 max_num_boxes_to_visualize = 14 [default = 20];</code>
     * @return Whether the maxNumBoxesToVisualize field is set.
     */
    boolean hasMaxNumBoxesToVisualize();
    /**
     * <pre>
     * Maximum number of detections to visualize
     * </pre>
     *
     * <code>optional int32 max_num_boxes_to_visualize = 14 [default = 20];</code>
     * @return The maxNumBoxesToVisualize.
     */
    int getMaxNumBoxesToVisualize();

    /**
     * <pre>
     * When drawing a single detection, each label is by default visualized as
     * &lt;label name&gt; : &lt;label score&gt;. One can skip the name or/and score using the
     * following fields:
     * </pre>
     *
     * <code>optional bool skip_scores = 15 [default = false];</code>
     * @return Whether the skipScores field is set.
     */
    boolean hasSkipScores();
    /**
     * <pre>
     * When drawing a single detection, each label is by default visualized as
     * &lt;label name&gt; : &lt;label score&gt;. One can skip the name or/and score using the
     * following fields:
     * </pre>
     *
     * <code>optional bool skip_scores = 15 [default = false];</code>
     * @return The skipScores.
     */
    boolean getSkipScores();

    /**
     * <code>optional bool skip_labels = 16 [default = false];</code>
     * @return Whether the skipLabels field is set.
     */
    boolean hasSkipLabels();
    /**
     * <code>optional bool skip_labels = 16 [default = false];</code>
     * @return The skipLabels.
     */
    boolean getSkipLabels();

    /**
     * <pre>
     * Whether to show groundtruth boxes in addition to detected boxes in
     * visualizations.
     * </pre>
     *
     * <code>optional bool visualize_groundtruth_boxes = 17 [default = false];</code>
     * @return Whether the visualizeGroundtruthBoxes field is set.
     */
    boolean hasVisualizeGroundtruthBoxes();
    /**
     * <pre>
     * Whether to show groundtruth boxes in addition to detected boxes in
     * visualizations.
     * </pre>
     *
     * <code>optional bool visualize_groundtruth_boxes = 17 [default = false];</code>
     * @return The visualizeGroundtruthBoxes.
     */
    boolean getVisualizeGroundtruthBoxes();

    /**
     * <pre>
     * Box color for visualizing groundtruth boxes.
     * </pre>
     *
     * <code>optional string groundtruth_box_visualization_color = 18 [default = "black"];</code>
     * @return Whether the groundtruthBoxVisualizationColor field is set.
     */
    boolean hasGroundtruthBoxVisualizationColor();
    /**
     * <pre>
     * Box color for visualizing groundtruth boxes.
     * </pre>
     *
     * <code>optional string groundtruth_box_visualization_color = 18 [default = "black"];</code>
     * @return The groundtruthBoxVisualizationColor.
     */
    java.lang.String getGroundtruthBoxVisualizationColor();
    /**
     * <pre>
     * Box color for visualizing groundtruth boxes.
     * </pre>
     *
     * <code>optional string groundtruth_box_visualization_color = 18 [default = "black"];</code>
     * @return The bytes for groundtruthBoxVisualizationColor.
     */
    com.google.protobuf.ByteString
        getGroundtruthBoxVisualizationColorBytes();

    /**
     * <pre>
     * Whether to keep image identifier in filename when exported to
     * visualization_export_dir.
     * </pre>
     *
     * <code>optional bool keep_image_id_for_visualization_export = 19 [default = false];</code>
     * @return Whether the keepImageIdForVisualizationExport field is set.
     */
    boolean hasKeepImageIdForVisualizationExport();
    /**
     * <pre>
     * Whether to keep image identifier in filename when exported to
     * visualization_export_dir.
     * </pre>
     *
     * <code>optional bool keep_image_id_for_visualization_export = 19 [default = false];</code>
     * @return The keepImageIdForVisualizationExport.
     */
    boolean getKeepImageIdForVisualizationExport();

    /**
     * <pre>
     * Whether to retain original images (i.e. not pre-processed) in the tensor
     * dictionary, so that they can be displayed in Tensorboard.
     * </pre>
     *
     * <code>optional bool retain_original_images = 23 [default = true];</code>
     * @return Whether the retainOriginalImages field is set.
     */
    boolean hasRetainOriginalImages();
    /**
     * <pre>
     * Whether to retain original images (i.e. not pre-processed) in the tensor
     * dictionary, so that they can be displayed in Tensorboard.
     * </pre>
     *
     * <code>optional bool retain_original_images = 23 [default = true];</code>
     * @return The retainOriginalImages.
     */
    boolean getRetainOriginalImages();

    /**
     * <pre>
     * If True, additionally include per-category metrics.
     * </pre>
     *
     * <code>optional bool include_metrics_per_category = 24 [default = false];</code>
     * @return Whether the includeMetricsPerCategory field is set.
     */
    boolean hasIncludeMetricsPerCategory();
    /**
     * <pre>
     * If True, additionally include per-category metrics.
     * </pre>
     *
     * <code>optional bool include_metrics_per_category = 24 [default = false];</code>
     * @return The includeMetricsPerCategory.
     */
    boolean getIncludeMetricsPerCategory();

    /**
     * <pre>
     * If true, includes all metrics per category.
     * </pre>
     *
     * <code>optional bool all_metrics_per_category = 35 [default = false];</code>
     * @return Whether the allMetricsPerCategory field is set.
     */
    boolean hasAllMetricsPerCategory();
    /**
     * <pre>
     * If true, includes all metrics per category.
     * </pre>
     *
     * <code>optional bool all_metrics_per_category = 35 [default = false];</code>
     * @return The allMetricsPerCategory.
     */
    boolean getAllMetricsPerCategory();

    /**
     * <pre>
     * Optional super-category definitions: keys are super-category names;
     * values are comma-separated categories (assumed to correspond to category
     * names (`display_name`) in the label map.
     * </pre>
     *
     * <code>map&lt;string, string&gt; super_categories = 34;</code>
     */
    int getSuperCategoriesCount();
    /**
     * <pre>
     * Optional super-category definitions: keys are super-category names;
     * values are comma-separated categories (assumed to correspond to category
     * names (`display_name`) in the label map.
     * </pre>
     *
     * <code>map&lt;string, string&gt; super_categories = 34;</code>
     */
    boolean containsSuperCategories(
        java.lang.String key);
    /**
     * Use {@link #getSuperCategoriesMap()} instead.
     */
    @java.lang.Deprecated
    java.util.Map<java.lang.String, java.lang.String>
    getSuperCategories();
    /**
     * <pre>
     * Optional super-category definitions: keys are super-category names;
     * values are comma-separated categories (assumed to correspond to category
     * names (`display_name`) in the label map.
     * </pre>
     *
     * <code>map&lt;string, string&gt; super_categories = 34;</code>
     */
    java.util.Map<java.lang.String, java.lang.String>
    getSuperCategoriesMap();
    /**
     * <pre>
     * Optional super-category definitions: keys are super-category names;
     * values are comma-separated categories (assumed to correspond to category
     * names (`display_name`) in the label map.
     * </pre>
     *
     * <code>map&lt;string, string&gt; super_categories = 34;</code>
     */

    java.lang.String getSuperCategoriesOrDefault(
        java.lang.String key,
        java.lang.String defaultValue);
    /**
     * <pre>
     * Optional super-category definitions: keys are super-category names;
     * values are comma-separated categories (assumed to correspond to category
     * names (`display_name`) in the label map.
     * </pre>
     *
     * <code>map&lt;string, string&gt; super_categories = 34;</code>
     */

    java.lang.String getSuperCategoriesOrThrow(
        java.lang.String key);

    /**
     * <pre>
     * Recall range within which precision should be computed.
     * </pre>
     *
     * <code>optional float recall_lower_bound = 26 [default = 0];</code>
     * @return Whether the recallLowerBound field is set.
     */
    boolean hasRecallLowerBound();
    /**
     * <pre>
     * Recall range within which precision should be computed.
     * </pre>
     *
     * <code>optional float recall_lower_bound = 26 [default = 0];</code>
     * @return The recallLowerBound.
     */
    float getRecallLowerBound();

    /**
     * <code>optional float recall_upper_bound = 27 [default = 1];</code>
     * @return Whether the recallUpperBound field is set.
     */
    boolean hasRecallUpperBound();
    /**
     * <code>optional float recall_upper_bound = 27 [default = 1];</code>
     * @return The recallUpperBound.
     */
    float getRecallUpperBound();

    /**
     * <pre>
     * Whether to retain additional channels (i.e. not pre-processed) in the
     * tensor dictionary, so that they can be displayed in Tensorboard.
     * </pre>
     *
     * <code>optional bool retain_original_image_additional_channels = 28 [default = false];</code>
     * @return Whether the retainOriginalImageAdditionalChannels field is set.
     */
    boolean hasRetainOriginalImageAdditionalChannels();
    /**
     * <pre>
     * Whether to retain additional channels (i.e. not pre-processed) in the
     * tensor dictionary, so that they can be displayed in Tensorboard.
     * </pre>
     *
     * <code>optional bool retain_original_image_additional_channels = 28 [default = false];</code>
     * @return The retainOriginalImageAdditionalChannels.
     */
    boolean getRetainOriginalImageAdditionalChannels();

    /**
     * <pre>
     * When this flag is set, images are not resized during evaluation.
     * When this flag is not set (default case), image are resized according
     * to the image_resizer config in the model during evaluation.
     * </pre>
     *
     * <code>optional bool force_no_resize = 29 [default = false];</code>
     * @return Whether the forceNoResize field is set.
     */
    boolean hasForceNoResize();
    /**
     * <pre>
     * When this flag is set, images are not resized during evaluation.
     * When this flag is not set (default case), image are resized according
     * to the image_resizer config in the model during evaluation.
     * </pre>
     *
     * <code>optional bool force_no_resize = 29 [default = false];</code>
     * @return The forceNoResize.
     */
    boolean getForceNoResize();

    /**
     * <pre>
     * Whether to use a dummy loss in eval so model.loss() is not executed.
     * </pre>
     *
     * <code>optional bool use_dummy_loss_in_eval = 30 [default = false];</code>
     * @return Whether the useDummyLossInEval field is set.
     */
    boolean hasUseDummyLossInEval();
    /**
     * <pre>
     * Whether to use a dummy loss in eval so model.loss() is not executed.
     * </pre>
     *
     * <code>optional bool use_dummy_loss_in_eval = 30 [default = false];</code>
     * @return The useDummyLossInEval.
     */
    boolean getUseDummyLossInEval();

    /**
     * <pre>
     * Specifies which keypoints should be connected by an edge, which may improve
     * visualization. An example would be human pose estimation where certain
     * joints can be connected.
     * </pre>
     *
     * <code>repeated .object_detection.protos.KeypointEdge keypoint_edge = 32;</code>
     */
    java.util.List<object_detection.protos.Eval.KeypointEdge>
        getKeypointEdgeList();
    /**
     * <pre>
     * Specifies which keypoints should be connected by an edge, which may improve
     * visualization. An example would be human pose estimation where certain
     * joints can be connected.
     * </pre>
     *
     * <code>repeated .object_detection.protos.KeypointEdge keypoint_edge = 32;</code>
     */
    object_detection.protos.Eval.KeypointEdge getKeypointEdge(int index);
    /**
     * <pre>
     * Specifies which keypoints should be connected by an edge, which may improve
     * visualization. An example would be human pose estimation where certain
     * joints can be connected.
     * </pre>
     *
     * <code>repeated .object_detection.protos.KeypointEdge keypoint_edge = 32;</code>
     */
    int getKeypointEdgeCount();
    /**
     * <pre>
     * Specifies which keypoints should be connected by an edge, which may improve
     * visualization. An example would be human pose estimation where certain
     * joints can be connected.
     * </pre>
     *
     * <code>repeated .object_detection.protos.KeypointEdge keypoint_edge = 32;</code>
     */
    java.util.List<? extends object_detection.protos.Eval.KeypointEdgeOrBuilder>
        getKeypointEdgeOrBuilderList();
    /**
     * <pre>
     * Specifies which keypoints should be connected by an edge, which may improve
     * visualization. An example would be human pose estimation where certain
     * joints can be connected.
     * </pre>
     *
     * <code>repeated .object_detection.protos.KeypointEdge keypoint_edge = 32;</code>
     */
    object_detection.protos.Eval.KeypointEdgeOrBuilder getKeypointEdgeOrBuilder(
        int index);

    /**
     * <pre>
     * The "groundtruth_labeled_classes" field indicates which classes have been
     * labeled on the images. If skip_predictions_for_unlabeled_class is set,
     * detector predictions that do not match to the groundtruth_labeled_classes
     * will be ignored. This is useful for evaluating on test data that are not
     * exhaustively labeled.
     * </pre>
     *
     * <code>optional bool skip_predictions_for_unlabeled_class = 33 [default = false];</code>
     * @return Whether the skipPredictionsForUnlabeledClass field is set.
     */
    boolean hasSkipPredictionsForUnlabeledClass();
    /**
     * <pre>
     * The "groundtruth_labeled_classes" field indicates which classes have been
     * labeled on the images. If skip_predictions_for_unlabeled_class is set,
     * detector predictions that do not match to the groundtruth_labeled_classes
     * will be ignored. This is useful for evaluating on test data that are not
     * exhaustively labeled.
     * </pre>
     *
     * <code>optional bool skip_predictions_for_unlabeled_class = 33 [default = false];</code>
     * @return The skipPredictionsForUnlabeledClass.
     */
    boolean getSkipPredictionsForUnlabeledClass();
  }
  /**
   * <pre>
   * Message for configuring DetectionModel evaluation jobs (eval.py).
   * Next id - 36
   * </pre>
   *
   * Protobuf type {@code object_detection.protos.EvalConfig}
   */
  public static final class EvalConfig extends
      com.google.protobuf.GeneratedMessageV3 implements
      // @@protoc_insertion_point(message_implements:object_detection.protos.EvalConfig)
      EvalConfigOrBuilder {
  private static final long serialVersionUID = 0L;
    // Use EvalConfig.newBuilder() to construct.
    private EvalConfig(com.google.protobuf.GeneratedMessageV3.Builder<?> builder) {
      super(builder);
    }
    private EvalConfig() {
      batchSize_ = 1;
      numVisualizations_ = 10;
      numExamples_ = 5000;
      evalIntervalSecs_ = 300;
      visualizationExportDir_ = "";
      evalMaster_ = "";
      metricsSet_ = com.google.protobuf.LazyStringArrayList.EMPTY;
      parameterizedMetric_ = java.util.Collections.emptyList();
      exportPath_ = "";
      minScoreThreshold_ = 0.5F;
      maxNumBoxesToVisualize_ = 20;
      groundtruthBoxVisualizationColor_ = "black";
      retainOriginalImages_ = true;
      recallUpperBound_ = 1F;
      keypointEdge_ = java.util.Collections.emptyList();
    }

    @java.lang.Override
    @SuppressWarnings({"unused"})
    protected java.lang.Object newInstance(
        UnusedPrivateParameter unused) {
      return new EvalConfig();
    }

    @java.lang.Override
    public final com.google.protobuf.UnknownFieldSet
    getUnknownFields() {
      return this.unknownFields;
    }
    private EvalConfig(
        com.google.protobuf.CodedInputStream input,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws com.google.protobuf.InvalidProtocolBufferException {
      this();
      if (extensionRegistry == null) {
        throw new java.lang.NullPointerException();
      }
      int mutable_bitField0_ = 0;
      com.google.protobuf.UnknownFieldSet.Builder unknownFields =
          com.google.protobuf.UnknownFieldSet.newBuilder();
      try {
        boolean done = false;
        while (!done) {
          int tag = input.readTag();
          switch (tag) {
            case 0:
              done = true;
              break;
            case 8: {
              bitField0_ |= 0x00000002;
              numVisualizations_ = input.readUInt32();
              break;
            }
            case 16: {
              bitField0_ |= 0x00000004;
              numExamples_ = input.readUInt32();
              break;
            }
            case 24: {
              bitField0_ |= 0x00000008;
              evalIntervalSecs_ = input.readUInt32();
              break;
            }
            case 32: {
              bitField0_ |= 0x00000010;
              maxEvals_ = input.readUInt32();
              break;
            }
            case 40: {
              bitField0_ |= 0x00000020;
              saveGraph_ = input.readBool();
              break;
            }
            case 50: {
              com.google.protobuf.ByteString bs = input.readBytes();
              bitField0_ |= 0x00000040;
              visualizationExportDir_ = bs;
              break;
            }
            case 58: {
              com.google.protobuf.ByteString bs = input.readBytes();
              bitField0_ |= 0x00000080;
              evalMaster_ = bs;
              break;
            }
            case 66: {
              com.google.protobuf.ByteString bs = input.readBytes();
              if (!((mutable_bitField0_ & 0x00000100) != 0)) {
                metricsSet_ = new com.google.protobuf.LazyStringArrayList();
                mutable_bitField0_ |= 0x00000100;
              }
              metricsSet_.add(bs);
              break;
            }
            case 74: {
              com.google.protobuf.ByteString bs = input.readBytes();
              bitField0_ |= 0x00000100;
              exportPath_ = bs;
              break;
            }
            case 80: {
              bitField0_ |= 0x00000200;
              ignoreGroundtruth_ = input.readBool();
              break;
            }
            case 88: {
              bitField0_ |= 0x00000400;
              useMovingAverages_ = input.readBool();
              break;
            }
            case 96: {
              bitField0_ |= 0x00000800;
              evalInstanceMasks_ = input.readBool();
              break;
            }
            case 109: {
              bitField0_ |= 0x00001000;
              minScoreThreshold_ = input.readFloat();
              break;
            }
            case 112: {
              bitField0_ |= 0x00002000;
              maxNumBoxesToVisualize_ = input.readInt32();
              break;
            }
            case 120: {
              bitField0_ |= 0x00004000;
              skipScores_ = input.readBool();
              break;
            }
            case 128: {
              bitField0_ |= 0x00008000;
              skipLabels_ = input.readBool();
              break;
            }
            case 136: {
              bitField0_ |= 0x00010000;
              visualizeGroundtruthBoxes_ = input.readBool();
              break;
            }
            case 146: {
              com.google.protobuf.ByteString bs = input.readBytes();
              bitField0_ |= 0x00020000;
              groundtruthBoxVisualizationColor_ = bs;
              break;
            }
            case 152: {
              bitField0_ |= 0x00040000;
              keepImageIdForVisualizationExport_ = input.readBool();
              break;
            }
            case 184: {
              bitField0_ |= 0x00080000;
              retainOriginalImages_ = input.readBool();
              break;
            }
            case 192: {
              bitField0_ |= 0x00100000;
              includeMetricsPerCategory_ = input.readBool();
              break;
            }
            case 200: {
              bitField0_ |= 0x00000001;
              batchSize_ = input.readUInt32();
              break;
            }
            case 213: {
              bitField0_ |= 0x00400000;
              recallLowerBound_ = input.readFloat();
              break;
            }
            case 221: {
              bitField0_ |= 0x00800000;
              recallUpperBound_ = input.readFloat();
              break;
            }
            case 224: {
              bitField0_ |= 0x01000000;
              retainOriginalImageAdditionalChannels_ = input.readBool();
              break;
            }
            case 232: {
              bitField0_ |= 0x02000000;
              forceNoResize_ = input.readBool();
              break;
            }
            case 240: {
              bitField0_ |= 0x04000000;
              useDummyLossInEval_ = input.readBool();
              break;
            }
            case 250: {
              if (!((mutable_bitField0_ & 0x00000200) != 0)) {
                parameterizedMetric_ = new java.util.ArrayList<object_detection.protos.Eval.ParameterizedMetric>();
                mutable_bitField0_ |= 0x00000200;
              }
              parameterizedMetric_.add(
                  input.readMessage(object_detection.protos.Eval.ParameterizedMetric.PARSER, extensionRegistry));
              break;
            }
            case 258: {
              if (!((mutable_bitField0_ & 0x40000000) != 0)) {
                keypointEdge_ = new java.util.ArrayList<object_detection.protos.Eval.KeypointEdge>();
                mutable_bitField0_ |= 0x40000000;
              }
              keypointEdge_.add(
                  input.readMessage(object_detection.protos.Eval.KeypointEdge.PARSER, extensionRegistry));
              break;
            }
            case 264: {
              bitField0_ |= 0x08000000;
              skipPredictionsForUnlabeledClass_ = input.readBool();
              break;
            }
            case 274: {
              if (!((mutable_bitField0_ & 0x01000000) != 0)) {
                superCategories_ = com.google.protobuf.MapField.newMapField(
                    SuperCategoriesDefaultEntryHolder.defaultEntry);
                mutable_bitField0_ |= 0x01000000;
              }
              com.google.protobuf.MapEntry<java.lang.String, java.lang.String>
              superCategories__ = input.readMessage(
                  SuperCategoriesDefaultEntryHolder.defaultEntry.getParserForType(), extensionRegistry);
              superCategories_.getMutableMap().put(
                  superCategories__.getKey(), superCategories__.getValue());
              break;
            }
            case 280: {
              bitField0_ |= 0x00200000;
              allMetricsPerCategory_ = input.readBool();
              break;
            }
            default: {
              if (!parseUnknownField(
                  input, unknownFields, extensionRegistry, tag)) {
                done = true;
              }
              break;
            }
          }
        }
      } catch (com.google.protobuf.InvalidProtocolBufferException e) {
        throw e.setUnfinishedMessage(this);
      } catch (java.io.IOException e) {
        throw new com.google.protobuf.InvalidProtocolBufferException(
            e).setUnfinishedMessage(this);
      } finally {
        if (((mutable_bitField0_ & 0x00000100) != 0)) {
          metricsSet_ = metricsSet_.getUnmodifiableView();
        }
        if (((mutable_bitField0_ & 0x00000200) != 0)) {
          parameterizedMetric_ = java.util.Collections.unmodifiableList(parameterizedMetric_);
        }
        if (((mutable_bitField0_ & 0x40000000) != 0)) {
          keypointEdge_ = java.util.Collections.unmodifiableList(keypointEdge_);
        }
        this.unknownFields = unknownFields.build();
        makeExtensionsImmutable();
      }
    }
    public static final com.google.protobuf.Descriptors.Descriptor
        getDescriptor() {
      return object_detection.protos.Eval.internal_static_object_detection_protos_EvalConfig_descriptor;
    }

    @SuppressWarnings({"rawtypes"})
    @java.lang.Override
    protected com.google.protobuf.MapField internalGetMapField(
        int number) {
      switch (number) {
        case 34:
          return internalGetSuperCategories();
        default:
          throw new RuntimeException(
              "Invalid map field number: " + number);
      }
    }
    @java.lang.Override
    protected com.google.protobuf.GeneratedMessageV3.FieldAccessorTable
        internalGetFieldAccessorTable() {
      return object_detection.protos.Eval.internal_static_object_detection_protos_EvalConfig_fieldAccessorTable
          .ensureFieldAccessorsInitialized(
              object_detection.protos.Eval.EvalConfig.class, object_detection.protos.Eval.EvalConfig.Builder.class);
    }

    private int bitField0_;
    public static final int BATCH_SIZE_FIELD_NUMBER = 25;
    private int batchSize_;
    /**
     * <code>optional uint32 batch_size = 25 [default = 1];</code>
     * @return Whether the batchSize field is set.
     */
    @java.lang.Override
    public boolean hasBatchSize() {
      return ((bitField0_ & 0x00000001) != 0);
    }
    /**
     * <code>optional uint32 batch_size = 25 [default = 1];</code>
     * @return The batchSize.
     */
    @java.lang.Override
    public int getBatchSize() {
      return batchSize_;
    }

    public static final int NUM_VISUALIZATIONS_FIELD_NUMBER = 1;
    private int numVisualizations_;
    /**
     * <pre>
     * Number of visualization images to generate.
     * </pre>
     *
     * <code>optional uint32 num_visualizations = 1 [default = 10];</code>
     * @return Whether the numVisualizations field is set.
     */
    @java.lang.Override
    public boolean hasNumVisualizations() {
      return ((bitField0_ & 0x00000002) != 0);
    }
    /**
     * <pre>
     * Number of visualization images to generate.
     * </pre>
     *
     * <code>optional uint32 num_visualizations = 1 [default = 10];</code>
     * @return The numVisualizations.
     */
    @java.lang.Override
    public int getNumVisualizations() {
      return numVisualizations_;
    }

    public static final int NUM_EXAMPLES_FIELD_NUMBER = 2;
    private int numExamples_;
    /**
     * <pre>
     * Number of examples to process of evaluation.
     * </pre>
     *
     * <code>optional uint32 num_examples = 2 [default = 5000, deprecated = true];</code>
     * @return Whether the numExamples field is set.
     */
    @java.lang.Override
    @java.lang.Deprecated public boolean hasNumExamples() {
      return ((bitField0_ & 0x00000004) != 0);
    }
    /**
     * <pre>
     * Number of examples to process of evaluation.
     * </pre>
     *
     * <code>optional uint32 num_examples = 2 [default = 5000, deprecated = true];</code>
     * @return The numExamples.
     */
    @java.lang.Override
    @java.lang.Deprecated public int getNumExamples() {
      return numExamples_;
    }

    public static final int EVAL_INTERVAL_SECS_FIELD_NUMBER = 3;
    private int evalIntervalSecs_;
    /**
     * <pre>
     * How often to run evaluation.
     * </pre>
     *
     * <code>optional uint32 eval_interval_secs = 3 [default = 300];</code>
     * @return Whether the evalIntervalSecs field is set.
     */
    @java.lang.Override
    public boolean hasEvalIntervalSecs() {
      return ((bitField0_ & 0x00000008) != 0);
    }
    /**
     * <pre>
     * How often to run evaluation.
     * </pre>
     *
     * <code>optional uint32 eval_interval_secs = 3 [default = 300];</code>
     * @return The evalIntervalSecs.
     */
    @java.lang.Override
    public int getEvalIntervalSecs() {
      return evalIntervalSecs_;
    }

    public static final int MAX_EVALS_FIELD_NUMBER = 4;
    private int maxEvals_;
    /**
     * <pre>
     * Maximum number of times to run evaluation. If set to 0, will run forever.
     * </pre>
     *
     * <code>optional uint32 max_evals = 4 [default = 0, deprecated = true];</code>
     * @return Whether the maxEvals field is set.
     */
    @java.lang.Override
    @java.lang.Deprecated public boolean hasMaxEvals() {
      return ((bitField0_ & 0x00000010) != 0);
    }
    /**
     * <pre>
     * Maximum number of times to run evaluation. If set to 0, will run forever.
     * </pre>
     *
     * <code>optional uint32 max_evals = 4 [default = 0, deprecated = true];</code>
     * @return The maxEvals.
     */
    @java.lang.Override
    @java.lang.Deprecated public int getMaxEvals() {
      return maxEvals_;
    }

    public static final int SAVE_GRAPH_FIELD_NUMBER = 5;
    private boolean saveGraph_;
    /**
     * <pre>
     * Whether the TensorFlow graph used for evaluation should be saved to disk.
     * </pre>
     *
     * <code>optional bool save_graph = 5 [default = false];</code>
     * @return Whether the saveGraph field is set.
     */
    @java.lang.Override
    public boolean hasSaveGraph() {
      return ((bitField0_ & 0x00000020) != 0);
    }
    /**
     * <pre>
     * Whether the TensorFlow graph used for evaluation should be saved to disk.
     * </pre>
     *
     * <code>optional bool save_graph = 5 [default = false];</code>
     * @return The saveGraph.
     */
    @java.lang.Override
    public boolean getSaveGraph() {
      return saveGraph_;
    }

    public static final int VISUALIZATION_EXPORT_DIR_FIELD_NUMBER = 6;
    private volatile java.lang.Object visualizationExportDir_;
    /**
     * <pre>
     * Path to directory to store visualizations in. If empty, visualization
     * images are not exported (only shown on Tensorboard).
     * </pre>
     *
     * <code>optional string visualization_export_dir = 6 [default = ""];</code>
     * @return Whether the visualizationExportDir field is set.
     */
    @java.lang.Override
    public boolean hasVisualizationExportDir() {
      return ((bitField0_ & 0x00000040) != 0);
    }
    /**
     * <pre>
     * Path to directory to store visualizations in. If empty, visualization
     * images are not exported (only shown on Tensorboard).
     * </pre>
     *
     * <code>optional string visualization_export_dir = 6 [default = ""];</code>
     * @return The visualizationExportDir.
     */
    @java.lang.Override
    public java.lang.String getVisualizationExportDir() {
      java.lang.Object ref = visualizationExportDir_;
      if (ref instanceof java.lang.String) {
        return (java.lang.String) ref;
      } else {
        com.google.protobuf.ByteString bs =
            (com.google.protobuf.ByteString) ref;
        java.lang.String s = bs.toStringUtf8();
        if (bs.isValidUtf8()) {
          visualizationExportDir_ = s;
        }
        return s;
      }
    }
    /**
     * <pre>
     * Path to directory to store visualizations in. If empty, visualization
     * images are not exported (only shown on Tensorboard).
     * </pre>
     *
     * <code>optional string visualization_export_dir = 6 [default = ""];</code>
     * @return The bytes for visualizationExportDir.
     */
    @java.lang.Override
    public com.google.protobuf.ByteString
        getVisualizationExportDirBytes() {
      java.lang.Object ref = visualizationExportDir_;
      if (ref instanceof java.lang.String) {
        com.google.protobuf.ByteString b =
            com.google.protobuf.ByteString.copyFromUtf8(
                (java.lang.String) ref);
        visualizationExportDir_ = b;
        return b;
      } else {
        return (com.google.protobuf.ByteString) ref;
      }
    }

    public static final int EVAL_MASTER_FIELD_NUMBER = 7;
    private volatile java.lang.Object evalMaster_;
    /**
     * <pre>
     * BNS name of the TensorFlow master.
     * </pre>
     *
     * <code>optional string eval_master = 7 [default = ""];</code>
     * @return Whether the evalMaster field is set.
     */
    @java.lang.Override
    public boolean hasEvalMaster() {
      return ((bitField0_ & 0x00000080) != 0);
    }
    /**
     * <pre>
     * BNS name of the TensorFlow master.
     * </pre>
     *
     * <code>optional string eval_master = 7 [default = ""];</code>
     * @return The evalMaster.
     */
    @java.lang.Override
    public java.lang.String getEvalMaster() {
      java.lang.Object ref = evalMaster_;
      if (ref instanceof java.lang.String) {
        return (java.lang.String) ref;
      } else {
        com.google.protobuf.ByteString bs =
            (com.google.protobuf.ByteString) ref;
        java.lang.String s = bs.toStringUtf8();
        if (bs.isValidUtf8()) {
          evalMaster_ = s;
        }
        return s;
      }
    }
    /**
     * <pre>
     * BNS name of the TensorFlow master.
     * </pre>
     *
     * <code>optional string eval_master = 7 [default = ""];</code>
     * @return The bytes for evalMaster.
     */
    @java.lang.Override
    public com.google.protobuf.ByteString
        getEvalMasterBytes() {
      java.lang.Object ref = evalMaster_;
      if (ref instanceof java.lang.String) {
        com.google.protobuf.ByteString b =
            com.google.protobuf.ByteString.copyFromUtf8(
                (java.lang.String) ref);
        evalMaster_ = b;
        return b;
      } else {
        return (com.google.protobuf.ByteString) ref;
      }
    }

    public static final int METRICS_SET_FIELD_NUMBER = 8;
    private com.google.protobuf.LazyStringList metricsSet_;
    /**
     * <pre>
     * Type of metrics to use for evaluation.
     * </pre>
     *
     * <code>repeated string metrics_set = 8;</code>
     * @return A list containing the metricsSet.
     */
    public com.google.protobuf.ProtocolStringList
        getMetricsSetList() {
      return metricsSet_;
    }
    /**
     * <pre>
     * Type of metrics to use for evaluation.
     * </pre>
     *
     * <code>repeated string metrics_set = 8;</code>
     * @return The count of metricsSet.
     */
    public int getMetricsSetCount() {
      return metricsSet_.size();
    }
    /**
     * <pre>
     * Type of metrics to use for evaluation.
     * </pre>
     *
     * <code>repeated string metrics_set = 8;</code>
     * @param index The index of the element to return.
     * @return The metricsSet at the given index.
     */
    public java.lang.String getMetricsSet(int index) {
      return metricsSet_.get(index);
    }
    /**
     * <pre>
     * Type of metrics to use for evaluation.
     * </pre>
     *
     * <code>repeated string metrics_set = 8;</code>
     * @param index The index of the value to return.
     * @return The bytes of the metricsSet at the given index.
     */
    public com.google.protobuf.ByteString
        getMetricsSetBytes(int index) {
      return metricsSet_.getByteString(index);
    }

    public static final int PARAMETERIZED_METRIC_FIELD_NUMBER = 31;
    private java.util.List<object_detection.protos.Eval.ParameterizedMetric> parameterizedMetric_;
    /**
     * <pre>
     * Type of metrics to use for evaluation. Unlike `metrics_set` above, this
     * field allows configuring evaluation metric through config files.
     * </pre>
     *
     * <code>repeated .object_detection.protos.ParameterizedMetric parameterized_metric = 31;</code>
     */
    @java.lang.Override
    public java.util.List<object_detection.protos.Eval.ParameterizedMetric> getParameterizedMetricList() {
      return parameterizedMetric_;
    }
    /**
     * <pre>
     * Type of metrics to use for evaluation. Unlike `metrics_set` above, this
     * field allows configuring evaluation metric through config files.
     * </pre>
     *
     * <code>repeated .object_detection.protos.ParameterizedMetric parameterized_metric = 31;</code>
     */
    @java.lang.Override
    public java.util.List<? extends object_detection.protos.Eval.ParameterizedMetricOrBuilder>
        getParameterizedMetricOrBuilderList() {
      return parameterizedMetric_;
    }
    /**
     * <pre>
     * Type of metrics to use for evaluation. Unlike `metrics_set` above, this
     * field allows configuring evaluation metric through config files.
     * </pre>
     *
     * <code>repeated .object_detection.protos.ParameterizedMetric parameterized_metric = 31;</code>
     */
    @java.lang.Override
    public int getParameterizedMetricCount() {
      return parameterizedMetric_.size();
    }
    /**
     * <pre>
     * Type of metrics to use for evaluation. Unlike `metrics_set` above, this
     * field allows configuring evaluation metric through config files.
     * </pre>
     *
     * <code>repeated .object_detection.protos.ParameterizedMetric parameterized_metric = 31;</code>
     */
    @java.lang.Override
    public object_detection.protos.Eval.ParameterizedMetric getParameterizedMetric(int index) {
      return parameterizedMetric_.get(index);
    }
    /**
     * <pre>
     * Type of metrics to use for evaluation. Unlike `metrics_set` above, this
     * field allows configuring evaluation metric through config files.
     * </pre>
     *
     * <code>repeated .object_detection.protos.ParameterizedMetric parameterized_metric = 31;</code>
     */
    @java.lang.Override
    public object_detection.protos.Eval.ParameterizedMetricOrBuilder getParameterizedMetricOrBuilder(
        int index) {
      return parameterizedMetric_.get(index);
    }

    public static final int EXPORT_PATH_FIELD_NUMBER = 9;
    private volatile java.lang.Object exportPath_;
    /**
     * <pre>
     * Path to export detections to COCO compatible JSON format.
     * </pre>
     *
     * <code>optional string export_path = 9 [default = ""];</code>
     * @return Whether the exportPath field is set.
     */
    @java.lang.Override
    public boolean hasExportPath() {
      return ((bitField0_ & 0x00000100) != 0);
    }
    /**
     * <pre>
     * Path to export detections to COCO compatible JSON format.
     * </pre>
     *
     * <code>optional string export_path = 9 [default = ""];</code>
     * @return The exportPath.
     */
    @java.lang.Override
    public java.lang.String getExportPath() {
      java.lang.Object ref = exportPath_;
      if (ref instanceof java.lang.String) {
        return (java.lang.String) ref;
      } else {
        com.google.protobuf.ByteString bs =
            (com.google.protobuf.ByteString) ref;
        java.lang.String s = bs.toStringUtf8();
        if (bs.isValidUtf8()) {
          exportPath_ = s;
        }
        return s;
      }
    }
    /**
     * <pre>
     * Path to export detections to COCO compatible JSON format.
     * </pre>
     *
     * <code>optional string export_path = 9 [default = ""];</code>
     * @return The bytes for exportPath.
     */
    @java.lang.Override
    public com.google.protobuf.ByteString
        getExportPathBytes() {
      java.lang.Object ref = exportPath_;
      if (ref instanceof java.lang.String) {
        com.google.protobuf.ByteString b =
            com.google.protobuf.ByteString.copyFromUtf8(
                (java.lang.String) ref);
        exportPath_ = b;
        return b;
      } else {
        return (com.google.protobuf.ByteString) ref;
      }
    }

    public static final int IGNORE_GROUNDTRUTH_FIELD_NUMBER = 10;
    private boolean ignoreGroundtruth_;
    /**
     * <pre>
     * Option to not read groundtruth labels and only export detections to
     * COCO-compatible JSON file.
     * </pre>
     *
     * <code>optional bool ignore_groundtruth = 10 [default = false];</code>
     * @return Whether the ignoreGroundtruth field is set.
     */
    @java.lang.Override
    public boolean hasIgnoreGroundtruth() {
      return ((bitField0_ & 0x00000200) != 0);
    }
    /**
     * <pre>
     * Option to not read groundtruth labels and only export detections to
     * COCO-compatible JSON file.
     * </pre>
     *
     * <code>optional bool ignore_groundtruth = 10 [default = false];</code>
     * @return The ignoreGroundtruth.
     */
    @java.lang.Override
    public boolean getIgnoreGroundtruth() {
      return ignoreGroundtruth_;
    }

    public static final int USE_MOVING_AVERAGES_FIELD_NUMBER = 11;
    private boolean useMovingAverages_;
    /**
     * <pre>
     * Use exponential moving averages of variables for evaluation.
     * TODO(rathodv): When this is false make sure the model is constructed
     * without moving averages in restore_fn.
     * </pre>
     *
     * <code>optional bool use_moving_averages = 11 [default = false];</code>
     * @return Whether the useMovingAverages field is set.
     */
    @java.lang.Override
    public boolean hasUseMovingAverages() {
      return ((bitField0_ & 0x00000400) != 0);
    }
    /**
     * <pre>
     * Use exponential moving averages of variables for evaluation.
     * TODO(rathodv): When this is false make sure the model is constructed
     * without moving averages in restore_fn.
     * </pre>
     *
     * <code>optional bool use_moving_averages = 11 [default = false];</code>
     * @return The useMovingAverages.
     */
    @java.lang.Override
    public boolean getUseMovingAverages() {
      return useMovingAverages_;
    }

    public static final int EVAL_INSTANCE_MASKS_FIELD_NUMBER = 12;
    private boolean evalInstanceMasks_;
    /**
     * <pre>
     * Whether to evaluate instance masks.
     * Note that since there is no evaluation code currently for instance
     * segmentation this option is unused.
     * </pre>
     *
     * <code>optional bool eval_instance_masks = 12 [default = false];</code>
     * @return Whether the evalInstanceMasks field is set.
     */
    @java.lang.Override
    public boolean hasEvalInstanceMasks() {
      return ((bitField0_ & 0x00000800) != 0);
    }
    /**
     * <pre>
     * Whether to evaluate instance masks.
     * Note that since there is no evaluation code currently for instance
     * segmentation this option is unused.
     * </pre>
     *
     * <code>optional bool eval_instance_masks = 12 [default = false];</code>
     * @return The evalInstanceMasks.
     */
    @java.lang.Override
    public boolean getEvalInstanceMasks() {
      return evalInstanceMasks_;
    }

    public static final int MIN_SCORE_THRESHOLD_FIELD_NUMBER = 13;
    private float minScoreThreshold_;
    /**
     * <pre>
     * Minimum score threshold for a detected object box to be visualized
     * </pre>
     *
     * <code>optional float min_score_threshold = 13 [default = 0.5];</code>
     * @return Whether the minScoreThreshold field is set.
     */
    @java.lang.Override
    public boolean hasMinScoreThreshold() {
      return ((bitField0_ & 0x00001000) != 0);
    }
    /**
     * <pre>
     * Minimum score threshold for a detected object box to be visualized
     * </pre>
     *
     * <code>optional float min_score_threshold = 13 [default = 0.5];</code>
     * @return The minScoreThreshold.
     */
    @java.lang.Override
    public float getMinScoreThreshold() {
      return minScoreThreshold_;
    }

    public static final int MAX_NUM_BOXES_TO_VISUALIZE_FIELD_NUMBER = 14;
    private int maxNumBoxesToVisualize_;
    /**
     * <pre>
     * Maximum number of detections to visualize
     * </pre>
     *
     * <code>optional int32 max_num_boxes_to_visualize = 14 [default = 20];</code>
     * @return Whether the maxNumBoxesToVisualize field is set.
     */
    @java.lang.Override
    public boolean hasMaxNumBoxesToVisualize() {
      return ((bitField0_ & 0x00002000) != 0);
    }
    /**
     * <pre>
     * Maximum number of detections to visualize
     * </pre>
     *
     * <code>optional int32 max_num_boxes_to_visualize = 14 [default = 20];</code>
     * @return The maxNumBoxesToVisualize.
     */
    @java.lang.Override
    public int getMaxNumBoxesToVisualize() {
      return maxNumBoxesToVisualize_;
    }

    public static final int SKIP_SCORES_FIELD_NUMBER = 15;
    private boolean skipScores_;
    /**
     * <pre>
     * When drawing a single detection, each label is by default visualized as
     * &lt;label name&gt; : &lt;label score&gt;. One can skip the name or/and score using the
     * following fields:
     * </pre>
     *
     * <code>optional bool skip_scores = 15 [default = false];</code>
     * @return Whether the skipScores field is set.
     */
    @java.lang.Override
    public boolean hasSkipScores() {
      return ((bitField0_ & 0x00004000) != 0);
    }
    /**
     * <pre>
     * When drawing a single detection, each label is by default visualized as
     * &lt;label name&gt; : &lt;label score&gt;. One can skip the name or/and score using the
     * following fields:
     * </pre>
     *
     * <code>optional bool skip_scores = 15 [default = false];</code>
     * @return The skipScores.
     */
    @java.lang.Override
    public boolean getSkipScores() {
      return skipScores_;
    }

    public static final int SKIP_LABELS_FIELD_NUMBER = 16;
    private boolean skipLabels_;
    /**
     * <code>optional bool skip_labels = 16 [default = false];</code>
     * @return Whether the skipLabels field is set.
     */
    @java.lang.Override
    public boolean hasSkipLabels() {
      return ((bitField0_ & 0x00008000) != 0);
    }
    /**
     * <code>optional bool skip_labels = 16 [default = false];</code>
     * @return The skipLabels.
     */
    @java.lang.Override
    public boolean getSkipLabels() {
      return skipLabels_;
    }

    public static final int VISUALIZE_GROUNDTRUTH_BOXES_FIELD_NUMBER = 17;
    private boolean visualizeGroundtruthBoxes_;
    /**
     * <pre>
     * Whether to show groundtruth boxes in addition to detected boxes in
     * visualizations.
     * </pre>
     *
     * <code>optional bool visualize_groundtruth_boxes = 17 [default = false];</code>
     * @return Whether the visualizeGroundtruthBoxes field is set.
     */
    @java.lang.Override
    public boolean hasVisualizeGroundtruthBoxes() {
      return ((bitField0_ & 0x00010000) != 0);
    }
    /**
     * <pre>
     * Whether to show groundtruth boxes in addition to detected boxes in
     * visualizations.
     * </pre>
     *
     * <code>optional bool visualize_groundtruth_boxes = 17 [default = false];</code>
     * @return The visualizeGroundtruthBoxes.
     */
    @java.lang.Override
    public boolean getVisualizeGroundtruthBoxes() {
      return visualizeGroundtruthBoxes_;
    }

    public static final int GROUNDTRUTH_BOX_VISUALIZATION_COLOR_FIELD_NUMBER = 18;
    private volatile java.lang.Object groundtruthBoxVisualizationColor_;
    /**
     * <pre>
     * Box color for visualizing groundtruth boxes.
     * </pre>
     *
     * <code>optional string groundtruth_box_visualization_color = 18 [default = "black"];</code>
     * @return Whether the groundtruthBoxVisualizationColor field is set.
     */
    @java.lang.Override
    public boolean hasGroundtruthBoxVisualizationColor() {
      return ((bitField0_ & 0x00020000) != 0);
    }
    /**
     * <pre>
     * Box color for visualizing groundtruth boxes.
     * </pre>
     *
     * <code>optional string groundtruth_box_visualization_color = 18 [default = "black"];</code>
     * @return The groundtruthBoxVisualizationColor.
     */
    @java.lang.Override
    public java.lang.String getGroundtruthBoxVisualizationColor() {
      java.lang.Object ref = groundtruthBoxVisualizationColor_;
      if (ref instanceof java.lang.String) {
        return (java.lang.String) ref;
      } else {
        com.google.protobuf.ByteString bs =
            (com.google.protobuf.ByteString) ref;
        java.lang.String s = bs.toStringUtf8();
        if (bs.isValidUtf8()) {
          groundtruthBoxVisualizationColor_ = s;
        }
        return s;
      }
    }
    /**
     * <pre>
     * Box color for visualizing groundtruth boxes.
     * </pre>
     *
     * <code>optional string groundtruth_box_visualization_color = 18 [default = "black"];</code>
     * @return The bytes for groundtruthBoxVisualizationColor.
     */
    @java.lang.Override
    public com.google.protobuf.ByteString
        getGroundtruthBoxVisualizationColorBytes() {
      java.lang.Object ref = groundtruthBoxVisualizationColor_;
      if (ref instanceof java.lang.String) {
        com.google.protobuf.ByteString b =
            com.google.protobuf.ByteString.copyFromUtf8(
                (java.lang.String) ref);
        groundtruthBoxVisualizationColor_ = b;
        return b;
      } else {
        return (com.google.protobuf.ByteString) ref;
      }
    }

    public static final int KEEP_IMAGE_ID_FOR_VISUALIZATION_EXPORT_FIELD_NUMBER = 19;
    private boolean keepImageIdForVisualizationExport_;
    /**
     * <pre>
     * Whether to keep image identifier in filename when exported to
     * visualization_export_dir.
     * </pre>
     *
     * <code>optional bool keep_image_id_for_visualization_export = 19 [default = false];</code>
     * @return Whether the keepImageIdForVisualizationExport field is set.
     */
    @java.lang.Override
    public boolean hasKeepImageIdForVisualizationExport() {
      return ((bitField0_ & 0x00040000) != 0);
    }
    /**
     * <pre>
     * Whether to keep image identifier in filename when exported to
     * visualization_export_dir.
     * </pre>
     *
     * <code>optional bool keep_image_id_for_visualization_export = 19 [default = false];</code>
     * @return The keepImageIdForVisualizationExport.
     */
    @java.lang.Override
    public boolean getKeepImageIdForVisualizationExport() {
      return keepImageIdForVisualizationExport_;
    }

    public static final int RETAIN_ORIGINAL_IMAGES_FIELD_NUMBER = 23;
    private boolean retainOriginalImages_;
    /**
     * <pre>
     * Whether to retain original images (i.e. not pre-processed) in the tensor
     * dictionary, so that they can be displayed in Tensorboard.
     * </pre>
     *
     * <code>optional bool retain_original_images = 23 [default = true];</code>
     * @return Whether the retainOriginalImages field is set.
     */
    @java.lang.Override
    public boolean hasRetainOriginalImages() {
      return ((bitField0_ & 0x00080000) != 0);
    }
    /**
     * <pre>
     * Whether to retain original images (i.e. not pre-processed) in the tensor
     * dictionary, so that they can be displayed in Tensorboard.
     * </pre>
     *
     * <code>optional bool retain_original_images = 23 [default = true];</code>
     * @return The retainOriginalImages.
     */
    @java.lang.Override
    public boolean getRetainOriginalImages() {
      return retainOriginalImages_;
    }

    public static final int INCLUDE_METRICS_PER_CATEGORY_FIELD_NUMBER = 24;
    private boolean includeMetricsPerCategory_;
    /**
     * <pre>
     * If True, additionally include per-category metrics.
     * </pre>
     *
     * <code>optional bool include_metrics_per_category = 24 [default = false];</code>
     * @return Whether the includeMetricsPerCategory field is set.
     */
    @java.lang.Override
    public boolean hasIncludeMetricsPerCategory() {
      return ((bitField0_ & 0x00100000) != 0);
    }
    /**
     * <pre>
     * If True, additionally include per-category metrics.
     * </pre>
     *
     * <code>optional bool include_metrics_per_category = 24 [default = false];</code>
     * @return The includeMetricsPerCategory.
     */
    @java.lang.Override
    public boolean getIncludeMetricsPerCategory() {
      return includeMetricsPerCategory_;
    }

    public static final int ALL_METRICS_PER_CATEGORY_FIELD_NUMBER = 35;
    private boolean allMetricsPerCategory_;
    /**
     * <pre>
     * If true, includes all metrics per category.
     * </pre>
     *
     * <code>optional bool all_metrics_per_category = 35 [default = false];</code>
     * @return Whether the allMetricsPerCategory field is set.
     */
    @java.lang.Override
    public boolean hasAllMetricsPerCategory() {
      return ((bitField0_ & 0x00200000) != 0);
    }
    /**
     * <pre>
     * If true, includes all metrics per category.
     * </pre>
     *
     * <code>optional bool all_metrics_per_category = 35 [default = false];</code>
     * @return The allMetricsPerCategory.
     */
    @java.lang.Override
    public boolean getAllMetricsPerCategory() {
      return allMetricsPerCategory_;
    }

    public static final int SUPER_CATEGORIES_FIELD_NUMBER = 34;
    private static final class SuperCategoriesDefaultEntryHolder {
      static final com.google.protobuf.MapEntry<
          java.lang.String, java.lang.String> defaultEntry =
              com.google.protobuf.MapEntry
              .<java.lang.String, java.lang.String>newDefaultInstance(
                  object_detection.protos.Eval.internal_static_object_detection_protos_EvalConfig_SuperCategoriesEntry_descriptor,
                  com.google.protobuf.WireFormat.FieldType.STRING,
                  "",
                  com.google.protobuf.WireFormat.FieldType.STRING,
                  "");
    }
    private com.google.protobuf.MapField<
        java.lang.String, java.lang.String> superCategories_;
    private com.google.protobuf.MapField<java.lang.String, java.lang.String>
    internalGetSuperCategories() {
      if (superCategories_ == null) {
        return com.google.protobuf.MapField.emptyMapField(
            SuperCategoriesDefaultEntryHolder.defaultEntry);
      }
      return superCategories_;
    }

    public int getSuperCategoriesCount() {
      return internalGetSuperCategories().getMap().size();
    }
    /**
     * <pre>
     * Optional super-category definitions: keys are super-category names;
     * values are comma-separated categories (assumed to correspond to category
     * names (`display_name`) in the label map.
     * </pre>
     *
     * <code>map&lt;string, string&gt; super_categories = 34;</code>
     */

    @java.lang.Override
    public boolean containsSuperCategories(
        java.lang.String key) {
      if (key == null) { throw new java.lang.NullPointerException(); }
      return internalGetSuperCategories().getMap().containsKey(key);
    }
    /**
     * Use {@link #getSuperCategoriesMap()} instead.
     */
    @java.lang.Override
    @java.lang.Deprecated
    public java.util.Map<java.lang.String, java.lang.String> getSuperCategories() {
      return getSuperCategoriesMap();
    }
    /**
     * <pre>
     * Optional super-category definitions: keys are super-category names;
     * values are comma-separated categories (assumed to correspond to category
     * names (`display_name`) in the label map.
     * </pre>
     *
     * <code>map&lt;string, string&gt; super_categories = 34;</code>
     */
    @java.lang.Override

    public java.util.Map<java.lang.String, java.lang.String> getSuperCategoriesMap() {
      return internalGetSuperCategories().getMap();
    }
    /**
     * <pre>
     * Optional super-category definitions: keys are super-category names;
     * values are comma-separated categories (assumed to correspond to category
     * names (`display_name`) in the label map.
     * </pre>
     *
     * <code>map&lt;string, string&gt; super_categories = 34;</code>
     */
    @java.lang.Override

    public java.lang.String getSuperCategoriesOrDefault(
        java.lang.String key,
        java.lang.String defaultValue) {
      if (key == null) { throw new java.lang.NullPointerException(); }
      java.util.Map<java.lang.String, java.lang.String> map =
          internalGetSuperCategories().getMap();
      return map.containsKey(key) ? map.get(key) : defaultValue;
    }
    /**
     * <pre>
     * Optional super-category definitions: keys are super-category names;
     * values are comma-separated categories (assumed to correspond to category
     * names (`display_name`) in the label map.
     * </pre>
     *
     * <code>map&lt;string, string&gt; super_categories = 34;</code>
     */
    @java.lang.Override

    public java.lang.String getSuperCategoriesOrThrow(
        java.lang.String key) {
      if (key == null) { throw new java.lang.NullPointerException(); }
      java.util.Map<java.lang.String, java.lang.String> map =
          internalGetSuperCategories().getMap();
      if (!map.containsKey(key)) {
        throw new java.lang.IllegalArgumentException();
      }
      return map.get(key);
    }

    public static final int RECALL_LOWER_BOUND_FIELD_NUMBER = 26;
    private float recallLowerBound_;
    /**
     * <pre>
     * Recall range within which precision should be computed.
     * </pre>
     *
     * <code>optional float recall_lower_bound = 26 [default = 0];</code>
     * @return Whether the recallLowerBound field is set.
     */
    @java.lang.Override
    public boolean hasRecallLowerBound() {
      return ((bitField0_ & 0x00400000) != 0);
    }
    /**
     * <pre>
     * Recall range within which precision should be computed.
     * </pre>
     *
     * <code>optional float recall_lower_bound = 26 [default = 0];</code>
     * @return The recallLowerBound.
     */
    @java.lang.Override
    public float getRecallLowerBound() {
      return recallLowerBound_;
    }

    public static final int RECALL_UPPER_BOUND_FIELD_NUMBER = 27;
    private float recallUpperBound_;
    /**
     * <code>optional float recall_upper_bound = 27 [default = 1];</code>
     * @return Whether the recallUpperBound field is set.
     */
    @java.lang.Override
    public boolean hasRecallUpperBound() {
      return ((bitField0_ & 0x00800000) != 0);
    }
    /**
     * <code>optional float recall_upper_bound = 27 [default = 1];</code>
     * @return The recallUpperBound.
     */
    @java.lang.Override
    public float getRecallUpperBound() {
      return recallUpperBound_;
    }

    public static final int RETAIN_ORIGINAL_IMAGE_ADDITIONAL_CHANNELS_FIELD_NUMBER = 28;
    private boolean retainOriginalImageAdditionalChannels_;
    /**
     * <pre>
     * Whether to retain additional channels (i.e. not pre-processed) in the
     * tensor dictionary, so that they can be displayed in Tensorboard.
     * </pre>
     *
     * <code>optional bool retain_original_image_additional_channels = 28 [default = false];</code>
     * @return Whether the retainOriginalImageAdditionalChannels field is set.
     */
    @java.lang.Override
    public boolean hasRetainOriginalImageAdditionalChannels() {
      return ((bitField0_ & 0x01000000) != 0);
    }
    /**
     * <pre>
     * Whether to retain additional channels (i.e. not pre-processed) in the
     * tensor dictionary, so that they can be displayed in Tensorboard.
     * </pre>
     *
     * <code>optional bool retain_original_image_additional_channels = 28 [default = false];</code>
     * @return The retainOriginalImageAdditionalChannels.
     */
    @java.lang.Override
    public boolean getRetainOriginalImageAdditionalChannels() {
      return retainOriginalImageAdditionalChannels_;
    }

    public static final int FORCE_NO_RESIZE_FIELD_NUMBER = 29;
    private boolean forceNoResize_;
    /**
     * <pre>
     * When this flag is set, images are not resized during evaluation.
     * When this flag is not set (default case), image are resized according
     * to the image_resizer config in the model during evaluation.
     * </pre>
     *
     * <code>optional bool force_no_resize = 29 [default = false];</code>
     * @return Whether the forceNoResize field is set.
     */
    @java.lang.Override
    public boolean hasForceNoResize() {
      return ((bitField0_ & 0x02000000) != 0);
    }
    /**
     * <pre>
     * When this flag is set, images are not resized during evaluation.
     * When this flag is not set (default case), image are resized according
     * to the image_resizer config in the model during evaluation.
     * </pre>
     *
     * <code>optional bool force_no_resize = 29 [default = false];</code>
     * @return The forceNoResize.
     */
    @java.lang.Override
    public boolean getForceNoResize() {
      return forceNoResize_;
    }

    public static final int USE_DUMMY_LOSS_IN_EVAL_FIELD_NUMBER = 30;
    private boolean useDummyLossInEval_;
    /**
     * <pre>
     * Whether to use a dummy loss in eval so model.loss() is not executed.
     * </pre>
     *
     * <code>optional bool use_dummy_loss_in_eval = 30 [default = false];</code>
     * @return Whether the useDummyLossInEval field is set.
     */
    @java.lang.Override
    public boolean hasUseDummyLossInEval() {
      return ((bitField0_ & 0x04000000) != 0);
    }
    /**
     * <pre>
     * Whether to use a dummy loss in eval so model.loss() is not executed.
     * </pre>
     *
     * <code>optional bool use_dummy_loss_in_eval = 30 [default = false];</code>
     * @return The useDummyLossInEval.
     */
    @java.lang.Override
    public boolean getUseDummyLossInEval() {
      return useDummyLossInEval_;
    }

    public static final int KEYPOINT_EDGE_FIELD_NUMBER = 32;
    private java.util.List<object_detection.protos.Eval.KeypointEdge> keypointEdge_;
    /**
     * <pre>
     * Specifies which keypoints should be connected by an edge, which may improve
     * visualization. An example would be human pose estimation where certain
     * joints can be connected.
     * </pre>
     *
     * <code>repeated .object_detection.protos.KeypointEdge keypoint_edge = 32;</code>
     */
    @java.lang.Override
    public java.util.List<object_detection.protos.Eval.KeypointEdge> getKeypointEdgeList() {
      return keypointEdge_;
    }
    /**
     * <pre>
     * Specifies which keypoints should be connected by an edge, which may improve
     * visualization. An example would be human pose estimation where certain
     * joints can be connected.
     * </pre>
     *
     * <code>repeated .object_detection.protos.KeypointEdge keypoint_edge = 32;</code>
     */
    @java.lang.Override
    public java.util.List<? extends object_detection.protos.Eval.KeypointEdgeOrBuilder>
        getKeypointEdgeOrBuilderList() {
      return keypointEdge_;
    }
    /**
     * <pre>
     * Specifies which keypoints should be connected by an edge, which may improve
     * visualization. An example would be human pose estimation where certain
     * joints can be connected.
     * </pre>
     *
     * <code>repeated .object_detection.protos.KeypointEdge keypoint_edge = 32;</code>
     */
    @java.lang.Override
    public int getKeypointEdgeCount() {
      return keypointEdge_.size();
    }
    /**
     * <pre>
     * Specifies which keypoints should be connected by an edge, which may improve
     * visualization. An example would be human pose estimation where certain
     * joints can be connected.
     * </pre>
     *
     * <code>repeated .object_detection.protos.KeypointEdge keypoint_edge = 32;</code>
     */
    @java.lang.Override
    public object_detection.protos.Eval.KeypointEdge getKeypointEdge(int index) {
      return keypointEdge_.get(index);
    }
    /**
     * <pre>
     * Specifies which keypoints should be connected by an edge, which may improve
     * visualization. An example would be human pose estimation where certain
     * joints can be connected.
     * </pre>
     *
     * <code>repeated .object_detection.protos.KeypointEdge keypoint_edge = 32;</code>
     */
    @java.lang.Override
    public object_detection.protos.Eval.KeypointEdgeOrBuilder getKeypointEdgeOrBuilder(
        int index) {
      return keypointEdge_.get(index);
    }

    public static final int SKIP_PREDICTIONS_FOR_UNLABELED_CLASS_FIELD_NUMBER = 33;
    private boolean skipPredictionsForUnlabeledClass_;
    /**
     * <pre>
     * The "groundtruth_labeled_classes" field indicates which classes have been
     * labeled on the images. If skip_predictions_for_unlabeled_class is set,
     * detector predictions that do not match to the groundtruth_labeled_classes
     * will be ignored. This is useful for evaluating on test data that are not
     * exhaustively labeled.
     * </pre>
     *
     * <code>optional bool skip_predictions_for_unlabeled_class = 33 [default = false];</code>
     * @return Whether the skipPredictionsForUnlabeledClass field is set.
     */
    @java.lang.Override
    public boolean hasSkipPredictionsForUnlabeledClass() {
      return ((bitField0_ & 0x08000000) != 0);
    }
    /**
     * <pre>
     * The "groundtruth_labeled_classes" field indicates which classes have been
     * labeled on the images. If skip_predictions_for_unlabeled_class is set,
     * detector predictions that do not match to the groundtruth_labeled_classes
     * will be ignored. This is useful for evaluating on test data that are not
     * exhaustively labeled.
     * </pre>
     *
     * <code>optional bool skip_predictions_for_unlabeled_class = 33 [default = false];</code>
     * @return The skipPredictionsForUnlabeledClass.
     */
    @java.lang.Override
    public boolean getSkipPredictionsForUnlabeledClass() {
      return skipPredictionsForUnlabeledClass_;
    }

    private byte memoizedIsInitialized = -1;
    @java.lang.Override
    public final boolean isInitialized() {
      byte isInitialized = memoizedIsInitialized;
      if (isInitialized == 1) return true;
      if (isInitialized == 0) return false;

      memoizedIsInitialized = 1;
      return true;
    }

    @java.lang.Override
    public void writeTo(com.google.protobuf.CodedOutputStream output)
                        throws java.io.IOException {
      if (((bitField0_ & 0x00000002) != 0)) {
        output.writeUInt32(1, numVisualizations_);
      }
      if (((bitField0_ & 0x00000004) != 0)) {
        output.writeUInt32(2, numExamples_);
      }
      if (((bitField0_ & 0x00000008) != 0)) {
        output.writeUInt32(3, evalIntervalSecs_);
      }
      if (((bitField0_ & 0x00000010) != 0)) {
        output.writeUInt32(4, maxEvals_);
      }
      if (((bitField0_ & 0x00000020) != 0)) {
        output.writeBool(5, saveGraph_);
      }
      if (((bitField0_ & 0x00000040) != 0)) {
        com.google.protobuf.GeneratedMessageV3.writeString(output, 6, visualizationExportDir_);
      }
      if (((bitField0_ & 0x00000080) != 0)) {
        com.google.protobuf.GeneratedMessageV3.writeString(output, 7, evalMaster_);
      }
      for (int i = 0; i < metricsSet_.size(); i++) {
        com.google.protobuf.GeneratedMessageV3.writeString(output, 8, metricsSet_.getRaw(i));
      }
      if (((bitField0_ & 0x00000100) != 0)) {
        com.google.protobuf.GeneratedMessageV3.writeString(output, 9, exportPath_);
      }
      if (((bitField0_ & 0x00000200) != 0)) {
        output.writeBool(10, ignoreGroundtruth_);
      }
      if (((bitField0_ & 0x00000400) != 0)) {
        output.writeBool(11, useMovingAverages_);
      }
      if (((bitField0_ & 0x00000800) != 0)) {
        output.writeBool(12, evalInstanceMasks_);
      }
      if (((bitField0_ & 0x00001000) != 0)) {
        output.writeFloat(13, minScoreThreshold_);
      }
      if (((bitField0_ & 0x00002000) != 0)) {
        output.writeInt32(14, maxNumBoxesToVisualize_);
      }
      if (((bitField0_ & 0x00004000) != 0)) {
        output.writeBool(15, skipScores_);
      }
      if (((bitField0_ & 0x00008000) != 0)) {
        output.writeBool(16, skipLabels_);
      }
      if (((bitField0_ & 0x00010000) != 0)) {
        output.writeBool(17, visualizeGroundtruthBoxes_);
      }
      if (((bitField0_ & 0x00020000) != 0)) {
        com.google.protobuf.GeneratedMessageV3.writeString(output, 18, groundtruthBoxVisualizationColor_);
      }
      if (((bitField0_ & 0x00040000) != 0)) {
        output.writeBool(19, keepImageIdForVisualizationExport_);
      }
      if (((bitField0_ & 0x00080000) != 0)) {
        output.writeBool(23, retainOriginalImages_);
      }
      if (((bitField0_ & 0x00100000) != 0)) {
        output.writeBool(24, includeMetricsPerCategory_);
      }
      if (((bitField0_ & 0x00000001) != 0)) {
        output.writeUInt32(25, batchSize_);
      }
      if (((bitField0_ & 0x00400000) != 0)) {
        output.writeFloat(26, recallLowerBound_);
      }
      if (((bitField0_ & 0x00800000) != 0)) {
        output.writeFloat(27, recallUpperBound_);
      }
      if (((bitField0_ & 0x01000000) != 0)) {
        output.writeBool(28, retainOriginalImageAdditionalChannels_);
      }
      if (((bitField0_ & 0x02000000) != 0)) {
        output.writeBool(29, forceNoResize_);
      }
      if (((bitField0_ & 0x04000000) != 0)) {
        output.writeBool(30, useDummyLossInEval_);
      }
      for (int i = 0; i < parameterizedMetric_.size(); i++) {
        output.writeMessage(31, parameterizedMetric_.get(i));
      }
      for (int i = 0; i < keypointEdge_.size(); i++) {
        output.writeMessage(32, keypointEdge_.get(i));
      }
      if (((bitField0_ & 0x08000000) != 0)) {
        output.writeBool(33, skipPredictionsForUnlabeledClass_);
      }
      com.google.protobuf.GeneratedMessageV3
        .serializeStringMapTo(
          output,
          internalGetSuperCategories(),
          SuperCategoriesDefaultEntryHolder.defaultEntry,
          34);
      if (((bitField0_ & 0x00200000) != 0)) {
        output.writeBool(35, allMetricsPerCategory_);
      }
      unknownFields.writeTo(output);
    }

    @java.lang.Override
    public int getSerializedSize() {
      int size = memoizedSize;
      if (size != -1) return size;

      size = 0;
      if (((bitField0_ & 0x00000002) != 0)) {
        size += com.google.protobuf.CodedOutputStream
          .computeUInt32Size(1, numVisualizations_);
      }
      if (((bitField0_ & 0x00000004) != 0)) {
        size += com.google.protobuf.CodedOutputStream
          .computeUInt32Size(2, numExamples_);
      }
      if (((bitField0_ & 0x00000008) != 0)) {
        size += com.google.protobuf.CodedOutputStream
          .computeUInt32Size(3, evalIntervalSecs_);
      }
      if (((bitField0_ & 0x00000010) != 0)) {
        size += com.google.protobuf.CodedOutputStream
          .computeUInt32Size(4, maxEvals_);
      }
      if (((bitField0_ & 0x00000020) != 0)) {
        size += com.google.protobuf.CodedOutputStream
          .computeBoolSize(5, saveGraph_);
      }
      if (((bitField0_ & 0x00000040) != 0)) {
        size += com.google.protobuf.GeneratedMessageV3.computeStringSize(6, visualizationExportDir_);
      }
      if (((bitField0_ & 0x00000080) != 0)) {
        size += com.google.protobuf.GeneratedMessageV3.computeStringSize(7, evalMaster_);
      }
      {
        int dataSize = 0;
        for (int i = 0; i < metricsSet_.size(); i++) {
          dataSize += computeStringSizeNoTag(metricsSet_.getRaw(i));
        }
        size += dataSize;
        size += 1 * getMetricsSetList().size();
      }
      if (((bitField0_ & 0x00000100) != 0)) {
        size += com.google.protobuf.GeneratedMessageV3.computeStringSize(9, exportPath_);
      }
      if (((bitField0_ & 0x00000200) != 0)) {
        size += com.google.protobuf.CodedOutputStream
          .computeBoolSize(10, ignoreGroundtruth_);
      }
      if (((bitField0_ & 0x00000400) != 0)) {
        size += com.google.protobuf.CodedOutputStream
          .computeBoolSize(11, useMovingAverages_);
      }
      if (((bitField0_ & 0x00000800) != 0)) {
        size += com.google.protobuf.CodedOutputStream
          .computeBoolSize(12, evalInstanceMasks_);
      }
      if (((bitField0_ & 0x00001000) != 0)) {
        size += com.google.protobuf.CodedOutputStream
          .computeFloatSize(13, minScoreThreshold_);
      }
      if (((bitField0_ & 0x00002000) != 0)) {
        size += com.google.protobuf.CodedOutputStream
          .computeInt32Size(14, maxNumBoxesToVisualize_);
      }
      if (((bitField0_ & 0x00004000) != 0)) {
        size += com.google.protobuf.CodedOutputStream
          .computeBoolSize(15, skipScores_);
      }
      if (((bitField0_ & 0x00008000) != 0)) {
        size += com.google.protobuf.CodedOutputStream
          .computeBoolSize(16, skipLabels_);
      }
      if (((bitField0_ & 0x00010000) != 0)) {
        size += com.google.protobuf.CodedOutputStream
          .computeBoolSize(17, visualizeGroundtruthBoxes_);
      }
      if (((bitField0_ & 0x00020000) != 0)) {
        size += com.google.protobuf.GeneratedMessageV3.computeStringSize(18, groundtruthBoxVisualizationColor_);
      }
      if (((bitField0_ & 0x00040000) != 0)) {
        size += com.google.protobuf.CodedOutputStream
          .computeBoolSize(19, keepImageIdForVisualizationExport_);
      }
      if (((bitField0_ & 0x00080000) != 0)) {
        size += com.google.protobuf.CodedOutputStream
          .computeBoolSize(23, retainOriginalImages_);
      }
      if (((bitField0_ & 0x00100000) != 0)) {
        size += com.google.protobuf.CodedOutputStream
          .computeBoolSize(24, includeMetricsPerCategory_);
      }
      if (((bitField0_ & 0x00000001) != 0)) {
        size += com.google.protobuf.CodedOutputStream
          .computeUInt32Size(25, batchSize_);
      }
      if (((bitField0_ & 0x00400000) != 0)) {
        size += com.google.protobuf.CodedOutputStream
          .computeFloatSize(26, recallLowerBound_);
      }
      if (((bitField0_ & 0x00800000) != 0)) {
        size += com.google.protobuf.CodedOutputStream
          .computeFloatSize(27, recallUpperBound_);
      }
      if (((bitField0_ & 0x01000000) != 0)) {
        size += com.google.protobuf.CodedOutputStream
          .computeBoolSize(28, retainOriginalImageAdditionalChannels_);
      }
      if (((bitField0_ & 0x02000000) != 0)) {
        size += com.google.protobuf.CodedOutputStream
          .computeBoolSize(29, forceNoResize_);
      }
      if (((bitField0_ & 0x04000000) != 0)) {
        size += com.google.protobuf.CodedOutputStream
          .computeBoolSize(30, useDummyLossInEval_);
      }
      for (int i = 0; i < parameterizedMetric_.size(); i++) {
        size += com.google.protobuf.CodedOutputStream
          .computeMessageSize(31, parameterizedMetric_.get(i));
      }
      for (int i = 0; i < keypointEdge_.size(); i++) {
        size += com.google.protobuf.CodedOutputStream
          .computeMessageSize(32, keypointEdge_.get(i));
      }
      if (((bitField0_ & 0x08000000) != 0)) {
        size += com.google.protobuf.CodedOutputStream
          .computeBoolSize(33, skipPredictionsForUnlabeledClass_);
      }
      for (java.util.Map.Entry<java.lang.String, java.lang.String> entry
           : internalGetSuperCategories().getMap().entrySet()) {
        com.google.protobuf.MapEntry<java.lang.String, java.lang.String>
        superCategories__ = SuperCategoriesDefaultEntryHolder.defaultEntry.newBuilderForType()
            .setKey(entry.getKey())
            .setValue(entry.getValue())
            .build();
        size += com.google.protobuf.CodedOutputStream
            .computeMessageSize(34, superCategories__);
      }
      if (((bitField0_ & 0x00200000) != 0)) {
        size += com.google.protobuf.CodedOutputStream
          .computeBoolSize(35, allMetricsPerCategory_);
      }
      size += unknownFields.getSerializedSize();
      memoizedSize = size;
      return size;
    }

    @java.lang.Override
    public boolean equals(final java.lang.Object obj) {
      if (obj == this) {
       return true;
      }
      if (!(obj instanceof object_detection.protos.Eval.EvalConfig)) {
        return super.equals(obj);
      }
      object_detection.protos.Eval.EvalConfig other = (object_detection.protos.Eval.EvalConfig) obj;

      if (hasBatchSize() != other.hasBatchSize()) return false;
      if (hasBatchSize()) {
        if (getBatchSize()
            != other.getBatchSize()) return false;
      }
      if (hasNumVisualizations() != other.hasNumVisualizations()) return false;
      if (hasNumVisualizations()) {
        if (getNumVisualizations()
            != other.getNumVisualizations()) return false;
      }
      if (hasNumExamples() != other.hasNumExamples()) return false;
      if (hasNumExamples()) {
        if (getNumExamples()
            != other.getNumExamples()) return false;
      }
      if (hasEvalIntervalSecs() != other.hasEvalIntervalSecs()) return false;
      if (hasEvalIntervalSecs()) {
        if (getEvalIntervalSecs()
            != other.getEvalIntervalSecs()) return false;
      }
      if (hasMaxEvals() != other.hasMaxEvals()) return false;
      if (hasMaxEvals()) {
        if (getMaxEvals()
            != other.getMaxEvals()) return false;
      }
      if (hasSaveGraph() != other.hasSaveGraph()) return false;
      if (hasSaveGraph()) {
        if (getSaveGraph()
            != other.getSaveGraph()) return false;
      }
      if (hasVisualizationExportDir() != other.hasVisualizationExportDir()) return false;
      if (hasVisualizationExportDir()) {
        if (!getVisualizationExportDir()
            .equals(other.getVisualizationExportDir())) return false;
      }
      if (hasEvalMaster() != other.hasEvalMaster()) return false;
      if (hasEvalMaster()) {
        if (!getEvalMaster()
            .equals(other.getEvalMaster())) return false;
      }
      if (!getMetricsSetList()
          .equals(other.getMetricsSetList())) return false;
      if (!getParameterizedMetricList()
          .equals(other.getParameterizedMetricList())) return false;
      if (hasExportPath() != other.hasExportPath()) return false;
      if (hasExportPath()) {
        if (!getExportPath()
            .equals(other.getExportPath())) return false;
      }
      if (hasIgnoreGroundtruth() != other.hasIgnoreGroundtruth()) return false;
      if (hasIgnoreGroundtruth()) {
        if (getIgnoreGroundtruth()
            != other.getIgnoreGroundtruth()) return false;
      }
      if (hasUseMovingAverages() != other.hasUseMovingAverages()) return false;
      if (hasUseMovingAverages()) {
        if (getUseMovingAverages()
            != other.getUseMovingAverages()) return false;
      }
      if (hasEvalInstanceMasks() != other.hasEvalInstanceMasks()) return false;
      if (hasEvalInstanceMasks()) {
        if (getEvalInstanceMasks()
            != other.getEvalInstanceMasks()) return false;
      }
      if (hasMinScoreThreshold() != other.hasMinScoreThreshold()) return false;
      if (hasMinScoreThreshold()) {
        if (java.lang.Float.floatToIntBits(getMinScoreThreshold())
            != java.lang.Float.floatToIntBits(
                other.getMinScoreThreshold())) return false;
      }
      if (hasMaxNumBoxesToVisualize() != other.hasMaxNumBoxesToVisualize()) return false;
      if (hasMaxNumBoxesToVisualize()) {
        if (getMaxNumBoxesToVisualize()
            != other.getMaxNumBoxesToVisualize()) return false;
      }
      if (hasSkipScores() != other.hasSkipScores()) return false;
      if (hasSkipScores()) {
        if (getSkipScores()
            != other.getSkipScores()) return false;
      }
      if (hasSkipLabels() != other.hasSkipLabels()) return false;
      if (hasSkipLabels()) {
        if (getSkipLabels()
            != other.getSkipLabels()) return false;
      }
      if (hasVisualizeGroundtruthBoxes() != other.hasVisualizeGroundtruthBoxes()) return false;
      if (hasVisualizeGroundtruthBoxes()) {
        if (getVisualizeGroundtruthBoxes()
            != other.getVisualizeGroundtruthBoxes()) return false;
      }
      if (hasGroundtruthBoxVisualizationColor() != other.hasGroundtruthBoxVisualizationColor()) return false;
      if (hasGroundtruthBoxVisualizationColor()) {
        if (!getGroundtruthBoxVisualizationColor()
            .equals(other.getGroundtruthBoxVisualizationColor())) return false;
      }
      if (hasKeepImageIdForVisualizationExport() != other.hasKeepImageIdForVisualizationExport()) return false;
      if (hasKeepImageIdForVisualizationExport()) {
        if (getKeepImageIdForVisualizationExport()
            != other.getKeepImageIdForVisualizationExport()) return false;
      }
      if (hasRetainOriginalImages() != other.hasRetainOriginalImages()) return false;
      if (hasRetainOriginalImages()) {
        if (getRetainOriginalImages()
            != other.getRetainOriginalImages()) return false;
      }
      if (hasIncludeMetricsPerCategory() != other.hasIncludeMetricsPerCategory()) return false;
      if (hasIncludeMetricsPerCategory()) {
        if (getIncludeMetricsPerCategory()
            != other.getIncludeMetricsPerCategory()) return false;
      }
      if (hasAllMetricsPerCategory() != other.hasAllMetricsPerCategory()) return false;
      if (hasAllMetricsPerCategory()) {
        if (getAllMetricsPerCategory()
            != other.getAllMetricsPerCategory()) return false;
      }
      if (!internalGetSuperCategories().equals(
          other.internalGetSuperCategories())) return false;
      if (hasRecallLowerBound() != other.hasRecallLowerBound()) return false;
      if (hasRecallLowerBound()) {
        if (java.lang.Float.floatToIntBits(getRecallLowerBound())
            != java.lang.Float.floatToIntBits(
                other.getRecallLowerBound())) return false;
      }
      if (hasRecallUpperBound() != other.hasRecallUpperBound()) return false;
      if (hasRecallUpperBound()) {
        if (java.lang.Float.floatToIntBits(getRecallUpperBound())
            != java.lang.Float.floatToIntBits(
                other.getRecallUpperBound())) return false;
      }
      if (hasRetainOriginalImageAdditionalChannels() != other.hasRetainOriginalImageAdditionalChannels()) return false;
      if (hasRetainOriginalImageAdditionalChannels()) {
        if (getRetainOriginalImageAdditionalChannels()
            != other.getRetainOriginalImageAdditionalChannels()) return false;
      }
      if (hasForceNoResize() != other.hasForceNoResize()) return false;
      if (hasForceNoResize()) {
        if (getForceNoResize()
            != other.getForceNoResize()) return false;
      }
      if (hasUseDummyLossInEval() != other.hasUseDummyLossInEval()) return false;
      if (hasUseDummyLossInEval()) {
        if (getUseDummyLossInEval()
            != other.getUseDummyLossInEval()) return false;
      }
      if (!getKeypointEdgeList()
          .equals(other.getKeypointEdgeList())) return false;
      if (hasSkipPredictionsForUnlabeledClass() != other.hasSkipPredictionsForUnlabeledClass()) return false;
      if (hasSkipPredictionsForUnlabeledClass()) {
        if (getSkipPredictionsForUnlabeledClass()
            != other.getSkipPredictionsForUnlabeledClass()) return false;
      }
      if (!unknownFields.equals(other.unknownFields)) return false;
      return true;
    }

    @java.lang.Override
    public int hashCode() {
      if (memoizedHashCode != 0) {
        return memoizedHashCode;
      }
      int hash = 41;
      hash = (19 * hash) + getDescriptor().hashCode();
      if (hasBatchSize()) {
        hash = (37 * hash) + BATCH_SIZE_FIELD_NUMBER;
        hash = (53 * hash) + getBatchSize();
      }
      if (hasNumVisualizations()) {
        hash = (37 * hash) + NUM_VISUALIZATIONS_FIELD_NUMBER;
        hash = (53 * hash) + getNumVisualizations();
      }
      if (hasNumExamples()) {
        hash = (37 * hash) + NUM_EXAMPLES_FIELD_NUMBER;
        hash = (53 * hash) + getNumExamples();
      }
      if (hasEvalIntervalSecs()) {
        hash = (37 * hash) + EVAL_INTERVAL_SECS_FIELD_NUMBER;
        hash = (53 * hash) + getEvalIntervalSecs();
      }
      if (hasMaxEvals()) {
        hash = (37 * hash) + MAX_EVALS_FIELD_NUMBER;
        hash = (53 * hash) + getMaxEvals();
      }
      if (hasSaveGraph()) {
        hash = (37 * hash) + SAVE_GRAPH_FIELD_NUMBER;
        hash = (53 * hash) + com.google.protobuf.Internal.hashBoolean(
            getSaveGraph());
      }
      if (hasVisualizationExportDir()) {
        hash = (37 * hash) + VISUALIZATION_EXPORT_DIR_FIELD_NUMBER;
        hash = (53 * hash) + getVisualizationExportDir().hashCode();
      }
      if (hasEvalMaster()) {
        hash = (37 * hash) + EVAL_MASTER_FIELD_NUMBER;
        hash = (53 * hash) + getEvalMaster().hashCode();
      }
      if (getMetricsSetCount() > 0) {
        hash = (37 * hash) + METRICS_SET_FIELD_NUMBER;
        hash = (53 * hash) + getMetricsSetList().hashCode();
      }
      if (getParameterizedMetricCount() > 0) {
        hash = (37 * hash) + PARAMETERIZED_METRIC_FIELD_NUMBER;
        hash = (53 * hash) + getParameterizedMetricList().hashCode();
      }
      if (hasExportPath()) {
        hash = (37 * hash) + EXPORT_PATH_FIELD_NUMBER;
        hash = (53 * hash) + getExportPath().hashCode();
      }
      if (hasIgnoreGroundtruth()) {
        hash = (37 * hash) + IGNORE_GROUNDTRUTH_FIELD_NUMBER;
        hash = (53 * hash) + com.google.protobuf.Internal.hashBoolean(
            getIgnoreGroundtruth());
      }
      if (hasUseMovingAverages()) {
        hash = (37 * hash) + USE_MOVING_AVERAGES_FIELD_NUMBER;
        hash = (53 * hash) + com.google.protobuf.Internal.hashBoolean(
            getUseMovingAverages());
      }
      if (hasEvalInstanceMasks()) {
        hash = (37 * hash) + EVAL_INSTANCE_MASKS_FIELD_NUMBER;
        hash = (53 * hash) + com.google.protobuf.Internal.hashBoolean(
            getEvalInstanceMasks());
      }
      if (hasMinScoreThreshold()) {
        hash = (37 * hash) + MIN_SCORE_THRESHOLD_FIELD_NUMBER;
        hash = (53 * hash) + java.lang.Float.floatToIntBits(
            getMinScoreThreshold());
      }
      if (hasMaxNumBoxesToVisualize()) {
        hash = (37 * hash) + MAX_NUM_BOXES_TO_VISUALIZE_FIELD_NUMBER;
        hash = (53 * hash) + getMaxNumBoxesToVisualize();
      }
      if (hasSkipScores()) {
        hash = (37 * hash) + SKIP_SCORES_FIELD_NUMBER;
        hash = (53 * hash) + com.google.protobuf.Internal.hashBoolean(
            getSkipScores());
      }
      if (hasSkipLabels()) {
        hash = (37 * hash) + SKIP_LABELS_FIELD_NUMBER;
        hash = (53 * hash) + com.google.protobuf.Internal.hashBoolean(
            getSkipLabels());
      }
      if (hasVisualizeGroundtruthBoxes()) {
        hash = (37 * hash) + VISUALIZE_GROUNDTRUTH_BOXES_FIELD_NUMBER;
        hash = (53 * hash) + com.google.protobuf.Internal.hashBoolean(
            getVisualizeGroundtruthBoxes());
      }
      if (hasGroundtruthBoxVisualizationColor()) {
        hash = (37 * hash) + GROUNDTRUTH_BOX_VISUALIZATION_COLOR_FIELD_NUMBER;
        hash = (53 * hash) + getGroundtruthBoxVisualizationColor().hashCode();
      }
      if (hasKeepImageIdForVisualizationExport()) {
        hash = (37 * hash) + KEEP_IMAGE_ID_FOR_VISUALIZATION_EXPORT_FIELD_NUMBER;
        hash = (53 * hash) + com.google.protobuf.Internal.hashBoolean(
            getKeepImageIdForVisualizationExport());
      }
      if (hasRetainOriginalImages()) {
        hash = (37 * hash) + RETAIN_ORIGINAL_IMAGES_FIELD_NUMBER;
        hash = (53 * hash) + com.google.protobuf.Internal.hashBoolean(
            getRetainOriginalImages());
      }
      if (hasIncludeMetricsPerCategory()) {
        hash = (37 * hash) + INCLUDE_METRICS_PER_CATEGORY_FIELD_NUMBER;
        hash = (53 * hash) + com.google.protobuf.Internal.hashBoolean(
            getIncludeMetricsPerCategory());
      }
      if (hasAllMetricsPerCategory()) {
        hash = (37 * hash) + ALL_METRICS_PER_CATEGORY_FIELD_NUMBER;
        hash = (53 * hash) + com.google.protobuf.Internal.hashBoolean(
            getAllMetricsPerCategory());
      }
      if (!internalGetSuperCategories().getMap().isEmpty()) {
        hash = (37 * hash) + SUPER_CATEGORIES_FIELD_NUMBER;
        hash = (53 * hash) + internalGetSuperCategories().hashCode();
      }
      if (hasRecallLowerBound()) {
        hash = (37 * hash) + RECALL_LOWER_BOUND_FIELD_NUMBER;
        hash = (53 * hash) + java.lang.Float.floatToIntBits(
            getRecallLowerBound());
      }
      if (hasRecallUpperBound()) {
        hash = (37 * hash) + RECALL_UPPER_BOUND_FIELD_NUMBER;
        hash = (53 * hash) + java.lang.Float.floatToIntBits(
            getRecallUpperBound());
      }
      if (hasRetainOriginalImageAdditionalChannels()) {
        hash = (37 * hash) + RETAIN_ORIGINAL_IMAGE_ADDITIONAL_CHANNELS_FIELD_NUMBER;
        hash = (53 * hash) + com.google.protobuf.Internal.hashBoolean(
            getRetainOriginalImageAdditionalChannels());
      }
      if (hasForceNoResize()) {
        hash = (37 * hash) + FORCE_NO_RESIZE_FIELD_NUMBER;
        hash = (53 * hash) + com.google.protobuf.Internal.hashBoolean(
            getForceNoResize());
      }
      if (hasUseDummyLossInEval()) {
        hash = (37 * hash) + USE_DUMMY_LOSS_IN_EVAL_FIELD_NUMBER;
        hash = (53 * hash) + com.google.protobuf.Internal.hashBoolean(
            getUseDummyLossInEval());
      }
      if (getKeypointEdgeCount() > 0) {
        hash = (37 * hash) + KEYPOINT_EDGE_FIELD_NUMBER;
        hash = (53 * hash) + getKeypointEdgeList().hashCode();
      }
      if (hasSkipPredictionsForUnlabeledClass()) {
        hash = (37 * hash) + SKIP_PREDICTIONS_FOR_UNLABELED_CLASS_FIELD_NUMBER;
        hash = (53 * hash) + com.google.protobuf.Internal.hashBoolean(
            getSkipPredictionsForUnlabeledClass());
      }
      hash = (29 * hash) + unknownFields.hashCode();
      memoizedHashCode = hash;
      return hash;
    }

    public static object_detection.protos.Eval.EvalConfig parseFrom(
        java.nio.ByteBuffer data)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return PARSER.parseFrom(data);
    }
    public static object_detection.protos.Eval.EvalConfig parseFrom(
        java.nio.ByteBuffer data,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return PARSER.parseFrom(data, extensionRegistry);
    }
    public static object_detection.protos.Eval.EvalConfig parseFrom(
        com.google.protobuf.ByteString data)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return PARSER.parseFrom(data);
    }
    public static object_detection.protos.Eval.EvalConfig parseFrom(
        com.google.protobuf.ByteString data,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return PARSER.parseFrom(data, extensionRegistry);
    }
    public static object_detection.protos.Eval.EvalConfig parseFrom(byte[] data)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return PARSER.parseFrom(data);
    }
    public static object_detection.protos.Eval.EvalConfig parseFrom(
        byte[] data,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return PARSER.parseFrom(data, extensionRegistry);
    }
    public static object_detection.protos.Eval.EvalConfig parseFrom(java.io.InputStream input)
        throws java.io.IOException {
      return com.google.protobuf.GeneratedMessageV3
          .parseWithIOException(PARSER, input);
    }
    public static object_detection.protos.Eval.EvalConfig parseFrom(
        java.io.InputStream input,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws java.io.IOException {
      return com.google.protobuf.GeneratedMessageV3
          .parseWithIOException(PARSER, input, extensionRegistry);
    }
    public static object_detection.protos.Eval.EvalConfig parseDelimitedFrom(java.io.InputStream input)
        throws java.io.IOException {
      return com.google.protobuf.GeneratedMessageV3
          .parseDelimitedWithIOException(PARSER, input);
    }
    public static object_detection.protos.Eval.EvalConfig parseDelimitedFrom(
        java.io.InputStream input,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws java.io.IOException {
      return com.google.protobuf.GeneratedMessageV3
          .parseDelimitedWithIOException(PARSER, input, extensionRegistry);
    }
    public static object_detection.protos.Eval.EvalConfig parseFrom(
        com.google.protobuf.CodedInputStream input)
        throws java.io.IOException {
      return com.google.protobuf.GeneratedMessageV3
          .parseWithIOException(PARSER, input);
    }
    public static object_detection.protos.Eval.EvalConfig parseFrom(
        com.google.protobuf.CodedInputStream input,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws java.io.IOException {
      return com.google.protobuf.GeneratedMessageV3
          .parseWithIOException(PARSER, input, extensionRegistry);
    }

    @java.lang.Override
    public Builder newBuilderForType() { return newBuilder(); }
    public static Builder newBuilder() {
      return DEFAULT_INSTANCE.toBuilder();
    }
    public static Builder newBuilder(object_detection.protos.Eval.EvalConfig prototype) {
      return DEFAULT_INSTANCE.toBuilder().mergeFrom(prototype);
    }
    @java.lang.Override
    public Builder toBuilder() {
      return this == DEFAULT_INSTANCE
          ? new Builder() : new Builder().mergeFrom(this);
    }

    @java.lang.Override
    protected Builder newBuilderForType(
        com.google.protobuf.GeneratedMessageV3.BuilderParent parent) {
      Builder builder = new Builder(parent);
      return builder;
    }
    /**
     * <pre>
     * Message for configuring DetectionModel evaluation jobs (eval.py).
     * Next id - 36
     * </pre>
     *
     * Protobuf type {@code object_detection.protos.EvalConfig}
     */
    public static final class Builder extends
        com.google.protobuf.GeneratedMessageV3.Builder<Builder> implements
        // @@protoc_insertion_point(builder_implements:object_detection.protos.EvalConfig)
        object_detection.protos.Eval.EvalConfigOrBuilder {
      public static final com.google.protobuf.Descriptors.Descriptor
          getDescriptor() {
        return object_detection.protos.Eval.internal_static_object_detection_protos_EvalConfig_descriptor;
      }

      @SuppressWarnings({"rawtypes"})
      protected com.google.protobuf.MapField internalGetMapField(
          int number) {
        switch (number) {
          case 34:
            return internalGetSuperCategories();
          default:
            throw new RuntimeException(
                "Invalid map field number: " + number);
        }
      }
      @SuppressWarnings({"rawtypes"})
      protected com.google.protobuf.MapField internalGetMutableMapField(
          int number) {
        switch (number) {
          case 34:
            return internalGetMutableSuperCategories();
          default:
            throw new RuntimeException(
                "Invalid map field number: " + number);
        }
      }
      @java.lang.Override
      protected com.google.protobuf.GeneratedMessageV3.FieldAccessorTable
          internalGetFieldAccessorTable() {
        return object_detection.protos.Eval.internal_static_object_detection_protos_EvalConfig_fieldAccessorTable
            .ensureFieldAccessorsInitialized(
                object_detection.protos.Eval.EvalConfig.class, object_detection.protos.Eval.EvalConfig.Builder.class);
      }

      // Construct using object_detection.protos.Eval.EvalConfig.newBuilder()
      private Builder() {
        maybeForceBuilderInitialization();
      }

      private Builder(
          com.google.protobuf.GeneratedMessageV3.BuilderParent parent) {
        super(parent);
        maybeForceBuilderInitialization();
      }
      private void maybeForceBuilderInitialization() {
        if (com.google.protobuf.GeneratedMessageV3
                .alwaysUseFieldBuilders) {
          getParameterizedMetricFieldBuilder();
          getKeypointEdgeFieldBuilder();
        }
      }
      @java.lang.Override
      public Builder clear() {
        super.clear();
        batchSize_ = 1;
        bitField0_ = (bitField0_ & ~0x00000001);
        numVisualizations_ = 10;
        bitField0_ = (bitField0_ & ~0x00000002);
        numExamples_ = 5000;
        bitField0_ = (bitField0_ & ~0x00000004);
        evalIntervalSecs_ = 300;
        bitField0_ = (bitField0_ & ~0x00000008);
        maxEvals_ = 0;
        bitField0_ = (bitField0_ & ~0x00000010);
        saveGraph_ = false;
        bitField0_ = (bitField0_ & ~0x00000020);
        visualizationExportDir_ = "";
        bitField0_ = (bitField0_ & ~0x00000040);
        evalMaster_ = "";
        bitField0_ = (bitField0_ & ~0x00000080);
        metricsSet_ = com.google.protobuf.LazyStringArrayList.EMPTY;
        bitField0_ = (bitField0_ & ~0x00000100);
        if (parameterizedMetricBuilder_ == null) {
          parameterizedMetric_ = java.util.Collections.emptyList();
          bitField0_ = (bitField0_ & ~0x00000200);
        } else {
          parameterizedMetricBuilder_.clear();
        }
        exportPath_ = "";
        bitField0_ = (bitField0_ & ~0x00000400);
        ignoreGroundtruth_ = false;
        bitField0_ = (bitField0_ & ~0x00000800);
        useMovingAverages_ = false;
        bitField0_ = (bitField0_ & ~0x00001000);
        evalInstanceMasks_ = false;
        bitField0_ = (bitField0_ & ~0x00002000);
        minScoreThreshold_ = 0.5F;
        bitField0_ = (bitField0_ & ~0x00004000);
        maxNumBoxesToVisualize_ = 20;
        bitField0_ = (bitField0_ & ~0x00008000);
        skipScores_ = false;
        bitField0_ = (bitField0_ & ~0x00010000);
        skipLabels_ = false;
        bitField0_ = (bitField0_ & ~0x00020000);
        visualizeGroundtruthBoxes_ = false;
        bitField0_ = (bitField0_ & ~0x00040000);
        groundtruthBoxVisualizationColor_ = "black";
        bitField0_ = (bitField0_ & ~0x00080000);
        keepImageIdForVisualizationExport_ = false;
        bitField0_ = (bitField0_ & ~0x00100000);
        retainOriginalImages_ = true;
        bitField0_ = (bitField0_ & ~0x00200000);
        includeMetricsPerCategory_ = false;
        bitField0_ = (bitField0_ & ~0x00400000);
        allMetricsPerCategory_ = false;
        bitField0_ = (bitField0_ & ~0x00800000);
        internalGetMutableSuperCategories().clear();
        recallLowerBound_ = 0F;
        bitField0_ = (bitField0_ & ~0x02000000);
        recallUpperBound_ = 1F;
        bitField0_ = (bitField0_ & ~0x04000000);
        retainOriginalImageAdditionalChannels_ = false;
        bitField0_ = (bitField0_ & ~0x08000000);
        forceNoResize_ = false;
        bitField0_ = (bitField0_ & ~0x10000000);
        useDummyLossInEval_ = false;
        bitField0_ = (bitField0_ & ~0x20000000);
        if (keypointEdgeBuilder_ == null) {
          keypointEdge_ = java.util.Collections.emptyList();
          bitField0_ = (bitField0_ & ~0x40000000);
        } else {
          keypointEdgeBuilder_.clear();
        }
        skipPredictionsForUnlabeledClass_ = false;
        bitField0_ = (bitField0_ & ~0x80000000);
        return this;
      }

      @java.lang.Override
      public com.google.protobuf.Descriptors.Descriptor
          getDescriptorForType() {
        return object_detection.protos.Eval.internal_static_object_detection_protos_EvalConfig_descriptor;
      }

      @java.lang.Override
      public object_detection.protos.Eval.EvalConfig getDefaultInstanceForType() {
        return object_detection.protos.Eval.EvalConfig.getDefaultInstance();
      }

      @java.lang.Override
      public object_detection.protos.Eval.EvalConfig build() {
        object_detection.protos.Eval.EvalConfig result = buildPartial();
        if (!result.isInitialized()) {
          throw newUninitializedMessageException(result);
        }
        return result;
      }

      @java.lang.Override
      public object_detection.protos.Eval.EvalConfig buildPartial() {
        object_detection.protos.Eval.EvalConfig result = new object_detection.protos.Eval.EvalConfig(this);
        int from_bitField0_ = bitField0_;
        int to_bitField0_ = 0;
        if (((from_bitField0_ & 0x00000001) != 0)) {
          to_bitField0_ |= 0x00000001;
        }
        result.batchSize_ = batchSize_;
        if (((from_bitField0_ & 0x00000002) != 0)) {
          to_bitField0_ |= 0x00000002;
        }
        result.numVisualizations_ = numVisualizations_;
        if (((from_bitField0_ & 0x00000004) != 0)) {
          to_bitField0_ |= 0x00000004;
        }
        result.numExamples_ = numExamples_;
        if (((from_bitField0_ & 0x00000008) != 0)) {
          to_bitField0_ |= 0x00000008;
        }
        result.evalIntervalSecs_ = evalIntervalSecs_;
        if (((from_bitField0_ & 0x00000010) != 0)) {
          result.maxEvals_ = maxEvals_;
          to_bitField0_ |= 0x00000010;
        }
        if (((from_bitField0_ & 0x00000020) != 0)) {
          result.saveGraph_ = saveGraph_;
          to_bitField0_ |= 0x00000020;
        }
        if (((from_bitField0_ & 0x00000040) != 0)) {
          to_bitField0_ |= 0x00000040;
        }
        result.visualizationExportDir_ = visualizationExportDir_;
        if (((from_bitField0_ & 0x00000080) != 0)) {
          to_bitField0_ |= 0x00000080;
        }
        result.evalMaster_ = evalMaster_;
        if (((bitField0_ & 0x00000100) != 0)) {
          metricsSet_ = metricsSet_.getUnmodifiableView();
          bitField0_ = (bitField0_ & ~0x00000100);
        }
        result.metricsSet_ = metricsSet_;
        if (parameterizedMetricBuilder_ == null) {
          if (((bitField0_ & 0x00000200) != 0)) {
            parameterizedMetric_ = java.util.Collections.unmodifiableList(parameterizedMetric_);
            bitField0_ = (bitField0_ & ~0x00000200);
          }
          result.parameterizedMetric_ = parameterizedMetric_;
        } else {
          result.parameterizedMetric_ = parameterizedMetricBuilder_.build();
        }
        if (((from_bitField0_ & 0x00000400) != 0)) {
          to_bitField0_ |= 0x00000100;
        }
        result.exportPath_ = exportPath_;
        if (((from_bitField0_ & 0x00000800) != 0)) {
          result.ignoreGroundtruth_ = ignoreGroundtruth_;
          to_bitField0_ |= 0x00000200;
        }
        if (((from_bitField0_ & 0x00001000) != 0)) {
          result.useMovingAverages_ = useMovingAverages_;
          to_bitField0_ |= 0x00000400;
        }
        if (((from_bitField0_ & 0x00002000) != 0)) {
          result.evalInstanceMasks_ = evalInstanceMasks_;
          to_bitField0_ |= 0x00000800;
        }
        if (((from_bitField0_ & 0x00004000) != 0)) {
          to_bitField0_ |= 0x00001000;
        }
        result.minScoreThreshold_ = minScoreThreshold_;
        if (((from_bitField0_ & 0x00008000) != 0)) {
          to_bitField0_ |= 0x00002000;
        }
        result.maxNumBoxesToVisualize_ = maxNumBoxesToVisualize_;
        if (((from_bitField0_ & 0x00010000) != 0)) {
          result.skipScores_ = skipScores_;
          to_bitField0_ |= 0x00004000;
        }
        if (((from_bitField0_ & 0x00020000) != 0)) {
          result.skipLabels_ = skipLabels_;
          to_bitField0_ |= 0x00008000;
        }
        if (((from_bitField0_ & 0x00040000) != 0)) {
          result.visualizeGroundtruthBoxes_ = visualizeGroundtruthBoxes_;
          to_bitField0_ |= 0x00010000;
        }
        if (((from_bitField0_ & 0x00080000) != 0)) {
          to_bitField0_ |= 0x00020000;
        }
        result.groundtruthBoxVisualizationColor_ = groundtruthBoxVisualizationColor_;
        if (((from_bitField0_ & 0x00100000) != 0)) {
          result.keepImageIdForVisualizationExport_ = keepImageIdForVisualizationExport_;
          to_bitField0_ |= 0x00040000;
        }
        if (((from_bitField0_ & 0x00200000) != 0)) {
          to_bitField0_ |= 0x00080000;
        }
        result.retainOriginalImages_ = retainOriginalImages_;
        if (((from_bitField0_ & 0x00400000) != 0)) {
          result.includeMetricsPerCategory_ = includeMetricsPerCategory_;
          to_bitField0_ |= 0x00100000;
        }
        if (((from_bitField0_ & 0x00800000) != 0)) {
          result.allMetricsPerCategory_ = allMetricsPerCategory_;
          to_bitField0_ |= 0x00200000;
        }
        result.superCategories_ = internalGetSuperCategories();
        result.superCategories_.makeImmutable();
        if (((from_bitField0_ & 0x02000000) != 0)) {
          result.recallLowerBound_ = recallLowerBound_;
          to_bitField0_ |= 0x00400000;
        }
        if (((from_bitField0_ & 0x04000000) != 0)) {
          to_bitField0_ |= 0x00800000;
        }
        result.recallUpperBound_ = recallUpperBound_;
        if (((from_bitField0_ & 0x08000000) != 0)) {
          result.retainOriginalImageAdditionalChannels_ = retainOriginalImageAdditionalChannels_;
          to_bitField0_ |= 0x01000000;
        }
        if (((from_bitField0_ & 0x10000000) != 0)) {
          result.forceNoResize_ = forceNoResize_;
          to_bitField0_ |= 0x02000000;
        }
        if (((from_bitField0_ & 0x20000000) != 0)) {
          result.useDummyLossInEval_ = useDummyLossInEval_;
          to_bitField0_ |= 0x04000000;
        }
        if (keypointEdgeBuilder_ == null) {
          if (((bitField0_ & 0x40000000) != 0)) {
            keypointEdge_ = java.util.Collections.unmodifiableList(keypointEdge_);
            bitField0_ = (bitField0_ & ~0x40000000);
          }
          result.keypointEdge_ = keypointEdge_;
        } else {
          result.keypointEdge_ = keypointEdgeBuilder_.build();
        }
        if (((from_bitField0_ & 0x80000000) != 0)) {
          result.skipPredictionsForUnlabeledClass_ = skipPredictionsForUnlabeledClass_;
          to_bitField0_ |= 0x08000000;
        }
        result.bitField0_ = to_bitField0_;
        onBuilt();
        return result;
      }

      @java.lang.Override
      public Builder clone() {
        return super.clone();
      }
      @java.lang.Override
      public Builder setField(
          com.google.protobuf.Descriptors.FieldDescriptor field,
          java.lang.Object value) {
        return super.setField(field, value);
      }
      @java.lang.Override
      public Builder clearField(
          com.google.protobuf.Descriptors.FieldDescriptor field) {
        return super.clearField(field);
      }
      @java.lang.Override
      public Builder clearOneof(
          com.google.protobuf.Descriptors.OneofDescriptor oneof) {
        return super.clearOneof(oneof);
      }
      @java.lang.Override
      public Builder setRepeatedField(
          com.google.protobuf.Descriptors.FieldDescriptor field,
          int index, java.lang.Object value) {
        return super.setRepeatedField(field, index, value);
      }
      @java.lang.Override
      public Builder addRepeatedField(
          com.google.protobuf.Descriptors.FieldDescriptor field,
          java.lang.Object value) {
        return super.addRepeatedField(field, value);
      }
      @java.lang.Override
      public Builder mergeFrom(com.google.protobuf.Message other) {
        if (other instanceof object_detection.protos.Eval.EvalConfig) {
          return mergeFrom((object_detection.protos.Eval.EvalConfig)other);
        } else {
          super.mergeFrom(other);
          return this;
        }
      }

      public Builder mergeFrom(object_detection.protos.Eval.EvalConfig other) {
        if (other == object_detection.protos.Eval.EvalConfig.getDefaultInstance()) return this;
        if (other.hasBatchSize()) {
          setBatchSize(other.getBatchSize());
        }
        if (other.hasNumVisualizations()) {
          setNumVisualizations(other.getNumVisualizations());
        }
        if (other.hasNumExamples()) {
          setNumExamples(other.getNumExamples());
        }
        if (other.hasEvalIntervalSecs()) {
          setEvalIntervalSecs(other.getEvalIntervalSecs());
        }
        if (other.hasMaxEvals()) {
          setMaxEvals(other.getMaxEvals());
        }
        if (other.hasSaveGraph()) {
          setSaveGraph(other.getSaveGraph());
        }
        if (other.hasVisualizationExportDir()) {
          bitField0_ |= 0x00000040;
          visualizationExportDir_ = other.visualizationExportDir_;
          onChanged();
        }
        if (other.hasEvalMaster()) {
          bitField0_ |= 0x00000080;
          evalMaster_ = other.evalMaster_;
          onChanged();
        }
        if (!other.metricsSet_.isEmpty()) {
          if (metricsSet_.isEmpty()) {
            metricsSet_ = other.metricsSet_;
            bitField0_ = (bitField0_ & ~0x00000100);
          } else {
            ensureMetricsSetIsMutable();
            metricsSet_.addAll(other.metricsSet_);
          }
          onChanged();
        }
        if (parameterizedMetricBuilder_ == null) {
          if (!other.parameterizedMetric_.isEmpty()) {
            if (parameterizedMetric_.isEmpty()) {
              parameterizedMetric_ = other.parameterizedMetric_;
              bitField0_ = (bitField0_ & ~0x00000200);
            } else {
              ensureParameterizedMetricIsMutable();
              parameterizedMetric_.addAll(other.parameterizedMetric_);
            }
            onChanged();
          }
        } else {
          if (!other.parameterizedMetric_.isEmpty()) {
            if (parameterizedMetricBuilder_.isEmpty()) {
              parameterizedMetricBuilder_.dispose();
              parameterizedMetricBuilder_ = null;
              parameterizedMetric_ = other.parameterizedMetric_;
              bitField0_ = (bitField0_ & ~0x00000200);
              parameterizedMetricBuilder_ =
                com.google.protobuf.GeneratedMessageV3.alwaysUseFieldBuilders ?
                   getParameterizedMetricFieldBuilder() : null;
            } else {
              parameterizedMetricBuilder_.addAllMessages(other.parameterizedMetric_);
            }
          }
        }
        if (other.hasExportPath()) {
          bitField0_ |= 0x00000400;
          exportPath_ = other.exportPath_;
          onChanged();
        }
        if (other.hasIgnoreGroundtruth()) {
          setIgnoreGroundtruth(other.getIgnoreGroundtruth());
        }
        if (other.hasUseMovingAverages()) {
          setUseMovingAverages(other.getUseMovingAverages());
        }
        if (other.hasEvalInstanceMasks()) {
          setEvalInstanceMasks(other.getEvalInstanceMasks());
        }
        if (other.hasMinScoreThreshold()) {
          setMinScoreThreshold(other.getMinScoreThreshold());
        }
        if (other.hasMaxNumBoxesToVisualize()) {
          setMaxNumBoxesToVisualize(other.getMaxNumBoxesToVisualize());
        }
        if (other.hasSkipScores()) {
          setSkipScores(other.getSkipScores());
        }
        if (other.hasSkipLabels()) {
          setSkipLabels(other.getSkipLabels());
        }
        if (other.hasVisualizeGroundtruthBoxes()) {
          setVisualizeGroundtruthBoxes(other.getVisualizeGroundtruthBoxes());
        }
        if (other.hasGroundtruthBoxVisualizationColor()) {
          bitField0_ |= 0x00080000;
          groundtruthBoxVisualizationColor_ = other.groundtruthBoxVisualizationColor_;
          onChanged();
        }
        if (other.hasKeepImageIdForVisualizationExport()) {
          setKeepImageIdForVisualizationExport(other.getKeepImageIdForVisualizationExport());
        }
        if (other.hasRetainOriginalImages()) {
          setRetainOriginalImages(other.getRetainOriginalImages());
        }
        if (other.hasIncludeMetricsPerCategory()) {
          setIncludeMetricsPerCategory(other.getIncludeMetricsPerCategory());
        }
        if (other.hasAllMetricsPerCategory()) {
          setAllMetricsPerCategory(other.getAllMetricsPerCategory());
        }
        internalGetMutableSuperCategories().mergeFrom(
            other.internalGetSuperCategories());
        if (other.hasRecallLowerBound()) {
          setRecallLowerBound(other.getRecallLowerBound());
        }
        if (other.hasRecallUpperBound()) {
          setRecallUpperBound(other.getRecallUpperBound());
        }
        if (other.hasRetainOriginalImageAdditionalChannels()) {
          setRetainOriginalImageAdditionalChannels(other.getRetainOriginalImageAdditionalChannels());
        }
        if (other.hasForceNoResize()) {
          setForceNoResize(other.getForceNoResize());
        }
        if (other.hasUseDummyLossInEval()) {
          setUseDummyLossInEval(other.getUseDummyLossInEval());
        }
        if (keypointEdgeBuilder_ == null) {
          if (!other.keypointEdge_.isEmpty()) {
            if (keypointEdge_.isEmpty()) {
              keypointEdge_ = other.keypointEdge_;
              bitField0_ = (bitField0_ & ~0x40000000);
            } else {
              ensureKeypointEdgeIsMutable();
              keypointEdge_.addAll(other.keypointEdge_);
            }
            onChanged();
          }
        } else {
          if (!other.keypointEdge_.isEmpty()) {
            if (keypointEdgeBuilder_.isEmpty()) {
              keypointEdgeBuilder_.dispose();
              keypointEdgeBuilder_ = null;
              keypointEdge_ = other.keypointEdge_;
              bitField0_ = (bitField0_ & ~0x40000000);
              keypointEdgeBuilder_ =
                com.google.protobuf.GeneratedMessageV3.alwaysUseFieldBuilders ?
                   getKeypointEdgeFieldBuilder() : null;
            } else {
              keypointEdgeBuilder_.addAllMessages(other.keypointEdge_);
            }
          }
        }
        if (other.hasSkipPredictionsForUnlabeledClass()) {
          setSkipPredictionsForUnlabeledClass(other.getSkipPredictionsForUnlabeledClass());
        }
        this.mergeUnknownFields(other.unknownFields);
        onChanged();
        return this;
      }

      @java.lang.Override
      public final boolean isInitialized() {
        return true;
      }

      @java.lang.Override
      public Builder mergeFrom(
          com.google.protobuf.CodedInputStream input,
          com.google.protobuf.ExtensionRegistryLite extensionRegistry)
          throws java.io.IOException {
        object_detection.protos.Eval.EvalConfig parsedMessage = null;
        try {
          parsedMessage = PARSER.parsePartialFrom(input, extensionRegistry);
        } catch (com.google.protobuf.InvalidProtocolBufferException e) {
          parsedMessage = (object_detection.protos.Eval.EvalConfig) e.getUnfinishedMessage();
          throw e.unwrapIOException();
        } finally {
          if (parsedMessage != null) {
            mergeFrom(parsedMessage);
          }
        }
        return this;
      }
      private int bitField0_;

      private int batchSize_ = 1;
      /**
       * <code>optional uint32 batch_size = 25 [default = 1];</code>
       * @return Whether the batchSize field is set.
       */
      @java.lang.Override
      public boolean hasBatchSize() {
        return ((bitField0_ & 0x00000001) != 0);
      }
      /**
       * <code>optional uint32 batch_size = 25 [default = 1];</code>
       * @return The batchSize.
       */
      @java.lang.Override
      public int getBatchSize() {
        return batchSize_;
      }
      /**
       * <code>optional uint32 batch_size = 25 [default = 1];</code>
       * @param value The batchSize to set.
       * @return This builder for chaining.
       */
      public Builder setBatchSize(int value) {
        bitField0_ |= 0x00000001;
        batchSize_ = value;
        onChanged();
        return this;
      }
      /**
       * <code>optional uint32 batch_size = 25 [default = 1];</code>
       * @return This builder for chaining.
       */
      public Builder clearBatchSize() {
        bitField0_ = (bitField0_ & ~0x00000001);
        batchSize_ = 1;
        onChanged();
        return this;
      }

      private int numVisualizations_ = 10;
      /**
       * <pre>
       * Number of visualization images to generate.
       * </pre>
       *
       * <code>optional uint32 num_visualizations = 1 [default = 10];</code>
       * @return Whether the numVisualizations field is set.
       */
      @java.lang.Override
      public boolean hasNumVisualizations() {
        return ((bitField0_ & 0x00000002) != 0);
      }
      /**
       * <pre>
       * Number of visualization images to generate.
       * </pre>
       *
       * <code>optional uint32 num_visualizations = 1 [default = 10];</code>
       * @return The numVisualizations.
       */
      @java.lang.Override
      public int getNumVisualizations() {
        return numVisualizations_;
      }
      /**
       * <pre>
       * Number of visualization images to generate.
       * </pre>
       *
       * <code>optional uint32 num_visualizations = 1 [default = 10];</code>
       * @param value The numVisualizations to set.
       * @return This builder for chaining.
       */
      public Builder setNumVisualizations(int value) {
        bitField0_ |= 0x00000002;
        numVisualizations_ = value;
        onChanged();
        return this;
      }
      /**
       * <pre>
       * Number of visualization images to generate.
       * </pre>
       *
       * <code>optional uint32 num_visualizations = 1 [default = 10];</code>
       * @return This builder for chaining.
       */
      public Builder clearNumVisualizations() {
        bitField0_ = (bitField0_ & ~0x00000002);
        numVisualizations_ = 10;
        onChanged();
        return this;
      }

      private int numExamples_ = 5000;
      /**
       * <pre>
       * Number of examples to process of evaluation.
       * </pre>
       *
       * <code>optional uint32 num_examples = 2 [default = 5000, deprecated = true];</code>
       * @return Whether the numExamples field is set.
       */
      @java.lang.Override
      @java.lang.Deprecated public boolean hasNumExamples() {
        return ((bitField0_ & 0x00000004) != 0);
      }
      /**
       * <pre>
       * Number of examples to process of evaluation.
       * </pre>
       *
       * <code>optional uint32 num_examples = 2 [default = 5000, deprecated = true];</code>
       * @return The numExamples.
       */
      @java.lang.Override
      @java.lang.Deprecated public int getNumExamples() {
        return numExamples_;
      }
      /**
       * <pre>
       * Number of examples to process of evaluation.
       * </pre>
       *
       * <code>optional uint32 num_examples = 2 [default = 5000, deprecated = true];</code>
       * @param value The numExamples to set.
       * @return This builder for chaining.
       */
      @java.lang.Deprecated public Builder setNumExamples(int value) {
        bitField0_ |= 0x00000004;
        numExamples_ = value;
        onChanged();
        return this;
      }
      /**
       * <pre>
       * Number of examples to process of evaluation.
       * </pre>
       *
       * <code>optional uint32 num_examples = 2 [default = 5000, deprecated = true];</code>
       * @return This builder for chaining.
       */
      @java.lang.Deprecated public Builder clearNumExamples() {
        bitField0_ = (bitField0_ & ~0x00000004);
        numExamples_ = 5000;
        onChanged();
        return this;
      }

      private int evalIntervalSecs_ = 300;
      /**
       * <pre>
       * How often to run evaluation.
       * </pre>
       *
       * <code>optional uint32 eval_interval_secs = 3 [default = 300];</code>
       * @return Whether the evalIntervalSecs field is set.
       */
      @java.lang.Override
      public boolean hasEvalIntervalSecs() {
        return ((bitField0_ & 0x00000008) != 0);
      }
      /**
       * <pre>
       * How often to run evaluation.
       * </pre>
       *
       * <code>optional uint32 eval_interval_secs = 3 [default = 300];</code>
       * @return The evalIntervalSecs.
       */
      @java.lang.Override
      public int getEvalIntervalSecs() {
        return evalIntervalSecs_;
      }
      /**
       * <pre>
       * How often to run evaluation.
       * </pre>
       *
       * <code>optional uint32 eval_interval_secs = 3 [default = 300];</code>
       * @param value The evalIntervalSecs to set.
       * @return This builder for chaining.
       */
      public Builder setEvalIntervalSecs(int value) {
        bitField0_ |= 0x00000008;
        evalIntervalSecs_ = value;
        onChanged();
        return this;
      }
      /**
       * <pre>
       * How often to run evaluation.
       * </pre>
       *
       * <code>optional uint32 eval_interval_secs = 3 [default = 300];</code>
       * @return This builder for chaining.
       */
      public Builder clearEvalIntervalSecs() {
        bitField0_ = (bitField0_ & ~0x00000008);
        evalIntervalSecs_ = 300;
        onChanged();
        return this;
      }

      private int maxEvals_ ;
      /**
       * <pre>
       * Maximum number of times to run evaluation. If set to 0, will run forever.
       * </pre>
       *
       * <code>optional uint32 max_evals = 4 [default = 0, deprecated = true];</code>
       * @return Whether the maxEvals field is set.
       */
      @java.lang.Override
      @java.lang.Deprecated public boolean hasMaxEvals() {
        return ((bitField0_ & 0x00000010) != 0);
      }
      /**
       * <pre>
       * Maximum number of times to run evaluation. If set to 0, will run forever.
       * </pre>
       *
       * <code>optional uint32 max_evals = 4 [default = 0, deprecated = true];</code>
       * @return The maxEvals.
       */
      @java.lang.Override
      @java.lang.Deprecated public int getMaxEvals() {
        return maxEvals_;
      }
      /**
       * <pre>
       * Maximum number of times to run evaluation. If set to 0, will run forever.
       * </pre>
       *
       * <code>optional uint32 max_evals = 4 [default = 0, deprecated = true];</code>
       * @param value The maxEvals to set.
       * @return This builder for chaining.
       */
      @java.lang.Deprecated public Builder setMaxEvals(int value) {
        bitField0_ |= 0x00000010;
        maxEvals_ = value;
        onChanged();
        return this;
      }
      /**
       * <pre>
       * Maximum number of times to run evaluation. If set to 0, will run forever.
       * </pre>
       *
       * <code>optional uint32 max_evals = 4 [default = 0, deprecated = true];</code>
       * @return This builder for chaining.
       */
      @java.lang.Deprecated public Builder clearMaxEvals() {
        bitField0_ = (bitField0_ & ~0x00000010);
        maxEvals_ = 0;
        onChanged();
        return this;
      }

      private boolean saveGraph_ ;
      /**
       * <pre>
       * Whether the TensorFlow graph used for evaluation should be saved to disk.
       * </pre>
       *
       * <code>optional bool save_graph = 5 [default = false];</code>
       * @return Whether the saveGraph field is set.
       */
      @java.lang.Override
      public boolean hasSaveGraph() {
        return ((bitField0_ & 0x00000020) != 0);
      }
      /**
       * <pre>
       * Whether the TensorFlow graph used for evaluation should be saved to disk.
       * </pre>
       *
       * <code>optional bool save_graph = 5 [default = false];</code>
       * @return The saveGraph.
       */
      @java.lang.Override
      public boolean getSaveGraph() {
        return saveGraph_;
      }
      /**
       * <pre>
       * Whether the TensorFlow graph used for evaluation should be saved to disk.
       * </pre>
       *
       * <code>optional bool save_graph = 5 [default = false];</code>
       * @param value The saveGraph to set.
       * @return This builder for chaining.
       */
      public Builder setSaveGraph(boolean value) {
        bitField0_ |= 0x00000020;
        saveGraph_ = value;
        onChanged();
        return this;
      }
      /**
       * <pre>
       * Whether the TensorFlow graph used for evaluation should be saved to disk.
       * </pre>
       *
       * <code>optional bool save_graph = 5 [default = false];</code>
       * @return This builder for chaining.
       */
      public Builder clearSaveGraph() {
        bitField0_ = (bitField0_ & ~0x00000020);
        saveGraph_ = false;
        onChanged();
        return this;
      }

      private java.lang.Object visualizationExportDir_ = "";
      /**
       * <pre>
       * Path to directory to store visualizations in. If empty, visualization
       * images are not exported (only shown on Tensorboard).
       * </pre>
       *
       * <code>optional string visualization_export_dir = 6 [default = ""];</code>
       * @return Whether the visualizationExportDir field is set.
       */
      public boolean hasVisualizationExportDir() {
        return ((bitField0_ & 0x00000040) != 0);
      }
      /**
       * <pre>
       * Path to directory to store visualizations in. If empty, visualization
       * images are not exported (only shown on Tensorboard).
       * </pre>
       *
       * <code>optional string visualization_export_dir = 6 [default = ""];</code>
       * @return The visualizationExportDir.
       */
      public java.lang.String getVisualizationExportDir() {
        java.lang.Object ref = visualizationExportDir_;
        if (!(ref instanceof java.lang.String)) {
          com.google.protobuf.ByteString bs =
              (com.google.protobuf.ByteString) ref;
          java.lang.String s = bs.toStringUtf8();
          if (bs.isValidUtf8()) {
            visualizationExportDir_ = s;
          }
          return s;
        } else {
          return (java.lang.String) ref;
        }
      }
      /**
       * <pre>
       * Path to directory to store visualizations in. If empty, visualization
       * images are not exported (only shown on Tensorboard).
       * </pre>
       *
       * <code>optional string visualization_export_dir = 6 [default = ""];</code>
       * @return The bytes for visualizationExportDir.
       */
      public com.google.protobuf.ByteString
          getVisualizationExportDirBytes() {
        java.lang.Object ref = visualizationExportDir_;
        if (ref instanceof String) {
          com.google.protobuf.ByteString b =
              com.google.protobuf.ByteString.copyFromUtf8(
                  (java.lang.String) ref);
          visualizationExportDir_ = b;
          return b;
        } else {
          return (com.google.protobuf.ByteString) ref;
        }
      }
      /**
       * <pre>
       * Path to directory to store visualizations in. If empty, visualization
       * images are not exported (only shown on Tensorboard).
       * </pre>
       *
       * <code>optional string visualization_export_dir = 6 [default = ""];</code>
       * @param value The visualizationExportDir to set.
       * @return This builder for chaining.
       */
      public Builder setVisualizationExportDir(
          java.lang.String value) {
        if (value == null) {
    throw new NullPointerException();
  }
  bitField0_ |= 0x00000040;
        visualizationExportDir_ = value;
        onChanged();
        return this;
      }
      /**
       * <pre>
       * Path to directory to store visualizations in. If empty, visualization
       * images are not exported (only shown on Tensorboard).
       * </pre>
       *
       * <code>optional string visualization_export_dir = 6 [default = ""];</code>
       * @return This builder for chaining.
       */
      public Builder clearVisualizationExportDir() {
        bitField0_ = (bitField0_ & ~0x00000040);
        visualizationExportDir_ = getDefaultInstance().getVisualizationExportDir();
        onChanged();
        return this;
      }
      /**
       * <pre>
       * Path to directory to store visualizations in. If empty, visualization
       * images are not exported (only shown on Tensorboard).
       * </pre>
       *
       * <code>optional string visualization_export_dir = 6 [default = ""];</code>
       * @param value The bytes for visualizationExportDir to set.
       * @return This builder for chaining.
       */
      public Builder setVisualizationExportDirBytes(
          com.google.protobuf.ByteString value) {
        if (value == null) {
    throw new NullPointerException();
  }
  bitField0_ |= 0x00000040;
        visualizationExportDir_ = value;
        onChanged();
        return this;
      }

      private java.lang.Object evalMaster_ = "";
      /**
       * <pre>
       * BNS name of the TensorFlow master.
       * </pre>
       *
       * <code>optional string eval_master = 7 [default = ""];</code>
       * @return Whether the evalMaster field is set.
       */
      public boolean hasEvalMaster() {
        return ((bitField0_ & 0x00000080) != 0);
      }
      /**
       * <pre>
       * BNS name of the TensorFlow master.
       * </pre>
       *
       * <code>optional string eval_master = 7 [default = ""];</code>
       * @return The evalMaster.
       */
      public java.lang.String getEvalMaster() {
        java.lang.Object ref = evalMaster_;
        if (!(ref instanceof java.lang.String)) {
          com.google.protobuf.ByteString bs =
              (com.google.protobuf.ByteString) ref;
          java.lang.String s = bs.toStringUtf8();
          if (bs.isValidUtf8()) {
            evalMaster_ = s;
          }
          return s;
        } else {
          return (java.lang.String) ref;
        }
      }
      /**
       * <pre>
       * BNS name of the TensorFlow master.
       * </pre>
       *
       * <code>optional string eval_master = 7 [default = ""];</code>
       * @return The bytes for evalMaster.
       */
      public com.google.protobuf.ByteString
          getEvalMasterBytes() {
        java.lang.Object ref = evalMaster_;
        if (ref instanceof String) {
          com.google.protobuf.ByteString b =
              com.google.protobuf.ByteString.copyFromUtf8(
                  (java.lang.String) ref);
          evalMaster_ = b;
          return b;
        } else {
          return (com.google.protobuf.ByteString) ref;
        }
      }
      /**
       * <pre>
       * BNS name of the TensorFlow master.
       * </pre>
       *
       * <code>optional string eval_master = 7 [default = ""];</code>
       * @param value The evalMaster to set.
       * @return This builder for chaining.
       */
      public Builder setEvalMaster(
          java.lang.String value) {
        if (value == null) {
    throw new NullPointerException();
  }
  bitField0_ |= 0x00000080;
        evalMaster_ = value;
        onChanged();
        return this;
      }
      /**
       * <pre>
       * BNS name of the TensorFlow master.
       * </pre>
       *
       * <code>optional string eval_master = 7 [default = ""];</code>
       * @return This builder for chaining.
       */
      public Builder clearEvalMaster() {
        bitField0_ = (bitField0_ & ~0x00000080);
        evalMaster_ = getDefaultInstance().getEvalMaster();
        onChanged();
        return this;
      }
      /**
       * <pre>
       * BNS name of the TensorFlow master.
       * </pre>
       *
       * <code>optional string eval_master = 7 [default = ""];</code>
       * @param value The bytes for evalMaster to set.
       * @return This builder for chaining.
       */
      public Builder setEvalMasterBytes(
          com.google.protobuf.ByteString value) {
        if (value == null) {
    throw new NullPointerException();
  }
  bitField0_ |= 0x00000080;
        evalMaster_ = value;
        onChanged();
        return this;
      }

      private com.google.protobuf.LazyStringList metricsSet_ = com.google.protobuf.LazyStringArrayList.EMPTY;
      private void ensureMetricsSetIsMutable() {
        if (!((bitField0_ & 0x00000100) != 0)) {
          metricsSet_ = new com.google.protobuf.LazyStringArrayList(metricsSet_);
          bitField0_ |= 0x00000100;
         }
      }
      /**
       * <pre>
       * Type of metrics to use for evaluation.
       * </pre>
       *
       * <code>repeated string metrics_set = 8;</code>
       * @return A list containing the metricsSet.
       */
      public com.google.protobuf.ProtocolStringList
          getMetricsSetList() {
        return metricsSet_.getUnmodifiableView();
      }
      /**
       * <pre>
       * Type of metrics to use for evaluation.
       * </pre>
       *
       * <code>repeated string metrics_set = 8;</code>
       * @return The count of metricsSet.
       */
      public int getMetricsSetCount() {
        return metricsSet_.size();
      }
      /**
       * <pre>
       * Type of metrics to use for evaluation.
       * </pre>
       *
       * <code>repeated string metrics_set = 8;</code>
       * @param index The index of the element to return.
       * @return The metricsSet at the given index.
       */
      public java.lang.String getMetricsSet(int index) {
        return metricsSet_.get(index);
      }
      /**
       * <pre>
       * Type of metrics to use for evaluation.
       * </pre>
       *
       * <code>repeated string metrics_set = 8;</code>
       * @param index The index of the value to return.
       * @return The bytes of the metricsSet at the given index.
       */
      public com.google.protobuf.ByteString
          getMetricsSetBytes(int index) {
        return metricsSet_.getByteString(index);
      }
      /**
       * <pre>
       * Type of metrics to use for evaluation.
       * </pre>
       *
       * <code>repeated string metrics_set = 8;</code>
       * @param index The index to set the value at.
       * @param value The metricsSet to set.
       * @return This builder for chaining.
       */
      public Builder setMetricsSet(
          int index, java.lang.String value) {
        if (value == null) {
    throw new NullPointerException();
  }
  ensureMetricsSetIsMutable();
        metricsSet_.set(index, value);
        onChanged();
        return this;
      }
      /**
       * <pre>
       * Type of metrics to use for evaluation.
       * </pre>
       *
       * <code>repeated string metrics_set = 8;</code>
       * @param value The metricsSet to add.
       * @return This builder for chaining.
       */
      public Builder addMetricsSet(
          java.lang.String value) {
        if (value == null) {
    throw new NullPointerException();
  }
  ensureMetricsSetIsMutable();
        metricsSet_.add(value);
        onChanged();
        return this;
      }
      /**
       * <pre>
       * Type of metrics to use for evaluation.
       * </pre>
       *
       * <code>repeated string metrics_set = 8;</code>
       * @param values The metricsSet to add.
       * @return This builder for chaining.
       */
      public Builder addAllMetricsSet(
          java.lang.Iterable<java.lang.String> values) {
        ensureMetricsSetIsMutable();
        com.google.protobuf.AbstractMessageLite.Builder.addAll(
            values, metricsSet_);
        onChanged();
        return this;
      }
      /**
       * <pre>
       * Type of metrics to use for evaluation.
       * </pre>
       *
       * <code>repeated string metrics_set = 8;</code>
       * @return This builder for chaining.
       */
      public Builder clearMetricsSet() {
        metricsSet_ = com.google.protobuf.LazyStringArrayList.EMPTY;
        bitField0_ = (bitField0_ & ~0x00000100);
        onChanged();
        return this;
      }
      /**
       * <pre>
       * Type of metrics to use for evaluation.
       * </pre>
       *
       * <code>repeated string metrics_set = 8;</code>
       * @param value The bytes of the metricsSet to add.
       * @return This builder for chaining.
       */
      public Builder addMetricsSetBytes(
          com.google.protobuf.ByteString value) {
        if (value == null) {
    throw new NullPointerException();
  }
  ensureMetricsSetIsMutable();
        metricsSet_.add(value);
        onChanged();
        return this;
      }

      private java.util.List<object_detection.protos.Eval.ParameterizedMetric> parameterizedMetric_ =
        java.util.Collections.emptyList();
      private void ensureParameterizedMetricIsMutable() {
        if (!((bitField0_ & 0x00000200) != 0)) {
          parameterizedMetric_ = new java.util.ArrayList<object_detection.protos.Eval.ParameterizedMetric>(parameterizedMetric_);
          bitField0_ |= 0x00000200;
         }
      }

      private com.google.protobuf.RepeatedFieldBuilderV3<
          object_detection.protos.Eval.ParameterizedMetric, object_detection.protos.Eval.ParameterizedMetric.Builder, object_detection.protos.Eval.ParameterizedMetricOrBuilder> parameterizedMetricBuilder_;

      /**
       * <pre>
       * Type of metrics to use for evaluation. Unlike `metrics_set` above, this
       * field allows configuring evaluation metric through config files.
       * </pre>
       *
       * <code>repeated .object_detection.protos.ParameterizedMetric parameterized_metric = 31;</code>
       */
      public java.util.List<object_detection.protos.Eval.ParameterizedMetric> getParameterizedMetricList() {
        if (parameterizedMetricBuilder_ == null) {
          return java.util.Collections.unmodifiableList(parameterizedMetric_);
        } else {
          return parameterizedMetricBuilder_.getMessageList();
        }
      }
      /**
       * <pre>
       * Type of metrics to use for evaluation. Unlike `metrics_set` above, this
       * field allows configuring evaluation metric through config files.
       * </pre>
       *
       * <code>repeated .object_detection.protos.ParameterizedMetric parameterized_metric = 31;</code>
       */
      public int getParameterizedMetricCount() {
        if (parameterizedMetricBuilder_ == null) {
          return parameterizedMetric_.size();
        } else {
          return parameterizedMetricBuilder_.getCount();
        }
      }
      /**
       * <pre>
       * Type of metrics to use for evaluation. Unlike `metrics_set` above, this
       * field allows configuring evaluation metric through config files.
       * </pre>
       *
       * <code>repeated .object_detection.protos.ParameterizedMetric parameterized_metric = 31;</code>
       */
      public object_detection.protos.Eval.ParameterizedMetric getParameterizedMetric(int index) {
        if (parameterizedMetricBuilder_ == null) {
          return parameterizedMetric_.get(index);
        } else {
          return parameterizedMetricBuilder_.getMessage(index);
        }
      }
      /**
       * <pre>
       * Type of metrics to use for evaluation. Unlike `metrics_set` above, this
       * field allows configuring evaluation metric through config files.
       * </pre>
       *
       * <code>repeated .object_detection.protos.ParameterizedMetric parameterized_metric = 31;</code>
       */
      public Builder setParameterizedMetric(
          int index, object_detection.protos.Eval.ParameterizedMetric value) {
        if (parameterizedMetricBuilder_ == null) {
          if (value == null) {
            throw new NullPointerException();
          }
          ensureParameterizedMetricIsMutable();
          parameterizedMetric_.set(index, value);
          onChanged();
        } else {
          parameterizedMetricBuilder_.setMessage(index, value);
        }
        return this;
      }
      /**
       * <pre>
       * Type of metrics to use for evaluation. Unlike `metrics_set` above, this
       * field allows configuring evaluation metric through config files.
       * </pre>
       *
       * <code>repeated .object_detection.protos.ParameterizedMetric parameterized_metric = 31;</code>
       */
      public Builder setParameterizedMetric(
          int index, object_detection.protos.Eval.ParameterizedMetric.Builder builderForValue) {
        if (parameterizedMetricBuilder_ == null) {
          ensureParameterizedMetricIsMutable();
          parameterizedMetric_.set(index, builderForValue.build());
          onChanged();
        } else {
          parameterizedMetricBuilder_.setMessage(index, builderForValue.build());
        }
        return this;
      }
      /**
       * <pre>
       * Type of metrics to use for evaluation. Unlike `metrics_set` above, this
       * field allows configuring evaluation metric through config files.
       * </pre>
       *
       * <code>repeated .object_detection.protos.ParameterizedMetric parameterized_metric = 31;</code>
       */
      public Builder addParameterizedMetric(object_detection.protos.Eval.ParameterizedMetric value) {
        if (parameterizedMetricBuilder_ == null) {
          if (value == null) {
            throw new NullPointerException();
          }
          ensureParameterizedMetricIsMutable();
          parameterizedMetric_.add(value);
          onChanged();
        } else {
          parameterizedMetricBuilder_.addMessage(value);
        }
        return this;
      }
      /**
       * <pre>
       * Type of metrics to use for evaluation. Unlike `metrics_set` above, this
       * field allows configuring evaluation metric through config files.
       * </pre>
       *
       * <code>repeated .object_detection.protos.ParameterizedMetric parameterized_metric = 31;</code>
       */
      public Builder addParameterizedMetric(
          int index, object_detection.protos.Eval.ParameterizedMetric value) {
        if (parameterizedMetricBuilder_ == null) {
          if (value == null) {
            throw new NullPointerException();
          }
          ensureParameterizedMetricIsMutable();
          parameterizedMetric_.add(index, value);
          onChanged();
        } else {
          parameterizedMetricBuilder_.addMessage(index, value);
        }
        return this;
      }
      /**
       * <pre>
       * Type of metrics to use for evaluation. Unlike `metrics_set` above, this
       * field allows configuring evaluation metric through config files.
       * </pre>
       *
       * <code>repeated .object_detection.protos.ParameterizedMetric parameterized_metric = 31;</code>
       */
      public Builder addParameterizedMetric(
          object_detection.protos.Eval.ParameterizedMetric.Builder builderForValue) {
        if (parameterizedMetricBuilder_ == null) {
          ensureParameterizedMetricIsMutable();
          parameterizedMetric_.add(builderForValue.build());
          onChanged();
        } else {
          parameterizedMetricBuilder_.addMessage(builderForValue.build());
        }
        return this;
      }
      /**
       * <pre>
       * Type of metrics to use for evaluation. Unlike `metrics_set` above, this
       * field allows configuring evaluation metric through config files.
       * </pre>
       *
       * <code>repeated .object_detection.protos.ParameterizedMetric parameterized_metric = 31;</code>
       */
      public Builder addParameterizedMetric(
          int index, object_detection.protos.Eval.ParameterizedMetric.Builder builderForValue) {
        if (parameterizedMetricBuilder_ == null) {
          ensureParameterizedMetricIsMutable();
          parameterizedMetric_.add(index, builderForValue.build());
          onChanged();
        } else {
          parameterizedMetricBuilder_.addMessage(index, builderForValue.build());
        }
        return this;
      }
      /**
       * <pre>
       * Type of metrics to use for evaluation. Unlike `metrics_set` above, this
       * field allows configuring evaluation metric through config files.
       * </pre>
       *
       * <code>repeated .object_detection.protos.ParameterizedMetric parameterized_metric = 31;</code>
       */
      public Builder addAllParameterizedMetric(
          java.lang.Iterable<? extends object_detection.protos.Eval.ParameterizedMetric> values) {
        if (parameterizedMetricBuilder_ == null) {
          ensureParameterizedMetricIsMutable();
          com.google.protobuf.AbstractMessageLite.Builder.addAll(
              values, parameterizedMetric_);
          onChanged();
        } else {
          parameterizedMetricBuilder_.addAllMessages(values);
        }
        return this;
      }
      /**
       * <pre>
       * Type of metrics to use for evaluation. Unlike `metrics_set` above, this
       * field allows configuring evaluation metric through config files.
       * </pre>
       *
       * <code>repeated .object_detection.protos.ParameterizedMetric parameterized_metric = 31;</code>
       */
      public Builder clearParameterizedMetric() {
        if (parameterizedMetricBuilder_ == null) {
          parameterizedMetric_ = java.util.Collections.emptyList();
          bitField0_ = (bitField0_ & ~0x00000200);
          onChanged();
        } else {
          parameterizedMetricBuilder_.clear();
        }
        return this;
      }
      /**
       * <pre>
       * Type of metrics to use for evaluation. Unlike `metrics_set` above, this
       * field allows configuring evaluation metric through config files.
       * </pre>
       *
       * <code>repeated .object_detection.protos.ParameterizedMetric parameterized_metric = 31;</code>
       */
      public Builder removeParameterizedMetric(int index) {
        if (parameterizedMetricBuilder_ == null) {
          ensureParameterizedMetricIsMutable();
          parameterizedMetric_.remove(index);
          onChanged();
        } else {
          parameterizedMetricBuilder_.remove(index);
        }
        return this;
      }
      /**
       * <pre>
       * Type of metrics to use for evaluation. Unlike `metrics_set` above, this
       * field allows configuring evaluation metric through config files.
       * </pre>
       *
       * <code>repeated .object_detection.protos.ParameterizedMetric parameterized_metric = 31;</code>
       */
      public object_detection.protos.Eval.ParameterizedMetric.Builder getParameterizedMetricBuilder(
          int index) {
        return getParameterizedMetricFieldBuilder().getBuilder(index);
      }
      /**
       * <pre>
       * Type of metrics to use for evaluation. Unlike `metrics_set` above, this
       * field allows configuring evaluation metric through config files.
       * </pre>
       *
       * <code>repeated .object_detection.protos.ParameterizedMetric parameterized_metric = 31;</code>
       */
      public object_detection.protos.Eval.ParameterizedMetricOrBuilder getParameterizedMetricOrBuilder(
          int index) {
        if (parameterizedMetricBuilder_ == null) {
          return parameterizedMetric_.get(index);  } else {
          return parameterizedMetricBuilder_.getMessageOrBuilder(index);
        }
      }
      /**
       * <pre>
       * Type of metrics to use for evaluation. Unlike `metrics_set` above, this
       * field allows configuring evaluation metric through config files.
       * </pre>
       *
       * <code>repeated .object_detection.protos.ParameterizedMetric parameterized_metric = 31;</code>
       */
      public java.util.List<? extends object_detection.protos.Eval.ParameterizedMetricOrBuilder>
           getParameterizedMetricOrBuilderList() {
        if (parameterizedMetricBuilder_ != null) {
          return parameterizedMetricBuilder_.getMessageOrBuilderList();
        } else {
          return java.util.Collections.unmodifiableList(parameterizedMetric_);
        }
      }
      /**
       * <pre>
       * Type of metrics to use for evaluation. Unlike `metrics_set` above, this
       * field allows configuring evaluation metric through config files.
       * </pre>
       *
       * <code>repeated .object_detection.protos.ParameterizedMetric parameterized_metric = 31;</code>
       */
      public object_detection.protos.Eval.ParameterizedMetric.Builder addParameterizedMetricBuilder() {
        return getParameterizedMetricFieldBuilder().addBuilder(
            object_detection.protos.Eval.ParameterizedMetric.getDefaultInstance());
      }
      /**
       * <pre>
       * Type of metrics to use for evaluation. Unlike `metrics_set` above, this
       * field allows configuring evaluation metric through config files.
       * </pre>
       *
       * <code>repeated .object_detection.protos.ParameterizedMetric parameterized_metric = 31;</code>
       */
      public object_detection.protos.Eval.ParameterizedMetric.Builder addParameterizedMetricBuilder(
          int index) {
        return getParameterizedMetricFieldBuilder().addBuilder(
            index, object_detection.protos.Eval.ParameterizedMetric.getDefaultInstance());
      }
      /**
       * <pre>
       * Type of metrics to use for evaluation. Unlike `metrics_set` above, this
       * field allows configuring evaluation metric through config files.
       * </pre>
       *
       * <code>repeated .object_detection.protos.ParameterizedMetric parameterized_metric = 31;</code>
       */
      public java.util.List<object_detection.protos.Eval.ParameterizedMetric.Builder>
           getParameterizedMetricBuilderList() {
        return getParameterizedMetricFieldBuilder().getBuilderList();
      }
      private com.google.protobuf.RepeatedFieldBuilderV3<
          object_detection.protos.Eval.ParameterizedMetric, object_detection.protos.Eval.ParameterizedMetric.Builder, object_detection.protos.Eval.ParameterizedMetricOrBuilder>
          getParameterizedMetricFieldBuilder() {
        if (parameterizedMetricBuilder_ == null) {
          parameterizedMetricBuilder_ = new com.google.protobuf.RepeatedFieldBuilderV3<
              object_detection.protos.Eval.ParameterizedMetric, object_detection.protos.Eval.ParameterizedMetric.Builder, object_detection.protos.Eval.ParameterizedMetricOrBuilder>(
                  parameterizedMetric_,
                  ((bitField0_ & 0x00000200) != 0),
                  getParentForChildren(),
                  isClean());
          parameterizedMetric_ = null;
        }
        return parameterizedMetricBuilder_;
      }

      private java.lang.Object exportPath_ = "";
      /**
       * <pre>
       * Path to export detections to COCO compatible JSON format.
       * </pre>
       *
       * <code>optional string export_path = 9 [default = ""];</code>
       * @return Whether the exportPath field is set.
       */
      public boolean hasExportPath() {
        return ((bitField0_ & 0x00000400) != 0);
      }
      /**
       * <pre>
       * Path to export detections to COCO compatible JSON format.
       * </pre>
       *
       * <code>optional string export_path = 9 [default = ""];</code>
       * @return The exportPath.
       */
      public java.lang.String getExportPath() {
        java.lang.Object ref = exportPath_;
        if (!(ref instanceof java.lang.String)) {
          com.google.protobuf.ByteString bs =
              (com.google.protobuf.ByteString) ref;
          java.lang.String s = bs.toStringUtf8();
          if (bs.isValidUtf8()) {
            exportPath_ = s;
          }
          return s;
        } else {
          return (java.lang.String) ref;
        }
      }
      /**
       * <pre>
       * Path to export detections to COCO compatible JSON format.
       * </pre>
       *
       * <code>optional string export_path = 9 [default = ""];</code>
       * @return The bytes for exportPath.
       */
      public com.google.protobuf.ByteString
          getExportPathBytes() {
        java.lang.Object ref = exportPath_;
        if (ref instanceof String) {
          com.google.protobuf.ByteString b =
              com.google.protobuf.ByteString.copyFromUtf8(
                  (java.lang.String) ref);
          exportPath_ = b;
          return b;
        } else {
          return (com.google.protobuf.ByteString) ref;
        }
      }
      /**
       * <pre>
       * Path to export detections to COCO compatible JSON format.
       * </pre>
       *
       * <code>optional string export_path = 9 [default = ""];</code>
       * @param value The exportPath to set.
       * @return This builder for chaining.
       */
      public Builder setExportPath(
          java.lang.String value) {
        if (value == null) {
    throw new NullPointerException();
  }
  bitField0_ |= 0x00000400;
        exportPath_ = value;
        onChanged();
        return this;
      }
      /**
       * <pre>
       * Path to export detections to COCO compatible JSON format.
       * </pre>
       *
       * <code>optional string export_path = 9 [default = ""];</code>
       * @return This builder for chaining.
       */
      public Builder clearExportPath() {
        bitField0_ = (bitField0_ & ~0x00000400);
        exportPath_ = getDefaultInstance().getExportPath();
        onChanged();
        return this;
      }
      /**
       * <pre>
       * Path to export detections to COCO compatible JSON format.
       * </pre>
       *
       * <code>optional string export_path = 9 [default = ""];</code>
       * @param value The bytes for exportPath to set.
       * @return This builder for chaining.
       */
      public Builder setExportPathBytes(
          com.google.protobuf.ByteString value) {
        if (value == null) {
    throw new NullPointerException();
  }
  bitField0_ |= 0x00000400;
        exportPath_ = value;
        onChanged();
        return this;
      }

      private boolean ignoreGroundtruth_ ;
      /**
       * <pre>
       * Option to not read groundtruth labels and only export detections to
       * COCO-compatible JSON file.
       * </pre>
       *
       * <code>optional bool ignore_groundtruth = 10 [default = false];</code>
       * @return Whether the ignoreGroundtruth field is set.
       */
      @java.lang.Override
      public boolean hasIgnoreGroundtruth() {
        return ((bitField0_ & 0x00000800) != 0);
      }
      /**
       * <pre>
       * Option to not read groundtruth labels and only export detections to
       * COCO-compatible JSON file.
       * </pre>
       *
       * <code>optional bool ignore_groundtruth = 10 [default = false];</code>
       * @return The ignoreGroundtruth.
       */
      @java.lang.Override
      public boolean getIgnoreGroundtruth() {
        return ignoreGroundtruth_;
      }
      /**
       * <pre>
       * Option to not read groundtruth labels and only export detections to
       * COCO-compatible JSON file.
       * </pre>
       *
       * <code>optional bool ignore_groundtruth = 10 [default = false];</code>
       * @param value The ignoreGroundtruth to set.
       * @return This builder for chaining.
       */
      public Builder setIgnoreGroundtruth(boolean value) {
        bitField0_ |= 0x00000800;
        ignoreGroundtruth_ = value;
        onChanged();
        return this;
      }
      /**
       * <pre>
       * Option to not read groundtruth labels and only export detections to
       * COCO-compatible JSON file.
       * </pre>
       *
       * <code>optional bool ignore_groundtruth = 10 [default = false];</code>
       * @return This builder for chaining.
       */
      public Builder clearIgnoreGroundtruth() {
        bitField0_ = (bitField0_ & ~0x00000800);
        ignoreGroundtruth_ = false;
        onChanged();
        return this;
      }

      private boolean useMovingAverages_ ;
      /**
       * <pre>
       * Use exponential moving averages of variables for evaluation.
       * TODO(rathodv): When this is false make sure the model is constructed
       * without moving averages in restore_fn.
       * </pre>
       *
       * <code>optional bool use_moving_averages = 11 [default = false];</code>
       * @return Whether the useMovingAverages field is set.
       */
      @java.lang.Override
      public boolean hasUseMovingAverages() {
        return ((bitField0_ & 0x00001000) != 0);
      }
      /**
       * <pre>
       * Use exponential moving averages of variables for evaluation.
       * TODO(rathodv): When this is false make sure the model is constructed
       * without moving averages in restore_fn.
       * </pre>
       *
       * <code>optional bool use_moving_averages = 11 [default = false];</code>
       * @return The useMovingAverages.
       */
      @java.lang.Override
      public boolean getUseMovingAverages() {
        return useMovingAverages_;
      }
      /**
       * <pre>
       * Use exponential moving averages of variables for evaluation.
       * TODO(rathodv): When this is false make sure the model is constructed
       * without moving averages in restore_fn.
       * </pre>
       *
       * <code>optional bool use_moving_averages = 11 [default = false];</code>
       * @param value The useMovingAverages to set.
       * @return This builder for chaining.
       */
      public Builder setUseMovingAverages(boolean value) {
        bitField0_ |= 0x00001000;
        useMovingAverages_ = value;
        onChanged();
        return this;
      }
      /**
       * <pre>
       * Use exponential moving averages of variables for evaluation.
       * TODO(rathodv): When this is false make sure the model is constructed
       * without moving averages in restore_fn.
       * </pre>
       *
       * <code>optional bool use_moving_averages = 11 [default = false];</code>
       * @return This builder for chaining.
       */
      public Builder clearUseMovingAverages() {
        bitField0_ = (bitField0_ & ~0x00001000);
        useMovingAverages_ = false;
        onChanged();
        return this;
      }

      private boolean evalInstanceMasks_ ;
      /**
       * <pre>
       * Whether to evaluate instance masks.
       * Note that since there is no evaluation code currently for instance
       * segmentation this option is unused.
       * </pre>
       *
       * <code>optional bool eval_instance_masks = 12 [default = false];</code>
       * @return Whether the evalInstanceMasks field is set.
       */
      @java.lang.Override
      public boolean hasEvalInstanceMasks() {
        return ((bitField0_ & 0x00002000) != 0);
      }
      /**
       * <pre>
       * Whether to evaluate instance masks.
       * Note that since there is no evaluation code currently for instance
       * segmentation this option is unused.
       * </pre>
       *
       * <code>optional bool eval_instance_masks = 12 [default = false];</code>
       * @return The evalInstanceMasks.
       */
      @java.lang.Override
      public boolean getEvalInstanceMasks() {
        return evalInstanceMasks_;
      }
      /**
       * <pre>
       * Whether to evaluate instance masks.
       * Note that since there is no evaluation code currently for instance
       * segmentation this option is unused.
       * </pre>
       *
       * <code>optional bool eval_instance_masks = 12 [default = false];</code>
       * @param value The evalInstanceMasks to set.
       * @return This builder for chaining.
       */
      public Builder setEvalInstanceMasks(boolean value) {
        bitField0_ |= 0x00002000;
        evalInstanceMasks_ = value;
        onChanged();
        return this;
      }
      /**
       * <pre>
       * Whether to evaluate instance masks.
       * Note that since there is no evaluation code currently for instance
       * segmentation this option is unused.
       * </pre>
       *
       * <code>optional bool eval_instance_masks = 12 [default = false];</code>
       * @return This builder for chaining.
       */
      public Builder clearEvalInstanceMasks() {
        bitField0_ = (bitField0_ & ~0x00002000);
        evalInstanceMasks_ = false;
        onChanged();
        return this;
      }

      private float minScoreThreshold_ = 0.5F;
      /**
       * <pre>
       * Minimum score threshold for a detected object box to be visualized
       * </pre>
       *
       * <code>optional float min_score_threshold = 13 [default = 0.5];</code>
       * @return Whether the minScoreThreshold field is set.
       */
      @java.lang.Override
      public boolean hasMinScoreThreshold() {
        return ((bitField0_ & 0x00004000) != 0);
      }
      /**
       * <pre>
       * Minimum score threshold for a detected object box to be visualized
       * </pre>
       *
       * <code>optional float min_score_threshold = 13 [default = 0.5];</code>
       * @return The minScoreThreshold.
       */
      @java.lang.Override
      public float getMinScoreThreshold() {
        return minScoreThreshold_;
      }
      /**
       * <pre>
       * Minimum score threshold for a detected object box to be visualized
       * </pre>
       *
       * <code>optional float min_score_threshold = 13 [default = 0.5];</code>
       * @param value The minScoreThreshold to set.
       * @return This builder for chaining.
       */
      public Builder setMinScoreThreshold(float value) {
        bitField0_ |= 0x00004000;
        minScoreThreshold_ = value;
        onChanged();
        return this;
      }
      /**
       * <pre>
       * Minimum score threshold for a detected object box to be visualized
       * </pre>
       *
       * <code>optional float min_score_threshold = 13 [default = 0.5];</code>
       * @return This builder for chaining.
       */
      public Builder clearMinScoreThreshold() {
        bitField0_ = (bitField0_ & ~0x00004000);
        minScoreThreshold_ = 0.5F;
        onChanged();
        return this;
      }

      private int maxNumBoxesToVisualize_ = 20;
      /**
       * <pre>
       * Maximum number of detections to visualize
       * </pre>
       *
       * <code>optional int32 max_num_boxes_to_visualize = 14 [default = 20];</code>
       * @return Whether the maxNumBoxesToVisualize field is set.
       */
      @java.lang.Override
      public boolean hasMaxNumBoxesToVisualize() {
        return ((bitField0_ & 0x00008000) != 0);
      }
      /**
       * <pre>
       * Maximum number of detections to visualize
       * </pre>
       *
       * <code>optional int32 max_num_boxes_to_visualize = 14 [default = 20];</code>
       * @return The maxNumBoxesToVisualize.
       */
      @java.lang.Override
      public int getMaxNumBoxesToVisualize() {
        return maxNumBoxesToVisualize_;
      }
      /**
       * <pre>
       * Maximum number of detections to visualize
       * </pre>
       *
       * <code>optional int32 max_num_boxes_to_visualize = 14 [default = 20];</code>
       * @param value The maxNumBoxesToVisualize to set.
       * @return This builder for chaining.
       */
      public Builder setMaxNumBoxesToVisualize(int value) {
        bitField0_ |= 0x00008000;
        maxNumBoxesToVisualize_ = value;
        onChanged();
        return this;
      }
      /**
       * <pre>
       * Maximum number of detections to visualize
       * </pre>
       *
       * <code>optional int32 max_num_boxes_to_visualize = 14 [default = 20];</code>
       * @return This builder for chaining.
       */
      public Builder clearMaxNumBoxesToVisualize() {
        bitField0_ = (bitField0_ & ~0x00008000);
        maxNumBoxesToVisualize_ = 20;
        onChanged();
        return this;
      }

      private boolean skipScores_ ;
      /**
       * <pre>
       * When drawing a single detection, each label is by default visualized as
       * &lt;label name&gt; : &lt;label score&gt;. One can skip the name or/and score using the
       * following fields:
       * </pre>
       *
       * <code>optional bool skip_scores = 15 [default = false];</code>
       * @return Whether the skipScores field is set.
       */
      @java.lang.Override
      public boolean hasSkipScores() {
        return ((bitField0_ & 0x00010000) != 0);
      }
      /**
       * <pre>
       * When drawing a single detection, each label is by default visualized as
       * &lt;label name&gt; : &lt;label score&gt;. One can skip the name or/and score using the
       * following fields:
       * </pre>
       *
       * <code>optional bool skip_scores = 15 [default = false];</code>
       * @return The skipScores.
       */
      @java.lang.Override
      public boolean getSkipScores() {
        return skipScores_;
      }
      /**
       * <pre>
       * When drawing a single detection, each label is by default visualized as
       * &lt;label name&gt; : &lt;label score&gt;. One can skip the name or/and score using the
       * following fields:
       * </pre>
       *
       * <code>optional bool skip_scores = 15 [default = false];</code>
       * @param value The skipScores to set.
       * @return This builder for chaining.
       */
      public Builder setSkipScores(boolean value) {
        bitField0_ |= 0x00010000;
        skipScores_ = value;
        onChanged();
        return this;
      }
      /**
       * <pre>
       * When drawing a single detection, each label is by default visualized as
       * &lt;label name&gt; : &lt;label score&gt;. One can skip the name or/and score using the
       * following fields:
       * </pre>
       *
       * <code>optional bool skip_scores = 15 [default = false];</code>
       * @return This builder for chaining.
       */
      public Builder clearSkipScores() {
        bitField0_ = (bitField0_ & ~0x00010000);
        skipScores_ = false;
        onChanged();
        return this;
      }

      private boolean skipLabels_ ;
      /**
       * <code>optional bool skip_labels = 16 [default = false];</code>
       * @return Whether the skipLabels field is set.
       */
      @java.lang.Override
      public boolean hasSkipLabels() {
        return ((bitField0_ & 0x00020000) != 0);
      }
      /**
       * <code>optional bool skip_labels = 16 [default = false];</code>
       * @return The skipLabels.
       */
      @java.lang.Override
      public boolean getSkipLabels() {
        return skipLabels_;
      }
      /**
       * <code>optional bool skip_labels = 16 [default = false];</code>
       * @param value The skipLabels to set.
       * @return This builder for chaining.
       */
      public Builder setSkipLabels(boolean value) {
        bitField0_ |= 0x00020000;
        skipLabels_ = value;
        onChanged();
        return this;
      }
      /**
       * <code>optional bool skip_labels = 16 [default = false];</code>
       * @return This builder for chaining.
       */
      public Builder clearSkipLabels() {
        bitField0_ = (bitField0_ & ~0x00020000);
        skipLabels_ = false;
        onChanged();
        return this;
      }

      private boolean visualizeGroundtruthBoxes_ ;
      /**
       * <pre>
       * Whether to show groundtruth boxes in addition to detected boxes in
       * visualizations.
       * </pre>
       *
       * <code>optional bool visualize_groundtruth_boxes = 17 [default = false];</code>
       * @return Whether the visualizeGroundtruthBoxes field is set.
       */
      @java.lang.Override
      public boolean hasVisualizeGroundtruthBoxes() {
        return ((bitField0_ & 0x00040000) != 0);
      }
      /**
       * <pre>
       * Whether to show groundtruth boxes in addition to detected boxes in
       * visualizations.
       * </pre>
       *
       * <code>optional bool visualize_groundtruth_boxes = 17 [default = false];</code>
       * @return The visualizeGroundtruthBoxes.
       */
      @java.lang.Override
      public boolean getVisualizeGroundtruthBoxes() {
        return visualizeGroundtruthBoxes_;
      }
      /**
       * <pre>
       * Whether to show groundtruth boxes in addition to detected boxes in
       * visualizations.
       * </pre>
       *
       * <code>optional bool visualize_groundtruth_boxes = 17 [default = false];</code>
       * @param value The visualizeGroundtruthBoxes to set.
       * @return This builder for chaining.
       */
      public Builder setVisualizeGroundtruthBoxes(boolean value) {
        bitField0_ |= 0x00040000;
        visualizeGroundtruthBoxes_ = value;
        onChanged();
        return this;
      }
      /**
       * <pre>
       * Whether to show groundtruth boxes in addition to detected boxes in
       * visualizations.
       * </pre>
       *
       * <code>optional bool visualize_groundtruth_boxes = 17 [default = false];</code>
       * @return This builder for chaining.
       */
      public Builder clearVisualizeGroundtruthBoxes() {
        bitField0_ = (bitField0_ & ~0x00040000);
        visualizeGroundtruthBoxes_ = false;
        onChanged();
        return this;
      }

      private java.lang.Object groundtruthBoxVisualizationColor_ = "black";
      /**
       * <pre>
       * Box color for visualizing groundtruth boxes.
       * </pre>
       *
       * <code>optional string groundtruth_box_visualization_color = 18 [default = "black"];</code>
       * @return Whether the groundtruthBoxVisualizationColor field is set.
       */
      public boolean hasGroundtruthBoxVisualizationColor() {
        return ((bitField0_ & 0x00080000) != 0);
      }
      /**
       * <pre>
       * Box color for visualizing groundtruth boxes.
       * </pre>
       *
       * <code>optional string groundtruth_box_visualization_color = 18 [default = "black"];</code>
       * @return The groundtruthBoxVisualizationColor.
       */
      public java.lang.String getGroundtruthBoxVisualizationColor() {
        java.lang.Object ref = groundtruthBoxVisualizationColor_;
        if (!(ref instanceof java.lang.String)) {
          com.google.protobuf.ByteString bs =
              (com.google.protobuf.ByteString) ref;
          java.lang.String s = bs.toStringUtf8();
          if (bs.isValidUtf8()) {
            groundtruthBoxVisualizationColor_ = s;
          }
          return s;
        } else {
          return (java.lang.String) ref;
        }
      }
      /**
       * <pre>
       * Box color for visualizing groundtruth boxes.
       * </pre>
       *
       * <code>optional string groundtruth_box_visualization_color = 18 [default = "black"];</code>
       * @return The bytes for groundtruthBoxVisualizationColor.
       */
      public com.google.protobuf.ByteString
          getGroundtruthBoxVisualizationColorBytes() {
        java.lang.Object ref = groundtruthBoxVisualizationColor_;
        if (ref instanceof String) {
          com.google.protobuf.ByteString b =
              com.google.protobuf.ByteString.copyFromUtf8(
                  (java.lang.String) ref);
          groundtruthBoxVisualizationColor_ = b;
          return b;
        } else {
          return (com.google.protobuf.ByteString) ref;
        }
      }
      /**
       * <pre>
       * Box color for visualizing groundtruth boxes.
       * </pre>
       *
       * <code>optional string groundtruth_box_visualization_color = 18 [default = "black"];</code>
       * @param value The groundtruthBoxVisualizationColor to set.
       * @return This builder for chaining.
       */
      public Builder setGroundtruthBoxVisualizationColor(
          java.lang.String value) {
        if (value == null) {
    throw new NullPointerException();
  }
  bitField0_ |= 0x00080000;
        groundtruthBoxVisualizationColor_ = value;
        onChanged();
        return this;
      }
      /**
       * <pre>
       * Box color for visualizing groundtruth boxes.
       * </pre>
       *
       * <code>optional string groundtruth_box_visualization_color = 18 [default = "black"];</code>
       * @return This builder for chaining.
       */
      public Builder clearGroundtruthBoxVisualizationColor() {
        bitField0_ = (bitField0_ & ~0x00080000);
        groundtruthBoxVisualizationColor_ = getDefaultInstance().getGroundtruthBoxVisualizationColor();
        onChanged();
        return this;
      }
      /**
       * <pre>
       * Box color for visualizing groundtruth boxes.
       * </pre>
       *
       * <code>optional string groundtruth_box_visualization_color = 18 [default = "black"];</code>
       * @param value The bytes for groundtruthBoxVisualizationColor to set.
       * @return This builder for chaining.
       */
      public Builder setGroundtruthBoxVisualizationColorBytes(
          com.google.protobuf.ByteString value) {
        if (value == null) {
    throw new NullPointerException();
  }
  bitField0_ |= 0x00080000;
        groundtruthBoxVisualizationColor_ = value;
        onChanged();
        return this;
      }

      private boolean keepImageIdForVisualizationExport_ ;
      /**
       * <pre>
       * Whether to keep image identifier in filename when exported to
       * visualization_export_dir.
       * </pre>
       *
       * <code>optional bool keep_image_id_for_visualization_export = 19 [default = false];</code>
       * @return Whether the keepImageIdForVisualizationExport field is set.
       */
      @java.lang.Override
      public boolean hasKeepImageIdForVisualizationExport() {
        return ((bitField0_ & 0x00100000) != 0);
      }
      /**
       * <pre>
       * Whether to keep image identifier in filename when exported to
       * visualization_export_dir.
       * </pre>
       *
       * <code>optional bool keep_image_id_for_visualization_export = 19 [default = false];</code>
       * @return The keepImageIdForVisualizationExport.
       */
      @java.lang.Override
      public boolean getKeepImageIdForVisualizationExport() {
        return keepImageIdForVisualizationExport_;
      }
      /**
       * <pre>
       * Whether to keep image identifier in filename when exported to
       * visualization_export_dir.
       * </pre>
       *
       * <code>optional bool keep_image_id_for_visualization_export = 19 [default = false];</code>
       * @param value The keepImageIdForVisualizationExport to set.
       * @return This builder for chaining.
       */
      public Builder setKeepImageIdForVisualizationExport(boolean value) {
        bitField0_ |= 0x00100000;
        keepImageIdForVisualizationExport_ = value;
        onChanged();
        return this;
      }
      /**
       * <pre>
       * Whether to keep image identifier in filename when exported to
       * visualization_export_dir.
       * </pre>
       *
       * <code>optional bool keep_image_id_for_visualization_export = 19 [default = false];</code>
       * @return This builder for chaining.
       */
      public Builder clearKeepImageIdForVisualizationExport() {
        bitField0_ = (bitField0_ & ~0x00100000);
        keepImageIdForVisualizationExport_ = false;
        onChanged();
        return this;
      }

      private boolean retainOriginalImages_ = true;
      /**
       * <pre>
       * Whether to retain original images (i.e. not pre-processed) in the tensor
       * dictionary, so that they can be displayed in Tensorboard.
       * </pre>
       *
       * <code>optional bool retain_original_images = 23 [default = true];</code>
       * @return Whether the retainOriginalImages field is set.
       */
      @java.lang.Override
      public boolean hasRetainOriginalImages() {
        return ((bitField0_ & 0x00200000) != 0);
      }
      /**
       * <pre>
       * Whether to retain original images (i.e. not pre-processed) in the tensor
       * dictionary, so that they can be displayed in Tensorboard.
       * </pre>
       *
       * <code>optional bool retain_original_images = 23 [default = true];</code>
       * @return The retainOriginalImages.
       */
      @java.lang.Override
      public boolean getRetainOriginalImages() {
        return retainOriginalImages_;
      }
      /**
       * <pre>
       * Whether to retain original images (i.e. not pre-processed) in the tensor
       * dictionary, so that they can be displayed in Tensorboard.
       * </pre>
       *
       * <code>optional bool retain_original_images = 23 [default = true];</code>
       * @param value The retainOriginalImages to set.
       * @return This builder for chaining.
       */
      public Builder setRetainOriginalImages(boolean value) {
        bitField0_ |= 0x00200000;
        retainOriginalImages_ = value;
        onChanged();
        return this;
      }
      /**
       * <pre>
       * Whether to retain original images (i.e. not pre-processed) in the tensor
       * dictionary, so that they can be displayed in Tensorboard.
       * </pre>
       *
       * <code>optional bool retain_original_images = 23 [default = true];</code>
       * @return This builder for chaining.
       */
      public Builder clearRetainOriginalImages() {
        bitField0_ = (bitField0_ & ~0x00200000);
        retainOriginalImages_ = true;
        onChanged();
        return this;
      }

      private boolean includeMetricsPerCategory_ ;
      /**
       * <pre>
       * If True, additionally include per-category metrics.
       * </pre>
       *
       * <code>optional bool include_metrics_per_category = 24 [default = false];</code>
       * @return Whether the includeMetricsPerCategory field is set.
       */
      @java.lang.Override
      public boolean hasIncludeMetricsPerCategory() {
        return ((bitField0_ & 0x00400000) != 0);
      }
      /**
       * <pre>
       * If True, additionally include per-category metrics.
       * </pre>
       *
       * <code>optional bool include_metrics_per_category = 24 [default = false];</code>
       * @return The includeMetricsPerCategory.
       */
      @java.lang.Override
      public boolean getIncludeMetricsPerCategory() {
        return includeMetricsPerCategory_;
      }
      /**
       * <pre>
       * If True, additionally include per-category metrics.
       * </pre>
       *
       * <code>optional bool include_metrics_per_category = 24 [default = false];</code>
       * @param value The includeMetricsPerCategory to set.
       * @return This builder for chaining.
       */
      public Builder setIncludeMetricsPerCategory(boolean value) {
        bitField0_ |= 0x00400000;
        includeMetricsPerCategory_ = value;
        onChanged();
        return this;
      }
      /**
       * <pre>
       * If True, additionally include per-category metrics.
       * </pre>
       *
       * <code>optional bool include_metrics_per_category = 24 [default = false];</code>
       * @return This builder for chaining.
       */
      public Builder clearIncludeMetricsPerCategory() {
        bitField0_ = (bitField0_ & ~0x00400000);
        includeMetricsPerCategory_ = false;
        onChanged();
        return this;
      }

      private boolean allMetricsPerCategory_ ;
      /**
       * <pre>
       * If true, includes all metrics per category.
       * </pre>
       *
       * <code>optional bool all_metrics_per_category = 35 [default = false];</code>
       * @return Whether the allMetricsPerCategory field is set.
       */
      @java.lang.Override
      public boolean hasAllMetricsPerCategory() {
        return ((bitField0_ & 0x00800000) != 0);
      }
      /**
       * <pre>
       * If true, includes all metrics per category.
       * </pre>
       *
       * <code>optional bool all_metrics_per_category = 35 [default = false];</code>
       * @return The allMetricsPerCategory.
       */
      @java.lang.Override
      public boolean getAllMetricsPerCategory() {
        return allMetricsPerCategory_;
      }
      /**
       * <pre>
       * If true, includes all metrics per category.
       * </pre>
       *
       * <code>optional bool all_metrics_per_category = 35 [default = false];</code>
       * @param value The allMetricsPerCategory to set.
       * @return This builder for chaining.
       */
      public Builder setAllMetricsPerCategory(boolean value) {
        bitField0_ |= 0x00800000;
        allMetricsPerCategory_ = value;
        onChanged();
        return this;
      }
      /**
       * <pre>
       * If true, includes all metrics per category.
       * </pre>
       *
       * <code>optional bool all_metrics_per_category = 35 [default = false];</code>
       * @return This builder for chaining.
       */
      public Builder clearAllMetricsPerCategory() {
        bitField0_ = (bitField0_ & ~0x00800000);
        allMetricsPerCategory_ = false;
        onChanged();
        return this;
      }

      private com.google.protobuf.MapField<
          java.lang.String, java.lang.String> superCategories_;
      private com.google.protobuf.MapField<java.lang.String, java.lang.String>
      internalGetSuperCategories() {
        if (superCategories_ == null) {
          return com.google.protobuf.MapField.emptyMapField(
              SuperCategoriesDefaultEntryHolder.defaultEntry);
        }
        return superCategories_;
      }
      private com.google.protobuf.MapField<java.lang.String, java.lang.String>
      internalGetMutableSuperCategories() {
        onChanged();;
        if (superCategories_ == null) {
          superCategories_ = com.google.protobuf.MapField.newMapField(
              SuperCategoriesDefaultEntryHolder.defaultEntry);
        }
        if (!superCategories_.isMutable()) {
          superCategories_ = superCategories_.copy();
        }
        return superCategories_;
      }

      public int getSuperCategoriesCount() {
        return internalGetSuperCategories().getMap().size();
      }
      /**
       * <pre>
       * Optional super-category definitions: keys are super-category names;
       * values are comma-separated categories (assumed to correspond to category
       * names (`display_name`) in the label map.
       * </pre>
       *
       * <code>map&lt;string, string&gt; super_categories = 34;</code>
       */

      @java.lang.Override
      public boolean containsSuperCategories(
          java.lang.String key) {
        if (key == null) { throw new java.lang.NullPointerException(); }
        return internalGetSuperCategories().getMap().containsKey(key);
      }
      /**
       * Use {@link #getSuperCategoriesMap()} instead.
       */
      @java.lang.Override
      @java.lang.Deprecated
      public java.util.Map<java.lang.String, java.lang.String> getSuperCategories() {
        return getSuperCategoriesMap();
      }
      /**
       * <pre>
       * Optional super-category definitions: keys are super-category names;
       * values are comma-separated categories (assumed to correspond to category
       * names (`display_name`) in the label map.
       * </pre>
       *
       * <code>map&lt;string, string&gt; super_categories = 34;</code>
       */
      @java.lang.Override

      public java.util.Map<java.lang.String, java.lang.String> getSuperCategoriesMap() {
        return internalGetSuperCategories().getMap();
      }
      /**
       * <pre>
       * Optional super-category definitions: keys are super-category names;
       * values are comma-separated categories (assumed to correspond to category
       * names (`display_name`) in the label map.
       * </pre>
       *
       * <code>map&lt;string, string&gt; super_categories = 34;</code>
       */
      @java.lang.Override

      public java.lang.String getSuperCategoriesOrDefault(
          java.lang.String key,
          java.lang.String defaultValue) {
        if (key == null) { throw new java.lang.NullPointerException(); }
        java.util.Map<java.lang.String, java.lang.String> map =
            internalGetSuperCategories().getMap();
        return map.containsKey(key) ? map.get(key) : defaultValue;
      }
      /**
       * <pre>
       * Optional super-category definitions: keys are super-category names;
       * values are comma-separated categories (assumed to correspond to category
       * names (`display_name`) in the label map.
       * </pre>
       *
       * <code>map&lt;string, string&gt; super_categories = 34;</code>
       */
      @java.lang.Override

      public java.lang.String getSuperCategoriesOrThrow(
          java.lang.String key) {
        if (key == null) { throw new java.lang.NullPointerException(); }
        java.util.Map<java.lang.String, java.lang.String> map =
            internalGetSuperCategories().getMap();
        if (!map.containsKey(key)) {
          throw new java.lang.IllegalArgumentException();
        }
        return map.get(key);
      }

      public Builder clearSuperCategories() {
        internalGetMutableSuperCategories().getMutableMap()
            .clear();
        return this;
      }
      /**
       * <pre>
       * Optional super-category definitions: keys are super-category names;
       * values are comma-separated categories (assumed to correspond to category
       * names (`display_name`) in the label map.
       * </pre>
       *
       * <code>map&lt;string, string&gt; super_categories = 34;</code>
       */

      public Builder removeSuperCategories(
          java.lang.String key) {
        if (key == null) { throw new java.lang.NullPointerException(); }
        internalGetMutableSuperCategories().getMutableMap()
            .remove(key);
        return this;
      }
      /**
       * Use alternate mutation accessors instead.
       */
      @java.lang.Deprecated
      public java.util.Map<java.lang.String, java.lang.String>
      getMutableSuperCategories() {
        return internalGetMutableSuperCategories().getMutableMap();
      }
      /**
       * <pre>
       * Optional super-category definitions: keys are super-category names;
       * values are comma-separated categories (assumed to correspond to category
       * names (`display_name`) in the label map.
       * </pre>
       *
       * <code>map&lt;string, string&gt; super_categories = 34;</code>
       */
      public Builder putSuperCategories(
          java.lang.String key,
          java.lang.String value) {
        if (key == null) { throw new java.lang.NullPointerException(); }
        if (value == null) { throw new java.lang.NullPointerException(); }
        internalGetMutableSuperCategories().getMutableMap()
            .put(key, value);
        return this;
      }
      /**
       * <pre>
       * Optional super-category definitions: keys are super-category names;
       * values are comma-separated categories (assumed to correspond to category
       * names (`display_name`) in the label map.
       * </pre>
       *
       * <code>map&lt;string, string&gt; super_categories = 34;</code>
       */

      public Builder putAllSuperCategories(
          java.util.Map<java.lang.String, java.lang.String> values) {
        internalGetMutableSuperCategories().getMutableMap()
            .putAll(values);
        return this;
      }

      private float recallLowerBound_ ;
      /**
       * <pre>
       * Recall range within which precision should be computed.
       * </pre>
       *
       * <code>optional float recall_lower_bound = 26 [default = 0];</code>
       * @return Whether the recallLowerBound field is set.
       */
      @java.lang.Override
      public boolean hasRecallLowerBound() {
        return ((bitField0_ & 0x02000000) != 0);
      }
      /**
       * <pre>
       * Recall range within which precision should be computed.
       * </pre>
       *
       * <code>optional float recall_lower_bound = 26 [default = 0];</code>
       * @return The recallLowerBound.
       */
      @java.lang.Override
      public float getRecallLowerBound() {
        return recallLowerBound_;
      }
      /**
       * <pre>
       * Recall range within which precision should be computed.
       * </pre>
       *
       * <code>optional float recall_lower_bound = 26 [default = 0];</code>
       * @param value The recallLowerBound to set.
       * @return This builder for chaining.
       */
      public Builder setRecallLowerBound(float value) {
        bitField0_ |= 0x02000000;
        recallLowerBound_ = value;
        onChanged();
        return this;
      }
      /**
       * <pre>
       * Recall range within which precision should be computed.
       * </pre>
       *
       * <code>optional float recall_lower_bound = 26 [default = 0];</code>
       * @return This builder for chaining.
       */
      public Builder clearRecallLowerBound() {
        bitField0_ = (bitField0_ & ~0x02000000);
        recallLowerBound_ = 0F;
        onChanged();
        return this;
      }

      private float recallUpperBound_ = 1F;
      /**
       * <code>optional float recall_upper_bound = 27 [default = 1];</code>
       * @return Whether the recallUpperBound field is set.
       */
      @java.lang.Override
      public boolean hasRecallUpperBound() {
        return ((bitField0_ & 0x04000000) != 0);
      }
      /**
       * <code>optional float recall_upper_bound = 27 [default = 1];</code>
       * @return The recallUpperBound.
       */
      @java.lang.Override
      public float getRecallUpperBound() {
        return recallUpperBound_;
      }
      /**
       * <code>optional float recall_upper_bound = 27 [default = 1];</code>
       * @param value The recallUpperBound to set.
       * @return This builder for chaining.
       */
      public Builder setRecallUpperBound(float value) {
        bitField0_ |= 0x04000000;
        recallUpperBound_ = value;
        onChanged();
        return this;
      }
      /**
       * <code>optional float recall_upper_bound = 27 [default = 1];</code>
       * @return This builder for chaining.
       */
      public Builder clearRecallUpperBound() {
        bitField0_ = (bitField0_ & ~0x04000000);
        recallUpperBound_ = 1F;
        onChanged();
        return this;
      }

      private boolean retainOriginalImageAdditionalChannels_ ;
      /**
       * <pre>
       * Whether to retain additional channels (i.e. not pre-processed) in the
       * tensor dictionary, so that they can be displayed in Tensorboard.
       * </pre>
       *
       * <code>optional bool retain_original_image_additional_channels = 28 [default = false];</code>
       * @return Whether the retainOriginalImageAdditionalChannels field is set.
       */
      @java.lang.Override
      public boolean hasRetainOriginalImageAdditionalChannels() {
        return ((bitField0_ & 0x08000000) != 0);
      }
      /**
       * <pre>
       * Whether to retain additional channels (i.e. not pre-processed) in the
       * tensor dictionary, so that they can be displayed in Tensorboard.
       * </pre>
       *
       * <code>optional bool retain_original_image_additional_channels = 28 [default = false];</code>
       * @return The retainOriginalImageAdditionalChannels.
       */
      @java.lang.Override
      public boolean getRetainOriginalImageAdditionalChannels() {
        return retainOriginalImageAdditionalChannels_;
      }
      /**
       * <pre>
       * Whether to retain additional channels (i.e. not pre-processed) in the
       * tensor dictionary, so that they can be displayed in Tensorboard.
       * </pre>
       *
       * <code>optional bool retain_original_image_additional_channels = 28 [default = false];</code>
       * @param value The retainOriginalImageAdditionalChannels to set.
       * @return This builder for chaining.
       */
      public Builder setRetainOriginalImageAdditionalChannels(boolean value) {
        bitField0_ |= 0x08000000;
        retainOriginalImageAdditionalChannels_ = value;
        onChanged();
        return this;
      }
      /**
       * <pre>
       * Whether to retain additional channels (i.e. not pre-processed) in the
       * tensor dictionary, so that they can be displayed in Tensorboard.
       * </pre>
       *
       * <code>optional bool retain_original_image_additional_channels = 28 [default = false];</code>
       * @return This builder for chaining.
       */
      public Builder clearRetainOriginalImageAdditionalChannels() {
        bitField0_ = (bitField0_ & ~0x08000000);
        retainOriginalImageAdditionalChannels_ = false;
        onChanged();
        return this;
      }

      private boolean forceNoResize_ ;
      /**
       * <pre>
       * When this flag is set, images are not resized during evaluation.
       * When this flag is not set (default case), image are resized according
       * to the image_resizer config in the model during evaluation.
       * </pre>
       *
       * <code>optional bool force_no_resize = 29 [default = false];</code>
       * @return Whether the forceNoResize field is set.
       */
      @java.lang.Override
      public boolean hasForceNoResize() {
        return ((bitField0_ & 0x10000000) != 0);
      }
      /**
       * <pre>
       * When this flag is set, images are not resized during evaluation.
       * When this flag is not set (default case), image are resized according
       * to the image_resizer config in the model during evaluation.
       * </pre>
       *
       * <code>optional bool force_no_resize = 29 [default = false];</code>
       * @return The forceNoResize.
       */
      @java.lang.Override
      public boolean getForceNoResize() {
        return forceNoResize_;
      }
      /**
       * <pre>
       * When this flag is set, images are not resized during evaluation.
       * When this flag is not set (default case), image are resized according
       * to the image_resizer config in the model during evaluation.
       * </pre>
       *
       * <code>optional bool force_no_resize = 29 [default = false];</code>
       * @param value The forceNoResize to set.
       * @return This builder for chaining.
       */
      public Builder setForceNoResize(boolean value) {
        bitField0_ |= 0x10000000;
        forceNoResize_ = value;
        onChanged();
        return this;
      }
      /**
       * <pre>
       * When this flag is set, images are not resized during evaluation.
       * When this flag is not set (default case), image are resized according
       * to the image_resizer config in the model during evaluation.
       * </pre>
       *
       * <code>optional bool force_no_resize = 29 [default = false];</code>
       * @return This builder for chaining.
       */
      public Builder clearForceNoResize() {
        bitField0_ = (bitField0_ & ~0x10000000);
        forceNoResize_ = false;
        onChanged();
        return this;
      }

      private boolean useDummyLossInEval_ ;
      /**
       * <pre>
       * Whether to use a dummy loss in eval so model.loss() is not executed.
       * </pre>
       *
       * <code>optional bool use_dummy_loss_in_eval = 30 [default = false];</code>
       * @return Whether the useDummyLossInEval field is set.
       */
      @java.lang.Override
      public boolean hasUseDummyLossInEval() {
        return ((bitField0_ & 0x20000000) != 0);
      }
      /**
       * <pre>
       * Whether to use a dummy loss in eval so model.loss() is not executed.
       * </pre>
       *
       * <code>optional bool use_dummy_loss_in_eval = 30 [default = false];</code>
       * @return The useDummyLossInEval.
       */
      @java.lang.Override
      public boolean getUseDummyLossInEval() {
        return useDummyLossInEval_;
      }
      /**
       * <pre>
       * Whether to use a dummy loss in eval so model.loss() is not executed.
       * </pre>
       *
       * <code>optional bool use_dummy_loss_in_eval = 30 [default = false];</code>
       * @param value The useDummyLossInEval to set.
       * @return This builder for chaining.
       */
      public Builder setUseDummyLossInEval(boolean value) {
        bitField0_ |= 0x20000000;
        useDummyLossInEval_ = value;
        onChanged();
        return this;
      }
      /**
       * <pre>
       * Whether to use a dummy loss in eval so model.loss() is not executed.
       * </pre>
       *
       * <code>optional bool use_dummy_loss_in_eval = 30 [default = false];</code>
       * @return This builder for chaining.
       */
      public Builder clearUseDummyLossInEval() {
        bitField0_ = (bitField0_ & ~0x20000000);
        useDummyLossInEval_ = false;
        onChanged();
        return this;
      }

      private java.util.List<object_detection.protos.Eval.KeypointEdge> keypointEdge_ =
        java.util.Collections.emptyList();
      private void ensureKeypointEdgeIsMutable() {
        if (!((bitField0_ & 0x40000000) != 0)) {
          keypointEdge_ = new java.util.ArrayList<object_detection.protos.Eval.KeypointEdge>(keypointEdge_);
          bitField0_ |= 0x40000000;
         }
      }

      private com.google.protobuf.RepeatedFieldBuilderV3<
          object_detection.protos.Eval.KeypointEdge, object_detection.protos.Eval.KeypointEdge.Builder, object_detection.protos.Eval.KeypointEdgeOrBuilder> keypointEdgeBuilder_;

      /**
       * <pre>
       * Specifies which keypoints should be connected by an edge, which may improve
       * visualization. An example would be human pose estimation where certain
       * joints can be connected.
       * </pre>
       *
       * <code>repeated .object_detection.protos.KeypointEdge keypoint_edge = 32;</code>
       */
      public java.util.List<object_detection.protos.Eval.KeypointEdge> getKeypointEdgeList() {
        if (keypointEdgeBuilder_ == null) {
          return java.util.Collections.unmodifiableList(keypointEdge_);
        } else {
          return keypointEdgeBuilder_.getMessageList();
        }
      }
      /**
       * <pre>
       * Specifies which keypoints should be connected by an edge, which may improve
       * visualization. An example would be human pose estimation where certain
       * joints can be connected.
       * </pre>
       *
       * <code>repeated .object_detection.protos.KeypointEdge keypoint_edge = 32;</code>
       */
      public int getKeypointEdgeCount() {
        if (keypointEdgeBuilder_ == null) {
          return keypointEdge_.size();
        } else {
          return keypointEdgeBuilder_.getCount();
        }
      }
      /**
       * <pre>
       * Specifies which keypoints should be connected by an edge, which may improve
       * visualization. An example would be human pose estimation where certain
       * joints can be connected.
       * </pre>
       *
       * <code>repeated .object_detection.protos.KeypointEdge keypoint_edge = 32;</code>
       */
      public object_detection.protos.Eval.KeypointEdge getKeypointEdge(int index) {
        if (keypointEdgeBuilder_ == null) {
          return keypointEdge_.get(index);
        } else {
          return keypointEdgeBuilder_.getMessage(index);
        }
      }
      /**
       * <pre>
       * Specifies which keypoints should be connected by an edge, which may improve
       * visualization. An example would be human pose estimation where certain
       * joints can be connected.
       * </pre>
       *
       * <code>repeated .object_detection.protos.KeypointEdge keypoint_edge = 32;</code>
       */
      public Builder setKeypointEdge(
          int index, object_detection.protos.Eval.KeypointEdge value) {
        if (keypointEdgeBuilder_ == null) {
          if (value == null) {
            throw new NullPointerException();
          }
          ensureKeypointEdgeIsMutable();
          keypointEdge_.set(index, value);
          onChanged();
        } else {
          keypointEdgeBuilder_.setMessage(index, value);
        }
        return this;
      }
      /**
       * <pre>
       * Specifies which keypoints should be connected by an edge, which may improve
       * visualization. An example would be human pose estimation where certain
       * joints can be connected.
       * </pre>
       *
       * <code>repeated .object_detection.protos.KeypointEdge keypoint_edge = 32;</code>
       */
      public Builder setKeypointEdge(
          int index, object_detection.protos.Eval.KeypointEdge.Builder builderForValue) {
        if (keypointEdgeBuilder_ == null) {
          ensureKeypointEdgeIsMutable();
          keypointEdge_.set(index, builderForValue.build());
          onChanged();
        } else {
          keypointEdgeBuilder_.setMessage(index, builderForValue.build());
        }
        return this;
      }
      /**
       * <pre>
       * Specifies which keypoints should be connected by an edge, which may improve
       * visualization. An example would be human pose estimation where certain
       * joints can be connected.
       * </pre>
       *
       * <code>repeated .object_detection.protos.KeypointEdge keypoint_edge = 32;</code>
       */
      public Builder addKeypointEdge(object_detection.protos.Eval.KeypointEdge value) {
        if (keypointEdgeBuilder_ == null) {
          if (value == null) {
            throw new NullPointerException();
          }
          ensureKeypointEdgeIsMutable();
          keypointEdge_.add(value);
          onChanged();
        } else {
          keypointEdgeBuilder_.addMessage(value);
        }
        return this;
      }
      /**
       * <pre>
       * Specifies which keypoints should be connected by an edge, which may improve
       * visualization. An example would be human pose estimation where certain
       * joints can be connected.
       * </pre>
       *
       * <code>repeated .object_detection.protos.KeypointEdge keypoint_edge = 32;</code>
       */
      public Builder addKeypointEdge(
          int index, object_detection.protos.Eval.KeypointEdge value) {
        if (keypointEdgeBuilder_ == null) {
          if (value == null) {
            throw new NullPointerException();
          }
          ensureKeypointEdgeIsMutable();
          keypointEdge_.add(index, value);
          onChanged();
        } else {
          keypointEdgeBuilder_.addMessage(index, value);
        }
        return this;
      }
      /**
       * <pre>
       * Specifies which keypoints should be connected by an edge, which may improve
       * visualization. An example would be human pose estimation where certain
       * joints can be connected.
       * </pre>
       *
       * <code>repeated .object_detection.protos.KeypointEdge keypoint_edge = 32;</code>
       */
      public Builder addKeypointEdge(
          object_detection.protos.Eval.KeypointEdge.Builder builderForValue) {
        if (keypointEdgeBuilder_ == null) {
          ensureKeypointEdgeIsMutable();
          keypointEdge_.add(builderForValue.build());
          onChanged();
        } else {
          keypointEdgeBuilder_.addMessage(builderForValue.build());
        }
        return this;
      }
      /**
       * <pre>
       * Specifies which keypoints should be connected by an edge, which may improve
       * visualization. An example would be human pose estimation where certain
       * joints can be connected.
       * </pre>
       *
       * <code>repeated .object_detection.protos.KeypointEdge keypoint_edge = 32;</code>
       */
      public Builder addKeypointEdge(
          int index, object_detection.protos.Eval.KeypointEdge.Builder builderForValue) {
        if (keypointEdgeBuilder_ == null) {
          ensureKeypointEdgeIsMutable();
          keypointEdge_.add(index, builderForValue.build());
          onChanged();
        } else {
          keypointEdgeBuilder_.addMessage(index, builderForValue.build());
        }
        return this;
      }
      /**
       * <pre>
       * Specifies which keypoints should be connected by an edge, which may improve
       * visualization. An example would be human pose estimation where certain
       * joints can be connected.
       * </pre>
       *
       * <code>repeated .object_detection.protos.KeypointEdge keypoint_edge = 32;</code>
       */
      public Builder addAllKeypointEdge(
          java.lang.Iterable<? extends object_detection.protos.Eval.KeypointEdge> values) {
        if (keypointEdgeBuilder_ == null) {
          ensureKeypointEdgeIsMutable();
          com.google.protobuf.AbstractMessageLite.Builder.addAll(
              values, keypointEdge_);
          onChanged();
        } else {
          keypointEdgeBuilder_.addAllMessages(values);
        }
        return this;
      }
      /**
       * <pre>
       * Specifies which keypoints should be connected by an edge, which may improve
       * visualization. An example would be human pose estimation where certain
       * joints can be connected.
       * </pre>
       *
       * <code>repeated .object_detection.protos.KeypointEdge keypoint_edge = 32;</code>
       */
      public Builder clearKeypointEdge() {
        if (keypointEdgeBuilder_ == null) {
          keypointEdge_ = java.util.Collections.emptyList();
          bitField0_ = (bitField0_ & ~0x40000000);
          onChanged();
        } else {
          keypointEdgeBuilder_.clear();
        }
        return this;
      }
      /**
       * <pre>
       * Specifies which keypoints should be connected by an edge, which may improve
       * visualization. An example would be human pose estimation where certain
       * joints can be connected.
       * </pre>
       *
       * <code>repeated .object_detection.protos.KeypointEdge keypoint_edge = 32;</code>
       */
      public Builder removeKeypointEdge(int index) {
        if (keypointEdgeBuilder_ == null) {
          ensureKeypointEdgeIsMutable();
          keypointEdge_.remove(index);
          onChanged();
        } else {
          keypointEdgeBuilder_.remove(index);
        }
        return this;
      }
      /**
       * <pre>
       * Specifies which keypoints should be connected by an edge, which may improve
       * visualization. An example would be human pose estimation where certain
       * joints can be connected.
       * </pre>
       *
       * <code>repeated .object_detection.protos.KeypointEdge keypoint_edge = 32;</code>
       */
      public object_detection.protos.Eval.KeypointEdge.Builder getKeypointEdgeBuilder(
          int index) {
        return getKeypointEdgeFieldBuilder().getBuilder(index);
      }
      /**
       * <pre>
       * Specifies which keypoints should be connected by an edge, which may improve
       * visualization. An example would be human pose estimation where certain
       * joints can be connected.
       * </pre>
       *
       * <code>repeated .object_detection.protos.KeypointEdge keypoint_edge = 32;</code>
       */
      public object_detection.protos.Eval.KeypointEdgeOrBuilder getKeypointEdgeOrBuilder(
          int index) {
        if (keypointEdgeBuilder_ == null) {
          return keypointEdge_.get(index);  } else {
          return keypointEdgeBuilder_.getMessageOrBuilder(index);
        }
      }
      /**
       * <pre>
       * Specifies which keypoints should be connected by an edge, which may improve
       * visualization. An example would be human pose estimation where certain
       * joints can be connected.
       * </pre>
       *
       * <code>repeated .object_detection.protos.KeypointEdge keypoint_edge = 32;</code>
       */
      public java.util.List<? extends object_detection.protos.Eval.KeypointEdgeOrBuilder>
           getKeypointEdgeOrBuilderList() {
        if (keypointEdgeBuilder_ != null) {
          return keypointEdgeBuilder_.getMessageOrBuilderList();
        } else {
          return java.util.Collections.unmodifiableList(keypointEdge_);
        }
      }
      /**
       * <pre>
       * Specifies which keypoints should be connected by an edge, which may improve
       * visualization. An example would be human pose estimation where certain
       * joints can be connected.
       * </pre>
       *
       * <code>repeated .object_detection.protos.KeypointEdge keypoint_edge = 32;</code>
       */
      public object_detection.protos.Eval.KeypointEdge.Builder addKeypointEdgeBuilder() {
        return getKeypointEdgeFieldBuilder().addBuilder(
            object_detection.protos.Eval.KeypointEdge.getDefaultInstance());
      }
      /**
       * <pre>
       * Specifies which keypoints should be connected by an edge, which may improve
       * visualization. An example would be human pose estimation where certain
       * joints can be connected.
       * </pre>
       *
       * <code>repeated .object_detection.protos.KeypointEdge keypoint_edge = 32;</code>
       */
      public object_detection.protos.Eval.KeypointEdge.Builder addKeypointEdgeBuilder(
          int index) {
        return getKeypointEdgeFieldBuilder().addBuilder(
            index, object_detection.protos.Eval.KeypointEdge.getDefaultInstance());
      }
      /**
       * <pre>
       * Specifies which keypoints should be connected by an edge, which may improve
       * visualization. An example would be human pose estimation where certain
       * joints can be connected.
       * </pre>
       *
       * <code>repeated .object_detection.protos.KeypointEdge keypoint_edge = 32;</code>
       */
      public java.util.List<object_detection.protos.Eval.KeypointEdge.Builder>
           getKeypointEdgeBuilderList() {
        return getKeypointEdgeFieldBuilder().getBuilderList();
      }
      private com.google.protobuf.RepeatedFieldBuilderV3<
          object_detection.protos.Eval.KeypointEdge, object_detection.protos.Eval.KeypointEdge.Builder, object_detection.protos.Eval.KeypointEdgeOrBuilder>
          getKeypointEdgeFieldBuilder() {
        if (keypointEdgeBuilder_ == null) {
          keypointEdgeBuilder_ = new com.google.protobuf.RepeatedFieldBuilderV3<
              object_detection.protos.Eval.KeypointEdge, object_detection.protos.Eval.KeypointEdge.Builder, object_detection.protos.Eval.KeypointEdgeOrBuilder>(
                  keypointEdge_,
                  ((bitField0_ & 0x40000000) != 0),
                  getParentForChildren(),
                  isClean());
          keypointEdge_ = null;
        }
        return keypointEdgeBuilder_;
      }

      private boolean skipPredictionsForUnlabeledClass_ ;
      /**
       * <pre>
       * The "groundtruth_labeled_classes" field indicates which classes have been
       * labeled on the images. If skip_predictions_for_unlabeled_class is set,
       * detector predictions that do not match to the groundtruth_labeled_classes
       * will be ignored. This is useful for evaluating on test data that are not
       * exhaustively labeled.
       * </pre>
       *
       * <code>optional bool skip_predictions_for_unlabeled_class = 33 [default = false];</code>
       * @return Whether the skipPredictionsForUnlabeledClass field is set.
       */
      @java.lang.Override
      public boolean hasSkipPredictionsForUnlabeledClass() {
        return ((bitField0_ & 0x80000000) != 0);
      }
      /**
       * <pre>
       * The "groundtruth_labeled_classes" field indicates which classes have been
       * labeled on the images. If skip_predictions_for_unlabeled_class is set,
       * detector predictions that do not match to the groundtruth_labeled_classes
       * will be ignored. This is useful for evaluating on test data that are not
       * exhaustively labeled.
       * </pre>
       *
       * <code>optional bool skip_predictions_for_unlabeled_class = 33 [default = false];</code>
       * @return The skipPredictionsForUnlabeledClass.
       */
      @java.lang.Override
      public boolean getSkipPredictionsForUnlabeledClass() {
        return skipPredictionsForUnlabeledClass_;
      }
      /**
       * <pre>
       * The "groundtruth_labeled_classes" field indicates which classes have been
       * labeled on the images. If skip_predictions_for_unlabeled_class is set,
       * detector predictions that do not match to the groundtruth_labeled_classes
       * will be ignored. This is useful for evaluating on test data that are not
       * exhaustively labeled.
       * </pre>
       *
       * <code>optional bool skip_predictions_for_unlabeled_class = 33 [default = false];</code>
       * @param value The skipPredictionsForUnlabeledClass to set.
       * @return This builder for chaining.
       */
      public Builder setSkipPredictionsForUnlabeledClass(boolean value) {
        bitField0_ |= 0x80000000;
        skipPredictionsForUnlabeledClass_ = value;
        onChanged();
        return this;
      }
      /**
       * <pre>
       * The "groundtruth_labeled_classes" field indicates which classes have been
       * labeled on the images. If skip_predictions_for_unlabeled_class is set,
       * detector predictions that do not match to the groundtruth_labeled_classes
       * will be ignored. This is useful for evaluating on test data that are not
       * exhaustively labeled.
       * </pre>
       *
       * <code>optional bool skip_predictions_for_unlabeled_class = 33 [default = false];</code>
       * @return This builder for chaining.
       */
      public Builder clearSkipPredictionsForUnlabeledClass() {
        bitField0_ = (bitField0_ & ~0x80000000);
        skipPredictionsForUnlabeledClass_ = false;
        onChanged();
        return this;
      }
      @java.lang.Override
      public final Builder setUnknownFields(
          final com.google.protobuf.UnknownFieldSet unknownFields) {
        return super.setUnknownFields(unknownFields);
      }

      @java.lang.Override
      public final Builder mergeUnknownFields(
          final com.google.protobuf.UnknownFieldSet unknownFields) {
        return super.mergeUnknownFields(unknownFields);
      }


      // @@protoc_insertion_point(builder_scope:object_detection.protos.EvalConfig)
    }

    // @@protoc_insertion_point(class_scope:object_detection.protos.EvalConfig)
    private static final object_detection.protos.Eval.EvalConfig DEFAULT_INSTANCE;
    static {
      DEFAULT_INSTANCE = new object_detection.protos.Eval.EvalConfig();
    }

    public static object_detection.protos.Eval.EvalConfig getDefaultInstance() {
      return DEFAULT_INSTANCE;
    }

    @java.lang.Deprecated public static final com.google.protobuf.Parser<EvalConfig>
        PARSER = new com.google.protobuf.AbstractParser<EvalConfig>() {
      @java.lang.Override
      public EvalConfig parsePartialFrom(
          com.google.protobuf.CodedInputStream input,
          com.google.protobuf.ExtensionRegistryLite extensionRegistry)
          throws com.google.protobuf.InvalidProtocolBufferException {
        return new EvalConfig(input, extensionRegistry);
      }
    };

    public static com.google.protobuf.Parser<EvalConfig> parser() {
      return PARSER;
    }

    @java.lang.Override
    public com.google.protobuf.Parser<EvalConfig> getParserForType() {
      return PARSER;
    }

    @java.lang.Override
    public object_detection.protos.Eval.EvalConfig getDefaultInstanceForType() {
      return DEFAULT_INSTANCE;
    }

  }

  public interface ParameterizedMetricOrBuilder extends
      // @@protoc_insertion_point(interface_extends:object_detection.protos.ParameterizedMetric)
      com.google.protobuf.MessageOrBuilder {

    /**
     * <code>.object_detection.protos.CocoKeypointMetrics coco_keypoint_metrics = 1;</code>
     * @return Whether the cocoKeypointMetrics field is set.
     */
    boolean hasCocoKeypointMetrics();
    /**
     * <code>.object_detection.protos.CocoKeypointMetrics coco_keypoint_metrics = 1;</code>
     * @return The cocoKeypointMetrics.
     */
    object_detection.protos.Eval.CocoKeypointMetrics getCocoKeypointMetrics();
    /**
     * <code>.object_detection.protos.CocoKeypointMetrics coco_keypoint_metrics = 1;</code>
     */
    object_detection.protos.Eval.CocoKeypointMetricsOrBuilder getCocoKeypointMetricsOrBuilder();

    public object_detection.protos.Eval.ParameterizedMetric.ParameterizedMetricCase getParameterizedMetricCase();
  }
  /**
   * <pre>
   * A message to configure parameterized evaluation metric.
   * </pre>
   *
   * Protobuf type {@code object_detection.protos.ParameterizedMetric}
   */
  public static final class ParameterizedMetric extends
      com.google.protobuf.GeneratedMessageV3 implements
      // @@protoc_insertion_point(message_implements:object_detection.protos.ParameterizedMetric)
      ParameterizedMetricOrBuilder {
  private static final long serialVersionUID = 0L;
    // Use ParameterizedMetric.newBuilder() to construct.
    private ParameterizedMetric(com.google.protobuf.GeneratedMessageV3.Builder<?> builder) {
      super(builder);
    }
    private ParameterizedMetric() {
    }

    @java.lang.Override
    @SuppressWarnings({"unused"})
    protected java.lang.Object newInstance(
        UnusedPrivateParameter unused) {
      return new ParameterizedMetric();
    }

    @java.lang.Override
    public final com.google.protobuf.UnknownFieldSet
    getUnknownFields() {
      return this.unknownFields;
    }
    private ParameterizedMetric(
        com.google.protobuf.CodedInputStream input,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws com.google.protobuf.InvalidProtocolBufferException {
      this();
      if (extensionRegistry == null) {
        throw new java.lang.NullPointerException();
      }
      int mutable_bitField0_ = 0;
      com.google.protobuf.UnknownFieldSet.Builder unknownFields =
          com.google.protobuf.UnknownFieldSet.newBuilder();
      try {
        boolean done = false;
        while (!done) {
          int tag = input.readTag();
          switch (tag) {
            case 0:
              done = true;
              break;
            case 10: {
              object_detection.protos.Eval.CocoKeypointMetrics.Builder subBuilder = null;
              if (parameterizedMetricCase_ == 1) {
                subBuilder = ((object_detection.protos.Eval.CocoKeypointMetrics) parameterizedMetric_).toBuilder();
              }
              parameterizedMetric_ =
                  input.readMessage(object_detection.protos.Eval.CocoKeypointMetrics.PARSER, extensionRegistry);
              if (subBuilder != null) {
                subBuilder.mergeFrom((object_detection.protos.Eval.CocoKeypointMetrics) parameterizedMetric_);
                parameterizedMetric_ = subBuilder.buildPartial();
              }
              parameterizedMetricCase_ = 1;
              break;
            }
            default: {
              if (!parseUnknownField(
                  input, unknownFields, extensionRegistry, tag)) {
                done = true;
              }
              break;
            }
          }
        }
      } catch (com.google.protobuf.InvalidProtocolBufferException e) {
        throw e.setUnfinishedMessage(this);
      } catch (java.io.IOException e) {
        throw new com.google.protobuf.InvalidProtocolBufferException(
            e).setUnfinishedMessage(this);
      } finally {
        this.unknownFields = unknownFields.build();
        makeExtensionsImmutable();
      }
    }
    public static final com.google.protobuf.Descriptors.Descriptor
        getDescriptor() {
      return object_detection.protos.Eval.internal_static_object_detection_protos_ParameterizedMetric_descriptor;
    }

    @java.lang.Override
    protected com.google.protobuf.GeneratedMessageV3.FieldAccessorTable
        internalGetFieldAccessorTable() {
      return object_detection.protos.Eval.internal_static_object_detection_protos_ParameterizedMetric_fieldAccessorTable
          .ensureFieldAccessorsInitialized(
              object_detection.protos.Eval.ParameterizedMetric.class, object_detection.protos.Eval.ParameterizedMetric.Builder.class);
    }

    private int bitField0_;
    private int parameterizedMetricCase_ = 0;
    private java.lang.Object parameterizedMetric_;
    public enum ParameterizedMetricCase
        implements com.google.protobuf.Internal.EnumLite,
            com.google.protobuf.AbstractMessage.InternalOneOfEnum {
      COCO_KEYPOINT_METRICS(1),
      PARAMETERIZEDMETRIC_NOT_SET(0);
      private final int value;
      private ParameterizedMetricCase(int value) {
        this.value = value;
      }
      /**
       * @param value The number of the enum to look for.
       * @return The enum associated with the given number.
       * @deprecated Use {@link #forNumber(int)} instead.
       */
      @java.lang.Deprecated
      public static ParameterizedMetricCase valueOf(int value) {
        return forNumber(value);
      }

      public static ParameterizedMetricCase forNumber(int value) {
        switch (value) {
          case 1: return COCO_KEYPOINT_METRICS;
          case 0: return PARAMETERIZEDMETRIC_NOT_SET;
          default: return null;
        }
      }
      public int getNumber() {
        return this.value;
      }
    };

    public ParameterizedMetricCase
    getParameterizedMetricCase() {
      return ParameterizedMetricCase.forNumber(
          parameterizedMetricCase_);
    }

    public static final int COCO_KEYPOINT_METRICS_FIELD_NUMBER = 1;
    /**
     * <code>.object_detection.protos.CocoKeypointMetrics coco_keypoint_metrics = 1;</code>
     * @return Whether the cocoKeypointMetrics field is set.
     */
    @java.lang.Override
    public boolean hasCocoKeypointMetrics() {
      return parameterizedMetricCase_ == 1;
    }
    /**
     * <code>.object_detection.protos.CocoKeypointMetrics coco_keypoint_metrics = 1;</code>
     * @return The cocoKeypointMetrics.
     */
    @java.lang.Override
    public object_detection.protos.Eval.CocoKeypointMetrics getCocoKeypointMetrics() {
      if (parameterizedMetricCase_ == 1) {
         return (object_detection.protos.Eval.CocoKeypointMetrics) parameterizedMetric_;
      }
      return object_detection.protos.Eval.CocoKeypointMetrics.getDefaultInstance();
    }
    /**
     * <code>.object_detection.protos.CocoKeypointMetrics coco_keypoint_metrics = 1;</code>
     */
    @java.lang.Override
    public object_detection.protos.Eval.CocoKeypointMetricsOrBuilder getCocoKeypointMetricsOrBuilder() {
      if (parameterizedMetricCase_ == 1) {
         return (object_detection.protos.Eval.CocoKeypointMetrics) parameterizedMetric_;
      }
      return object_detection.protos.Eval.CocoKeypointMetrics.getDefaultInstance();
    }

    private byte memoizedIsInitialized = -1;
    @java.lang.Override
    public final boolean isInitialized() {
      byte isInitialized = memoizedIsInitialized;
      if (isInitialized == 1) return true;
      if (isInitialized == 0) return false;

      memoizedIsInitialized = 1;
      return true;
    }

    @java.lang.Override
    public void writeTo(com.google.protobuf.CodedOutputStream output)
                        throws java.io.IOException {
      if (parameterizedMetricCase_ == 1) {
        output.writeMessage(1, (object_detection.protos.Eval.CocoKeypointMetrics) parameterizedMetric_);
      }
      unknownFields.writeTo(output);
    }

    @java.lang.Override
    public int getSerializedSize() {
      int size = memoizedSize;
      if (size != -1) return size;

      size = 0;
      if (parameterizedMetricCase_ == 1) {
        size += com.google.protobuf.CodedOutputStream
          .computeMessageSize(1, (object_detection.protos.Eval.CocoKeypointMetrics) parameterizedMetric_);
      }
      size += unknownFields.getSerializedSize();
      memoizedSize = size;
      return size;
    }

    @java.lang.Override
    public boolean equals(final java.lang.Object obj) {
      if (obj == this) {
       return true;
      }
      if (!(obj instanceof object_detection.protos.Eval.ParameterizedMetric)) {
        return super.equals(obj);
      }
      object_detection.protos.Eval.ParameterizedMetric other = (object_detection.protos.Eval.ParameterizedMetric) obj;

      if (!getParameterizedMetricCase().equals(other.getParameterizedMetricCase())) return false;
      switch (parameterizedMetricCase_) {
        case 1:
          if (!getCocoKeypointMetrics()
              .equals(other.getCocoKeypointMetrics())) return false;
          break;
        case 0:
        default:
      }
      if (!unknownFields.equals(other.unknownFields)) return false;
      return true;
    }

    @java.lang.Override
    public int hashCode() {
      if (memoizedHashCode != 0) {
        return memoizedHashCode;
      }
      int hash = 41;
      hash = (19 * hash) + getDescriptor().hashCode();
      switch (parameterizedMetricCase_) {
        case 1:
          hash = (37 * hash) + COCO_KEYPOINT_METRICS_FIELD_NUMBER;
          hash = (53 * hash) + getCocoKeypointMetrics().hashCode();
          break;
        case 0:
        default:
      }
      hash = (29 * hash) + unknownFields.hashCode();
      memoizedHashCode = hash;
      return hash;
    }

    public static object_detection.protos.Eval.ParameterizedMetric parseFrom(
        java.nio.ByteBuffer data)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return PARSER.parseFrom(data);
    }
    public static object_detection.protos.Eval.ParameterizedMetric parseFrom(
        java.nio.ByteBuffer data,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return PARSER.parseFrom(data, extensionRegistry);
    }
    public static object_detection.protos.Eval.ParameterizedMetric parseFrom(
        com.google.protobuf.ByteString data)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return PARSER.parseFrom(data);
    }
    public static object_detection.protos.Eval.ParameterizedMetric parseFrom(
        com.google.protobuf.ByteString data,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return PARSER.parseFrom(data, extensionRegistry);
    }
    public static object_detection.protos.Eval.ParameterizedMetric parseFrom(byte[] data)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return PARSER.parseFrom(data);
    }
    public static object_detection.protos.Eval.ParameterizedMetric parseFrom(
        byte[] data,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return PARSER.parseFrom(data, extensionRegistry);
    }
    public static object_detection.protos.Eval.ParameterizedMetric parseFrom(java.io.InputStream input)
        throws java.io.IOException {
      return com.google.protobuf.GeneratedMessageV3
          .parseWithIOException(PARSER, input);
    }
    public static object_detection.protos.Eval.ParameterizedMetric parseFrom(
        java.io.InputStream input,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws java.io.IOException {
      return com.google.protobuf.GeneratedMessageV3
          .parseWithIOException(PARSER, input, extensionRegistry);
    }
    public static object_detection.protos.Eval.ParameterizedMetric parseDelimitedFrom(java.io.InputStream input)
        throws java.io.IOException {
      return com.google.protobuf.GeneratedMessageV3
          .parseDelimitedWithIOException(PARSER, input);
    }
    public static object_detection.protos.Eval.ParameterizedMetric parseDelimitedFrom(
        java.io.InputStream input,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws java.io.IOException {
      return com.google.protobuf.GeneratedMessageV3
          .parseDelimitedWithIOException(PARSER, input, extensionRegistry);
    }
    public static object_detection.protos.Eval.ParameterizedMetric parseFrom(
        com.google.protobuf.CodedInputStream input)
        throws java.io.IOException {
      return com.google.protobuf.GeneratedMessageV3
          .parseWithIOException(PARSER, input);
    }
    public static object_detection.protos.Eval.ParameterizedMetric parseFrom(
        com.google.protobuf.CodedInputStream input,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws java.io.IOException {
      return com.google.protobuf.GeneratedMessageV3
          .parseWithIOException(PARSER, input, extensionRegistry);
    }

    @java.lang.Override
    public Builder newBuilderForType() { return newBuilder(); }
    public static Builder newBuilder() {
      return DEFAULT_INSTANCE.toBuilder();
    }
    public static Builder newBuilder(object_detection.protos.Eval.ParameterizedMetric prototype) {
      return DEFAULT_INSTANCE.toBuilder().mergeFrom(prototype);
    }
    @java.lang.Override
    public Builder toBuilder() {
      return this == DEFAULT_INSTANCE
          ? new Builder() : new Builder().mergeFrom(this);
    }

    @java.lang.Override
    protected Builder newBuilderForType(
        com.google.protobuf.GeneratedMessageV3.BuilderParent parent) {
      Builder builder = new Builder(parent);
      return builder;
    }
    /**
     * <pre>
     * A message to configure parameterized evaluation metric.
     * </pre>
     *
     * Protobuf type {@code object_detection.protos.ParameterizedMetric}
     */
    public static final class Builder extends
        com.google.protobuf.GeneratedMessageV3.Builder<Builder> implements
        // @@protoc_insertion_point(builder_implements:object_detection.protos.ParameterizedMetric)
        object_detection.protos.Eval.ParameterizedMetricOrBuilder {
      public static final com.google.protobuf.Descriptors.Descriptor
          getDescriptor() {
        return object_detection.protos.Eval.internal_static_object_detection_protos_ParameterizedMetric_descriptor;
      }

      @java.lang.Override
      protected com.google.protobuf.GeneratedMessageV3.FieldAccessorTable
          internalGetFieldAccessorTable() {
        return object_detection.protos.Eval.internal_static_object_detection_protos_ParameterizedMetric_fieldAccessorTable
            .ensureFieldAccessorsInitialized(
                object_detection.protos.Eval.ParameterizedMetric.class, object_detection.protos.Eval.ParameterizedMetric.Builder.class);
      }

      // Construct using object_detection.protos.Eval.ParameterizedMetric.newBuilder()
      private Builder() {
        maybeForceBuilderInitialization();
      }

      private Builder(
          com.google.protobuf.GeneratedMessageV3.BuilderParent parent) {
        super(parent);
        maybeForceBuilderInitialization();
      }
      private void maybeForceBuilderInitialization() {
        if (com.google.protobuf.GeneratedMessageV3
                .alwaysUseFieldBuilders) {
        }
      }
      @java.lang.Override
      public Builder clear() {
        super.clear();
        parameterizedMetricCase_ = 0;
        parameterizedMetric_ = null;
        return this;
      }

      @java.lang.Override
      public com.google.protobuf.Descriptors.Descriptor
          getDescriptorForType() {
        return object_detection.protos.Eval.internal_static_object_detection_protos_ParameterizedMetric_descriptor;
      }

      @java.lang.Override
      public object_detection.protos.Eval.ParameterizedMetric getDefaultInstanceForType() {
        return object_detection.protos.Eval.ParameterizedMetric.getDefaultInstance();
      }

      @java.lang.Override
      public object_detection.protos.Eval.ParameterizedMetric build() {
        object_detection.protos.Eval.ParameterizedMetric result = buildPartial();
        if (!result.isInitialized()) {
          throw newUninitializedMessageException(result);
        }
        return result;
      }

      @java.lang.Override
      public object_detection.protos.Eval.ParameterizedMetric buildPartial() {
        object_detection.protos.Eval.ParameterizedMetric result = new object_detection.protos.Eval.ParameterizedMetric(this);
        int from_bitField0_ = bitField0_;
        int to_bitField0_ = 0;
        if (parameterizedMetricCase_ == 1) {
          if (cocoKeypointMetricsBuilder_ == null) {
            result.parameterizedMetric_ = parameterizedMetric_;
          } else {
            result.parameterizedMetric_ = cocoKeypointMetricsBuilder_.build();
          }
        }
        result.bitField0_ = to_bitField0_;
        result.parameterizedMetricCase_ = parameterizedMetricCase_;
        onBuilt();
        return result;
      }

      @java.lang.Override
      public Builder clone() {
        return super.clone();
      }
      @java.lang.Override
      public Builder setField(
          com.google.protobuf.Descriptors.FieldDescriptor field,
          java.lang.Object value) {
        return super.setField(field, value);
      }
      @java.lang.Override
      public Builder clearField(
          com.google.protobuf.Descriptors.FieldDescriptor field) {
        return super.clearField(field);
      }
      @java.lang.Override
      public Builder clearOneof(
          com.google.protobuf.Descriptors.OneofDescriptor oneof) {
        return super.clearOneof(oneof);
      }
      @java.lang.Override
      public Builder setRepeatedField(
          com.google.protobuf.Descriptors.FieldDescriptor field,
          int index, java.lang.Object value) {
        return super.setRepeatedField(field, index, value);
      }
      @java.lang.Override
      public Builder addRepeatedField(
          com.google.protobuf.Descriptors.FieldDescriptor field,
          java.lang.Object value) {
        return super.addRepeatedField(field, value);
      }
      @java.lang.Override
      public Builder mergeFrom(com.google.protobuf.Message other) {
        if (other instanceof object_detection.protos.Eval.ParameterizedMetric) {
          return mergeFrom((object_detection.protos.Eval.ParameterizedMetric)other);
        } else {
          super.mergeFrom(other);
          return this;
        }
      }

      public Builder mergeFrom(object_detection.protos.Eval.ParameterizedMetric other) {
        if (other == object_detection.protos.Eval.ParameterizedMetric.getDefaultInstance()) return this;
        switch (other.getParameterizedMetricCase()) {
          case COCO_KEYPOINT_METRICS: {
            mergeCocoKeypointMetrics(other.getCocoKeypointMetrics());
            break;
          }
          case PARAMETERIZEDMETRIC_NOT_SET: {
            break;
          }
        }
        this.mergeUnknownFields(other.unknownFields);
        onChanged();
        return this;
      }

      @java.lang.Override
      public final boolean isInitialized() {
        return true;
      }

      @java.lang.Override
      public Builder mergeFrom(
          com.google.protobuf.CodedInputStream input,
          com.google.protobuf.ExtensionRegistryLite extensionRegistry)
          throws java.io.IOException {
        object_detection.protos.Eval.ParameterizedMetric parsedMessage = null;
        try {
          parsedMessage = PARSER.parsePartialFrom(input, extensionRegistry);
        } catch (com.google.protobuf.InvalidProtocolBufferException e) {
          parsedMessage = (object_detection.protos.Eval.ParameterizedMetric) e.getUnfinishedMessage();
          throw e.unwrapIOException();
        } finally {
          if (parsedMessage != null) {
            mergeFrom(parsedMessage);
          }
        }
        return this;
      }
      private int parameterizedMetricCase_ = 0;
      private java.lang.Object parameterizedMetric_;
      public ParameterizedMetricCase
          getParameterizedMetricCase() {
        return ParameterizedMetricCase.forNumber(
            parameterizedMetricCase_);
      }

      public Builder clearParameterizedMetric() {
        parameterizedMetricCase_ = 0;
        parameterizedMetric_ = null;
        onChanged();
        return this;
      }

      private int bitField0_;

      private com.google.protobuf.SingleFieldBuilderV3<
          object_detection.protos.Eval.CocoKeypointMetrics, object_detection.protos.Eval.CocoKeypointMetrics.Builder, object_detection.protos.Eval.CocoKeypointMetricsOrBuilder> cocoKeypointMetricsBuilder_;
      /**
       * <code>.object_detection.protos.CocoKeypointMetrics coco_keypoint_metrics = 1;</code>
       * @return Whether the cocoKeypointMetrics field is set.
       */
      @java.lang.Override
      public boolean hasCocoKeypointMetrics() {
        return parameterizedMetricCase_ == 1;
      }
      /**
       * <code>.object_detection.protos.CocoKeypointMetrics coco_keypoint_metrics = 1;</code>
       * @return The cocoKeypointMetrics.
       */
      @java.lang.Override
      public object_detection.protos.Eval.CocoKeypointMetrics getCocoKeypointMetrics() {
        if (cocoKeypointMetricsBuilder_ == null) {
          if (parameterizedMetricCase_ == 1) {
            return (object_detection.protos.Eval.CocoKeypointMetrics) parameterizedMetric_;
          }
          return object_detection.protos.Eval.CocoKeypointMetrics.getDefaultInstance();
        } else {
          if (parameterizedMetricCase_ == 1) {
            return cocoKeypointMetricsBuilder_.getMessage();
          }
          return object_detection.protos.Eval.CocoKeypointMetrics.getDefaultInstance();
        }
      }
      /**
       * <code>.object_detection.protos.CocoKeypointMetrics coco_keypoint_metrics = 1;</code>
       */
      public Builder setCocoKeypointMetrics(object_detection.protos.Eval.CocoKeypointMetrics value) {
        if (cocoKeypointMetricsBuilder_ == null) {
          if (value == null) {
            throw new NullPointerException();
          }
          parameterizedMetric_ = value;
          onChanged();
        } else {
          cocoKeypointMetricsBuilder_.setMessage(value);
        }
        parameterizedMetricCase_ = 1;
        return this;
      }
      /**
       * <code>.object_detection.protos.CocoKeypointMetrics coco_keypoint_metrics = 1;</code>
       */
      public Builder setCocoKeypointMetrics(
          object_detection.protos.Eval.CocoKeypointMetrics.Builder builderForValue) {
        if (cocoKeypointMetricsBuilder_ == null) {
          parameterizedMetric_ = builderForValue.build();
          onChanged();
        } else {
          cocoKeypointMetricsBuilder_.setMessage(builderForValue.build());
        }
        parameterizedMetricCase_ = 1;
        return this;
      }
      /**
       * <code>.object_detection.protos.CocoKeypointMetrics coco_keypoint_metrics = 1;</code>
       */
      public Builder mergeCocoKeypointMetrics(object_detection.protos.Eval.CocoKeypointMetrics value) {
        if (cocoKeypointMetricsBuilder_ == null) {
          if (parameterizedMetricCase_ == 1 &&
              parameterizedMetric_ != object_detection.protos.Eval.CocoKeypointMetrics.getDefaultInstance()) {
            parameterizedMetric_ = object_detection.protos.Eval.CocoKeypointMetrics.newBuilder((object_detection.protos.Eval.CocoKeypointMetrics) parameterizedMetric_)
                .mergeFrom(value).buildPartial();
          } else {
            parameterizedMetric_ = value;
          }
          onChanged();
        } else {
          if (parameterizedMetricCase_ == 1) {
            cocoKeypointMetricsBuilder_.mergeFrom(value);
          }
          cocoKeypointMetricsBuilder_.setMessage(value);
        }
        parameterizedMetricCase_ = 1;
        return this;
      }
      /**
       * <code>.object_detection.protos.CocoKeypointMetrics coco_keypoint_metrics = 1;</code>
       */
      public Builder clearCocoKeypointMetrics() {
        if (cocoKeypointMetricsBuilder_ == null) {
          if (parameterizedMetricCase_ == 1) {
            parameterizedMetricCase_ = 0;
            parameterizedMetric_ = null;
            onChanged();
          }
        } else {
          if (parameterizedMetricCase_ == 1) {
            parameterizedMetricCase_ = 0;
            parameterizedMetric_ = null;
          }
          cocoKeypointMetricsBuilder_.clear();
        }
        return this;
      }
      /**
       * <code>.object_detection.protos.CocoKeypointMetrics coco_keypoint_metrics = 1;</code>
       */
      public object_detection.protos.Eval.CocoKeypointMetrics.Builder getCocoKeypointMetricsBuilder() {
        return getCocoKeypointMetricsFieldBuilder().getBuilder();
      }
      /**
       * <code>.object_detection.protos.CocoKeypointMetrics coco_keypoint_metrics = 1;</code>
       */
      @java.lang.Override
      public object_detection.protos.Eval.CocoKeypointMetricsOrBuilder getCocoKeypointMetricsOrBuilder() {
        if ((parameterizedMetricCase_ == 1) && (cocoKeypointMetricsBuilder_ != null)) {
          return cocoKeypointMetricsBuilder_.getMessageOrBuilder();
        } else {
          if (parameterizedMetricCase_ == 1) {
            return (object_detection.protos.Eval.CocoKeypointMetrics) parameterizedMetric_;
          }
          return object_detection.protos.Eval.CocoKeypointMetrics.getDefaultInstance();
        }
      }
      /**
       * <code>.object_detection.protos.CocoKeypointMetrics coco_keypoint_metrics = 1;</code>
       */
      private com.google.protobuf.SingleFieldBuilderV3<
          object_detection.protos.Eval.CocoKeypointMetrics, object_detection.protos.Eval.CocoKeypointMetrics.Builder, object_detection.protos.Eval.CocoKeypointMetricsOrBuilder>
          getCocoKeypointMetricsFieldBuilder() {
        if (cocoKeypointMetricsBuilder_ == null) {
          if (!(parameterizedMetricCase_ == 1)) {
            parameterizedMetric_ = object_detection.protos.Eval.CocoKeypointMetrics.getDefaultInstance();
          }
          cocoKeypointMetricsBuilder_ = new com.google.protobuf.SingleFieldBuilderV3<
              object_detection.protos.Eval.CocoKeypointMetrics, object_detection.protos.Eval.CocoKeypointMetrics.Builder, object_detection.protos.Eval.CocoKeypointMetricsOrBuilder>(
                  (object_detection.protos.Eval.CocoKeypointMetrics) parameterizedMetric_,
                  getParentForChildren(),
                  isClean());
          parameterizedMetric_ = null;
        }
        parameterizedMetricCase_ = 1;
        onChanged();;
        return cocoKeypointMetricsBuilder_;
      }
      @java.lang.Override
      public final Builder setUnknownFields(
          final com.google.protobuf.UnknownFieldSet unknownFields) {
        return super.setUnknownFields(unknownFields);
      }

      @java.lang.Override
      public final Builder mergeUnknownFields(
          final com.google.protobuf.UnknownFieldSet unknownFields) {
        return super.mergeUnknownFields(unknownFields);
      }


      // @@protoc_insertion_point(builder_scope:object_detection.protos.ParameterizedMetric)
    }

    // @@protoc_insertion_point(class_scope:object_detection.protos.ParameterizedMetric)
    private static final object_detection.protos.Eval.ParameterizedMetric DEFAULT_INSTANCE;
    static {
      DEFAULT_INSTANCE = new object_detection.protos.Eval.ParameterizedMetric();
    }

    public static object_detection.protos.Eval.ParameterizedMetric getDefaultInstance() {
      return DEFAULT_INSTANCE;
    }

    @java.lang.Deprecated public static final com.google.protobuf.Parser<ParameterizedMetric>
        PARSER = new com.google.protobuf.AbstractParser<ParameterizedMetric>() {
      @java.lang.Override
      public ParameterizedMetric parsePartialFrom(
          com.google.protobuf.CodedInputStream input,
          com.google.protobuf.ExtensionRegistryLite extensionRegistry)
          throws com.google.protobuf.InvalidProtocolBufferException {
        return new ParameterizedMetric(input, extensionRegistry);
      }
    };

    public static com.google.protobuf.Parser<ParameterizedMetric> parser() {
      return PARSER;
    }

    @java.lang.Override
    public com.google.protobuf.Parser<ParameterizedMetric> getParserForType() {
      return PARSER;
    }

    @java.lang.Override
    public object_detection.protos.Eval.ParameterizedMetric getDefaultInstanceForType() {
      return DEFAULT_INSTANCE;
    }

  }

  public interface CocoKeypointMetricsOrBuilder extends
      // @@protoc_insertion_point(interface_extends:object_detection.protos.CocoKeypointMetrics)
      com.google.protobuf.MessageOrBuilder {

    /**
     * <pre>
     * Identifies the class of object to which keypoints belong. By default this
     * should use the class's "display_name" in the label map.
     * </pre>
     *
     * <code>optional string class_label = 1;</code>
     * @return Whether the classLabel field is set.
     */
    boolean hasClassLabel();
    /**
     * <pre>
     * Identifies the class of object to which keypoints belong. By default this
     * should use the class's "display_name" in the label map.
     * </pre>
     *
     * <code>optional string class_label = 1;</code>
     * @return The classLabel.
     */
    java.lang.String getClassLabel();
    /**
     * <pre>
     * Identifies the class of object to which keypoints belong. By default this
     * should use the class's "display_name" in the label map.
     * </pre>
     *
     * <code>optional string class_label = 1;</code>
     * @return The bytes for classLabel.
     */
    com.google.protobuf.ByteString
        getClassLabelBytes();

    /**
     * <pre>
     * Keypoint specific standard deviations for COCO keypoint metrics, which
     * controls how OKS is computed.
     * See http://cocodataset.org/#keypoints-eval for details.
     * If your keypoints are similar to the COCO keypoints use the precomputed
     * standard deviations below:
     * "nose": 0.026
     * "left_eye": 0.025
     * "right_eye": 0.025
     * "left_ear": 0.035
     * "right_ear": 0.035
     * "left_shoulder": 0.079
     * "right_shoulder": 0.079
     * "left_elbow": 0.072
     * "right_elbow": 0.072
     * "left_wrist": 0.062
     * "right_wrist": 0.062
     * "left_hip": 0.107
     * "right_hip": 0.107
     * "left_knee": 0.087
     * "right_knee": 0.087
     * "left_ankle": 0.089
     * "right_ankle": 0.089
     * </pre>
     *
     * <code>map&lt;string, float&gt; keypoint_label_to_sigmas = 2;</code>
     */
    int getKeypointLabelToSigmasCount();
    /**
     * <pre>
     * Keypoint specific standard deviations for COCO keypoint metrics, which
     * controls how OKS is computed.
     * See http://cocodataset.org/#keypoints-eval for details.
     * If your keypoints are similar to the COCO keypoints use the precomputed
     * standard deviations below:
     * "nose": 0.026
     * "left_eye": 0.025
     * "right_eye": 0.025
     * "left_ear": 0.035
     * "right_ear": 0.035
     * "left_shoulder": 0.079
     * "right_shoulder": 0.079
     * "left_elbow": 0.072
     * "right_elbow": 0.072
     * "left_wrist": 0.062
     * "right_wrist": 0.062
     * "left_hip": 0.107
     * "right_hip": 0.107
     * "left_knee": 0.087
     * "right_knee": 0.087
     * "left_ankle": 0.089
     * "right_ankle": 0.089
     * </pre>
     *
     * <code>map&lt;string, float&gt; keypoint_label_to_sigmas = 2;</code>
     */
    boolean containsKeypointLabelToSigmas(
        java.lang.String key);
    /**
     * Use {@link #getKeypointLabelToSigmasMap()} instead.
     */
    @java.lang.Deprecated
    java.util.Map<java.lang.String, java.lang.Float>
    getKeypointLabelToSigmas();
    /**
     * <pre>
     * Keypoint specific standard deviations for COCO keypoint metrics, which
     * controls how OKS is computed.
     * See http://cocodataset.org/#keypoints-eval for details.
     * If your keypoints are similar to the COCO keypoints use the precomputed
     * standard deviations below:
     * "nose": 0.026
     * "left_eye": 0.025
     * "right_eye": 0.025
     * "left_ear": 0.035
     * "right_ear": 0.035
     * "left_shoulder": 0.079
     * "right_shoulder": 0.079
     * "left_elbow": 0.072
     * "right_elbow": 0.072
     * "left_wrist": 0.062
     * "right_wrist": 0.062
     * "left_hip": 0.107
     * "right_hip": 0.107
     * "left_knee": 0.087
     * "right_knee": 0.087
     * "left_ankle": 0.089
     * "right_ankle": 0.089
     * </pre>
     *
     * <code>map&lt;string, float&gt; keypoint_label_to_sigmas = 2;</code>
     */
    java.util.Map<java.lang.String, java.lang.Float>
    getKeypointLabelToSigmasMap();
    /**
     * <pre>
     * Keypoint specific standard deviations for COCO keypoint metrics, which
     * controls how OKS is computed.
     * See http://cocodataset.org/#keypoints-eval for details.
     * If your keypoints are similar to the COCO keypoints use the precomputed
     * standard deviations below:
     * "nose": 0.026
     * "left_eye": 0.025
     * "right_eye": 0.025
     * "left_ear": 0.035
     * "right_ear": 0.035
     * "left_shoulder": 0.079
     * "right_shoulder": 0.079
     * "left_elbow": 0.072
     * "right_elbow": 0.072
     * "left_wrist": 0.062
     * "right_wrist": 0.062
     * "left_hip": 0.107
     * "right_hip": 0.107
     * "left_knee": 0.087
     * "right_knee": 0.087
     * "left_ankle": 0.089
     * "right_ankle": 0.089
     * </pre>
     *
     * <code>map&lt;string, float&gt; keypoint_label_to_sigmas = 2;</code>
     */

    float getKeypointLabelToSigmasOrDefault(
        java.lang.String key,
        float defaultValue);
    /**
     * <pre>
     * Keypoint specific standard deviations for COCO keypoint metrics, which
     * controls how OKS is computed.
     * See http://cocodataset.org/#keypoints-eval for details.
     * If your keypoints are similar to the COCO keypoints use the precomputed
     * standard deviations below:
     * "nose": 0.026
     * "left_eye": 0.025
     * "right_eye": 0.025
     * "left_ear": 0.035
     * "right_ear": 0.035
     * "left_shoulder": 0.079
     * "right_shoulder": 0.079
     * "left_elbow": 0.072
     * "right_elbow": 0.072
     * "left_wrist": 0.062
     * "right_wrist": 0.062
     * "left_hip": 0.107
     * "right_hip": 0.107
     * "left_knee": 0.087
     * "right_knee": 0.087
     * "left_ankle": 0.089
     * "right_ankle": 0.089
     * </pre>
     *
     * <code>map&lt;string, float&gt; keypoint_label_to_sigmas = 2;</code>
     */

    float getKeypointLabelToSigmasOrThrow(
        java.lang.String key);
  }
  /**
   * <pre>
   * A message to evaluate COCO keypoint metrics for a specific class.
   * </pre>
   *
   * Protobuf type {@code object_detection.protos.CocoKeypointMetrics}
   */
  public static final class CocoKeypointMetrics extends
      com.google.protobuf.GeneratedMessageV3 implements
      // @@protoc_insertion_point(message_implements:object_detection.protos.CocoKeypointMetrics)
      CocoKeypointMetricsOrBuilder {
  private static final long serialVersionUID = 0L;
    // Use CocoKeypointMetrics.newBuilder() to construct.
    private CocoKeypointMetrics(com.google.protobuf.GeneratedMessageV3.Builder<?> builder) {
      super(builder);
    }
    private CocoKeypointMetrics() {
      classLabel_ = "";
    }

    @java.lang.Override
    @SuppressWarnings({"unused"})
    protected java.lang.Object newInstance(
        UnusedPrivateParameter unused) {
      return new CocoKeypointMetrics();
    }

    @java.lang.Override
    public final com.google.protobuf.UnknownFieldSet
    getUnknownFields() {
      return this.unknownFields;
    }
    private CocoKeypointMetrics(
        com.google.protobuf.CodedInputStream input,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws com.google.protobuf.InvalidProtocolBufferException {
      this();
      if (extensionRegistry == null) {
        throw new java.lang.NullPointerException();
      }
      int mutable_bitField0_ = 0;
      com.google.protobuf.UnknownFieldSet.Builder unknownFields =
          com.google.protobuf.UnknownFieldSet.newBuilder();
      try {
        boolean done = false;
        while (!done) {
          int tag = input.readTag();
          switch (tag) {
            case 0:
              done = true;
              break;
            case 10: {
              com.google.protobuf.ByteString bs = input.readBytes();
              bitField0_ |= 0x00000001;
              classLabel_ = bs;
              break;
            }
            case 18: {
              if (!((mutable_bitField0_ & 0x00000002) != 0)) {
                keypointLabelToSigmas_ = com.google.protobuf.MapField.newMapField(
                    KeypointLabelToSigmasDefaultEntryHolder.defaultEntry);
                mutable_bitField0_ |= 0x00000002;
              }
              com.google.protobuf.MapEntry<java.lang.String, java.lang.Float>
              keypointLabelToSigmas__ = input.readMessage(
                  KeypointLabelToSigmasDefaultEntryHolder.defaultEntry.getParserForType(), extensionRegistry);
              keypointLabelToSigmas_.getMutableMap().put(
                  keypointLabelToSigmas__.getKey(), keypointLabelToSigmas__.getValue());
              break;
            }
            default: {
              if (!parseUnknownField(
                  input, unknownFields, extensionRegistry, tag)) {
                done = true;
              }
              break;
            }
          }
        }
      } catch (com.google.protobuf.InvalidProtocolBufferException e) {
        throw e.setUnfinishedMessage(this);
      } catch (java.io.IOException e) {
        throw new com.google.protobuf.InvalidProtocolBufferException(
            e).setUnfinishedMessage(this);
      } finally {
        this.unknownFields = unknownFields.build();
        makeExtensionsImmutable();
      }
    }
    public static final com.google.protobuf.Descriptors.Descriptor
        getDescriptor() {
      return object_detection.protos.Eval.internal_static_object_detection_protos_CocoKeypointMetrics_descriptor;
    }

    @SuppressWarnings({"rawtypes"})
    @java.lang.Override
    protected com.google.protobuf.MapField internalGetMapField(
        int number) {
      switch (number) {
        case 2:
          return internalGetKeypointLabelToSigmas();
        default:
          throw new RuntimeException(
              "Invalid map field number: " + number);
      }
    }
    @java.lang.Override
    protected com.google.protobuf.GeneratedMessageV3.FieldAccessorTable
        internalGetFieldAccessorTable() {
      return object_detection.protos.Eval.internal_static_object_detection_protos_CocoKeypointMetrics_fieldAccessorTable
          .ensureFieldAccessorsInitialized(
              object_detection.protos.Eval.CocoKeypointMetrics.class, object_detection.protos.Eval.CocoKeypointMetrics.Builder.class);
    }

    private int bitField0_;
    public static final int CLASS_LABEL_FIELD_NUMBER = 1;
    private volatile java.lang.Object classLabel_;
    /**
     * <pre>
     * Identifies the class of object to which keypoints belong. By default this
     * should use the class's "display_name" in the label map.
     * </pre>
     *
     * <code>optional string class_label = 1;</code>
     * @return Whether the classLabel field is set.
     */
    @java.lang.Override
    public boolean hasClassLabel() {
      return ((bitField0_ & 0x00000001) != 0);
    }
    /**
     * <pre>
     * Identifies the class of object to which keypoints belong. By default this
     * should use the class's "display_name" in the label map.
     * </pre>
     *
     * <code>optional string class_label = 1;</code>
     * @return The classLabel.
     */
    @java.lang.Override
    public java.lang.String getClassLabel() {
      java.lang.Object ref = classLabel_;
      if (ref instanceof java.lang.String) {
        return (java.lang.String) ref;
      } else {
        com.google.protobuf.ByteString bs =
            (com.google.protobuf.ByteString) ref;
        java.lang.String s = bs.toStringUtf8();
        if (bs.isValidUtf8()) {
          classLabel_ = s;
        }
        return s;
      }
    }
    /**
     * <pre>
     * Identifies the class of object to which keypoints belong. By default this
     * should use the class's "display_name" in the label map.
     * </pre>
     *
     * <code>optional string class_label = 1;</code>
     * @return The bytes for classLabel.
     */
    @java.lang.Override
    public com.google.protobuf.ByteString
        getClassLabelBytes() {
      java.lang.Object ref = classLabel_;
      if (ref instanceof java.lang.String) {
        com.google.protobuf.ByteString b =
            com.google.protobuf.ByteString.copyFromUtf8(
                (java.lang.String) ref);
        classLabel_ = b;
        return b;
      } else {
        return (com.google.protobuf.ByteString) ref;
      }
    }

    public static final int KEYPOINT_LABEL_TO_SIGMAS_FIELD_NUMBER = 2;
    private static final class KeypointLabelToSigmasDefaultEntryHolder {
      static final com.google.protobuf.MapEntry<
          java.lang.String, java.lang.Float> defaultEntry =
              com.google.protobuf.MapEntry
              .<java.lang.String, java.lang.Float>newDefaultInstance(
                  object_detection.protos.Eval.internal_static_object_detection_protos_CocoKeypointMetrics_KeypointLabelToSigmasEntry_descriptor,
                  com.google.protobuf.WireFormat.FieldType.STRING,
                  "",
                  com.google.protobuf.WireFormat.FieldType.FLOAT,
                  0F);
    }
    private com.google.protobuf.MapField<
        java.lang.String, java.lang.Float> keypointLabelToSigmas_;
    private com.google.protobuf.MapField<java.lang.String, java.lang.Float>
    internalGetKeypointLabelToSigmas() {
      if (keypointLabelToSigmas_ == null) {
        return com.google.protobuf.MapField.emptyMapField(
            KeypointLabelToSigmasDefaultEntryHolder.defaultEntry);
      }
      return keypointLabelToSigmas_;
    }

    public int getKeypointLabelToSigmasCount() {
      return internalGetKeypointLabelToSigmas().getMap().size();
    }
    /**
     * <pre>
     * Keypoint specific standard deviations for COCO keypoint metrics, which
     * controls how OKS is computed.
     * See http://cocodataset.org/#keypoints-eval for details.
     * If your keypoints are similar to the COCO keypoints use the precomputed
     * standard deviations below:
     * "nose": 0.026
     * "left_eye": 0.025
     * "right_eye": 0.025
     * "left_ear": 0.035
     * "right_ear": 0.035
     * "left_shoulder": 0.079
     * "right_shoulder": 0.079
     * "left_elbow": 0.072
     * "right_elbow": 0.072
     * "left_wrist": 0.062
     * "right_wrist": 0.062
     * "left_hip": 0.107
     * "right_hip": 0.107
     * "left_knee": 0.087
     * "right_knee": 0.087
     * "left_ankle": 0.089
     * "right_ankle": 0.089
     * </pre>
     *
     * <code>map&lt;string, float&gt; keypoint_label_to_sigmas = 2;</code>
     */

    @java.lang.Override
    public boolean containsKeypointLabelToSigmas(
        java.lang.String key) {
      if (key == null) { throw new java.lang.NullPointerException(); }
      return internalGetKeypointLabelToSigmas().getMap().containsKey(key);
    }
    /**
     * Use {@link #getKeypointLabelToSigmasMap()} instead.
     */
    @java.lang.Override
    @java.lang.Deprecated
    public java.util.Map<java.lang.String, java.lang.Float> getKeypointLabelToSigmas() {
      return getKeypointLabelToSigmasMap();
    }
    /**
     * <pre>
     * Keypoint specific standard deviations for COCO keypoint metrics, which
     * controls how OKS is computed.
     * See http://cocodataset.org/#keypoints-eval for details.
     * If your keypoints are similar to the COCO keypoints use the precomputed
     * standard deviations below:
     * "nose": 0.026
     * "left_eye": 0.025
     * "right_eye": 0.025
     * "left_ear": 0.035
     * "right_ear": 0.035
     * "left_shoulder": 0.079
     * "right_shoulder": 0.079
     * "left_elbow": 0.072
     * "right_elbow": 0.072
     * "left_wrist": 0.062
     * "right_wrist": 0.062
     * "left_hip": 0.107
     * "right_hip": 0.107
     * "left_knee": 0.087
     * "right_knee": 0.087
     * "left_ankle": 0.089
     * "right_ankle": 0.089
     * </pre>
     *
     * <code>map&lt;string, float&gt; keypoint_label_to_sigmas = 2;</code>
     */
    @java.lang.Override

    public java.util.Map<java.lang.String, java.lang.Float> getKeypointLabelToSigmasMap() {
      return internalGetKeypointLabelToSigmas().getMap();
    }
    /**
     * <pre>
     * Keypoint specific standard deviations for COCO keypoint metrics, which
     * controls how OKS is computed.
     * See http://cocodataset.org/#keypoints-eval for details.
     * If your keypoints are similar to the COCO keypoints use the precomputed
     * standard deviations below:
     * "nose": 0.026
     * "left_eye": 0.025
     * "right_eye": 0.025
     * "left_ear": 0.035
     * "right_ear": 0.035
     * "left_shoulder": 0.079
     * "right_shoulder": 0.079
     * "left_elbow": 0.072
     * "right_elbow": 0.072
     * "left_wrist": 0.062
     * "right_wrist": 0.062
     * "left_hip": 0.107
     * "right_hip": 0.107
     * "left_knee": 0.087
     * "right_knee": 0.087
     * "left_ankle": 0.089
     * "right_ankle": 0.089
     * </pre>
     *
     * <code>map&lt;string, float&gt; keypoint_label_to_sigmas = 2;</code>
     */
    @java.lang.Override

    public float getKeypointLabelToSigmasOrDefault(
        java.lang.String key,
        float defaultValue) {
      if (key == null) { throw new java.lang.NullPointerException(); }
      java.util.Map<java.lang.String, java.lang.Float> map =
          internalGetKeypointLabelToSigmas().getMap();
      return map.containsKey(key) ? map.get(key) : defaultValue;
    }
    /**
     * <pre>
     * Keypoint specific standard deviations for COCO keypoint metrics, which
     * controls how OKS is computed.
     * See http://cocodataset.org/#keypoints-eval for details.
     * If your keypoints are similar to the COCO keypoints use the precomputed
     * standard deviations below:
     * "nose": 0.026
     * "left_eye": 0.025
     * "right_eye": 0.025
     * "left_ear": 0.035
     * "right_ear": 0.035
     * "left_shoulder": 0.079
     * "right_shoulder": 0.079
     * "left_elbow": 0.072
     * "right_elbow": 0.072
     * "left_wrist": 0.062
     * "right_wrist": 0.062
     * "left_hip": 0.107
     * "right_hip": 0.107
     * "left_knee": 0.087
     * "right_knee": 0.087
     * "left_ankle": 0.089
     * "right_ankle": 0.089
     * </pre>
     *
     * <code>map&lt;string, float&gt; keypoint_label_to_sigmas = 2;</code>
     */
    @java.lang.Override

    public float getKeypointLabelToSigmasOrThrow(
        java.lang.String key) {
      if (key == null) { throw new java.lang.NullPointerException(); }
      java.util.Map<java.lang.String, java.lang.Float> map =
          internalGetKeypointLabelToSigmas().getMap();
      if (!map.containsKey(key)) {
        throw new java.lang.IllegalArgumentException();
      }
      return map.get(key);
    }

    private byte memoizedIsInitialized = -1;
    @java.lang.Override
    public final boolean isInitialized() {
      byte isInitialized = memoizedIsInitialized;
      if (isInitialized == 1) return true;
      if (isInitialized == 0) return false;

      memoizedIsInitialized = 1;
      return true;
    }

    @java.lang.Override
    public void writeTo(com.google.protobuf.CodedOutputStream output)
                        throws java.io.IOException {
      if (((bitField0_ & 0x00000001) != 0)) {
        com.google.protobuf.GeneratedMessageV3.writeString(output, 1, classLabel_);
      }
      com.google.protobuf.GeneratedMessageV3
        .serializeStringMapTo(
          output,
          internalGetKeypointLabelToSigmas(),
          KeypointLabelToSigmasDefaultEntryHolder.defaultEntry,
          2);
      unknownFields.writeTo(output);
    }

    @java.lang.Override
    public int getSerializedSize() {
      int size = memoizedSize;
      if (size != -1) return size;

      size = 0;
      if (((bitField0_ & 0x00000001) != 0)) {
        size += com.google.protobuf.GeneratedMessageV3.computeStringSize(1, classLabel_);
      }
      for (java.util.Map.Entry<java.lang.String, java.lang.Float> entry
           : internalGetKeypointLabelToSigmas().getMap().entrySet()) {
        com.google.protobuf.MapEntry<java.lang.String, java.lang.Float>
        keypointLabelToSigmas__ = KeypointLabelToSigmasDefaultEntryHolder.defaultEntry.newBuilderForType()
            .setKey(entry.getKey())
            .setValue(entry.getValue())
            .build();
        size += com.google.protobuf.CodedOutputStream
            .computeMessageSize(2, keypointLabelToSigmas__);
      }
      size += unknownFields.getSerializedSize();
      memoizedSize = size;
      return size;
    }

    @java.lang.Override
    public boolean equals(final java.lang.Object obj) {
      if (obj == this) {
       return true;
      }
      if (!(obj instanceof object_detection.protos.Eval.CocoKeypointMetrics)) {
        return super.equals(obj);
      }
      object_detection.protos.Eval.CocoKeypointMetrics other = (object_detection.protos.Eval.CocoKeypointMetrics) obj;

      if (hasClassLabel() != other.hasClassLabel()) return false;
      if (hasClassLabel()) {
        if (!getClassLabel()
            .equals(other.getClassLabel())) return false;
      }
      if (!internalGetKeypointLabelToSigmas().equals(
          other.internalGetKeypointLabelToSigmas())) return false;
      if (!unknownFields.equals(other.unknownFields)) return false;
      return true;
    }

    @java.lang.Override
    public int hashCode() {
      if (memoizedHashCode != 0) {
        return memoizedHashCode;
      }
      int hash = 41;
      hash = (19 * hash) + getDescriptor().hashCode();
      if (hasClassLabel()) {
        hash = (37 * hash) + CLASS_LABEL_FIELD_NUMBER;
        hash = (53 * hash) + getClassLabel().hashCode();
      }
      if (!internalGetKeypointLabelToSigmas().getMap().isEmpty()) {
        hash = (37 * hash) + KEYPOINT_LABEL_TO_SIGMAS_FIELD_NUMBER;
        hash = (53 * hash) + internalGetKeypointLabelToSigmas().hashCode();
      }
      hash = (29 * hash) + unknownFields.hashCode();
      memoizedHashCode = hash;
      return hash;
    }

    public static object_detection.protos.Eval.CocoKeypointMetrics parseFrom(
        java.nio.ByteBuffer data)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return PARSER.parseFrom(data);
    }
    public static object_detection.protos.Eval.CocoKeypointMetrics parseFrom(
        java.nio.ByteBuffer data,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return PARSER.parseFrom(data, extensionRegistry);
    }
    public static object_detection.protos.Eval.CocoKeypointMetrics parseFrom(
        com.google.protobuf.ByteString data)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return PARSER.parseFrom(data);
    }
    public static object_detection.protos.Eval.CocoKeypointMetrics parseFrom(
        com.google.protobuf.ByteString data,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return PARSER.parseFrom(data, extensionRegistry);
    }
    public static object_detection.protos.Eval.CocoKeypointMetrics parseFrom(byte[] data)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return PARSER.parseFrom(data);
    }
    public static object_detection.protos.Eval.CocoKeypointMetrics parseFrom(
        byte[] data,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return PARSER.parseFrom(data, extensionRegistry);
    }
    public static object_detection.protos.Eval.CocoKeypointMetrics parseFrom(java.io.InputStream input)
        throws java.io.IOException {
      return com.google.protobuf.GeneratedMessageV3
          .parseWithIOException(PARSER, input);
    }
    public static object_detection.protos.Eval.CocoKeypointMetrics parseFrom(
        java.io.InputStream input,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws java.io.IOException {
      return com.google.protobuf.GeneratedMessageV3
          .parseWithIOException(PARSER, input, extensionRegistry);
    }
    public static object_detection.protos.Eval.CocoKeypointMetrics parseDelimitedFrom(java.io.InputStream input)
        throws java.io.IOException {
      return com.google.protobuf.GeneratedMessageV3
          .parseDelimitedWithIOException(PARSER, input);
    }
    public static object_detection.protos.Eval.CocoKeypointMetrics parseDelimitedFrom(
        java.io.InputStream input,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws java.io.IOException {
      return com.google.protobuf.GeneratedMessageV3
          .parseDelimitedWithIOException(PARSER, input, extensionRegistry);
    }
    public static object_detection.protos.Eval.CocoKeypointMetrics parseFrom(
        com.google.protobuf.CodedInputStream input)
        throws java.io.IOException {
      return com.google.protobuf.GeneratedMessageV3
          .parseWithIOException(PARSER, input);
    }
    public static object_detection.protos.Eval.CocoKeypointMetrics parseFrom(
        com.google.protobuf.CodedInputStream input,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws java.io.IOException {
      return com.google.protobuf.GeneratedMessageV3
          .parseWithIOException(PARSER, input, extensionRegistry);
    }

    @java.lang.Override
    public Builder newBuilderForType() { return newBuilder(); }
    public static Builder newBuilder() {
      return DEFAULT_INSTANCE.toBuilder();
    }
    public static Builder newBuilder(object_detection.protos.Eval.CocoKeypointMetrics prototype) {
      return DEFAULT_INSTANCE.toBuilder().mergeFrom(prototype);
    }
    @java.lang.Override
    public Builder toBuilder() {
      return this == DEFAULT_INSTANCE
          ? new Builder() : new Builder().mergeFrom(this);
    }

    @java.lang.Override
    protected Builder newBuilderForType(
        com.google.protobuf.GeneratedMessageV3.BuilderParent parent) {
      Builder builder = new Builder(parent);
      return builder;
    }
    /**
     * <pre>
     * A message to evaluate COCO keypoint metrics for a specific class.
     * </pre>
     *
     * Protobuf type {@code object_detection.protos.CocoKeypointMetrics}
     */
    public static final class Builder extends
        com.google.protobuf.GeneratedMessageV3.Builder<Builder> implements
        // @@protoc_insertion_point(builder_implements:object_detection.protos.CocoKeypointMetrics)
        object_detection.protos.Eval.CocoKeypointMetricsOrBuilder {
      public static final com.google.protobuf.Descriptors.Descriptor
          getDescriptor() {
        return object_detection.protos.Eval.internal_static_object_detection_protos_CocoKeypointMetrics_descriptor;
      }

      @SuppressWarnings({"rawtypes"})
      protected com.google.protobuf.MapField internalGetMapField(
          int number) {
        switch (number) {
          case 2:
            return internalGetKeypointLabelToSigmas();
          default:
            throw new RuntimeException(
                "Invalid map field number: " + number);
        }
      }
      @SuppressWarnings({"rawtypes"})
      protected com.google.protobuf.MapField internalGetMutableMapField(
          int number) {
        switch (number) {
          case 2:
            return internalGetMutableKeypointLabelToSigmas();
          default:
            throw new RuntimeException(
                "Invalid map field number: " + number);
        }
      }
      @java.lang.Override
      protected com.google.protobuf.GeneratedMessageV3.FieldAccessorTable
          internalGetFieldAccessorTable() {
        return object_detection.protos.Eval.internal_static_object_detection_protos_CocoKeypointMetrics_fieldAccessorTable
            .ensureFieldAccessorsInitialized(
                object_detection.protos.Eval.CocoKeypointMetrics.class, object_detection.protos.Eval.CocoKeypointMetrics.Builder.class);
      }

      // Construct using object_detection.protos.Eval.CocoKeypointMetrics.newBuilder()
      private Builder() {
        maybeForceBuilderInitialization();
      }

      private Builder(
          com.google.protobuf.GeneratedMessageV3.BuilderParent parent) {
        super(parent);
        maybeForceBuilderInitialization();
      }
      private void maybeForceBuilderInitialization() {
        if (com.google.protobuf.GeneratedMessageV3
                .alwaysUseFieldBuilders) {
        }
      }
      @java.lang.Override
      public Builder clear() {
        super.clear();
        classLabel_ = "";
        bitField0_ = (bitField0_ & ~0x00000001);
        internalGetMutableKeypointLabelToSigmas().clear();
        return this;
      }

      @java.lang.Override
      public com.google.protobuf.Descriptors.Descriptor
          getDescriptorForType() {
        return object_detection.protos.Eval.internal_static_object_detection_protos_CocoKeypointMetrics_descriptor;
      }

      @java.lang.Override
      public object_detection.protos.Eval.CocoKeypointMetrics getDefaultInstanceForType() {
        return object_detection.protos.Eval.CocoKeypointMetrics.getDefaultInstance();
      }

      @java.lang.Override
      public object_detection.protos.Eval.CocoKeypointMetrics build() {
        object_detection.protos.Eval.CocoKeypointMetrics result = buildPartial();
        if (!result.isInitialized()) {
          throw newUninitializedMessageException(result);
        }
        return result;
      }

      @java.lang.Override
      public object_detection.protos.Eval.CocoKeypointMetrics buildPartial() {
        object_detection.protos.Eval.CocoKeypointMetrics result = new object_detection.protos.Eval.CocoKeypointMetrics(this);
        int from_bitField0_ = bitField0_;
        int to_bitField0_ = 0;
        if (((from_bitField0_ & 0x00000001) != 0)) {
          to_bitField0_ |= 0x00000001;
        }
        result.classLabel_ = classLabel_;
        result.keypointLabelToSigmas_ = internalGetKeypointLabelToSigmas();
        result.keypointLabelToSigmas_.makeImmutable();
        result.bitField0_ = to_bitField0_;
        onBuilt();
        return result;
      }

      @java.lang.Override
      public Builder clone() {
        return super.clone();
      }
      @java.lang.Override
      public Builder setField(
          com.google.protobuf.Descriptors.FieldDescriptor field,
          java.lang.Object value) {
        return super.setField(field, value);
      }
      @java.lang.Override
      public Builder clearField(
          com.google.protobuf.Descriptors.FieldDescriptor field) {
        return super.clearField(field);
      }
      @java.lang.Override
      public Builder clearOneof(
          com.google.protobuf.Descriptors.OneofDescriptor oneof) {
        return super.clearOneof(oneof);
      }
      @java.lang.Override
      public Builder setRepeatedField(
          com.google.protobuf.Descriptors.FieldDescriptor field,
          int index, java.lang.Object value) {
        return super.setRepeatedField(field, index, value);
      }
      @java.lang.Override
      public Builder addRepeatedField(
          com.google.protobuf.Descriptors.FieldDescriptor field,
          java.lang.Object value) {
        return super.addRepeatedField(field, value);
      }
      @java.lang.Override
      public Builder mergeFrom(com.google.protobuf.Message other) {
        if (other instanceof object_detection.protos.Eval.CocoKeypointMetrics) {
          return mergeFrom((object_detection.protos.Eval.CocoKeypointMetrics)other);
        } else {
          super.mergeFrom(other);
          return this;
        }
      }

      public Builder mergeFrom(object_detection.protos.Eval.CocoKeypointMetrics other) {
        if (other == object_detection.protos.Eval.CocoKeypointMetrics.getDefaultInstance()) return this;
        if (other.hasClassLabel()) {
          bitField0_ |= 0x00000001;
          classLabel_ = other.classLabel_;
          onChanged();
        }
        internalGetMutableKeypointLabelToSigmas().mergeFrom(
            other.internalGetKeypointLabelToSigmas());
        this.mergeUnknownFields(other.unknownFields);
        onChanged();
        return this;
      }

      @java.lang.Override
      public final boolean isInitialized() {
        return true;
      }

      @java.lang.Override
      public Builder mergeFrom(
          com.google.protobuf.CodedInputStream input,
          com.google.protobuf.ExtensionRegistryLite extensionRegistry)
          throws java.io.IOException {
        object_detection.protos.Eval.CocoKeypointMetrics parsedMessage = null;
        try {
          parsedMessage = PARSER.parsePartialFrom(input, extensionRegistry);
        } catch (com.google.protobuf.InvalidProtocolBufferException e) {
          parsedMessage = (object_detection.protos.Eval.CocoKeypointMetrics) e.getUnfinishedMessage();
          throw e.unwrapIOException();
        } finally {
          if (parsedMessage != null) {
            mergeFrom(parsedMessage);
          }
        }
        return this;
      }
      private int bitField0_;

      private java.lang.Object classLabel_ = "";
      /**
       * <pre>
       * Identifies the class of object to which keypoints belong. By default this
       * should use the class's "display_name" in the label map.
       * </pre>
       *
       * <code>optional string class_label = 1;</code>
       * @return Whether the classLabel field is set.
       */
      public boolean hasClassLabel() {
        return ((bitField0_ & 0x00000001) != 0);
      }
      /**
       * <pre>
       * Identifies the class of object to which keypoints belong. By default this
       * should use the class's "display_name" in the label map.
       * </pre>
       *
       * <code>optional string class_label = 1;</code>
       * @return The classLabel.
       */
      public java.lang.String getClassLabel() {
        java.lang.Object ref = classLabel_;
        if (!(ref instanceof java.lang.String)) {
          com.google.protobuf.ByteString bs =
              (com.google.protobuf.ByteString) ref;
          java.lang.String s = bs.toStringUtf8();
          if (bs.isValidUtf8()) {
            classLabel_ = s;
          }
          return s;
        } else {
          return (java.lang.String) ref;
        }
      }
      /**
       * <pre>
       * Identifies the class of object to which keypoints belong. By default this
       * should use the class's "display_name" in the label map.
       * </pre>
       *
       * <code>optional string class_label = 1;</code>
       * @return The bytes for classLabel.
       */
      public com.google.protobuf.ByteString
          getClassLabelBytes() {
        java.lang.Object ref = classLabel_;
        if (ref instanceof String) {
          com.google.protobuf.ByteString b =
              com.google.protobuf.ByteString.copyFromUtf8(
                  (java.lang.String) ref);
          classLabel_ = b;
          return b;
        } else {
          return (com.google.protobuf.ByteString) ref;
        }
      }
      /**
       * <pre>
       * Identifies the class of object to which keypoints belong. By default this
       * should use the class's "display_name" in the label map.
       * </pre>
       *
       * <code>optional string class_label = 1;</code>
       * @param value The classLabel to set.
       * @return This builder for chaining.
       */
      public Builder setClassLabel(
          java.lang.String value) {
        if (value == null) {
    throw new NullPointerException();
  }
  bitField0_ |= 0x00000001;
        classLabel_ = value;
        onChanged();
        return this;
      }
      /**
       * <pre>
       * Identifies the class of object to which keypoints belong. By default this
       * should use the class's "display_name" in the label map.
       * </pre>
       *
       * <code>optional string class_label = 1;</code>
       * @return This builder for chaining.
       */
      public Builder clearClassLabel() {
        bitField0_ = (bitField0_ & ~0x00000001);
        classLabel_ = getDefaultInstance().getClassLabel();
        onChanged();
        return this;
      }
      /**
       * <pre>
       * Identifies the class of object to which keypoints belong. By default this
       * should use the class's "display_name" in the label map.
       * </pre>
       *
       * <code>optional string class_label = 1;</code>
       * @param value The bytes for classLabel to set.
       * @return This builder for chaining.
       */
      public Builder setClassLabelBytes(
          com.google.protobuf.ByteString value) {
        if (value == null) {
    throw new NullPointerException();
  }
  bitField0_ |= 0x00000001;
        classLabel_ = value;
        onChanged();
        return this;
      }

      private com.google.protobuf.MapField<
          java.lang.String, java.lang.Float> keypointLabelToSigmas_;
      private com.google.protobuf.MapField<java.lang.String, java.lang.Float>
      internalGetKeypointLabelToSigmas() {
        if (keypointLabelToSigmas_ == null) {
          return com.google.protobuf.MapField.emptyMapField(
              KeypointLabelToSigmasDefaultEntryHolder.defaultEntry);
        }
        return keypointLabelToSigmas_;
      }
      private com.google.protobuf.MapField<java.lang.String, java.lang.Float>
      internalGetMutableKeypointLabelToSigmas() {
        onChanged();;
        if (keypointLabelToSigmas_ == null) {
          keypointLabelToSigmas_ = com.google.protobuf.MapField.newMapField(
              KeypointLabelToSigmasDefaultEntryHolder.defaultEntry);
        }
        if (!keypointLabelToSigmas_.isMutable()) {
          keypointLabelToSigmas_ = keypointLabelToSigmas_.copy();
        }
        return keypointLabelToSigmas_;
      }

      public int getKeypointLabelToSigmasCount() {
        return internalGetKeypointLabelToSigmas().getMap().size();
      }
      /**
       * <pre>
       * Keypoint specific standard deviations for COCO keypoint metrics, which
       * controls how OKS is computed.
       * See http://cocodataset.org/#keypoints-eval for details.
       * If your keypoints are similar to the COCO keypoints use the precomputed
       * standard deviations below:
       * "nose": 0.026
       * "left_eye": 0.025
       * "right_eye": 0.025
       * "left_ear": 0.035
       * "right_ear": 0.035
       * "left_shoulder": 0.079
       * "right_shoulder": 0.079
       * "left_elbow": 0.072
       * "right_elbow": 0.072
       * "left_wrist": 0.062
       * "right_wrist": 0.062
       * "left_hip": 0.107
       * "right_hip": 0.107
       * "left_knee": 0.087
       * "right_knee": 0.087
       * "left_ankle": 0.089
       * "right_ankle": 0.089
       * </pre>
       *
       * <code>map&lt;string, float&gt; keypoint_label_to_sigmas = 2;</code>
       */

      @java.lang.Override
      public boolean containsKeypointLabelToSigmas(
          java.lang.String key) {
        if (key == null) { throw new java.lang.NullPointerException(); }
        return internalGetKeypointLabelToSigmas().getMap().containsKey(key);
      }
      /**
       * Use {@link #getKeypointLabelToSigmasMap()} instead.
       */
      @java.lang.Override
      @java.lang.Deprecated
      public java.util.Map<java.lang.String, java.lang.Float> getKeypointLabelToSigmas() {
        return getKeypointLabelToSigmasMap();
      }
      /**
       * <pre>
       * Keypoint specific standard deviations for COCO keypoint metrics, which
       * controls how OKS is computed.
       * See http://cocodataset.org/#keypoints-eval for details.
       * If your keypoints are similar to the COCO keypoints use the precomputed
       * standard deviations below:
       * "nose": 0.026
       * "left_eye": 0.025
       * "right_eye": 0.025
       * "left_ear": 0.035
       * "right_ear": 0.035
       * "left_shoulder": 0.079
       * "right_shoulder": 0.079
       * "left_elbow": 0.072
       * "right_elbow": 0.072
       * "left_wrist": 0.062
       * "right_wrist": 0.062
       * "left_hip": 0.107
       * "right_hip": 0.107
       * "left_knee": 0.087
       * "right_knee": 0.087
       * "left_ankle": 0.089
       * "right_ankle": 0.089
       * </pre>
       *
       * <code>map&lt;string, float&gt; keypoint_label_to_sigmas = 2;</code>
       */
      @java.lang.Override

      public java.util.Map<java.lang.String, java.lang.Float> getKeypointLabelToSigmasMap() {
        return internalGetKeypointLabelToSigmas().getMap();
      }
      /**
       * <pre>
       * Keypoint specific standard deviations for COCO keypoint metrics, which
       * controls how OKS is computed.
       * See http://cocodataset.org/#keypoints-eval for details.
       * If your keypoints are similar to the COCO keypoints use the precomputed
       * standard deviations below:
       * "nose": 0.026
       * "left_eye": 0.025
       * "right_eye": 0.025
       * "left_ear": 0.035
       * "right_ear": 0.035
       * "left_shoulder": 0.079
       * "right_shoulder": 0.079
       * "left_elbow": 0.072
       * "right_elbow": 0.072
       * "left_wrist": 0.062
       * "right_wrist": 0.062
       * "left_hip": 0.107
       * "right_hip": 0.107
       * "left_knee": 0.087
       * "right_knee": 0.087
       * "left_ankle": 0.089
       * "right_ankle": 0.089
       * </pre>
       *
       * <code>map&lt;string, float&gt; keypoint_label_to_sigmas = 2;</code>
       */
      @java.lang.Override

      public float getKeypointLabelToSigmasOrDefault(
          java.lang.String key,
          float defaultValue) {
        if (key == null) { throw new java.lang.NullPointerException(); }
        java.util.Map<java.lang.String, java.lang.Float> map =
            internalGetKeypointLabelToSigmas().getMap();
        return map.containsKey(key) ? map.get(key) : defaultValue;
      }
      /**
       * <pre>
       * Keypoint specific standard deviations for COCO keypoint metrics, which
       * controls how OKS is computed.
       * See http://cocodataset.org/#keypoints-eval for details.
       * If your keypoints are similar to the COCO keypoints use the precomputed
       * standard deviations below:
       * "nose": 0.026
       * "left_eye": 0.025
       * "right_eye": 0.025
       * "left_ear": 0.035
       * "right_ear": 0.035
       * "left_shoulder": 0.079
       * "right_shoulder": 0.079
       * "left_elbow": 0.072
       * "right_elbow": 0.072
       * "left_wrist": 0.062
       * "right_wrist": 0.062
       * "left_hip": 0.107
       * "right_hip": 0.107
       * "left_knee": 0.087
       * "right_knee": 0.087
       * "left_ankle": 0.089
       * "right_ankle": 0.089
       * </pre>
       *
       * <code>map&lt;string, float&gt; keypoint_label_to_sigmas = 2;</code>
       */
      @java.lang.Override

      public float getKeypointLabelToSigmasOrThrow(
          java.lang.String key) {
        if (key == null) { throw new java.lang.NullPointerException(); }
        java.util.Map<java.lang.String, java.lang.Float> map =
            internalGetKeypointLabelToSigmas().getMap();
        if (!map.containsKey(key)) {
          throw new java.lang.IllegalArgumentException();
        }
        return map.get(key);
      }

      public Builder clearKeypointLabelToSigmas() {
        internalGetMutableKeypointLabelToSigmas().getMutableMap()
            .clear();
        return this;
      }
      /**
       * <pre>
       * Keypoint specific standard deviations for COCO keypoint metrics, which
       * controls how OKS is computed.
       * See http://cocodataset.org/#keypoints-eval for details.
       * If your keypoints are similar to the COCO keypoints use the precomputed
       * standard deviations below:
       * "nose": 0.026
       * "left_eye": 0.025
       * "right_eye": 0.025
       * "left_ear": 0.035
       * "right_ear": 0.035
       * "left_shoulder": 0.079
       * "right_shoulder": 0.079
       * "left_elbow": 0.072
       * "right_elbow": 0.072
       * "left_wrist": 0.062
       * "right_wrist": 0.062
       * "left_hip": 0.107
       * "right_hip": 0.107
       * "left_knee": 0.087
       * "right_knee": 0.087
       * "left_ankle": 0.089
       * "right_ankle": 0.089
       * </pre>
       *
       * <code>map&lt;string, float&gt; keypoint_label_to_sigmas = 2;</code>
       */

      public Builder removeKeypointLabelToSigmas(
          java.lang.String key) {
        if (key == null) { throw new java.lang.NullPointerException(); }
        internalGetMutableKeypointLabelToSigmas().getMutableMap()
            .remove(key);
        return this;
      }
      /**
       * Use alternate mutation accessors instead.
       */
      @java.lang.Deprecated
      public java.util.Map<java.lang.String, java.lang.Float>
      getMutableKeypointLabelToSigmas() {
        return internalGetMutableKeypointLabelToSigmas().getMutableMap();
      }
      /**
       * <pre>
       * Keypoint specific standard deviations for COCO keypoint metrics, which
       * controls how OKS is computed.
       * See http://cocodataset.org/#keypoints-eval for details.
       * If your keypoints are similar to the COCO keypoints use the precomputed
       * standard deviations below:
       * "nose": 0.026
       * "left_eye": 0.025
       * "right_eye": 0.025
       * "left_ear": 0.035
       * "right_ear": 0.035
       * "left_shoulder": 0.079
       * "right_shoulder": 0.079
       * "left_elbow": 0.072
       * "right_elbow": 0.072
       * "left_wrist": 0.062
       * "right_wrist": 0.062
       * "left_hip": 0.107
       * "right_hip": 0.107
       * "left_knee": 0.087
       * "right_knee": 0.087
       * "left_ankle": 0.089
       * "right_ankle": 0.089
       * </pre>
       *
       * <code>map&lt;string, float&gt; keypoint_label_to_sigmas = 2;</code>
       */
      public Builder putKeypointLabelToSigmas(
          java.lang.String key,
          float value) {
        if (key == null) { throw new java.lang.NullPointerException(); }

        internalGetMutableKeypointLabelToSigmas().getMutableMap()
            .put(key, value);
        return this;
      }
      /**
       * <pre>
       * Keypoint specific standard deviations for COCO keypoint metrics, which
       * controls how OKS is computed.
       * See http://cocodataset.org/#keypoints-eval for details.
       * If your keypoints are similar to the COCO keypoints use the precomputed
       * standard deviations below:
       * "nose": 0.026
       * "left_eye": 0.025
       * "right_eye": 0.025
       * "left_ear": 0.035
       * "right_ear": 0.035
       * "left_shoulder": 0.079
       * "right_shoulder": 0.079
       * "left_elbow": 0.072
       * "right_elbow": 0.072
       * "left_wrist": 0.062
       * "right_wrist": 0.062
       * "left_hip": 0.107
       * "right_hip": 0.107
       * "left_knee": 0.087
       * "right_knee": 0.087
       * "left_ankle": 0.089
       * "right_ankle": 0.089
       * </pre>
       *
       * <code>map&lt;string, float&gt; keypoint_label_to_sigmas = 2;</code>
       */

      public Builder putAllKeypointLabelToSigmas(
          java.util.Map<java.lang.String, java.lang.Float> values) {
        internalGetMutableKeypointLabelToSigmas().getMutableMap()
            .putAll(values);
        return this;
      }
      @java.lang.Override
      public final Builder setUnknownFields(
          final com.google.protobuf.UnknownFieldSet unknownFields) {
        return super.setUnknownFields(unknownFields);
      }

      @java.lang.Override
      public final Builder mergeUnknownFields(
          final com.google.protobuf.UnknownFieldSet unknownFields) {
        return super.mergeUnknownFields(unknownFields);
      }


      // @@protoc_insertion_point(builder_scope:object_detection.protos.CocoKeypointMetrics)
    }

    // @@protoc_insertion_point(class_scope:object_detection.protos.CocoKeypointMetrics)
    private static final object_detection.protos.Eval.CocoKeypointMetrics DEFAULT_INSTANCE;
    static {
      DEFAULT_INSTANCE = new object_detection.protos.Eval.CocoKeypointMetrics();
    }

    public static object_detection.protos.Eval.CocoKeypointMetrics getDefaultInstance() {
      return DEFAULT_INSTANCE;
    }

    @java.lang.Deprecated public static final com.google.protobuf.Parser<CocoKeypointMetrics>
        PARSER = new com.google.protobuf.AbstractParser<CocoKeypointMetrics>() {
      @java.lang.Override
      public CocoKeypointMetrics parsePartialFrom(
          com.google.protobuf.CodedInputStream input,
          com.google.protobuf.ExtensionRegistryLite extensionRegistry)
          throws com.google.protobuf.InvalidProtocolBufferException {
        return new CocoKeypointMetrics(input, extensionRegistry);
      }
    };

    public static com.google.protobuf.Parser<CocoKeypointMetrics> parser() {
      return PARSER;
    }

    @java.lang.Override
    public com.google.protobuf.Parser<CocoKeypointMetrics> getParserForType() {
      return PARSER;
    }

    @java.lang.Override
    public object_detection.protos.Eval.CocoKeypointMetrics getDefaultInstanceForType() {
      return DEFAULT_INSTANCE;
    }

  }

  public interface KeypointEdgeOrBuilder extends
      // @@protoc_insertion_point(interface_extends:object_detection.protos.KeypointEdge)
      com.google.protobuf.MessageOrBuilder {

    /**
     * <pre>
     * Index of the keypoint where the edge starts from. Index starts at 0.
     * </pre>
     *
     * <code>optional int32 start = 1;</code>
     * @return Whether the start field is set.
     */
    boolean hasStart();
    /**
     * <pre>
     * Index of the keypoint where the edge starts from. Index starts at 0.
     * </pre>
     *
     * <code>optional int32 start = 1;</code>
     * @return The start.
     */
    int getStart();

    /**
     * <pre>
     * Index of the keypoint where the edge ends. Index starts at 0.
     * </pre>
     *
     * <code>optional int32 end = 2;</code>
     * @return Whether the end field is set.
     */
    boolean hasEnd();
    /**
     * <pre>
     * Index of the keypoint where the edge ends. Index starts at 0.
     * </pre>
     *
     * <code>optional int32 end = 2;</code>
     * @return The end.
     */
    int getEnd();
  }
  /**
   * <pre>
   * Defines an edge that should be drawn between two keypoints.
   * </pre>
   *
   * Protobuf type {@code object_detection.protos.KeypointEdge}
   */
  public static final class KeypointEdge extends
      com.google.protobuf.GeneratedMessageV3 implements
      // @@protoc_insertion_point(message_implements:object_detection.protos.KeypointEdge)
      KeypointEdgeOrBuilder {
  private static final long serialVersionUID = 0L;
    // Use KeypointEdge.newBuilder() to construct.
    private KeypointEdge(com.google.protobuf.GeneratedMessageV3.Builder<?> builder) {
      super(builder);
    }
    private KeypointEdge() {
    }

    @java.lang.Override
    @SuppressWarnings({"unused"})
    protected java.lang.Object newInstance(
        UnusedPrivateParameter unused) {
      return new KeypointEdge();
    }

    @java.lang.Override
    public final com.google.protobuf.UnknownFieldSet
    getUnknownFields() {
      return this.unknownFields;
    }
    private KeypointEdge(
        com.google.protobuf.CodedInputStream input,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws com.google.protobuf.InvalidProtocolBufferException {
      this();
      if (extensionRegistry == null) {
        throw new java.lang.NullPointerException();
      }
      int mutable_bitField0_ = 0;
      com.google.protobuf.UnknownFieldSet.Builder unknownFields =
          com.google.protobuf.UnknownFieldSet.newBuilder();
      try {
        boolean done = false;
        while (!done) {
          int tag = input.readTag();
          switch (tag) {
            case 0:
              done = true;
              break;
            case 8: {
              bitField0_ |= 0x00000001;
              start_ = input.readInt32();
              break;
            }
            case 16: {
              bitField0_ |= 0x00000002;
              end_ = input.readInt32();
              break;
            }
            default: {
              if (!parseUnknownField(
                  input, unknownFields, extensionRegistry, tag)) {
                done = true;
              }
              break;
            }
          }
        }
      } catch (com.google.protobuf.InvalidProtocolBufferException e) {
        throw e.setUnfinishedMessage(this);
      } catch (java.io.IOException e) {
        throw new com.google.protobuf.InvalidProtocolBufferException(
            e).setUnfinishedMessage(this);
      } finally {
        this.unknownFields = unknownFields.build();
        makeExtensionsImmutable();
      }
    }
    public static final com.google.protobuf.Descriptors.Descriptor
        getDescriptor() {
      return object_detection.protos.Eval.internal_static_object_detection_protos_KeypointEdge_descriptor;
    }

    @java.lang.Override
    protected com.google.protobuf.GeneratedMessageV3.FieldAccessorTable
        internalGetFieldAccessorTable() {
      return object_detection.protos.Eval.internal_static_object_detection_protos_KeypointEdge_fieldAccessorTable
          .ensureFieldAccessorsInitialized(
              object_detection.protos.Eval.KeypointEdge.class, object_detection.protos.Eval.KeypointEdge.Builder.class);
    }

    private int bitField0_;
    public static final int START_FIELD_NUMBER = 1;
    private int start_;
    /**
     * <pre>
     * Index of the keypoint where the edge starts from. Index starts at 0.
     * </pre>
     *
     * <code>optional int32 start = 1;</code>
     * @return Whether the start field is set.
     */
    @java.lang.Override
    public boolean hasStart() {
      return ((bitField0_ & 0x00000001) != 0);
    }
    /**
     * <pre>
     * Index of the keypoint where the edge starts from. Index starts at 0.
     * </pre>
     *
     * <code>optional int32 start = 1;</code>
     * @return The start.
     */
    @java.lang.Override
    public int getStart() {
      return start_;
    }

    public static final int END_FIELD_NUMBER = 2;
    private int end_;
    /**
     * <pre>
     * Index of the keypoint where the edge ends. Index starts at 0.
     * </pre>
     *
     * <code>optional int32 end = 2;</code>
     * @return Whether the end field is set.
     */
    @java.lang.Override
    public boolean hasEnd() {
      return ((bitField0_ & 0x00000002) != 0);
    }
    /**
     * <pre>
     * Index of the keypoint where the edge ends. Index starts at 0.
     * </pre>
     *
     * <code>optional int32 end = 2;</code>
     * @return The end.
     */
    @java.lang.Override
    public int getEnd() {
      return end_;
    }

    private byte memoizedIsInitialized = -1;
    @java.lang.Override
    public final boolean isInitialized() {
      byte isInitialized = memoizedIsInitialized;
      if (isInitialized == 1) return true;
      if (isInitialized == 0) return false;

      memoizedIsInitialized = 1;
      return true;
    }

    @java.lang.Override
    public void writeTo(com.google.protobuf.CodedOutputStream output)
                        throws java.io.IOException {
      if (((bitField0_ & 0x00000001) != 0)) {
        output.writeInt32(1, start_);
      }
      if (((bitField0_ & 0x00000002) != 0)) {
        output.writeInt32(2, end_);
      }
      unknownFields.writeTo(output);
    }

    @java.lang.Override
    public int getSerializedSize() {
      int size = memoizedSize;
      if (size != -1) return size;

      size = 0;
      if (((bitField0_ & 0x00000001) != 0)) {
        size += com.google.protobuf.CodedOutputStream
          .computeInt32Size(1, start_);
      }
      if (((bitField0_ & 0x00000002) != 0)) {
        size += com.google.protobuf.CodedOutputStream
          .computeInt32Size(2, end_);
      }
      size += unknownFields.getSerializedSize();
      memoizedSize = size;
      return size;
    }

    @java.lang.Override
    public boolean equals(final java.lang.Object obj) {
      if (obj == this) {
       return true;
      }
      if (!(obj instanceof object_detection.protos.Eval.KeypointEdge)) {
        return super.equals(obj);
      }
      object_detection.protos.Eval.KeypointEdge other = (object_detection.protos.Eval.KeypointEdge) obj;

      if (hasStart() != other.hasStart()) return false;
      if (hasStart()) {
        if (getStart()
            != other.getStart()) return false;
      }
      if (hasEnd() != other.hasEnd()) return false;
      if (hasEnd()) {
        if (getEnd()
            != other.getEnd()) return false;
      }
      if (!unknownFields.equals(other.unknownFields)) return false;
      return true;
    }

    @java.lang.Override
    public int hashCode() {
      if (memoizedHashCode != 0) {
        return memoizedHashCode;
      }
      int hash = 41;
      hash = (19 * hash) + getDescriptor().hashCode();
      if (hasStart()) {
        hash = (37 * hash) + START_FIELD_NUMBER;
        hash = (53 * hash) + getStart();
      }
      if (hasEnd()) {
        hash = (37 * hash) + END_FIELD_NUMBER;
        hash = (53 * hash) + getEnd();
      }
      hash = (29 * hash) + unknownFields.hashCode();
      memoizedHashCode = hash;
      return hash;
    }

    public static object_detection.protos.Eval.KeypointEdge parseFrom(
        java.nio.ByteBuffer data)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return PARSER.parseFrom(data);
    }
    public static object_detection.protos.Eval.KeypointEdge parseFrom(
        java.nio.ByteBuffer data,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return PARSER.parseFrom(data, extensionRegistry);
    }
    public static object_detection.protos.Eval.KeypointEdge parseFrom(
        com.google.protobuf.ByteString data)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return PARSER.parseFrom(data);
    }
    public static object_detection.protos.Eval.KeypointEdge parseFrom(
        com.google.protobuf.ByteString data,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return PARSER.parseFrom(data, extensionRegistry);
    }
    public static object_detection.protos.Eval.KeypointEdge parseFrom(byte[] data)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return PARSER.parseFrom(data);
    }
    public static object_detection.protos.Eval.KeypointEdge parseFrom(
        byte[] data,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return PARSER.parseFrom(data, extensionRegistry);
    }
    public static object_detection.protos.Eval.KeypointEdge parseFrom(java.io.InputStream input)
        throws java.io.IOException {
      return com.google.protobuf.GeneratedMessageV3
          .parseWithIOException(PARSER, input);
    }
    public static object_detection.protos.Eval.KeypointEdge parseFrom(
        java.io.InputStream input,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws java.io.IOException {
      return com.google.protobuf.GeneratedMessageV3
          .parseWithIOException(PARSER, input, extensionRegistry);
    }
    public static object_detection.protos.Eval.KeypointEdge parseDelimitedFrom(java.io.InputStream input)
        throws java.io.IOException {
      return com.google.protobuf.GeneratedMessageV3
          .parseDelimitedWithIOException(PARSER, input);
    }
    public static object_detection.protos.Eval.KeypointEdge parseDelimitedFrom(
        java.io.InputStream input,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws java.io.IOException {
      return com.google.protobuf.GeneratedMessageV3
          .parseDelimitedWithIOException(PARSER, input, extensionRegistry);
    }
    public static object_detection.protos.Eval.KeypointEdge parseFrom(
        com.google.protobuf.CodedInputStream input)
        throws java.io.IOException {
      return com.google.protobuf.GeneratedMessageV3
          .parseWithIOException(PARSER, input);
    }
    public static object_detection.protos.Eval.KeypointEdge parseFrom(
        com.google.protobuf.CodedInputStream input,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws java.io.IOException {
      return com.google.protobuf.GeneratedMessageV3
          .parseWithIOException(PARSER, input, extensionRegistry);
    }

    @java.lang.Override
    public Builder newBuilderForType() { return newBuilder(); }
    public static Builder newBuilder() {
      return DEFAULT_INSTANCE.toBuilder();
    }
    public static Builder newBuilder(object_detection.protos.Eval.KeypointEdge prototype) {
      return DEFAULT_INSTANCE.toBuilder().mergeFrom(prototype);
    }
    @java.lang.Override
    public Builder toBuilder() {
      return this == DEFAULT_INSTANCE
          ? new Builder() : new Builder().mergeFrom(this);
    }

    @java.lang.Override
    protected Builder newBuilderForType(
        com.google.protobuf.GeneratedMessageV3.BuilderParent parent) {
      Builder builder = new Builder(parent);
      return builder;
    }
    /**
     * <pre>
     * Defines an edge that should be drawn between two keypoints.
     * </pre>
     *
     * Protobuf type {@code object_detection.protos.KeypointEdge}
     */
    public static final class Builder extends
        com.google.protobuf.GeneratedMessageV3.Builder<Builder> implements
        // @@protoc_insertion_point(builder_implements:object_detection.protos.KeypointEdge)
        object_detection.protos.Eval.KeypointEdgeOrBuilder {
      public static final com.google.protobuf.Descriptors.Descriptor
          getDescriptor() {
        return object_detection.protos.Eval.internal_static_object_detection_protos_KeypointEdge_descriptor;
      }

      @java.lang.Override
      protected com.google.protobuf.GeneratedMessageV3.FieldAccessorTable
          internalGetFieldAccessorTable() {
        return object_detection.protos.Eval.internal_static_object_detection_protos_KeypointEdge_fieldAccessorTable
            .ensureFieldAccessorsInitialized(
                object_detection.protos.Eval.KeypointEdge.class, object_detection.protos.Eval.KeypointEdge.Builder.class);
      }

      // Construct using object_detection.protos.Eval.KeypointEdge.newBuilder()
      private Builder() {
        maybeForceBuilderInitialization();
      }

      private Builder(
          com.google.protobuf.GeneratedMessageV3.BuilderParent parent) {
        super(parent);
        maybeForceBuilderInitialization();
      }
      private void maybeForceBuilderInitialization() {
        if (com.google.protobuf.GeneratedMessageV3
                .alwaysUseFieldBuilders) {
        }
      }
      @java.lang.Override
      public Builder clear() {
        super.clear();
        start_ = 0;
        bitField0_ = (bitField0_ & ~0x00000001);
        end_ = 0;
        bitField0_ = (bitField0_ & ~0x00000002);
        return this;
      }

      @java.lang.Override
      public com.google.protobuf.Descriptors.Descriptor
          getDescriptorForType() {
        return object_detection.protos.Eval.internal_static_object_detection_protos_KeypointEdge_descriptor;
      }

      @java.lang.Override
      public object_detection.protos.Eval.KeypointEdge getDefaultInstanceForType() {
        return object_detection.protos.Eval.KeypointEdge.getDefaultInstance();
      }

      @java.lang.Override
      public object_detection.protos.Eval.KeypointEdge build() {
        object_detection.protos.Eval.KeypointEdge result = buildPartial();
        if (!result.isInitialized()) {
          throw newUninitializedMessageException(result);
        }
        return result;
      }

      @java.lang.Override
      public object_detection.protos.Eval.KeypointEdge buildPartial() {
        object_detection.protos.Eval.KeypointEdge result = new object_detection.protos.Eval.KeypointEdge(this);
        int from_bitField0_ = bitField0_;
        int to_bitField0_ = 0;
        if (((from_bitField0_ & 0x00000001) != 0)) {
          result.start_ = start_;
          to_bitField0_ |= 0x00000001;
        }
        if (((from_bitField0_ & 0x00000002) != 0)) {
          result.end_ = end_;
          to_bitField0_ |= 0x00000002;
        }
        result.bitField0_ = to_bitField0_;
        onBuilt();
        return result;
      }

      @java.lang.Override
      public Builder clone() {
        return super.clone();
      }
      @java.lang.Override
      public Builder setField(
          com.google.protobuf.Descriptors.FieldDescriptor field,
          java.lang.Object value) {
        return super.setField(field, value);
      }
      @java.lang.Override
      public Builder clearField(
          com.google.protobuf.Descriptors.FieldDescriptor field) {
        return super.clearField(field);
      }
      @java.lang.Override
      public Builder clearOneof(
          com.google.protobuf.Descriptors.OneofDescriptor oneof) {
        return super.clearOneof(oneof);
      }
      @java.lang.Override
      public Builder setRepeatedField(
          com.google.protobuf.Descriptors.FieldDescriptor field,
          int index, java.lang.Object value) {
        return super.setRepeatedField(field, index, value);
      }
      @java.lang.Override
      public Builder addRepeatedField(
          com.google.protobuf.Descriptors.FieldDescriptor field,
          java.lang.Object value) {
        return super.addRepeatedField(field, value);
      }
      @java.lang.Override
      public Builder mergeFrom(com.google.protobuf.Message other) {
        if (other instanceof object_detection.protos.Eval.KeypointEdge) {
          return mergeFrom((object_detection.protos.Eval.KeypointEdge)other);
        } else {
          super.mergeFrom(other);
          return this;
        }
      }

      public Builder mergeFrom(object_detection.protos.Eval.KeypointEdge other) {
        if (other == object_detection.protos.Eval.KeypointEdge.getDefaultInstance()) return this;
        if (other.hasStart()) {
          setStart(other.getStart());
        }
        if (other.hasEnd()) {
          setEnd(other.getEnd());
        }
        this.mergeUnknownFields(other.unknownFields);
        onChanged();
        return this;
      }

      @java.lang.Override
      public final boolean isInitialized() {
        return true;
      }

      @java.lang.Override
      public Builder mergeFrom(
          com.google.protobuf.CodedInputStream input,
          com.google.protobuf.ExtensionRegistryLite extensionRegistry)
          throws java.io.IOException {
        object_detection.protos.Eval.KeypointEdge parsedMessage = null;
        try {
          parsedMessage = PARSER.parsePartialFrom(input, extensionRegistry);
        } catch (com.google.protobuf.InvalidProtocolBufferException e) {
          parsedMessage = (object_detection.protos.Eval.KeypointEdge) e.getUnfinishedMessage();
          throw e.unwrapIOException();
        } finally {
          if (parsedMessage != null) {
            mergeFrom(parsedMessage);
          }
        }
        return this;
      }
      private int bitField0_;

      private int start_ ;
      /**
       * <pre>
       * Index of the keypoint where the edge starts from. Index starts at 0.
       * </pre>
       *
       * <code>optional int32 start = 1;</code>
       * @return Whether the start field is set.
       */
      @java.lang.Override
      public boolean hasStart() {
        return ((bitField0_ & 0x00000001) != 0);
      }
      /**
       * <pre>
       * Index of the keypoint where the edge starts from. Index starts at 0.
       * </pre>
       *
       * <code>optional int32 start = 1;</code>
       * @return The start.
       */
      @java.lang.Override
      public int getStart() {
        return start_;
      }
      /**
       * <pre>
       * Index of the keypoint where the edge starts from. Index starts at 0.
       * </pre>
       *
       * <code>optional int32 start = 1;</code>
       * @param value The start to set.
       * @return This builder for chaining.
       */
      public Builder setStart(int value) {
        bitField0_ |= 0x00000001;
        start_ = value;
        onChanged();
        return this;
      }
      /**
       * <pre>
       * Index of the keypoint where the edge starts from. Index starts at 0.
       * </pre>
       *
       * <code>optional int32 start = 1;</code>
       * @return This builder for chaining.
       */
      public Builder clearStart() {
        bitField0_ = (bitField0_ & ~0x00000001);
        start_ = 0;
        onChanged();
        return this;
      }

      private int end_ ;
      /**
       * <pre>
       * Index of the keypoint where the edge ends. Index starts at 0.
       * </pre>
       *
       * <code>optional int32 end = 2;</code>
       * @return Whether the end field is set.
       */
      @java.lang.Override
      public boolean hasEnd() {
        return ((bitField0_ & 0x00000002) != 0);
      }
      /**
       * <pre>
       * Index of the keypoint where the edge ends. Index starts at 0.
       * </pre>
       *
       * <code>optional int32 end = 2;</code>
       * @return The end.
       */
      @java.lang.Override
      public int getEnd() {
        return end_;
      }
      /**
       * <pre>
       * Index of the keypoint where the edge ends. Index starts at 0.
       * </pre>
       *
       * <code>optional int32 end = 2;</code>
       * @param value The end to set.
       * @return This builder for chaining.
       */
      public Builder setEnd(int value) {
        bitField0_ |= 0x00000002;
        end_ = value;
        onChanged();
        return this;
      }
      /**
       * <pre>
       * Index of the keypoint where the edge ends. Index starts at 0.
       * </pre>
       *
       * <code>optional int32 end = 2;</code>
       * @return This builder for chaining.
       */
      public Builder clearEnd() {
        bitField0_ = (bitField0_ & ~0x00000002);
        end_ = 0;
        onChanged();
        return this;
      }
      @java.lang.Override
      public final Builder setUnknownFields(
          final com.google.protobuf.UnknownFieldSet unknownFields) {
        return super.setUnknownFields(unknownFields);
      }

      @java.lang.Override
      public final Builder mergeUnknownFields(
          final com.google.protobuf.UnknownFieldSet unknownFields) {
        return super.mergeUnknownFields(unknownFields);
      }


      // @@protoc_insertion_point(builder_scope:object_detection.protos.KeypointEdge)
    }

    // @@protoc_insertion_point(class_scope:object_detection.protos.KeypointEdge)
    private static final object_detection.protos.Eval.KeypointEdge DEFAULT_INSTANCE;
    static {
      DEFAULT_INSTANCE = new object_detection.protos.Eval.KeypointEdge();
    }

    public static object_detection.protos.Eval.KeypointEdge getDefaultInstance() {
      return DEFAULT_INSTANCE;
    }

    @java.lang.Deprecated public static final com.google.protobuf.Parser<KeypointEdge>
        PARSER = new com.google.protobuf.AbstractParser<KeypointEdge>() {
      @java.lang.Override
      public KeypointEdge parsePartialFrom(
          com.google.protobuf.CodedInputStream input,
          com.google.protobuf.ExtensionRegistryLite extensionRegistry)
          throws com.google.protobuf.InvalidProtocolBufferException {
        return new KeypointEdge(input, extensionRegistry);
      }
    };

    public static com.google.protobuf.Parser<KeypointEdge> parser() {
      return PARSER;
    }

    @java.lang.Override
    public com.google.protobuf.Parser<KeypointEdge> getParserForType() {
      return PARSER;
    }

    @java.lang.Override
    public object_detection.protos.Eval.KeypointEdge getDefaultInstanceForType() {
      return DEFAULT_INSTANCE;
    }

  }

  private static final com.google.protobuf.Descriptors.Descriptor
    internal_static_object_detection_protos_EvalConfig_descriptor;
  private static final
    com.google.protobuf.GeneratedMessageV3.FieldAccessorTable
      internal_static_object_detection_protos_EvalConfig_fieldAccessorTable;
  private static final com.google.protobuf.Descriptors.Descriptor
    internal_static_object_detection_protos_EvalConfig_SuperCategoriesEntry_descriptor;
  private static final
    com.google.protobuf.GeneratedMessageV3.FieldAccessorTable
      internal_static_object_detection_protos_EvalConfig_SuperCategoriesEntry_fieldAccessorTable;
  private static final com.google.protobuf.Descriptors.Descriptor
    internal_static_object_detection_protos_ParameterizedMetric_descriptor;
  private static final
    com.google.protobuf.GeneratedMessageV3.FieldAccessorTable
      internal_static_object_detection_protos_ParameterizedMetric_fieldAccessorTable;
  private static final com.google.protobuf.Descriptors.Descriptor
    internal_static_object_detection_protos_CocoKeypointMetrics_descriptor;
  private static final
    com.google.protobuf.GeneratedMessageV3.FieldAccessorTable
      internal_static_object_detection_protos_CocoKeypointMetrics_fieldAccessorTable;
  private static final com.google.protobuf.Descriptors.Descriptor
    internal_static_object_detection_protos_CocoKeypointMetrics_KeypointLabelToSigmasEntry_descriptor;
  private static final
    com.google.protobuf.GeneratedMessageV3.FieldAccessorTable
      internal_static_object_detection_protos_CocoKeypointMetrics_KeypointLabelToSigmasEntry_fieldAccessorTable;
  private static final com.google.protobuf.Descriptors.Descriptor
    internal_static_object_detection_protos_KeypointEdge_descriptor;
  private static final
    com.google.protobuf.GeneratedMessageV3.FieldAccessorTable
      internal_static_object_detection_protos_KeypointEdge_fieldAccessorTable;

  public static com.google.protobuf.Descriptors.FileDescriptor
      getDescriptor() {
    return descriptor;
  }
  private static  com.google.protobuf.Descriptors.FileDescriptor
      descriptor;
  static {
    java.lang.String[] descriptorData = {
      "\n\"object_detection/protos/eval.proto\022\027ob" +
      "ject_detection.protos\"\252\n\n\nEvalConfig\022\025\n\n" +
      "batch_size\030\031 \001(\r:\0011\022\036\n\022num_visualization" +
      "s\030\001 \001(\r:\00210\022\036\n\014num_examples\030\002 \001(\r:\0045000B" +
      "\002\030\001\022\037\n\022eval_interval_secs\030\003 \001(\r:\003300\022\030\n\t" +
      "max_evals\030\004 \001(\r:\0010B\002\030\001\022\031\n\nsave_graph\030\005 \001" +
      "(\010:\005false\022\"\n\030visualization_export_dir\030\006 " +
      "\001(\t:\000\022\025\n\013eval_master\030\007 \001(\t:\000\022\023\n\013metrics_" +
      "set\030\010 \003(\t\022J\n\024parameterized_metric\030\037 \003(\0132" +
      ",.object_detection.protos.ParameterizedM" +
      "etric\022\025\n\013export_path\030\t \001(\t:\000\022!\n\022ignore_g" +
      "roundtruth\030\n \001(\010:\005false\022\"\n\023use_moving_av" +
      "erages\030\013 \001(\010:\005false\022\"\n\023eval_instance_mas" +
      "ks\030\014 \001(\010:\005false\022 \n\023min_score_threshold\030\r" +
      " \001(\002:\0030.5\022&\n\032max_num_boxes_to_visualize\030" +
      "\016 \001(\005:\00220\022\032\n\013skip_scores\030\017 \001(\010:\005false\022\032\n" +
      "\013skip_labels\030\020 \001(\010:\005false\022*\n\033visualize_g" +
      "roundtruth_boxes\030\021 \001(\010:\005false\0222\n#groundt" +
      "ruth_box_visualization_color\030\022 \001(\t:\005blac" +
      "k\0225\n&keep_image_id_for_visualization_exp" +
      "ort\030\023 \001(\010:\005false\022$\n\026retain_original_imag" +
      "es\030\027 \001(\010:\004true\022+\n\034include_metrics_per_ca" +
      "tegory\030\030 \001(\010:\005false\022\'\n\030all_metrics_per_c" +
      "ategory\030# \001(\010:\005false\022R\n\020super_categories" +
      "\030\" \003(\01328.object_detection.protos.EvalCon" +
      "fig.SuperCategoriesEntry\022\035\n\022recall_lower" +
      "_bound\030\032 \001(\002:\0010\022\035\n\022recall_upper_bound\030\033 " +
      "\001(\002:\0011\0228\n)retain_original_image_addition" +
      "al_channels\030\034 \001(\010:\005false\022\036\n\017force_no_res" +
      "ize\030\035 \001(\010:\005false\022%\n\026use_dummy_loss_in_ev" +
      "al\030\036 \001(\010:\005false\022<\n\rkeypoint_edge\030  \003(\0132%" +
      ".object_detection.protos.KeypointEdge\0223\n" +
      "$skip_predictions_for_unlabeled_class\030! " +
      "\001(\010:\005false\0326\n\024SuperCategoriesEntry\022\013\n\003ke" +
      "y\030\001 \001(\t\022\r\n\005value\030\002 \001(\t:\0028\001\"|\n\023Parameteri" +
      "zedMetric\022M\n\025coco_keypoint_metrics\030\001 \001(\013" +
      "2,.object_detection.protos.CocoKeypointM" +
      "etricsH\000B\026\n\024parameterized_metric\"\323\001\n\023Coc" +
      "oKeypointMetrics\022\023\n\013class_label\030\001 \001(\t\022i\n" +
      "\030keypoint_label_to_sigmas\030\002 \003(\0132G.object" +
      "_detection.protos.CocoKeypointMetrics.Ke" +
      "ypointLabelToSigmasEntry\032<\n\032KeypointLabe" +
      "lToSigmasEntry\022\013\n\003key\030\001 \001(\t\022\r\n\005value\030\002 \001" +
      "(\002:\0028\001\"*\n\014KeypointEdge\022\r\n\005start\030\001 \001(\005\022\013\n" +
      "\003end\030\002 \001(\005"
    };
    descriptor = com.google.protobuf.Descriptors.FileDescriptor
      .internalBuildGeneratedFileFrom(descriptorData,
        new com.google.protobuf.Descriptors.FileDescriptor[] {
        });
    internal_static_object_detection_protos_EvalConfig_descriptor =
      getDescriptor().getMessageTypes().get(0);
    internal_static_object_detection_protos_EvalConfig_fieldAccessorTable = new
      com.google.protobuf.GeneratedMessageV3.FieldAccessorTable(
        internal_static_object_detection_protos_EvalConfig_descriptor,
        new java.lang.String[] { "BatchSize", "NumVisualizations", "NumExamples", "EvalIntervalSecs", "MaxEvals", "SaveGraph", "VisualizationExportDir", "EvalMaster", "MetricsSet", "ParameterizedMetric", "ExportPath", "IgnoreGroundtruth", "UseMovingAverages", "EvalInstanceMasks", "MinScoreThreshold", "MaxNumBoxesToVisualize", "SkipScores", "SkipLabels", "VisualizeGroundtruthBoxes", "GroundtruthBoxVisualizationColor", "KeepImageIdForVisualizationExport", "RetainOriginalImages", "IncludeMetricsPerCategory", "AllMetricsPerCategory", "SuperCategories", "RecallLowerBound", "RecallUpperBound", "RetainOriginalImageAdditionalChannels", "ForceNoResize", "UseDummyLossInEval", "KeypointEdge", "SkipPredictionsForUnlabeledClass", });
    internal_static_object_detection_protos_EvalConfig_SuperCategoriesEntry_descriptor =
      internal_static_object_detection_protos_EvalConfig_descriptor.getNestedTypes().get(0);
    internal_static_object_detection_protos_EvalConfig_SuperCategoriesEntry_fieldAccessorTable = new
      com.google.protobuf.GeneratedMessageV3.FieldAccessorTable(
        internal_static_object_detection_protos_EvalConfig_SuperCategoriesEntry_descriptor,
        new java.lang.String[] { "Key", "Value", });
    internal_static_object_detection_protos_ParameterizedMetric_descriptor =
      getDescriptor().getMessageTypes().get(1);
    internal_static_object_detection_protos_ParameterizedMetric_fieldAccessorTable = new
      com.google.protobuf.GeneratedMessageV3.FieldAccessorTable(
        internal_static_object_detection_protos_ParameterizedMetric_descriptor,
        new java.lang.String[] { "CocoKeypointMetrics", "ParameterizedMetric", });
    internal_static_object_detection_protos_CocoKeypointMetrics_descriptor =
      getDescriptor().getMessageTypes().get(2);
    internal_static_object_detection_protos_CocoKeypointMetrics_fieldAccessorTable = new
      com.google.protobuf.GeneratedMessageV3.FieldAccessorTable(
        internal_static_object_detection_protos_CocoKeypointMetrics_descriptor,
        new java.lang.String[] { "ClassLabel", "KeypointLabelToSigmas", });
    internal_static_object_detection_protos_CocoKeypointMetrics_KeypointLabelToSigmasEntry_descriptor =
      internal_static_object_detection_protos_CocoKeypointMetrics_descriptor.getNestedTypes().get(0);
    internal_static_object_detection_protos_CocoKeypointMetrics_KeypointLabelToSigmasEntry_fieldAccessorTable = new
      com.google.protobuf.GeneratedMessageV3.FieldAccessorTable(
        internal_static_object_detection_protos_CocoKeypointMetrics_KeypointLabelToSigmasEntry_descriptor,
        new java.lang.String[] { "Key", "Value", });
    internal_static_object_detection_protos_KeypointEdge_descriptor =
      getDescriptor().getMessageTypes().get(3);
    internal_static_object_detection_protos_KeypointEdge_fieldAccessorTable = new
      com.google.protobuf.GeneratedMessageV3.FieldAccessorTable(
        internal_static_object_detection_protos_KeypointEdge_descriptor,
        new java.lang.String[] { "Start", "End", });
  }

  // @@protoc_insertion_point(outer_class_scope)
}
