/*
 * Copyright (c) 2020. Kin-Hong Wong. All Rights Reserved.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

// Generated by the protocol buffer compiler.  DO NOT EDIT!
// source: object_detection/protos/faster_rcnn.proto

package object_detection.protos;

public final class FasterRcnnOuterClass {
  private FasterRcnnOuterClass() {}
  public static void registerAllExtensions(
      com.google.protobuf.ExtensionRegistryLite registry) {
  }

  public static void registerAllExtensions(
      com.google.protobuf.ExtensionRegistry registry) {
    registerAllExtensions(
        (com.google.protobuf.ExtensionRegistryLite) registry);
  }
  /**
   * <pre>
   * Input type format: whether inputs are TfExamples or TfSequenceExamples.
   * </pre>
   *
   * Protobuf enum {@code object_detection.protos.AttentionPosition}
   */
  public enum AttentionPosition
      implements com.google.protobuf.ProtocolMessageEnum {
    /**
     * <pre>
     * Default, currently post box classifier
     * </pre>
     *
     * <code>ATTENTION_DEFAULT = 0;</code>
     */
    ATTENTION_DEFAULT(0),
    /**
     * <pre>
     * Post box classifier
     * </pre>
     *
     * <code>POST_BOX_CLASSIFIER = 1;</code>
     */
    POST_BOX_CLASSIFIER(1),
    /**
     * <pre>
     * Post RPN, pre box classifier
     * </pre>
     *
     * <code>POST_RPN = 2;</code>
     */
    POST_RPN(2),
    ;

    /**
     * <pre>
     * Default, currently post box classifier
     * </pre>
     *
     * <code>ATTENTION_DEFAULT = 0;</code>
     */
    public static final int ATTENTION_DEFAULT_VALUE = 0;
    /**
     * <pre>
     * Post box classifier
     * </pre>
     *
     * <code>POST_BOX_CLASSIFIER = 1;</code>
     */
    public static final int POST_BOX_CLASSIFIER_VALUE = 1;
    /**
     * <pre>
     * Post RPN, pre box classifier
     * </pre>
     *
     * <code>POST_RPN = 2;</code>
     */
    public static final int POST_RPN_VALUE = 2;


    public final int getNumber() {
      return value;
    }

    /**
     * @param value The numeric wire value of the corresponding enum entry.
     * @return The enum associated with the given numeric wire value.
     * @deprecated Use {@link #forNumber(int)} instead.
     */
    @java.lang.Deprecated
    public static AttentionPosition valueOf(int value) {
      return forNumber(value);
    }

    /**
     * @param value The numeric wire value of the corresponding enum entry.
     * @return The enum associated with the given numeric wire value.
     */
    public static AttentionPosition forNumber(int value) {
      switch (value) {
        case 0: return ATTENTION_DEFAULT;
        case 1: return POST_BOX_CLASSIFIER;
        case 2: return POST_RPN;
        default: return null;
      }
    }

    public static com.google.protobuf.Internal.EnumLiteMap<AttentionPosition>
        internalGetValueMap() {
      return internalValueMap;
    }
    private static final com.google.protobuf.Internal.EnumLiteMap<
        AttentionPosition> internalValueMap =
          new com.google.protobuf.Internal.EnumLiteMap<AttentionPosition>() {
            public AttentionPosition findValueByNumber(int number) {
              return AttentionPosition.forNumber(number);
            }
          };

    public final com.google.protobuf.Descriptors.EnumValueDescriptor
        getValueDescriptor() {
      return getDescriptor().getValues().get(ordinal());
    }
    public final com.google.protobuf.Descriptors.EnumDescriptor
        getDescriptorForType() {
      return getDescriptor();
    }
    public static final com.google.protobuf.Descriptors.EnumDescriptor
        getDescriptor() {
      return object_detection.protos.FasterRcnnOuterClass.getDescriptor().getEnumTypes().get(0);
    }

    private static final AttentionPosition[] VALUES = values();

    public static AttentionPosition valueOf(
        com.google.protobuf.Descriptors.EnumValueDescriptor desc) {
      if (desc.getType() != getDescriptor()) {
        throw new java.lang.IllegalArgumentException(
          "EnumValueDescriptor is not for this type.");
      }
      return VALUES[desc.getIndex()];
    }

    private final int value;

    private AttentionPosition(int value) {
      this.value = value;
    }

    // @@protoc_insertion_point(enum_scope:object_detection.protos.AttentionPosition)
  }

  public interface FasterRcnnOrBuilder extends
      // @@protoc_insertion_point(interface_extends:object_detection.protos.FasterRcnn)
      com.google.protobuf.MessageOrBuilder {

    /**
     * <pre>
     * Whether to construct only the Region Proposal Network (RPN).
     * </pre>
     *
     * <code>optional int32 number_of_stages = 1 [default = 2];</code>
     * @return Whether the numberOfStages field is set.
     */
    boolean hasNumberOfStages();
    /**
     * <pre>
     * Whether to construct only the Region Proposal Network (RPN).
     * </pre>
     *
     * <code>optional int32 number_of_stages = 1 [default = 2];</code>
     * @return The numberOfStages.
     */
    int getNumberOfStages();

    /**
     * <pre>
     * Number of classes to predict.
     * </pre>
     *
     * <code>optional int32 num_classes = 3;</code>
     * @return Whether the numClasses field is set.
     */
    boolean hasNumClasses();
    /**
     * <pre>
     * Number of classes to predict.
     * </pre>
     *
     * <code>optional int32 num_classes = 3;</code>
     * @return The numClasses.
     */
    int getNumClasses();

    /**
     * <pre>
     * Image resizer for preprocessing the input image.
     * </pre>
     *
     * <code>optional .object_detection.protos.ImageResizer image_resizer = 4;</code>
     * @return Whether the imageResizer field is set.
     */
    boolean hasImageResizer();
    /**
     * <pre>
     * Image resizer for preprocessing the input image.
     * </pre>
     *
     * <code>optional .object_detection.protos.ImageResizer image_resizer = 4;</code>
     * @return The imageResizer.
     */
    object_detection.protos.ImageResizerOuterClass.ImageResizer getImageResizer();
    /**
     * <pre>
     * Image resizer for preprocessing the input image.
     * </pre>
     *
     * <code>optional .object_detection.protos.ImageResizer image_resizer = 4;</code>
     */
    object_detection.protos.ImageResizerOuterClass.ImageResizerOrBuilder getImageResizerOrBuilder();

    /**
     * <pre>
     * Feature extractor config.
     * </pre>
     *
     * <code>optional .object_detection.protos.FasterRcnnFeatureExtractor feature_extractor = 5;</code>
     * @return Whether the featureExtractor field is set.
     */
    boolean hasFeatureExtractor();
    /**
     * <pre>
     * Feature extractor config.
     * </pre>
     *
     * <code>optional .object_detection.protos.FasterRcnnFeatureExtractor feature_extractor = 5;</code>
     * @return The featureExtractor.
     */
    object_detection.protos.FasterRcnnOuterClass.FasterRcnnFeatureExtractor getFeatureExtractor();
    /**
     * <pre>
     * Feature extractor config.
     * </pre>
     *
     * <code>optional .object_detection.protos.FasterRcnnFeatureExtractor feature_extractor = 5;</code>
     */
    object_detection.protos.FasterRcnnOuterClass.FasterRcnnFeatureExtractorOrBuilder getFeatureExtractorOrBuilder();

    /**
     * <pre>
     * Anchor generator to compute RPN anchors.
     * </pre>
     *
     * <code>optional .object_detection.protos.AnchorGenerator first_stage_anchor_generator = 6;</code>
     * @return Whether the firstStageAnchorGenerator field is set.
     */
    boolean hasFirstStageAnchorGenerator();
    /**
     * <pre>
     * Anchor generator to compute RPN anchors.
     * </pre>
     *
     * <code>optional .object_detection.protos.AnchorGenerator first_stage_anchor_generator = 6;</code>
     * @return The firstStageAnchorGenerator.
     */
    object_detection.protos.AnchorGeneratorOuterClass.AnchorGenerator getFirstStageAnchorGenerator();
    /**
     * <pre>
     * Anchor generator to compute RPN anchors.
     * </pre>
     *
     * <code>optional .object_detection.protos.AnchorGenerator first_stage_anchor_generator = 6;</code>
     */
    object_detection.protos.AnchorGeneratorOuterClass.AnchorGeneratorOrBuilder getFirstStageAnchorGeneratorOrBuilder();

    /**
     * <pre>
     * Atrous rate for the convolution op applied to the
     * `first_stage_features_to_crop` tensor to obtain box predictions.
     * </pre>
     *
     * <code>optional int32 first_stage_atrous_rate = 7 [default = 1];</code>
     * @return Whether the firstStageAtrousRate field is set.
     */
    boolean hasFirstStageAtrousRate();
    /**
     * <pre>
     * Atrous rate for the convolution op applied to the
     * `first_stage_features_to_crop` tensor to obtain box predictions.
     * </pre>
     *
     * <code>optional int32 first_stage_atrous_rate = 7 [default = 1];</code>
     * @return The firstStageAtrousRate.
     */
    int getFirstStageAtrousRate();

    /**
     * <pre>
     * Hyperparameters for the convolutional RPN box predictor.
     * </pre>
     *
     * <code>optional .object_detection.protos.Hyperparams first_stage_box_predictor_conv_hyperparams = 8;</code>
     * @return Whether the firstStageBoxPredictorConvHyperparams field is set.
     */
    boolean hasFirstStageBoxPredictorConvHyperparams();
    /**
     * <pre>
     * Hyperparameters for the convolutional RPN box predictor.
     * </pre>
     *
     * <code>optional .object_detection.protos.Hyperparams first_stage_box_predictor_conv_hyperparams = 8;</code>
     * @return The firstStageBoxPredictorConvHyperparams.
     */
    object_detection.protos.HyperparamsOuterClass.Hyperparams getFirstStageBoxPredictorConvHyperparams();
    /**
     * <pre>
     * Hyperparameters for the convolutional RPN box predictor.
     * </pre>
     *
     * <code>optional .object_detection.protos.Hyperparams first_stage_box_predictor_conv_hyperparams = 8;</code>
     */
    object_detection.protos.HyperparamsOuterClass.HyperparamsOrBuilder getFirstStageBoxPredictorConvHyperparamsOrBuilder();

    /**
     * <pre>
     * Kernel size to use for the convolution op just prior to RPN box
     * predictions.
     * </pre>
     *
     * <code>optional int32 first_stage_box_predictor_kernel_size = 9 [default = 3];</code>
     * @return Whether the firstStageBoxPredictorKernelSize field is set.
     */
    boolean hasFirstStageBoxPredictorKernelSize();
    /**
     * <pre>
     * Kernel size to use for the convolution op just prior to RPN box
     * predictions.
     * </pre>
     *
     * <code>optional int32 first_stage_box_predictor_kernel_size = 9 [default = 3];</code>
     * @return The firstStageBoxPredictorKernelSize.
     */
    int getFirstStageBoxPredictorKernelSize();

    /**
     * <pre>
     * Output depth for the convolution op just prior to RPN box predictions.
     * </pre>
     *
     * <code>optional int32 first_stage_box_predictor_depth = 10 [default = 512];</code>
     * @return Whether the firstStageBoxPredictorDepth field is set.
     */
    boolean hasFirstStageBoxPredictorDepth();
    /**
     * <pre>
     * Output depth for the convolution op just prior to RPN box predictions.
     * </pre>
     *
     * <code>optional int32 first_stage_box_predictor_depth = 10 [default = 512];</code>
     * @return The firstStageBoxPredictorDepth.
     */
    int getFirstStageBoxPredictorDepth();

    /**
     * <pre>
     * The batch size to use for computing the first stage objectness and
     * location losses.
     * </pre>
     *
     * <code>optional int32 first_stage_minibatch_size = 11 [default = 256];</code>
     * @return Whether the firstStageMinibatchSize field is set.
     */
    boolean hasFirstStageMinibatchSize();
    /**
     * <pre>
     * The batch size to use for computing the first stage objectness and
     * location losses.
     * </pre>
     *
     * <code>optional int32 first_stage_minibatch_size = 11 [default = 256];</code>
     * @return The firstStageMinibatchSize.
     */
    int getFirstStageMinibatchSize();

    /**
     * <pre>
     * Fraction of positive examples per image for the RPN.
     * </pre>
     *
     * <code>optional float first_stage_positive_balance_fraction = 12 [default = 0.5];</code>
     * @return Whether the firstStagePositiveBalanceFraction field is set.
     */
    boolean hasFirstStagePositiveBalanceFraction();
    /**
     * <pre>
     * Fraction of positive examples per image for the RPN.
     * </pre>
     *
     * <code>optional float first_stage_positive_balance_fraction = 12 [default = 0.5];</code>
     * @return The firstStagePositiveBalanceFraction.
     */
    float getFirstStagePositiveBalanceFraction();

    /**
     * <pre>
     * Non max suppression score threshold applied to first stage RPN proposals.
     * </pre>
     *
     * <code>optional float first_stage_nms_score_threshold = 13 [default = 0];</code>
     * @return Whether the firstStageNmsScoreThreshold field is set.
     */
    boolean hasFirstStageNmsScoreThreshold();
    /**
     * <pre>
     * Non max suppression score threshold applied to first stage RPN proposals.
     * </pre>
     *
     * <code>optional float first_stage_nms_score_threshold = 13 [default = 0];</code>
     * @return The firstStageNmsScoreThreshold.
     */
    float getFirstStageNmsScoreThreshold();

    /**
     * <pre>
     * Non max suppression IOU threshold applied to first stage RPN proposals.
     * </pre>
     *
     * <code>optional float first_stage_nms_iou_threshold = 14 [default = 0.7];</code>
     * @return Whether the firstStageNmsIouThreshold field is set.
     */
    boolean hasFirstStageNmsIouThreshold();
    /**
     * <pre>
     * Non max suppression IOU threshold applied to first stage RPN proposals.
     * </pre>
     *
     * <code>optional float first_stage_nms_iou_threshold = 14 [default = 0.7];</code>
     * @return The firstStageNmsIouThreshold.
     */
    float getFirstStageNmsIouThreshold();

    /**
     * <pre>
     * Maximum number of RPN proposals retained after first stage postprocessing.
     * </pre>
     *
     * <code>optional int32 first_stage_max_proposals = 15 [default = 300];</code>
     * @return Whether the firstStageMaxProposals field is set.
     */
    boolean hasFirstStageMaxProposals();
    /**
     * <pre>
     * Maximum number of RPN proposals retained after first stage postprocessing.
     * </pre>
     *
     * <code>optional int32 first_stage_max_proposals = 15 [default = 300];</code>
     * @return The firstStageMaxProposals.
     */
    int getFirstStageMaxProposals();

    /**
     * <pre>
     * First stage RPN localization loss weight.
     * </pre>
     *
     * <code>optional float first_stage_localization_loss_weight = 16 [default = 1];</code>
     * @return Whether the firstStageLocalizationLossWeight field is set.
     */
    boolean hasFirstStageLocalizationLossWeight();
    /**
     * <pre>
     * First stage RPN localization loss weight.
     * </pre>
     *
     * <code>optional float first_stage_localization_loss_weight = 16 [default = 1];</code>
     * @return The firstStageLocalizationLossWeight.
     */
    float getFirstStageLocalizationLossWeight();

    /**
     * <pre>
     * First stage RPN objectness loss weight.
     * </pre>
     *
     * <code>optional float first_stage_objectness_loss_weight = 17 [default = 1];</code>
     * @return Whether the firstStageObjectnessLossWeight field is set.
     */
    boolean hasFirstStageObjectnessLossWeight();
    /**
     * <pre>
     * First stage RPN objectness loss weight.
     * </pre>
     *
     * <code>optional float first_stage_objectness_loss_weight = 17 [default = 1];</code>
     * @return The firstStageObjectnessLossWeight.
     */
    float getFirstStageObjectnessLossWeight();

    /**
     * <pre>
     * Output size (width and height are set to be the same) of the initial
     * bilinear interpolation based cropping during ROI pooling.
     * </pre>
     *
     * <code>optional int32 initial_crop_size = 18;</code>
     * @return Whether the initialCropSize field is set.
     */
    boolean hasInitialCropSize();
    /**
     * <pre>
     * Output size (width and height are set to be the same) of the initial
     * bilinear interpolation based cropping during ROI pooling.
     * </pre>
     *
     * <code>optional int32 initial_crop_size = 18;</code>
     * @return The initialCropSize.
     */
    int getInitialCropSize();

    /**
     * <pre>
     * Kernel size of the max pool op on the cropped feature map during
     * ROI pooling.
     * </pre>
     *
     * <code>optional int32 maxpool_kernel_size = 19;</code>
     * @return Whether the maxpoolKernelSize field is set.
     */
    boolean hasMaxpoolKernelSize();
    /**
     * <pre>
     * Kernel size of the max pool op on the cropped feature map during
     * ROI pooling.
     * </pre>
     *
     * <code>optional int32 maxpool_kernel_size = 19;</code>
     * @return The maxpoolKernelSize.
     */
    int getMaxpoolKernelSize();

    /**
     * <pre>
     * Stride of the max pool op on the cropped feature map during ROI pooling.
     * </pre>
     *
     * <code>optional int32 maxpool_stride = 20;</code>
     * @return Whether the maxpoolStride field is set.
     */
    boolean hasMaxpoolStride();
    /**
     * <pre>
     * Stride of the max pool op on the cropped feature map during ROI pooling.
     * </pre>
     *
     * <code>optional int32 maxpool_stride = 20;</code>
     * @return The maxpoolStride.
     */
    int getMaxpoolStride();

    /**
     * <pre>
     * Hyperparameters for the second stage box predictor. If box predictor type
     * is set to rfcn_box_predictor, a R-FCN model is constructed, otherwise a
     * Faster R-CNN model is constructed.
     * </pre>
     *
     * <code>optional .object_detection.protos.BoxPredictor second_stage_box_predictor = 21;</code>
     * @return Whether the secondStageBoxPredictor field is set.
     */
    boolean hasSecondStageBoxPredictor();
    /**
     * <pre>
     * Hyperparameters for the second stage box predictor. If box predictor type
     * is set to rfcn_box_predictor, a R-FCN model is constructed, otherwise a
     * Faster R-CNN model is constructed.
     * </pre>
     *
     * <code>optional .object_detection.protos.BoxPredictor second_stage_box_predictor = 21;</code>
     * @return The secondStageBoxPredictor.
     */
    object_detection.protos.BoxPredictorOuterClass.BoxPredictor getSecondStageBoxPredictor();
    /**
     * <pre>
     * Hyperparameters for the second stage box predictor. If box predictor type
     * is set to rfcn_box_predictor, a R-FCN model is constructed, otherwise a
     * Faster R-CNN model is constructed.
     * </pre>
     *
     * <code>optional .object_detection.protos.BoxPredictor second_stage_box_predictor = 21;</code>
     */
    object_detection.protos.BoxPredictorOuterClass.BoxPredictorOrBuilder getSecondStageBoxPredictorOrBuilder();

    /**
     * <pre>
     * The batch size per image used for computing the classification and refined
     * location loss of the box classifier.
     * Note that this field is ignored if `hard_example_miner` is configured.
     * </pre>
     *
     * <code>optional int32 second_stage_batch_size = 22 [default = 64];</code>
     * @return Whether the secondStageBatchSize field is set.
     */
    boolean hasSecondStageBatchSize();
    /**
     * <pre>
     * The batch size per image used for computing the classification and refined
     * location loss of the box classifier.
     * Note that this field is ignored if `hard_example_miner` is configured.
     * </pre>
     *
     * <code>optional int32 second_stage_batch_size = 22 [default = 64];</code>
     * @return The secondStageBatchSize.
     */
    int getSecondStageBatchSize();

    /**
     * <pre>
     * Fraction of positive examples to use per image for the box classifier.
     * </pre>
     *
     * <code>optional float second_stage_balance_fraction = 23 [default = 0.25];</code>
     * @return Whether the secondStageBalanceFraction field is set.
     */
    boolean hasSecondStageBalanceFraction();
    /**
     * <pre>
     * Fraction of positive examples to use per image for the box classifier.
     * </pre>
     *
     * <code>optional float second_stage_balance_fraction = 23 [default = 0.25];</code>
     * @return The secondStageBalanceFraction.
     */
    float getSecondStageBalanceFraction();

    /**
     * <pre>
     * Post processing to apply on the second stage box classifier predictions.
     * Note: the `score_converter` provided to the FasterRCNNMetaArch constructor
     * is taken from this `second_stage_post_processing` proto.
     * </pre>
     *
     * <code>optional .object_detection.protos.PostProcessing second_stage_post_processing = 24;</code>
     * @return Whether the secondStagePostProcessing field is set.
     */
    boolean hasSecondStagePostProcessing();
    /**
     * <pre>
     * Post processing to apply on the second stage box classifier predictions.
     * Note: the `score_converter` provided to the FasterRCNNMetaArch constructor
     * is taken from this `second_stage_post_processing` proto.
     * </pre>
     *
     * <code>optional .object_detection.protos.PostProcessing second_stage_post_processing = 24;</code>
     * @return The secondStagePostProcessing.
     */
    object_detection.protos.PostProcessingOuterClass.PostProcessing getSecondStagePostProcessing();
    /**
     * <pre>
     * Post processing to apply on the second stage box classifier predictions.
     * Note: the `score_converter` provided to the FasterRCNNMetaArch constructor
     * is taken from this `second_stage_post_processing` proto.
     * </pre>
     *
     * <code>optional .object_detection.protos.PostProcessing second_stage_post_processing = 24;</code>
     */
    object_detection.protos.PostProcessingOuterClass.PostProcessingOrBuilder getSecondStagePostProcessingOrBuilder();

    /**
     * <pre>
     * Second stage refined localization loss weight.
     * </pre>
     *
     * <code>optional float second_stage_localization_loss_weight = 25 [default = 1];</code>
     * @return Whether the secondStageLocalizationLossWeight field is set.
     */
    boolean hasSecondStageLocalizationLossWeight();
    /**
     * <pre>
     * Second stage refined localization loss weight.
     * </pre>
     *
     * <code>optional float second_stage_localization_loss_weight = 25 [default = 1];</code>
     * @return The secondStageLocalizationLossWeight.
     */
    float getSecondStageLocalizationLossWeight();

    /**
     * <pre>
     * Second stage classification loss weight
     * </pre>
     *
     * <code>optional float second_stage_classification_loss_weight = 26 [default = 1];</code>
     * @return Whether the secondStageClassificationLossWeight field is set.
     */
    boolean hasSecondStageClassificationLossWeight();
    /**
     * <pre>
     * Second stage classification loss weight
     * </pre>
     *
     * <code>optional float second_stage_classification_loss_weight = 26 [default = 1];</code>
     * @return The secondStageClassificationLossWeight.
     */
    float getSecondStageClassificationLossWeight();

    /**
     * <pre>
     * Second stage instance mask loss weight. Note that this is only applicable
     * when `MaskRCNNBoxPredictor` is selected for second stage and configured to
     * predict instance masks.
     * </pre>
     *
     * <code>optional float second_stage_mask_prediction_loss_weight = 27 [default = 1];</code>
     * @return Whether the secondStageMaskPredictionLossWeight field is set.
     */
    boolean hasSecondStageMaskPredictionLossWeight();
    /**
     * <pre>
     * Second stage instance mask loss weight. Note that this is only applicable
     * when `MaskRCNNBoxPredictor` is selected for second stage and configured to
     * predict instance masks.
     * </pre>
     *
     * <code>optional float second_stage_mask_prediction_loss_weight = 27 [default = 1];</code>
     * @return The secondStageMaskPredictionLossWeight.
     */
    float getSecondStageMaskPredictionLossWeight();

    /**
     * <pre>
     * If not left to default, applies hard example mining only to classification
     * and localization loss..
     * </pre>
     *
     * <code>optional .object_detection.protos.HardExampleMiner hard_example_miner = 28;</code>
     * @return Whether the hardExampleMiner field is set.
     */
    boolean hasHardExampleMiner();
    /**
     * <pre>
     * If not left to default, applies hard example mining only to classification
     * and localization loss..
     * </pre>
     *
     * <code>optional .object_detection.protos.HardExampleMiner hard_example_miner = 28;</code>
     * @return The hardExampleMiner.
     */
    object_detection.protos.Losses.HardExampleMiner getHardExampleMiner();
    /**
     * <pre>
     * If not left to default, applies hard example mining only to classification
     * and localization loss..
     * </pre>
     *
     * <code>optional .object_detection.protos.HardExampleMiner hard_example_miner = 28;</code>
     */
    object_detection.protos.Losses.HardExampleMinerOrBuilder getHardExampleMinerOrBuilder();

    /**
     * <pre>
     * Loss for second stage box classifers, supports Softmax and Sigmoid.
     * Note that score converter must be consistent with loss type.
     * When there are multiple labels assigned to the same boxes, recommend
     * to use sigmoid loss and enable merge_multiple_label_boxes.
     * If not specified, Softmax loss is used as default.
     * </pre>
     *
     * <code>optional .object_detection.protos.ClassificationLoss second_stage_classification_loss = 29;</code>
     * @return Whether the secondStageClassificationLoss field is set.
     */
    boolean hasSecondStageClassificationLoss();
    /**
     * <pre>
     * Loss for second stage box classifers, supports Softmax and Sigmoid.
     * Note that score converter must be consistent with loss type.
     * When there are multiple labels assigned to the same boxes, recommend
     * to use sigmoid loss and enable merge_multiple_label_boxes.
     * If not specified, Softmax loss is used as default.
     * </pre>
     *
     * <code>optional .object_detection.protos.ClassificationLoss second_stage_classification_loss = 29;</code>
     * @return The secondStageClassificationLoss.
     */
    object_detection.protos.Losses.ClassificationLoss getSecondStageClassificationLoss();
    /**
     * <pre>
     * Loss for second stage box classifers, supports Softmax and Sigmoid.
     * Note that score converter must be consistent with loss type.
     * When there are multiple labels assigned to the same boxes, recommend
     * to use sigmoid loss and enable merge_multiple_label_boxes.
     * If not specified, Softmax loss is used as default.
     * </pre>
     *
     * <code>optional .object_detection.protos.ClassificationLoss second_stage_classification_loss = 29;</code>
     */
    object_detection.protos.Losses.ClassificationLossOrBuilder getSecondStageClassificationLossOrBuilder();

    /**
     * <pre>
     * Whether to update batch_norm inplace during training. This is required
     * for batch norm to work correctly on TPUs. When this is false, user must add
     * a control dependency on tf.GraphKeys.UPDATE_OPS for train/loss op in order
     * to update the batch norm moving average parameters.
     * </pre>
     *
     * <code>optional bool inplace_batchnorm_update = 30 [default = false];</code>
     * @return Whether the inplaceBatchnormUpdate field is set.
     */
    boolean hasInplaceBatchnormUpdate();
    /**
     * <pre>
     * Whether to update batch_norm inplace during training. This is required
     * for batch norm to work correctly on TPUs. When this is false, user must add
     * a control dependency on tf.GraphKeys.UPDATE_OPS for train/loss op in order
     * to update the batch norm moving average parameters.
     * </pre>
     *
     * <code>optional bool inplace_batchnorm_update = 30 [default = false];</code>
     * @return The inplaceBatchnormUpdate.
     */
    boolean getInplaceBatchnormUpdate();

    /**
     * <pre>
     * Force the use of matrix multiplication based crop and resize instead of
     * standard tf.image.crop_and_resize while computing second stage input
     * feature maps.
     * </pre>
     *
     * <code>optional bool use_matmul_crop_and_resize = 31 [default = false];</code>
     * @return Whether the useMatmulCropAndResize field is set.
     */
    boolean hasUseMatmulCropAndResize();
    /**
     * <pre>
     * Force the use of matrix multiplication based crop and resize instead of
     * standard tf.image.crop_and_resize while computing second stage input
     * feature maps.
     * </pre>
     *
     * <code>optional bool use_matmul_crop_and_resize = 31 [default = false];</code>
     * @return The useMatmulCropAndResize.
     */
    boolean getUseMatmulCropAndResize();

    /**
     * <pre>
     * Normally, anchors generated for a given image size are pruned during
     * training if they lie outside the image window. Setting this option to true,
     * clips the anchors to be within the image instead of pruning.
     * </pre>
     *
     * <code>optional bool clip_anchors_to_image = 32 [default = false];</code>
     * @return Whether the clipAnchorsToImage field is set.
     */
    boolean hasClipAnchorsToImage();
    /**
     * <pre>
     * Normally, anchors generated for a given image size are pruned during
     * training if they lie outside the image window. Setting this option to true,
     * clips the anchors to be within the image instead of pruning.
     * </pre>
     *
     * <code>optional bool clip_anchors_to_image = 32 [default = false];</code>
     * @return The clipAnchorsToImage.
     */
    boolean getClipAnchorsToImage();

    /**
     * <pre>
     * After peforming matching between anchors and targets, in order to pull out
     * targets for training Faster R-CNN meta architecture we perform a gather
     * operation. This options specifies whether to use an alternate
     * implementation of tf.gather that is faster on TPUs.
     * </pre>
     *
     * <code>optional bool use_matmul_gather_in_matcher = 33 [default = false];</code>
     * @return Whether the useMatmulGatherInMatcher field is set.
     */
    boolean hasUseMatmulGatherInMatcher();
    /**
     * <pre>
     * After peforming matching between anchors and targets, in order to pull out
     * targets for training Faster R-CNN meta architecture we perform a gather
     * operation. This options specifies whether to use an alternate
     * implementation of tf.gather that is faster on TPUs.
     * </pre>
     *
     * <code>optional bool use_matmul_gather_in_matcher = 33 [default = false];</code>
     * @return The useMatmulGatherInMatcher.
     */
    boolean getUseMatmulGatherInMatcher();

    /**
     * <pre>
     * Whether to use the balanced positive negative sampler implementation with
     * static shape guarantees.
     * </pre>
     *
     * <code>optional bool use_static_balanced_label_sampler = 34 [default = false];</code>
     * @return Whether the useStaticBalancedLabelSampler field is set.
     */
    boolean hasUseStaticBalancedLabelSampler();
    /**
     * <pre>
     * Whether to use the balanced positive negative sampler implementation with
     * static shape guarantees.
     * </pre>
     *
     * <code>optional bool use_static_balanced_label_sampler = 34 [default = false];</code>
     * @return The useStaticBalancedLabelSampler.
     */
    boolean getUseStaticBalancedLabelSampler();

    /**
     * <pre>
     * If True, uses implementation of ops with static shape guarantees.
     * </pre>
     *
     * <code>optional bool use_static_shapes = 35 [default = false];</code>
     * @return Whether the useStaticShapes field is set.
     */
    boolean hasUseStaticShapes();
    /**
     * <pre>
     * If True, uses implementation of ops with static shape guarantees.
     * </pre>
     *
     * <code>optional bool use_static_shapes = 35 [default = false];</code>
     * @return The useStaticShapes.
     */
    boolean getUseStaticShapes();

    /**
     * <pre>
     * Whether the masks present in groundtruth should be resized in the model to
     * match the image size.
     * </pre>
     *
     * <code>optional bool resize_masks = 36 [default = true];</code>
     * @return Whether the resizeMasks field is set.
     */
    boolean hasResizeMasks();
    /**
     * <pre>
     * Whether the masks present in groundtruth should be resized in the model to
     * match the image size.
     * </pre>
     *
     * <code>optional bool resize_masks = 36 [default = true];</code>
     * @return The resizeMasks.
     */
    boolean getResizeMasks();

    /**
     * <pre>
     * If True, uses implementation of ops with static shape guarantees when
     * running evaluation (specifically not is_training if False).
     * </pre>
     *
     * <code>optional bool use_static_shapes_for_eval = 37 [default = false];</code>
     * @return Whether the useStaticShapesForEval field is set.
     */
    boolean hasUseStaticShapesForEval();
    /**
     * <pre>
     * If True, uses implementation of ops with static shape guarantees when
     * running evaluation (specifically not is_training if False).
     * </pre>
     *
     * <code>optional bool use_static_shapes_for_eval = 37 [default = false];</code>
     * @return The useStaticShapesForEval.
     */
    boolean getUseStaticShapesForEval();

    /**
     * <pre>
     * If true, uses implementation of partitioned_non_max_suppression in first
     * stage.
     * </pre>
     *
     * <code>optional bool use_partitioned_nms_in_first_stage = 38 [default = true];</code>
     * @return Whether the usePartitionedNmsInFirstStage field is set.
     */
    boolean hasUsePartitionedNmsInFirstStage();
    /**
     * <pre>
     * If true, uses implementation of partitioned_non_max_suppression in first
     * stage.
     * </pre>
     *
     * <code>optional bool use_partitioned_nms_in_first_stage = 38 [default = true];</code>
     * @return The usePartitionedNmsInFirstStage.
     */
    boolean getUsePartitionedNmsInFirstStage();

    /**
     * <pre>
     * Whether to return raw detections (pre NMS).
     * </pre>
     *
     * <code>optional bool return_raw_detections_during_predict = 39 [default = false];</code>
     * @return Whether the returnRawDetectionsDuringPredict field is set.
     */
    boolean hasReturnRawDetectionsDuringPredict();
    /**
     * <pre>
     * Whether to return raw detections (pre NMS).
     * </pre>
     *
     * <code>optional bool return_raw_detections_during_predict = 39 [default = false];</code>
     * @return The returnRawDetectionsDuringPredict.
     */
    boolean getReturnRawDetectionsDuringPredict();

    /**
     * <pre>
     * Whether to use tf.image.combined_non_max_suppression.
     * </pre>
     *
     * <code>optional bool use_combined_nms_in_first_stage = 40 [default = false];</code>
     * @return Whether the useCombinedNmsInFirstStage field is set.
     */
    boolean hasUseCombinedNmsInFirstStage();
    /**
     * <pre>
     * Whether to use tf.image.combined_non_max_suppression.
     * </pre>
     *
     * <code>optional bool use_combined_nms_in_first_stage = 40 [default = false];</code>
     * @return The useCombinedNmsInFirstStage.
     */
    boolean getUseCombinedNmsInFirstStage();

    /**
     * <pre>
     * Whether to output final box feature. If true, it will crop the rpn feature
     * map based on the final prediction boxes, then pass the crops through the
     * box_classifier to compute the final features in the postprocess() method.
     * </pre>
     *
     * <code>optional bool output_final_box_features = 42 [default = false];</code>
     * @return Whether the outputFinalBoxFeatures field is set.
     */
    boolean hasOutputFinalBoxFeatures();
    /**
     * <pre>
     * Whether to output final box feature. If true, it will crop the rpn feature
     * map based on the final prediction boxes, then pass the crops through the
     * box_classifier to compute the final features in the postprocess() method.
     * </pre>
     *
     * <code>optional bool output_final_box_features = 42 [default = false];</code>
     * @return The outputFinalBoxFeatures.
     */
    boolean getOutputFinalBoxFeatures();

    /**
     * <pre>
     * Whether to output final box rpn features. If true, it will crop the rpn
     * feature map in the postprocess() method based on the final prediction
     * boxes.
     * </pre>
     *
     * <code>optional bool output_final_box_rpn_features = 43 [default = false];</code>
     * @return Whether the outputFinalBoxRpnFeatures field is set.
     */
    boolean hasOutputFinalBoxRpnFeatures();
    /**
     * <pre>
     * Whether to output final box rpn features. If true, it will crop the rpn
     * feature map in the postprocess() method based on the final prediction
     * boxes.
     * </pre>
     *
     * <code>optional bool output_final_box_rpn_features = 43 [default = false];</code>
     * @return The outputFinalBoxRpnFeatures.
     */
    boolean getOutputFinalBoxRpnFeatures();

    /**
     * <pre>
     * Configs for context model.
     * </pre>
     *
     * <code>optional .object_detection.protos.Context context_config = 41;</code>
     * @return Whether the contextConfig field is set.
     */
    boolean hasContextConfig();
    /**
     * <pre>
     * Configs for context model.
     * </pre>
     *
     * <code>optional .object_detection.protos.Context context_config = 41;</code>
     * @return The contextConfig.
     */
    object_detection.protos.FasterRcnnOuterClass.Context getContextConfig();
    /**
     * <pre>
     * Configs for context model.
     * </pre>
     *
     * <code>optional .object_detection.protos.Context context_config = 41;</code>
     */
    object_detection.protos.FasterRcnnOuterClass.ContextOrBuilder getContextConfigOrBuilder();
  }
  /**
   * Protobuf type {@code object_detection.protos.FasterRcnn}
   */
  public static final class FasterRcnn extends
      com.google.protobuf.GeneratedMessageV3 implements
      // @@protoc_insertion_point(message_implements:object_detection.protos.FasterRcnn)
      FasterRcnnOrBuilder {
  private static final long serialVersionUID = 0L;
    // Use FasterRcnn.newBuilder() to construct.
    private FasterRcnn(com.google.protobuf.GeneratedMessageV3.Builder<?> builder) {
      super(builder);
    }
    private FasterRcnn() {
      numberOfStages_ = 2;
      firstStageAtrousRate_ = 1;
      firstStageBoxPredictorKernelSize_ = 3;
      firstStageBoxPredictorDepth_ = 512;
      firstStageMinibatchSize_ = 256;
      firstStagePositiveBalanceFraction_ = 0.5F;
      firstStageNmsIouThreshold_ = 0.7F;
      firstStageMaxProposals_ = 300;
      firstStageLocalizationLossWeight_ = 1F;
      firstStageObjectnessLossWeight_ = 1F;
      secondStageBatchSize_ = 64;
      secondStageBalanceFraction_ = 0.25F;
      secondStageLocalizationLossWeight_ = 1F;
      secondStageClassificationLossWeight_ = 1F;
      secondStageMaskPredictionLossWeight_ = 1F;
      resizeMasks_ = true;
      usePartitionedNmsInFirstStage_ = true;
    }

    @java.lang.Override
    @SuppressWarnings({"unused"})
    protected java.lang.Object newInstance(
        UnusedPrivateParameter unused) {
      return new FasterRcnn();
    }

    @java.lang.Override
    public final com.google.protobuf.UnknownFieldSet
    getUnknownFields() {
      return this.unknownFields;
    }
    private FasterRcnn(
        com.google.protobuf.CodedInputStream input,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws com.google.protobuf.InvalidProtocolBufferException {
      this();
      if (extensionRegistry == null) {
        throw new java.lang.NullPointerException();
      }
      int mutable_bitField0_ = 0;
      int mutable_bitField1_ = 0;
      com.google.protobuf.UnknownFieldSet.Builder unknownFields =
          com.google.protobuf.UnknownFieldSet.newBuilder();
      try {
        boolean done = false;
        while (!done) {
          int tag = input.readTag();
          switch (tag) {
            case 0:
              done = true;
              break;
            case 8: {
              bitField0_ |= 0x00000001;
              numberOfStages_ = input.readInt32();
              break;
            }
            case 24: {
              bitField0_ |= 0x00000002;
              numClasses_ = input.readInt32();
              break;
            }
            case 34: {
              object_detection.protos.ImageResizerOuterClass.ImageResizer.Builder subBuilder = null;
              if (((bitField0_ & 0x00000004) != 0)) {
                subBuilder = imageResizer_.toBuilder();
              }
              imageResizer_ = input.readMessage(object_detection.protos.ImageResizerOuterClass.ImageResizer.PARSER, extensionRegistry);
              if (subBuilder != null) {
                subBuilder.mergeFrom(imageResizer_);
                imageResizer_ = subBuilder.buildPartial();
              }
              bitField0_ |= 0x00000004;
              break;
            }
            case 42: {
              object_detection.protos.FasterRcnnOuterClass.FasterRcnnFeatureExtractor.Builder subBuilder = null;
              if (((bitField0_ & 0x00000008) != 0)) {
                subBuilder = featureExtractor_.toBuilder();
              }
              featureExtractor_ = input.readMessage(object_detection.protos.FasterRcnnOuterClass.FasterRcnnFeatureExtractor.PARSER, extensionRegistry);
              if (subBuilder != null) {
                subBuilder.mergeFrom(featureExtractor_);
                featureExtractor_ = subBuilder.buildPartial();
              }
              bitField0_ |= 0x00000008;
              break;
            }
            case 50: {
              object_detection.protos.AnchorGeneratorOuterClass.AnchorGenerator.Builder subBuilder = null;
              if (((bitField0_ & 0x00000010) != 0)) {
                subBuilder = firstStageAnchorGenerator_.toBuilder();
              }
              firstStageAnchorGenerator_ = input.readMessage(object_detection.protos.AnchorGeneratorOuterClass.AnchorGenerator.PARSER, extensionRegistry);
              if (subBuilder != null) {
                subBuilder.mergeFrom(firstStageAnchorGenerator_);
                firstStageAnchorGenerator_ = subBuilder.buildPartial();
              }
              bitField0_ |= 0x00000010;
              break;
            }
            case 56: {
              bitField0_ |= 0x00000020;
              firstStageAtrousRate_ = input.readInt32();
              break;
            }
            case 66: {
              object_detection.protos.HyperparamsOuterClass.Hyperparams.Builder subBuilder = null;
              if (((bitField0_ & 0x00000040) != 0)) {
                subBuilder = firstStageBoxPredictorConvHyperparams_.toBuilder();
              }
              firstStageBoxPredictorConvHyperparams_ = input.readMessage(object_detection.protos.HyperparamsOuterClass.Hyperparams.PARSER, extensionRegistry);
              if (subBuilder != null) {
                subBuilder.mergeFrom(firstStageBoxPredictorConvHyperparams_);
                firstStageBoxPredictorConvHyperparams_ = subBuilder.buildPartial();
              }
              bitField0_ |= 0x00000040;
              break;
            }
            case 72: {
              bitField0_ |= 0x00000080;
              firstStageBoxPredictorKernelSize_ = input.readInt32();
              break;
            }
            case 80: {
              bitField0_ |= 0x00000100;
              firstStageBoxPredictorDepth_ = input.readInt32();
              break;
            }
            case 88: {
              bitField0_ |= 0x00000200;
              firstStageMinibatchSize_ = input.readInt32();
              break;
            }
            case 101: {
              bitField0_ |= 0x00000400;
              firstStagePositiveBalanceFraction_ = input.readFloat();
              break;
            }
            case 109: {
              bitField0_ |= 0x00000800;
              firstStageNmsScoreThreshold_ = input.readFloat();
              break;
            }
            case 117: {
              bitField0_ |= 0x00001000;
              firstStageNmsIouThreshold_ = input.readFloat();
              break;
            }
            case 120: {
              bitField0_ |= 0x00002000;
              firstStageMaxProposals_ = input.readInt32();
              break;
            }
            case 133: {
              bitField0_ |= 0x00004000;
              firstStageLocalizationLossWeight_ = input.readFloat();
              break;
            }
            case 141: {
              bitField0_ |= 0x00008000;
              firstStageObjectnessLossWeight_ = input.readFloat();
              break;
            }
            case 144: {
              bitField0_ |= 0x00010000;
              initialCropSize_ = input.readInt32();
              break;
            }
            case 152: {
              bitField0_ |= 0x00020000;
              maxpoolKernelSize_ = input.readInt32();
              break;
            }
            case 160: {
              bitField0_ |= 0x00040000;
              maxpoolStride_ = input.readInt32();
              break;
            }
            case 170: {
              object_detection.protos.BoxPredictorOuterClass.BoxPredictor.Builder subBuilder = null;
              if (((bitField0_ & 0x00080000) != 0)) {
                subBuilder = secondStageBoxPredictor_.toBuilder();
              }
              secondStageBoxPredictor_ = input.readMessage(object_detection.protos.BoxPredictorOuterClass.BoxPredictor.PARSER, extensionRegistry);
              if (subBuilder != null) {
                subBuilder.mergeFrom(secondStageBoxPredictor_);
                secondStageBoxPredictor_ = subBuilder.buildPartial();
              }
              bitField0_ |= 0x00080000;
              break;
            }
            case 176: {
              bitField0_ |= 0x00100000;
              secondStageBatchSize_ = input.readInt32();
              break;
            }
            case 189: {
              bitField0_ |= 0x00200000;
              secondStageBalanceFraction_ = input.readFloat();
              break;
            }
            case 194: {
              object_detection.protos.PostProcessingOuterClass.PostProcessing.Builder subBuilder = null;
              if (((bitField0_ & 0x00400000) != 0)) {
                subBuilder = secondStagePostProcessing_.toBuilder();
              }
              secondStagePostProcessing_ = input.readMessage(object_detection.protos.PostProcessingOuterClass.PostProcessing.PARSER, extensionRegistry);
              if (subBuilder != null) {
                subBuilder.mergeFrom(secondStagePostProcessing_);
                secondStagePostProcessing_ = subBuilder.buildPartial();
              }
              bitField0_ |= 0x00400000;
              break;
            }
            case 205: {
              bitField0_ |= 0x00800000;
              secondStageLocalizationLossWeight_ = input.readFloat();
              break;
            }
            case 213: {
              bitField0_ |= 0x01000000;
              secondStageClassificationLossWeight_ = input.readFloat();
              break;
            }
            case 221: {
              bitField0_ |= 0x02000000;
              secondStageMaskPredictionLossWeight_ = input.readFloat();
              break;
            }
            case 226: {
              object_detection.protos.Losses.HardExampleMiner.Builder subBuilder = null;
              if (((bitField0_ & 0x04000000) != 0)) {
                subBuilder = hardExampleMiner_.toBuilder();
              }
              hardExampleMiner_ = input.readMessage(object_detection.protos.Losses.HardExampleMiner.PARSER, extensionRegistry);
              if (subBuilder != null) {
                subBuilder.mergeFrom(hardExampleMiner_);
                hardExampleMiner_ = subBuilder.buildPartial();
              }
              bitField0_ |= 0x04000000;
              break;
            }
            case 234: {
              object_detection.protos.Losses.ClassificationLoss.Builder subBuilder = null;
              if (((bitField0_ & 0x08000000) != 0)) {
                subBuilder = secondStageClassificationLoss_.toBuilder();
              }
              secondStageClassificationLoss_ = input.readMessage(object_detection.protos.Losses.ClassificationLoss.PARSER, extensionRegistry);
              if (subBuilder != null) {
                subBuilder.mergeFrom(secondStageClassificationLoss_);
                secondStageClassificationLoss_ = subBuilder.buildPartial();
              }
              bitField0_ |= 0x08000000;
              break;
            }
            case 240: {
              bitField0_ |= 0x10000000;
              inplaceBatchnormUpdate_ = input.readBool();
              break;
            }
            case 248: {
              bitField0_ |= 0x20000000;
              useMatmulCropAndResize_ = input.readBool();
              break;
            }
            case 256: {
              bitField0_ |= 0x40000000;
              clipAnchorsToImage_ = input.readBool();
              break;
            }
            case 264: {
              bitField0_ |= 0x80000000;
              useMatmulGatherInMatcher_ = input.readBool();
              break;
            }
            case 272: {
              bitField1_ |= 0x00000001;
              useStaticBalancedLabelSampler_ = input.readBool();
              break;
            }
            case 280: {
              bitField1_ |= 0x00000002;
              useStaticShapes_ = input.readBool();
              break;
            }
            case 288: {
              bitField1_ |= 0x00000004;
              resizeMasks_ = input.readBool();
              break;
            }
            case 296: {
              bitField1_ |= 0x00000008;
              useStaticShapesForEval_ = input.readBool();
              break;
            }
            case 304: {
              bitField1_ |= 0x00000010;
              usePartitionedNmsInFirstStage_ = input.readBool();
              break;
            }
            case 312: {
              bitField1_ |= 0x00000020;
              returnRawDetectionsDuringPredict_ = input.readBool();
              break;
            }
            case 320: {
              bitField1_ |= 0x00000040;
              useCombinedNmsInFirstStage_ = input.readBool();
              break;
            }
            case 330: {
              object_detection.protos.FasterRcnnOuterClass.Context.Builder subBuilder = null;
              if (((bitField1_ & 0x00000200) != 0)) {
                subBuilder = contextConfig_.toBuilder();
              }
              contextConfig_ = input.readMessage(object_detection.protos.FasterRcnnOuterClass.Context.PARSER, extensionRegistry);
              if (subBuilder != null) {
                subBuilder.mergeFrom(contextConfig_);
                contextConfig_ = subBuilder.buildPartial();
              }
              bitField1_ |= 0x00000200;
              break;
            }
            case 336: {
              bitField1_ |= 0x00000080;
              outputFinalBoxFeatures_ = input.readBool();
              break;
            }
            case 344: {
              bitField1_ |= 0x00000100;
              outputFinalBoxRpnFeatures_ = input.readBool();
              break;
            }
            default: {
              if (!parseUnknownField(
                  input, unknownFields, extensionRegistry, tag)) {
                done = true;
              }
              break;
            }
          }
        }
      } catch (com.google.protobuf.InvalidProtocolBufferException e) {
        throw e.setUnfinishedMessage(this);
      } catch (java.io.IOException e) {
        throw new com.google.protobuf.InvalidProtocolBufferException(
            e).setUnfinishedMessage(this);
      } finally {
        this.unknownFields = unknownFields.build();
        makeExtensionsImmutable();
      }
    }
    public static final com.google.protobuf.Descriptors.Descriptor
        getDescriptor() {
      return object_detection.protos.FasterRcnnOuterClass.internal_static_object_detection_protos_FasterRcnn_descriptor;
    }

    @java.lang.Override
    protected com.google.protobuf.GeneratedMessageV3.FieldAccessorTable
        internalGetFieldAccessorTable() {
      return object_detection.protos.FasterRcnnOuterClass.internal_static_object_detection_protos_FasterRcnn_fieldAccessorTable
          .ensureFieldAccessorsInitialized(
              object_detection.protos.FasterRcnnOuterClass.FasterRcnn.class, object_detection.protos.FasterRcnnOuterClass.FasterRcnn.Builder.class);
    }

    private int bitField0_;
    private int bitField1_;
    public static final int NUMBER_OF_STAGES_FIELD_NUMBER = 1;
    private int numberOfStages_;
    /**
     * <pre>
     * Whether to construct only the Region Proposal Network (RPN).
     * </pre>
     *
     * <code>optional int32 number_of_stages = 1 [default = 2];</code>
     * @return Whether the numberOfStages field is set.
     */
    @java.lang.Override
    public boolean hasNumberOfStages() {
      return ((bitField0_ & 0x00000001) != 0);
    }
    /**
     * <pre>
     * Whether to construct only the Region Proposal Network (RPN).
     * </pre>
     *
     * <code>optional int32 number_of_stages = 1 [default = 2];</code>
     * @return The numberOfStages.
     */
    @java.lang.Override
    public int getNumberOfStages() {
      return numberOfStages_;
    }

    public static final int NUM_CLASSES_FIELD_NUMBER = 3;
    private int numClasses_;
    /**
     * <pre>
     * Number of classes to predict.
     * </pre>
     *
     * <code>optional int32 num_classes = 3;</code>
     * @return Whether the numClasses field is set.
     */
    @java.lang.Override
    public boolean hasNumClasses() {
      return ((bitField0_ & 0x00000002) != 0);
    }
    /**
     * <pre>
     * Number of classes to predict.
     * </pre>
     *
     * <code>optional int32 num_classes = 3;</code>
     * @return The numClasses.
     */
    @java.lang.Override
    public int getNumClasses() {
      return numClasses_;
    }

    public static final int IMAGE_RESIZER_FIELD_NUMBER = 4;
    private object_detection.protos.ImageResizerOuterClass.ImageResizer imageResizer_;
    /**
     * <pre>
     * Image resizer for preprocessing the input image.
     * </pre>
     *
     * <code>optional .object_detection.protos.ImageResizer image_resizer = 4;</code>
     * @return Whether the imageResizer field is set.
     */
    @java.lang.Override
    public boolean hasImageResizer() {
      return ((bitField0_ & 0x00000004) != 0);
    }
    /**
     * <pre>
     * Image resizer for preprocessing the input image.
     * </pre>
     *
     * <code>optional .object_detection.protos.ImageResizer image_resizer = 4;</code>
     * @return The imageResizer.
     */
    @java.lang.Override
    public object_detection.protos.ImageResizerOuterClass.ImageResizer getImageResizer() {
      return imageResizer_ == null ? object_detection.protos.ImageResizerOuterClass.ImageResizer.getDefaultInstance() : imageResizer_;
    }
    /**
     * <pre>
     * Image resizer for preprocessing the input image.
     * </pre>
     *
     * <code>optional .object_detection.protos.ImageResizer image_resizer = 4;</code>
     */
    @java.lang.Override
    public object_detection.protos.ImageResizerOuterClass.ImageResizerOrBuilder getImageResizerOrBuilder() {
      return imageResizer_ == null ? object_detection.protos.ImageResizerOuterClass.ImageResizer.getDefaultInstance() : imageResizer_;
    }

    public static final int FEATURE_EXTRACTOR_FIELD_NUMBER = 5;
    private object_detection.protos.FasterRcnnOuterClass.FasterRcnnFeatureExtractor featureExtractor_;
    /**
     * <pre>
     * Feature extractor config.
     * </pre>
     *
     * <code>optional .object_detection.protos.FasterRcnnFeatureExtractor feature_extractor = 5;</code>
     * @return Whether the featureExtractor field is set.
     */
    @java.lang.Override
    public boolean hasFeatureExtractor() {
      return ((bitField0_ & 0x00000008) != 0);
    }
    /**
     * <pre>
     * Feature extractor config.
     * </pre>
     *
     * <code>optional .object_detection.protos.FasterRcnnFeatureExtractor feature_extractor = 5;</code>
     * @return The featureExtractor.
     */
    @java.lang.Override
    public object_detection.protos.FasterRcnnOuterClass.FasterRcnnFeatureExtractor getFeatureExtractor() {
      return featureExtractor_ == null ? object_detection.protos.FasterRcnnOuterClass.FasterRcnnFeatureExtractor.getDefaultInstance() : featureExtractor_;
    }
    /**
     * <pre>
     * Feature extractor config.
     * </pre>
     *
     * <code>optional .object_detection.protos.FasterRcnnFeatureExtractor feature_extractor = 5;</code>
     */
    @java.lang.Override
    public object_detection.protos.FasterRcnnOuterClass.FasterRcnnFeatureExtractorOrBuilder getFeatureExtractorOrBuilder() {
      return featureExtractor_ == null ? object_detection.protos.FasterRcnnOuterClass.FasterRcnnFeatureExtractor.getDefaultInstance() : featureExtractor_;
    }

    public static final int FIRST_STAGE_ANCHOR_GENERATOR_FIELD_NUMBER = 6;
    private object_detection.protos.AnchorGeneratorOuterClass.AnchorGenerator firstStageAnchorGenerator_;
    /**
     * <pre>
     * Anchor generator to compute RPN anchors.
     * </pre>
     *
     * <code>optional .object_detection.protos.AnchorGenerator first_stage_anchor_generator = 6;</code>
     * @return Whether the firstStageAnchorGenerator field is set.
     */
    @java.lang.Override
    public boolean hasFirstStageAnchorGenerator() {
      return ((bitField0_ & 0x00000010) != 0);
    }
    /**
     * <pre>
     * Anchor generator to compute RPN anchors.
     * </pre>
     *
     * <code>optional .object_detection.protos.AnchorGenerator first_stage_anchor_generator = 6;</code>
     * @return The firstStageAnchorGenerator.
     */
    @java.lang.Override
    public object_detection.protos.AnchorGeneratorOuterClass.AnchorGenerator getFirstStageAnchorGenerator() {
      return firstStageAnchorGenerator_ == null ? object_detection.protos.AnchorGeneratorOuterClass.AnchorGenerator.getDefaultInstance() : firstStageAnchorGenerator_;
    }
    /**
     * <pre>
     * Anchor generator to compute RPN anchors.
     * </pre>
     *
     * <code>optional .object_detection.protos.AnchorGenerator first_stage_anchor_generator = 6;</code>
     */
    @java.lang.Override
    public object_detection.protos.AnchorGeneratorOuterClass.AnchorGeneratorOrBuilder getFirstStageAnchorGeneratorOrBuilder() {
      return firstStageAnchorGenerator_ == null ? object_detection.protos.AnchorGeneratorOuterClass.AnchorGenerator.getDefaultInstance() : firstStageAnchorGenerator_;
    }

    public static final int FIRST_STAGE_ATROUS_RATE_FIELD_NUMBER = 7;
    private int firstStageAtrousRate_;
    /**
     * <pre>
     * Atrous rate for the convolution op applied to the
     * `first_stage_features_to_crop` tensor to obtain box predictions.
     * </pre>
     *
     * <code>optional int32 first_stage_atrous_rate = 7 [default = 1];</code>
     * @return Whether the firstStageAtrousRate field is set.
     */
    @java.lang.Override
    public boolean hasFirstStageAtrousRate() {
      return ((bitField0_ & 0x00000020) != 0);
    }
    /**
     * <pre>
     * Atrous rate for the convolution op applied to the
     * `first_stage_features_to_crop` tensor to obtain box predictions.
     * </pre>
     *
     * <code>optional int32 first_stage_atrous_rate = 7 [default = 1];</code>
     * @return The firstStageAtrousRate.
     */
    @java.lang.Override
    public int getFirstStageAtrousRate() {
      return firstStageAtrousRate_;
    }

    public static final int FIRST_STAGE_BOX_PREDICTOR_CONV_HYPERPARAMS_FIELD_NUMBER = 8;
    private object_detection.protos.HyperparamsOuterClass.Hyperparams firstStageBoxPredictorConvHyperparams_;
    /**
     * <pre>
     * Hyperparameters for the convolutional RPN box predictor.
     * </pre>
     *
     * <code>optional .object_detection.protos.Hyperparams first_stage_box_predictor_conv_hyperparams = 8;</code>
     * @return Whether the firstStageBoxPredictorConvHyperparams field is set.
     */
    @java.lang.Override
    public boolean hasFirstStageBoxPredictorConvHyperparams() {
      return ((bitField0_ & 0x00000040) != 0);
    }
    /**
     * <pre>
     * Hyperparameters for the convolutional RPN box predictor.
     * </pre>
     *
     * <code>optional .object_detection.protos.Hyperparams first_stage_box_predictor_conv_hyperparams = 8;</code>
     * @return The firstStageBoxPredictorConvHyperparams.
     */
    @java.lang.Override
    public object_detection.protos.HyperparamsOuterClass.Hyperparams getFirstStageBoxPredictorConvHyperparams() {
      return firstStageBoxPredictorConvHyperparams_ == null ? object_detection.protos.HyperparamsOuterClass.Hyperparams.getDefaultInstance() : firstStageBoxPredictorConvHyperparams_;
    }
    /**
     * <pre>
     * Hyperparameters for the convolutional RPN box predictor.
     * </pre>
     *
     * <code>optional .object_detection.protos.Hyperparams first_stage_box_predictor_conv_hyperparams = 8;</code>
     */
    @java.lang.Override
    public object_detection.protos.HyperparamsOuterClass.HyperparamsOrBuilder getFirstStageBoxPredictorConvHyperparamsOrBuilder() {
      return firstStageBoxPredictorConvHyperparams_ == null ? object_detection.protos.HyperparamsOuterClass.Hyperparams.getDefaultInstance() : firstStageBoxPredictorConvHyperparams_;
    }

    public static final int FIRST_STAGE_BOX_PREDICTOR_KERNEL_SIZE_FIELD_NUMBER = 9;
    private int firstStageBoxPredictorKernelSize_;
    /**
     * <pre>
     * Kernel size to use for the convolution op just prior to RPN box
     * predictions.
     * </pre>
     *
     * <code>optional int32 first_stage_box_predictor_kernel_size = 9 [default = 3];</code>
     * @return Whether the firstStageBoxPredictorKernelSize field is set.
     */
    @java.lang.Override
    public boolean hasFirstStageBoxPredictorKernelSize() {
      return ((bitField0_ & 0x00000080) != 0);
    }
    /**
     * <pre>
     * Kernel size to use for the convolution op just prior to RPN box
     * predictions.
     * </pre>
     *
     * <code>optional int32 first_stage_box_predictor_kernel_size = 9 [default = 3];</code>
     * @return The firstStageBoxPredictorKernelSize.
     */
    @java.lang.Override
    public int getFirstStageBoxPredictorKernelSize() {
      return firstStageBoxPredictorKernelSize_;
    }

    public static final int FIRST_STAGE_BOX_PREDICTOR_DEPTH_FIELD_NUMBER = 10;
    private int firstStageBoxPredictorDepth_;
    /**
     * <pre>
     * Output depth for the convolution op just prior to RPN box predictions.
     * </pre>
     *
     * <code>optional int32 first_stage_box_predictor_depth = 10 [default = 512];</code>
     * @return Whether the firstStageBoxPredictorDepth field is set.
     */
    @java.lang.Override
    public boolean hasFirstStageBoxPredictorDepth() {
      return ((bitField0_ & 0x00000100) != 0);
    }
    /**
     * <pre>
     * Output depth for the convolution op just prior to RPN box predictions.
     * </pre>
     *
     * <code>optional int32 first_stage_box_predictor_depth = 10 [default = 512];</code>
     * @return The firstStageBoxPredictorDepth.
     */
    @java.lang.Override
    public int getFirstStageBoxPredictorDepth() {
      return firstStageBoxPredictorDepth_;
    }

    public static final int FIRST_STAGE_MINIBATCH_SIZE_FIELD_NUMBER = 11;
    private int firstStageMinibatchSize_;
    /**
     * <pre>
     * The batch size to use for computing the first stage objectness and
     * location losses.
     * </pre>
     *
     * <code>optional int32 first_stage_minibatch_size = 11 [default = 256];</code>
     * @return Whether the firstStageMinibatchSize field is set.
     */
    @java.lang.Override
    public boolean hasFirstStageMinibatchSize() {
      return ((bitField0_ & 0x00000200) != 0);
    }
    /**
     * <pre>
     * The batch size to use for computing the first stage objectness and
     * location losses.
     * </pre>
     *
     * <code>optional int32 first_stage_minibatch_size = 11 [default = 256];</code>
     * @return The firstStageMinibatchSize.
     */
    @java.lang.Override
    public int getFirstStageMinibatchSize() {
      return firstStageMinibatchSize_;
    }

    public static final int FIRST_STAGE_POSITIVE_BALANCE_FRACTION_FIELD_NUMBER = 12;
    private float firstStagePositiveBalanceFraction_;
    /**
     * <pre>
     * Fraction of positive examples per image for the RPN.
     * </pre>
     *
     * <code>optional float first_stage_positive_balance_fraction = 12 [default = 0.5];</code>
     * @return Whether the firstStagePositiveBalanceFraction field is set.
     */
    @java.lang.Override
    public boolean hasFirstStagePositiveBalanceFraction() {
      return ((bitField0_ & 0x00000400) != 0);
    }
    /**
     * <pre>
     * Fraction of positive examples per image for the RPN.
     * </pre>
     *
     * <code>optional float first_stage_positive_balance_fraction = 12 [default = 0.5];</code>
     * @return The firstStagePositiveBalanceFraction.
     */
    @java.lang.Override
    public float getFirstStagePositiveBalanceFraction() {
      return firstStagePositiveBalanceFraction_;
    }

    public static final int FIRST_STAGE_NMS_SCORE_THRESHOLD_FIELD_NUMBER = 13;
    private float firstStageNmsScoreThreshold_;
    /**
     * <pre>
     * Non max suppression score threshold applied to first stage RPN proposals.
     * </pre>
     *
     * <code>optional float first_stage_nms_score_threshold = 13 [default = 0];</code>
     * @return Whether the firstStageNmsScoreThreshold field is set.
     */
    @java.lang.Override
    public boolean hasFirstStageNmsScoreThreshold() {
      return ((bitField0_ & 0x00000800) != 0);
    }
    /**
     * <pre>
     * Non max suppression score threshold applied to first stage RPN proposals.
     * </pre>
     *
     * <code>optional float first_stage_nms_score_threshold = 13 [default = 0];</code>
     * @return The firstStageNmsScoreThreshold.
     */
    @java.lang.Override
    public float getFirstStageNmsScoreThreshold() {
      return firstStageNmsScoreThreshold_;
    }

    public static final int FIRST_STAGE_NMS_IOU_THRESHOLD_FIELD_NUMBER = 14;
    private float firstStageNmsIouThreshold_;
    /**
     * <pre>
     * Non max suppression IOU threshold applied to first stage RPN proposals.
     * </pre>
     *
     * <code>optional float first_stage_nms_iou_threshold = 14 [default = 0.7];</code>
     * @return Whether the firstStageNmsIouThreshold field is set.
     */
    @java.lang.Override
    public boolean hasFirstStageNmsIouThreshold() {
      return ((bitField0_ & 0x00001000) != 0);
    }
    /**
     * <pre>
     * Non max suppression IOU threshold applied to first stage RPN proposals.
     * </pre>
     *
     * <code>optional float first_stage_nms_iou_threshold = 14 [default = 0.7];</code>
     * @return The firstStageNmsIouThreshold.
     */
    @java.lang.Override
    public float getFirstStageNmsIouThreshold() {
      return firstStageNmsIouThreshold_;
    }

    public static final int FIRST_STAGE_MAX_PROPOSALS_FIELD_NUMBER = 15;
    private int firstStageMaxProposals_;
    /**
     * <pre>
     * Maximum number of RPN proposals retained after first stage postprocessing.
     * </pre>
     *
     * <code>optional int32 first_stage_max_proposals = 15 [default = 300];</code>
     * @return Whether the firstStageMaxProposals field is set.
     */
    @java.lang.Override
    public boolean hasFirstStageMaxProposals() {
      return ((bitField0_ & 0x00002000) != 0);
    }
    /**
     * <pre>
     * Maximum number of RPN proposals retained after first stage postprocessing.
     * </pre>
     *
     * <code>optional int32 first_stage_max_proposals = 15 [default = 300];</code>
     * @return The firstStageMaxProposals.
     */
    @java.lang.Override
    public int getFirstStageMaxProposals() {
      return firstStageMaxProposals_;
    }

    public static final int FIRST_STAGE_LOCALIZATION_LOSS_WEIGHT_FIELD_NUMBER = 16;
    private float firstStageLocalizationLossWeight_;
    /**
     * <pre>
     * First stage RPN localization loss weight.
     * </pre>
     *
     * <code>optional float first_stage_localization_loss_weight = 16 [default = 1];</code>
     * @return Whether the firstStageLocalizationLossWeight field is set.
     */
    @java.lang.Override
    public boolean hasFirstStageLocalizationLossWeight() {
      return ((bitField0_ & 0x00004000) != 0);
    }
    /**
     * <pre>
     * First stage RPN localization loss weight.
     * </pre>
     *
     * <code>optional float first_stage_localization_loss_weight = 16 [default = 1];</code>
     * @return The firstStageLocalizationLossWeight.
     */
    @java.lang.Override
    public float getFirstStageLocalizationLossWeight() {
      return firstStageLocalizationLossWeight_;
    }

    public static final int FIRST_STAGE_OBJECTNESS_LOSS_WEIGHT_FIELD_NUMBER = 17;
    private float firstStageObjectnessLossWeight_;
    /**
     * <pre>
     * First stage RPN objectness loss weight.
     * </pre>
     *
     * <code>optional float first_stage_objectness_loss_weight = 17 [default = 1];</code>
     * @return Whether the firstStageObjectnessLossWeight field is set.
     */
    @java.lang.Override
    public boolean hasFirstStageObjectnessLossWeight() {
      return ((bitField0_ & 0x00008000) != 0);
    }
    /**
     * <pre>
     * First stage RPN objectness loss weight.
     * </pre>
     *
     * <code>optional float first_stage_objectness_loss_weight = 17 [default = 1];</code>
     * @return The firstStageObjectnessLossWeight.
     */
    @java.lang.Override
    public float getFirstStageObjectnessLossWeight() {
      return firstStageObjectnessLossWeight_;
    }

    public static final int INITIAL_CROP_SIZE_FIELD_NUMBER = 18;
    private int initialCropSize_;
    /**
     * <pre>
     * Output size (width and height are set to be the same) of the initial
     * bilinear interpolation based cropping during ROI pooling.
     * </pre>
     *
     * <code>optional int32 initial_crop_size = 18;</code>
     * @return Whether the initialCropSize field is set.
     */
    @java.lang.Override
    public boolean hasInitialCropSize() {
      return ((bitField0_ & 0x00010000) != 0);
    }
    /**
     * <pre>
     * Output size (width and height are set to be the same) of the initial
     * bilinear interpolation based cropping during ROI pooling.
     * </pre>
     *
     * <code>optional int32 initial_crop_size = 18;</code>
     * @return The initialCropSize.
     */
    @java.lang.Override
    public int getInitialCropSize() {
      return initialCropSize_;
    }

    public static final int MAXPOOL_KERNEL_SIZE_FIELD_NUMBER = 19;
    private int maxpoolKernelSize_;
    /**
     * <pre>
     * Kernel size of the max pool op on the cropped feature map during
     * ROI pooling.
     * </pre>
     *
     * <code>optional int32 maxpool_kernel_size = 19;</code>
     * @return Whether the maxpoolKernelSize field is set.
     */
    @java.lang.Override
    public boolean hasMaxpoolKernelSize() {
      return ((bitField0_ & 0x00020000) != 0);
    }
    /**
     * <pre>
     * Kernel size of the max pool op on the cropped feature map during
     * ROI pooling.
     * </pre>
     *
     * <code>optional int32 maxpool_kernel_size = 19;</code>
     * @return The maxpoolKernelSize.
     */
    @java.lang.Override
    public int getMaxpoolKernelSize() {
      return maxpoolKernelSize_;
    }

    public static final int MAXPOOL_STRIDE_FIELD_NUMBER = 20;
    private int maxpoolStride_;
    /**
     * <pre>
     * Stride of the max pool op on the cropped feature map during ROI pooling.
     * </pre>
     *
     * <code>optional int32 maxpool_stride = 20;</code>
     * @return Whether the maxpoolStride field is set.
     */
    @java.lang.Override
    public boolean hasMaxpoolStride() {
      return ((bitField0_ & 0x00040000) != 0);
    }
    /**
     * <pre>
     * Stride of the max pool op on the cropped feature map during ROI pooling.
     * </pre>
     *
     * <code>optional int32 maxpool_stride = 20;</code>
     * @return The maxpoolStride.
     */
    @java.lang.Override
    public int getMaxpoolStride() {
      return maxpoolStride_;
    }

    public static final int SECOND_STAGE_BOX_PREDICTOR_FIELD_NUMBER = 21;
    private object_detection.protos.BoxPredictorOuterClass.BoxPredictor secondStageBoxPredictor_;
    /**
     * <pre>
     * Hyperparameters for the second stage box predictor. If box predictor type
     * is set to rfcn_box_predictor, a R-FCN model is constructed, otherwise a
     * Faster R-CNN model is constructed.
     * </pre>
     *
     * <code>optional .object_detection.protos.BoxPredictor second_stage_box_predictor = 21;</code>
     * @return Whether the secondStageBoxPredictor field is set.
     */
    @java.lang.Override
    public boolean hasSecondStageBoxPredictor() {
      return ((bitField0_ & 0x00080000) != 0);
    }
    /**
     * <pre>
     * Hyperparameters for the second stage box predictor. If box predictor type
     * is set to rfcn_box_predictor, a R-FCN model is constructed, otherwise a
     * Faster R-CNN model is constructed.
     * </pre>
     *
     * <code>optional .object_detection.protos.BoxPredictor second_stage_box_predictor = 21;</code>
     * @return The secondStageBoxPredictor.
     */
    @java.lang.Override
    public object_detection.protos.BoxPredictorOuterClass.BoxPredictor getSecondStageBoxPredictor() {
      return secondStageBoxPredictor_ == null ? object_detection.protos.BoxPredictorOuterClass.BoxPredictor.getDefaultInstance() : secondStageBoxPredictor_;
    }
    /**
     * <pre>
     * Hyperparameters for the second stage box predictor. If box predictor type
     * is set to rfcn_box_predictor, a R-FCN model is constructed, otherwise a
     * Faster R-CNN model is constructed.
     * </pre>
     *
     * <code>optional .object_detection.protos.BoxPredictor second_stage_box_predictor = 21;</code>
     */
    @java.lang.Override
    public object_detection.protos.BoxPredictorOuterClass.BoxPredictorOrBuilder getSecondStageBoxPredictorOrBuilder() {
      return secondStageBoxPredictor_ == null ? object_detection.protos.BoxPredictorOuterClass.BoxPredictor.getDefaultInstance() : secondStageBoxPredictor_;
    }

    public static final int SECOND_STAGE_BATCH_SIZE_FIELD_NUMBER = 22;
    private int secondStageBatchSize_;
    /**
     * <pre>
     * The batch size per image used for computing the classification and refined
     * location loss of the box classifier.
     * Note that this field is ignored if `hard_example_miner` is configured.
     * </pre>
     *
     * <code>optional int32 second_stage_batch_size = 22 [default = 64];</code>
     * @return Whether the secondStageBatchSize field is set.
     */
    @java.lang.Override
    public boolean hasSecondStageBatchSize() {
      return ((bitField0_ & 0x00100000) != 0);
    }
    /**
     * <pre>
     * The batch size per image used for computing the classification and refined
     * location loss of the box classifier.
     * Note that this field is ignored if `hard_example_miner` is configured.
     * </pre>
     *
     * <code>optional int32 second_stage_batch_size = 22 [default = 64];</code>
     * @return The secondStageBatchSize.
     */
    @java.lang.Override
    public int getSecondStageBatchSize() {
      return secondStageBatchSize_;
    }

    public static final int SECOND_STAGE_BALANCE_FRACTION_FIELD_NUMBER = 23;
    private float secondStageBalanceFraction_;
    /**
     * <pre>
     * Fraction of positive examples to use per image for the box classifier.
     * </pre>
     *
     * <code>optional float second_stage_balance_fraction = 23 [default = 0.25];</code>
     * @return Whether the secondStageBalanceFraction field is set.
     */
    @java.lang.Override
    public boolean hasSecondStageBalanceFraction() {
      return ((bitField0_ & 0x00200000) != 0);
    }
    /**
     * <pre>
     * Fraction of positive examples to use per image for the box classifier.
     * </pre>
     *
     * <code>optional float second_stage_balance_fraction = 23 [default = 0.25];</code>
     * @return The secondStageBalanceFraction.
     */
    @java.lang.Override
    public float getSecondStageBalanceFraction() {
      return secondStageBalanceFraction_;
    }

    public static final int SECOND_STAGE_POST_PROCESSING_FIELD_NUMBER = 24;
    private object_detection.protos.PostProcessingOuterClass.PostProcessing secondStagePostProcessing_;
    /**
     * <pre>
     * Post processing to apply on the second stage box classifier predictions.
     * Note: the `score_converter` provided to the FasterRCNNMetaArch constructor
     * is taken from this `second_stage_post_processing` proto.
     * </pre>
     *
     * <code>optional .object_detection.protos.PostProcessing second_stage_post_processing = 24;</code>
     * @return Whether the secondStagePostProcessing field is set.
     */
    @java.lang.Override
    public boolean hasSecondStagePostProcessing() {
      return ((bitField0_ & 0x00400000) != 0);
    }
    /**
     * <pre>
     * Post processing to apply on the second stage box classifier predictions.
     * Note: the `score_converter` provided to the FasterRCNNMetaArch constructor
     * is taken from this `second_stage_post_processing` proto.
     * </pre>
     *
     * <code>optional .object_detection.protos.PostProcessing second_stage_post_processing = 24;</code>
     * @return The secondStagePostProcessing.
     */
    @java.lang.Override
    public object_detection.protos.PostProcessingOuterClass.PostProcessing getSecondStagePostProcessing() {
      return secondStagePostProcessing_ == null ? object_detection.protos.PostProcessingOuterClass.PostProcessing.getDefaultInstance() : secondStagePostProcessing_;
    }
    /**
     * <pre>
     * Post processing to apply on the second stage box classifier predictions.
     * Note: the `score_converter` provided to the FasterRCNNMetaArch constructor
     * is taken from this `second_stage_post_processing` proto.
     * </pre>
     *
     * <code>optional .object_detection.protos.PostProcessing second_stage_post_processing = 24;</code>
     */
    @java.lang.Override
    public object_detection.protos.PostProcessingOuterClass.PostProcessingOrBuilder getSecondStagePostProcessingOrBuilder() {
      return secondStagePostProcessing_ == null ? object_detection.protos.PostProcessingOuterClass.PostProcessing.getDefaultInstance() : secondStagePostProcessing_;
    }

    public static final int SECOND_STAGE_LOCALIZATION_LOSS_WEIGHT_FIELD_NUMBER = 25;
    private float secondStageLocalizationLossWeight_;
    /**
     * <pre>
     * Second stage refined localization loss weight.
     * </pre>
     *
     * <code>optional float second_stage_localization_loss_weight = 25 [default = 1];</code>
     * @return Whether the secondStageLocalizationLossWeight field is set.
     */
    @java.lang.Override
    public boolean hasSecondStageLocalizationLossWeight() {
      return ((bitField0_ & 0x00800000) != 0);
    }
    /**
     * <pre>
     * Second stage refined localization loss weight.
     * </pre>
     *
     * <code>optional float second_stage_localization_loss_weight = 25 [default = 1];</code>
     * @return The secondStageLocalizationLossWeight.
     */
    @java.lang.Override
    public float getSecondStageLocalizationLossWeight() {
      return secondStageLocalizationLossWeight_;
    }

    public static final int SECOND_STAGE_CLASSIFICATION_LOSS_WEIGHT_FIELD_NUMBER = 26;
    private float secondStageClassificationLossWeight_;
    /**
     * <pre>
     * Second stage classification loss weight
     * </pre>
     *
     * <code>optional float second_stage_classification_loss_weight = 26 [default = 1];</code>
     * @return Whether the secondStageClassificationLossWeight field is set.
     */
    @java.lang.Override
    public boolean hasSecondStageClassificationLossWeight() {
      return ((bitField0_ & 0x01000000) != 0);
    }
    /**
     * <pre>
     * Second stage classification loss weight
     * </pre>
     *
     * <code>optional float second_stage_classification_loss_weight = 26 [default = 1];</code>
     * @return The secondStageClassificationLossWeight.
     */
    @java.lang.Override
    public float getSecondStageClassificationLossWeight() {
      return secondStageClassificationLossWeight_;
    }

    public static final int SECOND_STAGE_MASK_PREDICTION_LOSS_WEIGHT_FIELD_NUMBER = 27;
    private float secondStageMaskPredictionLossWeight_;
    /**
     * <pre>
     * Second stage instance mask loss weight. Note that this is only applicable
     * when `MaskRCNNBoxPredictor` is selected for second stage and configured to
     * predict instance masks.
     * </pre>
     *
     * <code>optional float second_stage_mask_prediction_loss_weight = 27 [default = 1];</code>
     * @return Whether the secondStageMaskPredictionLossWeight field is set.
     */
    @java.lang.Override
    public boolean hasSecondStageMaskPredictionLossWeight() {
      return ((bitField0_ & 0x02000000) != 0);
    }
    /**
     * <pre>
     * Second stage instance mask loss weight. Note that this is only applicable
     * when `MaskRCNNBoxPredictor` is selected for second stage and configured to
     * predict instance masks.
     * </pre>
     *
     * <code>optional float second_stage_mask_prediction_loss_weight = 27 [default = 1];</code>
     * @return The secondStageMaskPredictionLossWeight.
     */
    @java.lang.Override
    public float getSecondStageMaskPredictionLossWeight() {
      return secondStageMaskPredictionLossWeight_;
    }

    public static final int HARD_EXAMPLE_MINER_FIELD_NUMBER = 28;
    private object_detection.protos.Losses.HardExampleMiner hardExampleMiner_;
    /**
     * <pre>
     * If not left to default, applies hard example mining only to classification
     * and localization loss..
     * </pre>
     *
     * <code>optional .object_detection.protos.HardExampleMiner hard_example_miner = 28;</code>
     * @return Whether the hardExampleMiner field is set.
     */
    @java.lang.Override
    public boolean hasHardExampleMiner() {
      return ((bitField0_ & 0x04000000) != 0);
    }
    /**
     * <pre>
     * If not left to default, applies hard example mining only to classification
     * and localization loss..
     * </pre>
     *
     * <code>optional .object_detection.protos.HardExampleMiner hard_example_miner = 28;</code>
     * @return The hardExampleMiner.
     */
    @java.lang.Override
    public object_detection.protos.Losses.HardExampleMiner getHardExampleMiner() {
      return hardExampleMiner_ == null ? object_detection.protos.Losses.HardExampleMiner.getDefaultInstance() : hardExampleMiner_;
    }
    /**
     * <pre>
     * If not left to default, applies hard example mining only to classification
     * and localization loss..
     * </pre>
     *
     * <code>optional .object_detection.protos.HardExampleMiner hard_example_miner = 28;</code>
     */
    @java.lang.Override
    public object_detection.protos.Losses.HardExampleMinerOrBuilder getHardExampleMinerOrBuilder() {
      return hardExampleMiner_ == null ? object_detection.protos.Losses.HardExampleMiner.getDefaultInstance() : hardExampleMiner_;
    }

    public static final int SECOND_STAGE_CLASSIFICATION_LOSS_FIELD_NUMBER = 29;
    private object_detection.protos.Losses.ClassificationLoss secondStageClassificationLoss_;
    /**
     * <pre>
     * Loss for second stage box classifers, supports Softmax and Sigmoid.
     * Note that score converter must be consistent with loss type.
     * When there are multiple labels assigned to the same boxes, recommend
     * to use sigmoid loss and enable merge_multiple_label_boxes.
     * If not specified, Softmax loss is used as default.
     * </pre>
     *
     * <code>optional .object_detection.protos.ClassificationLoss second_stage_classification_loss = 29;</code>
     * @return Whether the secondStageClassificationLoss field is set.
     */
    @java.lang.Override
    public boolean hasSecondStageClassificationLoss() {
      return ((bitField0_ & 0x08000000) != 0);
    }
    /**
     * <pre>
     * Loss for second stage box classifers, supports Softmax and Sigmoid.
     * Note that score converter must be consistent with loss type.
     * When there are multiple labels assigned to the same boxes, recommend
     * to use sigmoid loss and enable merge_multiple_label_boxes.
     * If not specified, Softmax loss is used as default.
     * </pre>
     *
     * <code>optional .object_detection.protos.ClassificationLoss second_stage_classification_loss = 29;</code>
     * @return The secondStageClassificationLoss.
     */
    @java.lang.Override
    public object_detection.protos.Losses.ClassificationLoss getSecondStageClassificationLoss() {
      return secondStageClassificationLoss_ == null ? object_detection.protos.Losses.ClassificationLoss.getDefaultInstance() : secondStageClassificationLoss_;
    }
    /**
     * <pre>
     * Loss for second stage box classifers, supports Softmax and Sigmoid.
     * Note that score converter must be consistent with loss type.
     * When there are multiple labels assigned to the same boxes, recommend
     * to use sigmoid loss and enable merge_multiple_label_boxes.
     * If not specified, Softmax loss is used as default.
     * </pre>
     *
     * <code>optional .object_detection.protos.ClassificationLoss second_stage_classification_loss = 29;</code>
     */
    @java.lang.Override
    public object_detection.protos.Losses.ClassificationLossOrBuilder getSecondStageClassificationLossOrBuilder() {
      return secondStageClassificationLoss_ == null ? object_detection.protos.Losses.ClassificationLoss.getDefaultInstance() : secondStageClassificationLoss_;
    }

    public static final int INPLACE_BATCHNORM_UPDATE_FIELD_NUMBER = 30;
    private boolean inplaceBatchnormUpdate_;
    /**
     * <pre>
     * Whether to update batch_norm inplace during training. This is required
     * for batch norm to work correctly on TPUs. When this is false, user must add
     * a control dependency on tf.GraphKeys.UPDATE_OPS for train/loss op in order
     * to update the batch norm moving average parameters.
     * </pre>
     *
     * <code>optional bool inplace_batchnorm_update = 30 [default = false];</code>
     * @return Whether the inplaceBatchnormUpdate field is set.
     */
    @java.lang.Override
    public boolean hasInplaceBatchnormUpdate() {
      return ((bitField0_ & 0x10000000) != 0);
    }
    /**
     * <pre>
     * Whether to update batch_norm inplace during training. This is required
     * for batch norm to work correctly on TPUs. When this is false, user must add
     * a control dependency on tf.GraphKeys.UPDATE_OPS for train/loss op in order
     * to update the batch norm moving average parameters.
     * </pre>
     *
     * <code>optional bool inplace_batchnorm_update = 30 [default = false];</code>
     * @return The inplaceBatchnormUpdate.
     */
    @java.lang.Override
    public boolean getInplaceBatchnormUpdate() {
      return inplaceBatchnormUpdate_;
    }

    public static final int USE_MATMUL_CROP_AND_RESIZE_FIELD_NUMBER = 31;
    private boolean useMatmulCropAndResize_;
    /**
     * <pre>
     * Force the use of matrix multiplication based crop and resize instead of
     * standard tf.image.crop_and_resize while computing second stage input
     * feature maps.
     * </pre>
     *
     * <code>optional bool use_matmul_crop_and_resize = 31 [default = false];</code>
     * @return Whether the useMatmulCropAndResize field is set.
     */
    @java.lang.Override
    public boolean hasUseMatmulCropAndResize() {
      return ((bitField0_ & 0x20000000) != 0);
    }
    /**
     * <pre>
     * Force the use of matrix multiplication based crop and resize instead of
     * standard tf.image.crop_and_resize while computing second stage input
     * feature maps.
     * </pre>
     *
     * <code>optional bool use_matmul_crop_and_resize = 31 [default = false];</code>
     * @return The useMatmulCropAndResize.
     */
    @java.lang.Override
    public boolean getUseMatmulCropAndResize() {
      return useMatmulCropAndResize_;
    }

    public static final int CLIP_ANCHORS_TO_IMAGE_FIELD_NUMBER = 32;
    private boolean clipAnchorsToImage_;
    /**
     * <pre>
     * Normally, anchors generated for a given image size are pruned during
     * training if they lie outside the image window. Setting this option to true,
     * clips the anchors to be within the image instead of pruning.
     * </pre>
     *
     * <code>optional bool clip_anchors_to_image = 32 [default = false];</code>
     * @return Whether the clipAnchorsToImage field is set.
     */
    @java.lang.Override
    public boolean hasClipAnchorsToImage() {
      return ((bitField0_ & 0x40000000) != 0);
    }
    /**
     * <pre>
     * Normally, anchors generated for a given image size are pruned during
     * training if they lie outside the image window. Setting this option to true,
     * clips the anchors to be within the image instead of pruning.
     * </pre>
     *
     * <code>optional bool clip_anchors_to_image = 32 [default = false];</code>
     * @return The clipAnchorsToImage.
     */
    @java.lang.Override
    public boolean getClipAnchorsToImage() {
      return clipAnchorsToImage_;
    }

    public static final int USE_MATMUL_GATHER_IN_MATCHER_FIELD_NUMBER = 33;
    private boolean useMatmulGatherInMatcher_;
    /**
     * <pre>
     * After peforming matching between anchors and targets, in order to pull out
     * targets for training Faster R-CNN meta architecture we perform a gather
     * operation. This options specifies whether to use an alternate
     * implementation of tf.gather that is faster on TPUs.
     * </pre>
     *
     * <code>optional bool use_matmul_gather_in_matcher = 33 [default = false];</code>
     * @return Whether the useMatmulGatherInMatcher field is set.
     */
    @java.lang.Override
    public boolean hasUseMatmulGatherInMatcher() {
      return ((bitField0_ & 0x80000000) != 0);
    }
    /**
     * <pre>
     * After peforming matching between anchors and targets, in order to pull out
     * targets for training Faster R-CNN meta architecture we perform a gather
     * operation. This options specifies whether to use an alternate
     * implementation of tf.gather that is faster on TPUs.
     * </pre>
     *
     * <code>optional bool use_matmul_gather_in_matcher = 33 [default = false];</code>
     * @return The useMatmulGatherInMatcher.
     */
    @java.lang.Override
    public boolean getUseMatmulGatherInMatcher() {
      return useMatmulGatherInMatcher_;
    }

    public static final int USE_STATIC_BALANCED_LABEL_SAMPLER_FIELD_NUMBER = 34;
    private boolean useStaticBalancedLabelSampler_;
    /**
     * <pre>
     * Whether to use the balanced positive negative sampler implementation with
     * static shape guarantees.
     * </pre>
     *
     * <code>optional bool use_static_balanced_label_sampler = 34 [default = false];</code>
     * @return Whether the useStaticBalancedLabelSampler field is set.
     */
    @java.lang.Override
    public boolean hasUseStaticBalancedLabelSampler() {
      return ((bitField1_ & 0x00000001) != 0);
    }
    /**
     * <pre>
     * Whether to use the balanced positive negative sampler implementation with
     * static shape guarantees.
     * </pre>
     *
     * <code>optional bool use_static_balanced_label_sampler = 34 [default = false];</code>
     * @return The useStaticBalancedLabelSampler.
     */
    @java.lang.Override
    public boolean getUseStaticBalancedLabelSampler() {
      return useStaticBalancedLabelSampler_;
    }

    public static final int USE_STATIC_SHAPES_FIELD_NUMBER = 35;
    private boolean useStaticShapes_;
    /**
     * <pre>
     * If True, uses implementation of ops with static shape guarantees.
     * </pre>
     *
     * <code>optional bool use_static_shapes = 35 [default = false];</code>
     * @return Whether the useStaticShapes field is set.
     */
    @java.lang.Override
    public boolean hasUseStaticShapes() {
      return ((bitField1_ & 0x00000002) != 0);
    }
    /**
     * <pre>
     * If True, uses implementation of ops with static shape guarantees.
     * </pre>
     *
     * <code>optional bool use_static_shapes = 35 [default = false];</code>
     * @return The useStaticShapes.
     */
    @java.lang.Override
    public boolean getUseStaticShapes() {
      return useStaticShapes_;
    }

    public static final int RESIZE_MASKS_FIELD_NUMBER = 36;
    private boolean resizeMasks_;
    /**
     * <pre>
     * Whether the masks present in groundtruth should be resized in the model to
     * match the image size.
     * </pre>
     *
     * <code>optional bool resize_masks = 36 [default = true];</code>
     * @return Whether the resizeMasks field is set.
     */
    @java.lang.Override
    public boolean hasResizeMasks() {
      return ((bitField1_ & 0x00000004) != 0);
    }
    /**
     * <pre>
     * Whether the masks present in groundtruth should be resized in the model to
     * match the image size.
     * </pre>
     *
     * <code>optional bool resize_masks = 36 [default = true];</code>
     * @return The resizeMasks.
     */
    @java.lang.Override
    public boolean getResizeMasks() {
      return resizeMasks_;
    }

    public static final int USE_STATIC_SHAPES_FOR_EVAL_FIELD_NUMBER = 37;
    private boolean useStaticShapesForEval_;
    /**
     * <pre>
     * If True, uses implementation of ops with static shape guarantees when
     * running evaluation (specifically not is_training if False).
     * </pre>
     *
     * <code>optional bool use_static_shapes_for_eval = 37 [default = false];</code>
     * @return Whether the useStaticShapesForEval field is set.
     */
    @java.lang.Override
    public boolean hasUseStaticShapesForEval() {
      return ((bitField1_ & 0x00000008) != 0);
    }
    /**
     * <pre>
     * If True, uses implementation of ops with static shape guarantees when
     * running evaluation (specifically not is_training if False).
     * </pre>
     *
     * <code>optional bool use_static_shapes_for_eval = 37 [default = false];</code>
     * @return The useStaticShapesForEval.
     */
    @java.lang.Override
    public boolean getUseStaticShapesForEval() {
      return useStaticShapesForEval_;
    }

    public static final int USE_PARTITIONED_NMS_IN_FIRST_STAGE_FIELD_NUMBER = 38;
    private boolean usePartitionedNmsInFirstStage_;
    /**
     * <pre>
     * If true, uses implementation of partitioned_non_max_suppression in first
     * stage.
     * </pre>
     *
     * <code>optional bool use_partitioned_nms_in_first_stage = 38 [default = true];</code>
     * @return Whether the usePartitionedNmsInFirstStage field is set.
     */
    @java.lang.Override
    public boolean hasUsePartitionedNmsInFirstStage() {
      return ((bitField1_ & 0x00000010) != 0);
    }
    /**
     * <pre>
     * If true, uses implementation of partitioned_non_max_suppression in first
     * stage.
     * </pre>
     *
     * <code>optional bool use_partitioned_nms_in_first_stage = 38 [default = true];</code>
     * @return The usePartitionedNmsInFirstStage.
     */
    @java.lang.Override
    public boolean getUsePartitionedNmsInFirstStage() {
      return usePartitionedNmsInFirstStage_;
    }

    public static final int RETURN_RAW_DETECTIONS_DURING_PREDICT_FIELD_NUMBER = 39;
    private boolean returnRawDetectionsDuringPredict_;
    /**
     * <pre>
     * Whether to return raw detections (pre NMS).
     * </pre>
     *
     * <code>optional bool return_raw_detections_during_predict = 39 [default = false];</code>
     * @return Whether the returnRawDetectionsDuringPredict field is set.
     */
    @java.lang.Override
    public boolean hasReturnRawDetectionsDuringPredict() {
      return ((bitField1_ & 0x00000020) != 0);
    }
    /**
     * <pre>
     * Whether to return raw detections (pre NMS).
     * </pre>
     *
     * <code>optional bool return_raw_detections_during_predict = 39 [default = false];</code>
     * @return The returnRawDetectionsDuringPredict.
     */
    @java.lang.Override
    public boolean getReturnRawDetectionsDuringPredict() {
      return returnRawDetectionsDuringPredict_;
    }

    public static final int USE_COMBINED_NMS_IN_FIRST_STAGE_FIELD_NUMBER = 40;
    private boolean useCombinedNmsInFirstStage_;
    /**
     * <pre>
     * Whether to use tf.image.combined_non_max_suppression.
     * </pre>
     *
     * <code>optional bool use_combined_nms_in_first_stage = 40 [default = false];</code>
     * @return Whether the useCombinedNmsInFirstStage field is set.
     */
    @java.lang.Override
    public boolean hasUseCombinedNmsInFirstStage() {
      return ((bitField1_ & 0x00000040) != 0);
    }
    /**
     * <pre>
     * Whether to use tf.image.combined_non_max_suppression.
     * </pre>
     *
     * <code>optional bool use_combined_nms_in_first_stage = 40 [default = false];</code>
     * @return The useCombinedNmsInFirstStage.
     */
    @java.lang.Override
    public boolean getUseCombinedNmsInFirstStage() {
      return useCombinedNmsInFirstStage_;
    }

    public static final int OUTPUT_FINAL_BOX_FEATURES_FIELD_NUMBER = 42;
    private boolean outputFinalBoxFeatures_;
    /**
     * <pre>
     * Whether to output final box feature. If true, it will crop the rpn feature
     * map based on the final prediction boxes, then pass the crops through the
     * box_classifier to compute the final features in the postprocess() method.
     * </pre>
     *
     * <code>optional bool output_final_box_features = 42 [default = false];</code>
     * @return Whether the outputFinalBoxFeatures field is set.
     */
    @java.lang.Override
    public boolean hasOutputFinalBoxFeatures() {
      return ((bitField1_ & 0x00000080) != 0);
    }
    /**
     * <pre>
     * Whether to output final box feature. If true, it will crop the rpn feature
     * map based on the final prediction boxes, then pass the crops through the
     * box_classifier to compute the final features in the postprocess() method.
     * </pre>
     *
     * <code>optional bool output_final_box_features = 42 [default = false];</code>
     * @return The outputFinalBoxFeatures.
     */
    @java.lang.Override
    public boolean getOutputFinalBoxFeatures() {
      return outputFinalBoxFeatures_;
    }

    public static final int OUTPUT_FINAL_BOX_RPN_FEATURES_FIELD_NUMBER = 43;
    private boolean outputFinalBoxRpnFeatures_;
    /**
     * <pre>
     * Whether to output final box rpn features. If true, it will crop the rpn
     * feature map in the postprocess() method based on the final prediction
     * boxes.
     * </pre>
     *
     * <code>optional bool output_final_box_rpn_features = 43 [default = false];</code>
     * @return Whether the outputFinalBoxRpnFeatures field is set.
     */
    @java.lang.Override
    public boolean hasOutputFinalBoxRpnFeatures() {
      return ((bitField1_ & 0x00000100) != 0);
    }
    /**
     * <pre>
     * Whether to output final box rpn features. If true, it will crop the rpn
     * feature map in the postprocess() method based on the final prediction
     * boxes.
     * </pre>
     *
     * <code>optional bool output_final_box_rpn_features = 43 [default = false];</code>
     * @return The outputFinalBoxRpnFeatures.
     */
    @java.lang.Override
    public boolean getOutputFinalBoxRpnFeatures() {
      return outputFinalBoxRpnFeatures_;
    }

    public static final int CONTEXT_CONFIG_FIELD_NUMBER = 41;
    private object_detection.protos.FasterRcnnOuterClass.Context contextConfig_;
    /**
     * <pre>
     * Configs for context model.
     * </pre>
     *
     * <code>optional .object_detection.protos.Context context_config = 41;</code>
     * @return Whether the contextConfig field is set.
     */
    @java.lang.Override
    public boolean hasContextConfig() {
      return ((bitField1_ & 0x00000200) != 0);
    }
    /**
     * <pre>
     * Configs for context model.
     * </pre>
     *
     * <code>optional .object_detection.protos.Context context_config = 41;</code>
     * @return The contextConfig.
     */
    @java.lang.Override
    public object_detection.protos.FasterRcnnOuterClass.Context getContextConfig() {
      return contextConfig_ == null ? object_detection.protos.FasterRcnnOuterClass.Context.getDefaultInstance() : contextConfig_;
    }
    /**
     * <pre>
     * Configs for context model.
     * </pre>
     *
     * <code>optional .object_detection.protos.Context context_config = 41;</code>
     */
    @java.lang.Override
    public object_detection.protos.FasterRcnnOuterClass.ContextOrBuilder getContextConfigOrBuilder() {
      return contextConfig_ == null ? object_detection.protos.FasterRcnnOuterClass.Context.getDefaultInstance() : contextConfig_;
    }

    private byte memoizedIsInitialized = -1;
    @java.lang.Override
    public final boolean isInitialized() {
      byte isInitialized = memoizedIsInitialized;
      if (isInitialized == 1) return true;
      if (isInitialized == 0) return false;

      memoizedIsInitialized = 1;
      return true;
    }

    @java.lang.Override
    public void writeTo(com.google.protobuf.CodedOutputStream output)
                        throws java.io.IOException {
      if (((bitField0_ & 0x00000001) != 0)) {
        output.writeInt32(1, numberOfStages_);
      }
      if (((bitField0_ & 0x00000002) != 0)) {
        output.writeInt32(3, numClasses_);
      }
      if (((bitField0_ & 0x00000004) != 0)) {
        output.writeMessage(4, getImageResizer());
      }
      if (((bitField0_ & 0x00000008) != 0)) {
        output.writeMessage(5, getFeatureExtractor());
      }
      if (((bitField0_ & 0x00000010) != 0)) {
        output.writeMessage(6, getFirstStageAnchorGenerator());
      }
      if (((bitField0_ & 0x00000020) != 0)) {
        output.writeInt32(7, firstStageAtrousRate_);
      }
      if (((bitField0_ & 0x00000040) != 0)) {
        output.writeMessage(8, getFirstStageBoxPredictorConvHyperparams());
      }
      if (((bitField0_ & 0x00000080) != 0)) {
        output.writeInt32(9, firstStageBoxPredictorKernelSize_);
      }
      if (((bitField0_ & 0x00000100) != 0)) {
        output.writeInt32(10, firstStageBoxPredictorDepth_);
      }
      if (((bitField0_ & 0x00000200) != 0)) {
        output.writeInt32(11, firstStageMinibatchSize_);
      }
      if (((bitField0_ & 0x00000400) != 0)) {
        output.writeFloat(12, firstStagePositiveBalanceFraction_);
      }
      if (((bitField0_ & 0x00000800) != 0)) {
        output.writeFloat(13, firstStageNmsScoreThreshold_);
      }
      if (((bitField0_ & 0x00001000) != 0)) {
        output.writeFloat(14, firstStageNmsIouThreshold_);
      }
      if (((bitField0_ & 0x00002000) != 0)) {
        output.writeInt32(15, firstStageMaxProposals_);
      }
      if (((bitField0_ & 0x00004000) != 0)) {
        output.writeFloat(16, firstStageLocalizationLossWeight_);
      }
      if (((bitField0_ & 0x00008000) != 0)) {
        output.writeFloat(17, firstStageObjectnessLossWeight_);
      }
      if (((bitField0_ & 0x00010000) != 0)) {
        output.writeInt32(18, initialCropSize_);
      }
      if (((bitField0_ & 0x00020000) != 0)) {
        output.writeInt32(19, maxpoolKernelSize_);
      }
      if (((bitField0_ & 0x00040000) != 0)) {
        output.writeInt32(20, maxpoolStride_);
      }
      if (((bitField0_ & 0x00080000) != 0)) {
        output.writeMessage(21, getSecondStageBoxPredictor());
      }
      if (((bitField0_ & 0x00100000) != 0)) {
        output.writeInt32(22, secondStageBatchSize_);
      }
      if (((bitField0_ & 0x00200000) != 0)) {
        output.writeFloat(23, secondStageBalanceFraction_);
      }
      if (((bitField0_ & 0x00400000) != 0)) {
        output.writeMessage(24, getSecondStagePostProcessing());
      }
      if (((bitField0_ & 0x00800000) != 0)) {
        output.writeFloat(25, secondStageLocalizationLossWeight_);
      }
      if (((bitField0_ & 0x01000000) != 0)) {
        output.writeFloat(26, secondStageClassificationLossWeight_);
      }
      if (((bitField0_ & 0x02000000) != 0)) {
        output.writeFloat(27, secondStageMaskPredictionLossWeight_);
      }
      if (((bitField0_ & 0x04000000) != 0)) {
        output.writeMessage(28, getHardExampleMiner());
      }
      if (((bitField0_ & 0x08000000) != 0)) {
        output.writeMessage(29, getSecondStageClassificationLoss());
      }
      if (((bitField0_ & 0x10000000) != 0)) {
        output.writeBool(30, inplaceBatchnormUpdate_);
      }
      if (((bitField0_ & 0x20000000) != 0)) {
        output.writeBool(31, useMatmulCropAndResize_);
      }
      if (((bitField0_ & 0x40000000) != 0)) {
        output.writeBool(32, clipAnchorsToImage_);
      }
      if (((bitField0_ & 0x80000000) != 0)) {
        output.writeBool(33, useMatmulGatherInMatcher_);
      }
      if (((bitField1_ & 0x00000001) != 0)) {
        output.writeBool(34, useStaticBalancedLabelSampler_);
      }
      if (((bitField1_ & 0x00000002) != 0)) {
        output.writeBool(35, useStaticShapes_);
      }
      if (((bitField1_ & 0x00000004) != 0)) {
        output.writeBool(36, resizeMasks_);
      }
      if (((bitField1_ & 0x00000008) != 0)) {
        output.writeBool(37, useStaticShapesForEval_);
      }
      if (((bitField1_ & 0x00000010) != 0)) {
        output.writeBool(38, usePartitionedNmsInFirstStage_);
      }
      if (((bitField1_ & 0x00000020) != 0)) {
        output.writeBool(39, returnRawDetectionsDuringPredict_);
      }
      if (((bitField1_ & 0x00000040) != 0)) {
        output.writeBool(40, useCombinedNmsInFirstStage_);
      }
      if (((bitField1_ & 0x00000200) != 0)) {
        output.writeMessage(41, getContextConfig());
      }
      if (((bitField1_ & 0x00000080) != 0)) {
        output.writeBool(42, outputFinalBoxFeatures_);
      }
      if (((bitField1_ & 0x00000100) != 0)) {
        output.writeBool(43, outputFinalBoxRpnFeatures_);
      }
      unknownFields.writeTo(output);
    }

    @java.lang.Override
    public int getSerializedSize() {
      int size = memoizedSize;
      if (size != -1) return size;

      size = 0;
      if (((bitField0_ & 0x00000001) != 0)) {
        size += com.google.protobuf.CodedOutputStream
          .computeInt32Size(1, numberOfStages_);
      }
      if (((bitField0_ & 0x00000002) != 0)) {
        size += com.google.protobuf.CodedOutputStream
          .computeInt32Size(3, numClasses_);
      }
      if (((bitField0_ & 0x00000004) != 0)) {
        size += com.google.protobuf.CodedOutputStream
          .computeMessageSize(4, getImageResizer());
      }
      if (((bitField0_ & 0x00000008) != 0)) {
        size += com.google.protobuf.CodedOutputStream
          .computeMessageSize(5, getFeatureExtractor());
      }
      if (((bitField0_ & 0x00000010) != 0)) {
        size += com.google.protobuf.CodedOutputStream
          .computeMessageSize(6, getFirstStageAnchorGenerator());
      }
      if (((bitField0_ & 0x00000020) != 0)) {
        size += com.google.protobuf.CodedOutputStream
          .computeInt32Size(7, firstStageAtrousRate_);
      }
      if (((bitField0_ & 0x00000040) != 0)) {
        size += com.google.protobuf.CodedOutputStream
          .computeMessageSize(8, getFirstStageBoxPredictorConvHyperparams());
      }
      if (((bitField0_ & 0x00000080) != 0)) {
        size += com.google.protobuf.CodedOutputStream
          .computeInt32Size(9, firstStageBoxPredictorKernelSize_);
      }
      if (((bitField0_ & 0x00000100) != 0)) {
        size += com.google.protobuf.CodedOutputStream
          .computeInt32Size(10, firstStageBoxPredictorDepth_);
      }
      if (((bitField0_ & 0x00000200) != 0)) {
        size += com.google.protobuf.CodedOutputStream
          .computeInt32Size(11, firstStageMinibatchSize_);
      }
      if (((bitField0_ & 0x00000400) != 0)) {
        size += com.google.protobuf.CodedOutputStream
          .computeFloatSize(12, firstStagePositiveBalanceFraction_);
      }
      if (((bitField0_ & 0x00000800) != 0)) {
        size += com.google.protobuf.CodedOutputStream
          .computeFloatSize(13, firstStageNmsScoreThreshold_);
      }
      if (((bitField0_ & 0x00001000) != 0)) {
        size += com.google.protobuf.CodedOutputStream
          .computeFloatSize(14, firstStageNmsIouThreshold_);
      }
      if (((bitField0_ & 0x00002000) != 0)) {
        size += com.google.protobuf.CodedOutputStream
          .computeInt32Size(15, firstStageMaxProposals_);
      }
      if (((bitField0_ & 0x00004000) != 0)) {
        size += com.google.protobuf.CodedOutputStream
          .computeFloatSize(16, firstStageLocalizationLossWeight_);
      }
      if (((bitField0_ & 0x00008000) != 0)) {
        size += com.google.protobuf.CodedOutputStream
          .computeFloatSize(17, firstStageObjectnessLossWeight_);
      }
      if (((bitField0_ & 0x00010000) != 0)) {
        size += com.google.protobuf.CodedOutputStream
          .computeInt32Size(18, initialCropSize_);
      }
      if (((bitField0_ & 0x00020000) != 0)) {
        size += com.google.protobuf.CodedOutputStream
          .computeInt32Size(19, maxpoolKernelSize_);
      }
      if (((bitField0_ & 0x00040000) != 0)) {
        size += com.google.protobuf.CodedOutputStream
          .computeInt32Size(20, maxpoolStride_);
      }
      if (((bitField0_ & 0x00080000) != 0)) {
        size += com.google.protobuf.CodedOutputStream
          .computeMessageSize(21, getSecondStageBoxPredictor());
      }
      if (((bitField0_ & 0x00100000) != 0)) {
        size += com.google.protobuf.CodedOutputStream
          .computeInt32Size(22, secondStageBatchSize_);
      }
      if (((bitField0_ & 0x00200000) != 0)) {
        size += com.google.protobuf.CodedOutputStream
          .computeFloatSize(23, secondStageBalanceFraction_);
      }
      if (((bitField0_ & 0x00400000) != 0)) {
        size += com.google.protobuf.CodedOutputStream
          .computeMessageSize(24, getSecondStagePostProcessing());
      }
      if (((bitField0_ & 0x00800000) != 0)) {
        size += com.google.protobuf.CodedOutputStream
          .computeFloatSize(25, secondStageLocalizationLossWeight_);
      }
      if (((bitField0_ & 0x01000000) != 0)) {
        size += com.google.protobuf.CodedOutputStream
          .computeFloatSize(26, secondStageClassificationLossWeight_);
      }
      if (((bitField0_ & 0x02000000) != 0)) {
        size += com.google.protobuf.CodedOutputStream
          .computeFloatSize(27, secondStageMaskPredictionLossWeight_);
      }
      if (((bitField0_ & 0x04000000) != 0)) {
        size += com.google.protobuf.CodedOutputStream
          .computeMessageSize(28, getHardExampleMiner());
      }
      if (((bitField0_ & 0x08000000) != 0)) {
        size += com.google.protobuf.CodedOutputStream
          .computeMessageSize(29, getSecondStageClassificationLoss());
      }
      if (((bitField0_ & 0x10000000) != 0)) {
        size += com.google.protobuf.CodedOutputStream
          .computeBoolSize(30, inplaceBatchnormUpdate_);
      }
      if (((bitField0_ & 0x20000000) != 0)) {
        size += com.google.protobuf.CodedOutputStream
          .computeBoolSize(31, useMatmulCropAndResize_);
      }
      if (((bitField0_ & 0x40000000) != 0)) {
        size += com.google.protobuf.CodedOutputStream
          .computeBoolSize(32, clipAnchorsToImage_);
      }
      if (((bitField0_ & 0x80000000) != 0)) {
        size += com.google.protobuf.CodedOutputStream
          .computeBoolSize(33, useMatmulGatherInMatcher_);
      }
      if (((bitField1_ & 0x00000001) != 0)) {
        size += com.google.protobuf.CodedOutputStream
          .computeBoolSize(34, useStaticBalancedLabelSampler_);
      }
      if (((bitField1_ & 0x00000002) != 0)) {
        size += com.google.protobuf.CodedOutputStream
          .computeBoolSize(35, useStaticShapes_);
      }
      if (((bitField1_ & 0x00000004) != 0)) {
        size += com.google.protobuf.CodedOutputStream
          .computeBoolSize(36, resizeMasks_);
      }
      if (((bitField1_ & 0x00000008) != 0)) {
        size += com.google.protobuf.CodedOutputStream
          .computeBoolSize(37, useStaticShapesForEval_);
      }
      if (((bitField1_ & 0x00000010) != 0)) {
        size += com.google.protobuf.CodedOutputStream
          .computeBoolSize(38, usePartitionedNmsInFirstStage_);
      }
      if (((bitField1_ & 0x00000020) != 0)) {
        size += com.google.protobuf.CodedOutputStream
          .computeBoolSize(39, returnRawDetectionsDuringPredict_);
      }
      if (((bitField1_ & 0x00000040) != 0)) {
        size += com.google.protobuf.CodedOutputStream
          .computeBoolSize(40, useCombinedNmsInFirstStage_);
      }
      if (((bitField1_ & 0x00000200) != 0)) {
        size += com.google.protobuf.CodedOutputStream
          .computeMessageSize(41, getContextConfig());
      }
      if (((bitField1_ & 0x00000080) != 0)) {
        size += com.google.protobuf.CodedOutputStream
          .computeBoolSize(42, outputFinalBoxFeatures_);
      }
      if (((bitField1_ & 0x00000100) != 0)) {
        size += com.google.protobuf.CodedOutputStream
          .computeBoolSize(43, outputFinalBoxRpnFeatures_);
      }
      size += unknownFields.getSerializedSize();
      memoizedSize = size;
      return size;
    }

    @java.lang.Override
    public boolean equals(final java.lang.Object obj) {
      if (obj == this) {
       return true;
      }
      if (!(obj instanceof object_detection.protos.FasterRcnnOuterClass.FasterRcnn)) {
        return super.equals(obj);
      }
      object_detection.protos.FasterRcnnOuterClass.FasterRcnn other = (object_detection.protos.FasterRcnnOuterClass.FasterRcnn) obj;

      if (hasNumberOfStages() != other.hasNumberOfStages()) return false;
      if (hasNumberOfStages()) {
        if (getNumberOfStages()
            != other.getNumberOfStages()) return false;
      }
      if (hasNumClasses() != other.hasNumClasses()) return false;
      if (hasNumClasses()) {
        if (getNumClasses()
            != other.getNumClasses()) return false;
      }
      if (hasImageResizer() != other.hasImageResizer()) return false;
      if (hasImageResizer()) {
        if (!getImageResizer()
            .equals(other.getImageResizer())) return false;
      }
      if (hasFeatureExtractor() != other.hasFeatureExtractor()) return false;
      if (hasFeatureExtractor()) {
        if (!getFeatureExtractor()
            .equals(other.getFeatureExtractor())) return false;
      }
      if (hasFirstStageAnchorGenerator() != other.hasFirstStageAnchorGenerator()) return false;
      if (hasFirstStageAnchorGenerator()) {
        if (!getFirstStageAnchorGenerator()
            .equals(other.getFirstStageAnchorGenerator())) return false;
      }
      if (hasFirstStageAtrousRate() != other.hasFirstStageAtrousRate()) return false;
      if (hasFirstStageAtrousRate()) {
        if (getFirstStageAtrousRate()
            != other.getFirstStageAtrousRate()) return false;
      }
      if (hasFirstStageBoxPredictorConvHyperparams() != other.hasFirstStageBoxPredictorConvHyperparams()) return false;
      if (hasFirstStageBoxPredictorConvHyperparams()) {
        if (!getFirstStageBoxPredictorConvHyperparams()
            .equals(other.getFirstStageBoxPredictorConvHyperparams())) return false;
      }
      if (hasFirstStageBoxPredictorKernelSize() != other.hasFirstStageBoxPredictorKernelSize()) return false;
      if (hasFirstStageBoxPredictorKernelSize()) {
        if (getFirstStageBoxPredictorKernelSize()
            != other.getFirstStageBoxPredictorKernelSize()) return false;
      }
      if (hasFirstStageBoxPredictorDepth() != other.hasFirstStageBoxPredictorDepth()) return false;
      if (hasFirstStageBoxPredictorDepth()) {
        if (getFirstStageBoxPredictorDepth()
            != other.getFirstStageBoxPredictorDepth()) return false;
      }
      if (hasFirstStageMinibatchSize() != other.hasFirstStageMinibatchSize()) return false;
      if (hasFirstStageMinibatchSize()) {
        if (getFirstStageMinibatchSize()
            != other.getFirstStageMinibatchSize()) return false;
      }
      if (hasFirstStagePositiveBalanceFraction() != other.hasFirstStagePositiveBalanceFraction()) return false;
      if (hasFirstStagePositiveBalanceFraction()) {
        if (java.lang.Float.floatToIntBits(getFirstStagePositiveBalanceFraction())
            != java.lang.Float.floatToIntBits(
                other.getFirstStagePositiveBalanceFraction())) return false;
      }
      if (hasFirstStageNmsScoreThreshold() != other.hasFirstStageNmsScoreThreshold()) return false;
      if (hasFirstStageNmsScoreThreshold()) {
        if (java.lang.Float.floatToIntBits(getFirstStageNmsScoreThreshold())
            != java.lang.Float.floatToIntBits(
                other.getFirstStageNmsScoreThreshold())) return false;
      }
      if (hasFirstStageNmsIouThreshold() != other.hasFirstStageNmsIouThreshold()) return false;
      if (hasFirstStageNmsIouThreshold()) {
        if (java.lang.Float.floatToIntBits(getFirstStageNmsIouThreshold())
            != java.lang.Float.floatToIntBits(
                other.getFirstStageNmsIouThreshold())) return false;
      }
      if (hasFirstStageMaxProposals() != other.hasFirstStageMaxProposals()) return false;
      if (hasFirstStageMaxProposals()) {
        if (getFirstStageMaxProposals()
            != other.getFirstStageMaxProposals()) return false;
      }
      if (hasFirstStageLocalizationLossWeight() != other.hasFirstStageLocalizationLossWeight()) return false;
      if (hasFirstStageLocalizationLossWeight()) {
        if (java.lang.Float.floatToIntBits(getFirstStageLocalizationLossWeight())
            != java.lang.Float.floatToIntBits(
                other.getFirstStageLocalizationLossWeight())) return false;
      }
      if (hasFirstStageObjectnessLossWeight() != other.hasFirstStageObjectnessLossWeight()) return false;
      if (hasFirstStageObjectnessLossWeight()) {
        if (java.lang.Float.floatToIntBits(getFirstStageObjectnessLossWeight())
            != java.lang.Float.floatToIntBits(
                other.getFirstStageObjectnessLossWeight())) return false;
      }
      if (hasInitialCropSize() != other.hasInitialCropSize()) return false;
      if (hasInitialCropSize()) {
        if (getInitialCropSize()
            != other.getInitialCropSize()) return false;
      }
      if (hasMaxpoolKernelSize() != other.hasMaxpoolKernelSize()) return false;
      if (hasMaxpoolKernelSize()) {
        if (getMaxpoolKernelSize()
            != other.getMaxpoolKernelSize()) return false;
      }
      if (hasMaxpoolStride() != other.hasMaxpoolStride()) return false;
      if (hasMaxpoolStride()) {
        if (getMaxpoolStride()
            != other.getMaxpoolStride()) return false;
      }
      if (hasSecondStageBoxPredictor() != other.hasSecondStageBoxPredictor()) return false;
      if (hasSecondStageBoxPredictor()) {
        if (!getSecondStageBoxPredictor()
            .equals(other.getSecondStageBoxPredictor())) return false;
      }
      if (hasSecondStageBatchSize() != other.hasSecondStageBatchSize()) return false;
      if (hasSecondStageBatchSize()) {
        if (getSecondStageBatchSize()
            != other.getSecondStageBatchSize()) return false;
      }
      if (hasSecondStageBalanceFraction() != other.hasSecondStageBalanceFraction()) return false;
      if (hasSecondStageBalanceFraction()) {
        if (java.lang.Float.floatToIntBits(getSecondStageBalanceFraction())
            != java.lang.Float.floatToIntBits(
                other.getSecondStageBalanceFraction())) return false;
      }
      if (hasSecondStagePostProcessing() != other.hasSecondStagePostProcessing()) return false;
      if (hasSecondStagePostProcessing()) {
        if (!getSecondStagePostProcessing()
            .equals(other.getSecondStagePostProcessing())) return false;
      }
      if (hasSecondStageLocalizationLossWeight() != other.hasSecondStageLocalizationLossWeight()) return false;
      if (hasSecondStageLocalizationLossWeight()) {
        if (java.lang.Float.floatToIntBits(getSecondStageLocalizationLossWeight())
            != java.lang.Float.floatToIntBits(
                other.getSecondStageLocalizationLossWeight())) return false;
      }
      if (hasSecondStageClassificationLossWeight() != other.hasSecondStageClassificationLossWeight()) return false;
      if (hasSecondStageClassificationLossWeight()) {
        if (java.lang.Float.floatToIntBits(getSecondStageClassificationLossWeight())
            != java.lang.Float.floatToIntBits(
                other.getSecondStageClassificationLossWeight())) return false;
      }
      if (hasSecondStageMaskPredictionLossWeight() != other.hasSecondStageMaskPredictionLossWeight()) return false;
      if (hasSecondStageMaskPredictionLossWeight()) {
        if (java.lang.Float.floatToIntBits(getSecondStageMaskPredictionLossWeight())
            != java.lang.Float.floatToIntBits(
                other.getSecondStageMaskPredictionLossWeight())) return false;
      }
      if (hasHardExampleMiner() != other.hasHardExampleMiner()) return false;
      if (hasHardExampleMiner()) {
        if (!getHardExampleMiner()
            .equals(other.getHardExampleMiner())) return false;
      }
      if (hasSecondStageClassificationLoss() != other.hasSecondStageClassificationLoss()) return false;
      if (hasSecondStageClassificationLoss()) {
        if (!getSecondStageClassificationLoss()
            .equals(other.getSecondStageClassificationLoss())) return false;
      }
      if (hasInplaceBatchnormUpdate() != other.hasInplaceBatchnormUpdate()) return false;
      if (hasInplaceBatchnormUpdate()) {
        if (getInplaceBatchnormUpdate()
            != other.getInplaceBatchnormUpdate()) return false;
      }
      if (hasUseMatmulCropAndResize() != other.hasUseMatmulCropAndResize()) return false;
      if (hasUseMatmulCropAndResize()) {
        if (getUseMatmulCropAndResize()
            != other.getUseMatmulCropAndResize()) return false;
      }
      if (hasClipAnchorsToImage() != other.hasClipAnchorsToImage()) return false;
      if (hasClipAnchorsToImage()) {
        if (getClipAnchorsToImage()
            != other.getClipAnchorsToImage()) return false;
      }
      if (hasUseMatmulGatherInMatcher() != other.hasUseMatmulGatherInMatcher()) return false;
      if (hasUseMatmulGatherInMatcher()) {
        if (getUseMatmulGatherInMatcher()
            != other.getUseMatmulGatherInMatcher()) return false;
      }
      if (hasUseStaticBalancedLabelSampler() != other.hasUseStaticBalancedLabelSampler()) return false;
      if (hasUseStaticBalancedLabelSampler()) {
        if (getUseStaticBalancedLabelSampler()
            != other.getUseStaticBalancedLabelSampler()) return false;
      }
      if (hasUseStaticShapes() != other.hasUseStaticShapes()) return false;
      if (hasUseStaticShapes()) {
        if (getUseStaticShapes()
            != other.getUseStaticShapes()) return false;
      }
      if (hasResizeMasks() != other.hasResizeMasks()) return false;
      if (hasResizeMasks()) {
        if (getResizeMasks()
            != other.getResizeMasks()) return false;
      }
      if (hasUseStaticShapesForEval() != other.hasUseStaticShapesForEval()) return false;
      if (hasUseStaticShapesForEval()) {
        if (getUseStaticShapesForEval()
            != other.getUseStaticShapesForEval()) return false;
      }
      if (hasUsePartitionedNmsInFirstStage() != other.hasUsePartitionedNmsInFirstStage()) return false;
      if (hasUsePartitionedNmsInFirstStage()) {
        if (getUsePartitionedNmsInFirstStage()
            != other.getUsePartitionedNmsInFirstStage()) return false;
      }
      if (hasReturnRawDetectionsDuringPredict() != other.hasReturnRawDetectionsDuringPredict()) return false;
      if (hasReturnRawDetectionsDuringPredict()) {
        if (getReturnRawDetectionsDuringPredict()
            != other.getReturnRawDetectionsDuringPredict()) return false;
      }
      if (hasUseCombinedNmsInFirstStage() != other.hasUseCombinedNmsInFirstStage()) return false;
      if (hasUseCombinedNmsInFirstStage()) {
        if (getUseCombinedNmsInFirstStage()
            != other.getUseCombinedNmsInFirstStage()) return false;
      }
      if (hasOutputFinalBoxFeatures() != other.hasOutputFinalBoxFeatures()) return false;
      if (hasOutputFinalBoxFeatures()) {
        if (getOutputFinalBoxFeatures()
            != other.getOutputFinalBoxFeatures()) return false;
      }
      if (hasOutputFinalBoxRpnFeatures() != other.hasOutputFinalBoxRpnFeatures()) return false;
      if (hasOutputFinalBoxRpnFeatures()) {
        if (getOutputFinalBoxRpnFeatures()
            != other.getOutputFinalBoxRpnFeatures()) return false;
      }
      if (hasContextConfig() != other.hasContextConfig()) return false;
      if (hasContextConfig()) {
        if (!getContextConfig()
            .equals(other.getContextConfig())) return false;
      }
      if (!unknownFields.equals(other.unknownFields)) return false;
      return true;
    }

    @java.lang.Override
    public int hashCode() {
      if (memoizedHashCode != 0) {
        return memoizedHashCode;
      }
      int hash = 41;
      hash = (19 * hash) + getDescriptor().hashCode();
      if (hasNumberOfStages()) {
        hash = (37 * hash) + NUMBER_OF_STAGES_FIELD_NUMBER;
        hash = (53 * hash) + getNumberOfStages();
      }
      if (hasNumClasses()) {
        hash = (37 * hash) + NUM_CLASSES_FIELD_NUMBER;
        hash = (53 * hash) + getNumClasses();
      }
      if (hasImageResizer()) {
        hash = (37 * hash) + IMAGE_RESIZER_FIELD_NUMBER;
        hash = (53 * hash) + getImageResizer().hashCode();
      }
      if (hasFeatureExtractor()) {
        hash = (37 * hash) + FEATURE_EXTRACTOR_FIELD_NUMBER;
        hash = (53 * hash) + getFeatureExtractor().hashCode();
      }
      if (hasFirstStageAnchorGenerator()) {
        hash = (37 * hash) + FIRST_STAGE_ANCHOR_GENERATOR_FIELD_NUMBER;
        hash = (53 * hash) + getFirstStageAnchorGenerator().hashCode();
      }
      if (hasFirstStageAtrousRate()) {
        hash = (37 * hash) + FIRST_STAGE_ATROUS_RATE_FIELD_NUMBER;
        hash = (53 * hash) + getFirstStageAtrousRate();
      }
      if (hasFirstStageBoxPredictorConvHyperparams()) {
        hash = (37 * hash) + FIRST_STAGE_BOX_PREDICTOR_CONV_HYPERPARAMS_FIELD_NUMBER;
        hash = (53 * hash) + getFirstStageBoxPredictorConvHyperparams().hashCode();
      }
      if (hasFirstStageBoxPredictorKernelSize()) {
        hash = (37 * hash) + FIRST_STAGE_BOX_PREDICTOR_KERNEL_SIZE_FIELD_NUMBER;
        hash = (53 * hash) + getFirstStageBoxPredictorKernelSize();
      }
      if (hasFirstStageBoxPredictorDepth()) {
        hash = (37 * hash) + FIRST_STAGE_BOX_PREDICTOR_DEPTH_FIELD_NUMBER;
        hash = (53 * hash) + getFirstStageBoxPredictorDepth();
      }
      if (hasFirstStageMinibatchSize()) {
        hash = (37 * hash) + FIRST_STAGE_MINIBATCH_SIZE_FIELD_NUMBER;
        hash = (53 * hash) + getFirstStageMinibatchSize();
      }
      if (hasFirstStagePositiveBalanceFraction()) {
        hash = (37 * hash) + FIRST_STAGE_POSITIVE_BALANCE_FRACTION_FIELD_NUMBER;
        hash = (53 * hash) + java.lang.Float.floatToIntBits(
            getFirstStagePositiveBalanceFraction());
      }
      if (hasFirstStageNmsScoreThreshold()) {
        hash = (37 * hash) + FIRST_STAGE_NMS_SCORE_THRESHOLD_FIELD_NUMBER;
        hash = (53 * hash) + java.lang.Float.floatToIntBits(
            getFirstStageNmsScoreThreshold());
      }
      if (hasFirstStageNmsIouThreshold()) {
        hash = (37 * hash) + FIRST_STAGE_NMS_IOU_THRESHOLD_FIELD_NUMBER;
        hash = (53 * hash) + java.lang.Float.floatToIntBits(
            getFirstStageNmsIouThreshold());
      }
      if (hasFirstStageMaxProposals()) {
        hash = (37 * hash) + FIRST_STAGE_MAX_PROPOSALS_FIELD_NUMBER;
        hash = (53 * hash) + getFirstStageMaxProposals();
      }
      if (hasFirstStageLocalizationLossWeight()) {
        hash = (37 * hash) + FIRST_STAGE_LOCALIZATION_LOSS_WEIGHT_FIELD_NUMBER;
        hash = (53 * hash) + java.lang.Float.floatToIntBits(
            getFirstStageLocalizationLossWeight());
      }
      if (hasFirstStageObjectnessLossWeight()) {
        hash = (37 * hash) + FIRST_STAGE_OBJECTNESS_LOSS_WEIGHT_FIELD_NUMBER;
        hash = (53 * hash) + java.lang.Float.floatToIntBits(
            getFirstStageObjectnessLossWeight());
      }
      if (hasInitialCropSize()) {
        hash = (37 * hash) + INITIAL_CROP_SIZE_FIELD_NUMBER;
        hash = (53 * hash) + getInitialCropSize();
      }
      if (hasMaxpoolKernelSize()) {
        hash = (37 * hash) + MAXPOOL_KERNEL_SIZE_FIELD_NUMBER;
        hash = (53 * hash) + getMaxpoolKernelSize();
      }
      if (hasMaxpoolStride()) {
        hash = (37 * hash) + MAXPOOL_STRIDE_FIELD_NUMBER;
        hash = (53 * hash) + getMaxpoolStride();
      }
      if (hasSecondStageBoxPredictor()) {
        hash = (37 * hash) + SECOND_STAGE_BOX_PREDICTOR_FIELD_NUMBER;
        hash = (53 * hash) + getSecondStageBoxPredictor().hashCode();
      }
      if (hasSecondStageBatchSize()) {
        hash = (37 * hash) + SECOND_STAGE_BATCH_SIZE_FIELD_NUMBER;
        hash = (53 * hash) + getSecondStageBatchSize();
      }
      if (hasSecondStageBalanceFraction()) {
        hash = (37 * hash) + SECOND_STAGE_BALANCE_FRACTION_FIELD_NUMBER;
        hash = (53 * hash) + java.lang.Float.floatToIntBits(
            getSecondStageBalanceFraction());
      }
      if (hasSecondStagePostProcessing()) {
        hash = (37 * hash) + SECOND_STAGE_POST_PROCESSING_FIELD_NUMBER;
        hash = (53 * hash) + getSecondStagePostProcessing().hashCode();
      }
      if (hasSecondStageLocalizationLossWeight()) {
        hash = (37 * hash) + SECOND_STAGE_LOCALIZATION_LOSS_WEIGHT_FIELD_NUMBER;
        hash = (53 * hash) + java.lang.Float.floatToIntBits(
            getSecondStageLocalizationLossWeight());
      }
      if (hasSecondStageClassificationLossWeight()) {
        hash = (37 * hash) + SECOND_STAGE_CLASSIFICATION_LOSS_WEIGHT_FIELD_NUMBER;
        hash = (53 * hash) + java.lang.Float.floatToIntBits(
            getSecondStageClassificationLossWeight());
      }
      if (hasSecondStageMaskPredictionLossWeight()) {
        hash = (37 * hash) + SECOND_STAGE_MASK_PREDICTION_LOSS_WEIGHT_FIELD_NUMBER;
        hash = (53 * hash) + java.lang.Float.floatToIntBits(
            getSecondStageMaskPredictionLossWeight());
      }
      if (hasHardExampleMiner()) {
        hash = (37 * hash) + HARD_EXAMPLE_MINER_FIELD_NUMBER;
        hash = (53 * hash) + getHardExampleMiner().hashCode();
      }
      if (hasSecondStageClassificationLoss()) {
        hash = (37 * hash) + SECOND_STAGE_CLASSIFICATION_LOSS_FIELD_NUMBER;
        hash = (53 * hash) + getSecondStageClassificationLoss().hashCode();
      }
      if (hasInplaceBatchnormUpdate()) {
        hash = (37 * hash) + INPLACE_BATCHNORM_UPDATE_FIELD_NUMBER;
        hash = (53 * hash) + com.google.protobuf.Internal.hashBoolean(
            getInplaceBatchnormUpdate());
      }
      if (hasUseMatmulCropAndResize()) {
        hash = (37 * hash) + USE_MATMUL_CROP_AND_RESIZE_FIELD_NUMBER;
        hash = (53 * hash) + com.google.protobuf.Internal.hashBoolean(
            getUseMatmulCropAndResize());
      }
      if (hasClipAnchorsToImage()) {
        hash = (37 * hash) + CLIP_ANCHORS_TO_IMAGE_FIELD_NUMBER;
        hash = (53 * hash) + com.google.protobuf.Internal.hashBoolean(
            getClipAnchorsToImage());
      }
      if (hasUseMatmulGatherInMatcher()) {
        hash = (37 * hash) + USE_MATMUL_GATHER_IN_MATCHER_FIELD_NUMBER;
        hash = (53 * hash) + com.google.protobuf.Internal.hashBoolean(
            getUseMatmulGatherInMatcher());
      }
      if (hasUseStaticBalancedLabelSampler()) {
        hash = (37 * hash) + USE_STATIC_BALANCED_LABEL_SAMPLER_FIELD_NUMBER;
        hash = (53 * hash) + com.google.protobuf.Internal.hashBoolean(
            getUseStaticBalancedLabelSampler());
      }
      if (hasUseStaticShapes()) {
        hash = (37 * hash) + USE_STATIC_SHAPES_FIELD_NUMBER;
        hash = (53 * hash) + com.google.protobuf.Internal.hashBoolean(
            getUseStaticShapes());
      }
      if (hasResizeMasks()) {
        hash = (37 * hash) + RESIZE_MASKS_FIELD_NUMBER;
        hash = (53 * hash) + com.google.protobuf.Internal.hashBoolean(
            getResizeMasks());
      }
      if (hasUseStaticShapesForEval()) {
        hash = (37 * hash) + USE_STATIC_SHAPES_FOR_EVAL_FIELD_NUMBER;
        hash = (53 * hash) + com.google.protobuf.Internal.hashBoolean(
            getUseStaticShapesForEval());
      }
      if (hasUsePartitionedNmsInFirstStage()) {
        hash = (37 * hash) + USE_PARTITIONED_NMS_IN_FIRST_STAGE_FIELD_NUMBER;
        hash = (53 * hash) + com.google.protobuf.Internal.hashBoolean(
            getUsePartitionedNmsInFirstStage());
      }
      if (hasReturnRawDetectionsDuringPredict()) {
        hash = (37 * hash) + RETURN_RAW_DETECTIONS_DURING_PREDICT_FIELD_NUMBER;
        hash = (53 * hash) + com.google.protobuf.Internal.hashBoolean(
            getReturnRawDetectionsDuringPredict());
      }
      if (hasUseCombinedNmsInFirstStage()) {
        hash = (37 * hash) + USE_COMBINED_NMS_IN_FIRST_STAGE_FIELD_NUMBER;
        hash = (53 * hash) + com.google.protobuf.Internal.hashBoolean(
            getUseCombinedNmsInFirstStage());
      }
      if (hasOutputFinalBoxFeatures()) {
        hash = (37 * hash) + OUTPUT_FINAL_BOX_FEATURES_FIELD_NUMBER;
        hash = (53 * hash) + com.google.protobuf.Internal.hashBoolean(
            getOutputFinalBoxFeatures());
      }
      if (hasOutputFinalBoxRpnFeatures()) {
        hash = (37 * hash) + OUTPUT_FINAL_BOX_RPN_FEATURES_FIELD_NUMBER;
        hash = (53 * hash) + com.google.protobuf.Internal.hashBoolean(
            getOutputFinalBoxRpnFeatures());
      }
      if (hasContextConfig()) {
        hash = (37 * hash) + CONTEXT_CONFIG_FIELD_NUMBER;
        hash = (53 * hash) + getContextConfig().hashCode();
      }
      hash = (29 * hash) + unknownFields.hashCode();
      memoizedHashCode = hash;
      return hash;
    }

    public static object_detection.protos.FasterRcnnOuterClass.FasterRcnn parseFrom(
        java.nio.ByteBuffer data)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return PARSER.parseFrom(data);
    }
    public static object_detection.protos.FasterRcnnOuterClass.FasterRcnn parseFrom(
        java.nio.ByteBuffer data,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return PARSER.parseFrom(data, extensionRegistry);
    }
    public static object_detection.protos.FasterRcnnOuterClass.FasterRcnn parseFrom(
        com.google.protobuf.ByteString data)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return PARSER.parseFrom(data);
    }
    public static object_detection.protos.FasterRcnnOuterClass.FasterRcnn parseFrom(
        com.google.protobuf.ByteString data,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return PARSER.parseFrom(data, extensionRegistry);
    }
    public static object_detection.protos.FasterRcnnOuterClass.FasterRcnn parseFrom(byte[] data)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return PARSER.parseFrom(data);
    }
    public static object_detection.protos.FasterRcnnOuterClass.FasterRcnn parseFrom(
        byte[] data,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return PARSER.parseFrom(data, extensionRegistry);
    }
    public static object_detection.protos.FasterRcnnOuterClass.FasterRcnn parseFrom(java.io.InputStream input)
        throws java.io.IOException {
      return com.google.protobuf.GeneratedMessageV3
          .parseWithIOException(PARSER, input);
    }
    public static object_detection.protos.FasterRcnnOuterClass.FasterRcnn parseFrom(
        java.io.InputStream input,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws java.io.IOException {
      return com.google.protobuf.GeneratedMessageV3
          .parseWithIOException(PARSER, input, extensionRegistry);
    }
    public static object_detection.protos.FasterRcnnOuterClass.FasterRcnn parseDelimitedFrom(java.io.InputStream input)
        throws java.io.IOException {
      return com.google.protobuf.GeneratedMessageV3
          .parseDelimitedWithIOException(PARSER, input);
    }
    public static object_detection.protos.FasterRcnnOuterClass.FasterRcnn parseDelimitedFrom(
        java.io.InputStream input,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws java.io.IOException {
      return com.google.protobuf.GeneratedMessageV3
          .parseDelimitedWithIOException(PARSER, input, extensionRegistry);
    }
    public static object_detection.protos.FasterRcnnOuterClass.FasterRcnn parseFrom(
        com.google.protobuf.CodedInputStream input)
        throws java.io.IOException {
      return com.google.protobuf.GeneratedMessageV3
          .parseWithIOException(PARSER, input);
    }
    public static object_detection.protos.FasterRcnnOuterClass.FasterRcnn parseFrom(
        com.google.protobuf.CodedInputStream input,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws java.io.IOException {
      return com.google.protobuf.GeneratedMessageV3
          .parseWithIOException(PARSER, input, extensionRegistry);
    }

    @java.lang.Override
    public Builder newBuilderForType() { return newBuilder(); }
    public static Builder newBuilder() {
      return DEFAULT_INSTANCE.toBuilder();
    }
    public static Builder newBuilder(object_detection.protos.FasterRcnnOuterClass.FasterRcnn prototype) {
      return DEFAULT_INSTANCE.toBuilder().mergeFrom(prototype);
    }
    @java.lang.Override
    public Builder toBuilder() {
      return this == DEFAULT_INSTANCE
          ? new Builder() : new Builder().mergeFrom(this);
    }

    @java.lang.Override
    protected Builder newBuilderForType(
        com.google.protobuf.GeneratedMessageV3.BuilderParent parent) {
      Builder builder = new Builder(parent);
      return builder;
    }
    /**
     * Protobuf type {@code object_detection.protos.FasterRcnn}
     */
    public static final class Builder extends
        com.google.protobuf.GeneratedMessageV3.Builder<Builder> implements
        // @@protoc_insertion_point(builder_implements:object_detection.protos.FasterRcnn)
        object_detection.protos.FasterRcnnOuterClass.FasterRcnnOrBuilder {
      public static final com.google.protobuf.Descriptors.Descriptor
          getDescriptor() {
        return object_detection.protos.FasterRcnnOuterClass.internal_static_object_detection_protos_FasterRcnn_descriptor;
      }

      @java.lang.Override
      protected com.google.protobuf.GeneratedMessageV3.FieldAccessorTable
          internalGetFieldAccessorTable() {
        return object_detection.protos.FasterRcnnOuterClass.internal_static_object_detection_protos_FasterRcnn_fieldAccessorTable
            .ensureFieldAccessorsInitialized(
                object_detection.protos.FasterRcnnOuterClass.FasterRcnn.class, object_detection.protos.FasterRcnnOuterClass.FasterRcnn.Builder.class);
      }

      // Construct using object_detection.protos.FasterRcnnOuterClass.FasterRcnn.newBuilder()
      private Builder() {
        maybeForceBuilderInitialization();
      }

      private Builder(
          com.google.protobuf.GeneratedMessageV3.BuilderParent parent) {
        super(parent);
        maybeForceBuilderInitialization();
      }
      private void maybeForceBuilderInitialization() {
        if (com.google.protobuf.GeneratedMessageV3
                .alwaysUseFieldBuilders) {
          getImageResizerFieldBuilder();
          getFeatureExtractorFieldBuilder();
          getFirstStageAnchorGeneratorFieldBuilder();
          getFirstStageBoxPredictorConvHyperparamsFieldBuilder();
          getSecondStageBoxPredictorFieldBuilder();
          getSecondStagePostProcessingFieldBuilder();
          getHardExampleMinerFieldBuilder();
          getSecondStageClassificationLossFieldBuilder();
          getContextConfigFieldBuilder();
        }
      }
      @java.lang.Override
      public Builder clear() {
        super.clear();
        numberOfStages_ = 2;
        bitField0_ = (bitField0_ & ~0x00000001);
        numClasses_ = 0;
        bitField0_ = (bitField0_ & ~0x00000002);
        if (imageResizerBuilder_ == null) {
          imageResizer_ = null;
        } else {
          imageResizerBuilder_.clear();
        }
        bitField0_ = (bitField0_ & ~0x00000004);
        if (featureExtractorBuilder_ == null) {
          featureExtractor_ = null;
        } else {
          featureExtractorBuilder_.clear();
        }
        bitField0_ = (bitField0_ & ~0x00000008);
        if (firstStageAnchorGeneratorBuilder_ == null) {
          firstStageAnchorGenerator_ = null;
        } else {
          firstStageAnchorGeneratorBuilder_.clear();
        }
        bitField0_ = (bitField0_ & ~0x00000010);
        firstStageAtrousRate_ = 1;
        bitField0_ = (bitField0_ & ~0x00000020);
        if (firstStageBoxPredictorConvHyperparamsBuilder_ == null) {
          firstStageBoxPredictorConvHyperparams_ = null;
        } else {
          firstStageBoxPredictorConvHyperparamsBuilder_.clear();
        }
        bitField0_ = (bitField0_ & ~0x00000040);
        firstStageBoxPredictorKernelSize_ = 3;
        bitField0_ = (bitField0_ & ~0x00000080);
        firstStageBoxPredictorDepth_ = 512;
        bitField0_ = (bitField0_ & ~0x00000100);
        firstStageMinibatchSize_ = 256;
        bitField0_ = (bitField0_ & ~0x00000200);
        firstStagePositiveBalanceFraction_ = 0.5F;
        bitField0_ = (bitField0_ & ~0x00000400);
        firstStageNmsScoreThreshold_ = 0F;
        bitField0_ = (bitField0_ & ~0x00000800);
        firstStageNmsIouThreshold_ = 0.7F;
        bitField0_ = (bitField0_ & ~0x00001000);
        firstStageMaxProposals_ = 300;
        bitField0_ = (bitField0_ & ~0x00002000);
        firstStageLocalizationLossWeight_ = 1F;
        bitField0_ = (bitField0_ & ~0x00004000);
        firstStageObjectnessLossWeight_ = 1F;
        bitField0_ = (bitField0_ & ~0x00008000);
        initialCropSize_ = 0;
        bitField0_ = (bitField0_ & ~0x00010000);
        maxpoolKernelSize_ = 0;
        bitField0_ = (bitField0_ & ~0x00020000);
        maxpoolStride_ = 0;
        bitField0_ = (bitField0_ & ~0x00040000);
        if (secondStageBoxPredictorBuilder_ == null) {
          secondStageBoxPredictor_ = null;
        } else {
          secondStageBoxPredictorBuilder_.clear();
        }
        bitField0_ = (bitField0_ & ~0x00080000);
        secondStageBatchSize_ = 64;
        bitField0_ = (bitField0_ & ~0x00100000);
        secondStageBalanceFraction_ = 0.25F;
        bitField0_ = (bitField0_ & ~0x00200000);
        if (secondStagePostProcessingBuilder_ == null) {
          secondStagePostProcessing_ = null;
        } else {
          secondStagePostProcessingBuilder_.clear();
        }
        bitField0_ = (bitField0_ & ~0x00400000);
        secondStageLocalizationLossWeight_ = 1F;
        bitField0_ = (bitField0_ & ~0x00800000);
        secondStageClassificationLossWeight_ = 1F;
        bitField0_ = (bitField0_ & ~0x01000000);
        secondStageMaskPredictionLossWeight_ = 1F;
        bitField0_ = (bitField0_ & ~0x02000000);
        if (hardExampleMinerBuilder_ == null) {
          hardExampleMiner_ = null;
        } else {
          hardExampleMinerBuilder_.clear();
        }
        bitField0_ = (bitField0_ & ~0x04000000);
        if (secondStageClassificationLossBuilder_ == null) {
          secondStageClassificationLoss_ = null;
        } else {
          secondStageClassificationLossBuilder_.clear();
        }
        bitField0_ = (bitField0_ & ~0x08000000);
        inplaceBatchnormUpdate_ = false;
        bitField0_ = (bitField0_ & ~0x10000000);
        useMatmulCropAndResize_ = false;
        bitField0_ = (bitField0_ & ~0x20000000);
        clipAnchorsToImage_ = false;
        bitField0_ = (bitField0_ & ~0x40000000);
        useMatmulGatherInMatcher_ = false;
        bitField0_ = (bitField0_ & ~0x80000000);
        useStaticBalancedLabelSampler_ = false;
        bitField1_ = (bitField1_ & ~0x00000001);
        useStaticShapes_ = false;
        bitField1_ = (bitField1_ & ~0x00000002);
        resizeMasks_ = true;
        bitField1_ = (bitField1_ & ~0x00000004);
        useStaticShapesForEval_ = false;
        bitField1_ = (bitField1_ & ~0x00000008);
        usePartitionedNmsInFirstStage_ = true;
        bitField1_ = (bitField1_ & ~0x00000010);
        returnRawDetectionsDuringPredict_ = false;
        bitField1_ = (bitField1_ & ~0x00000020);
        useCombinedNmsInFirstStage_ = false;
        bitField1_ = (bitField1_ & ~0x00000040);
        outputFinalBoxFeatures_ = false;
        bitField1_ = (bitField1_ & ~0x00000080);
        outputFinalBoxRpnFeatures_ = false;
        bitField1_ = (bitField1_ & ~0x00000100);
        if (contextConfigBuilder_ == null) {
          contextConfig_ = null;
        } else {
          contextConfigBuilder_.clear();
        }
        bitField1_ = (bitField1_ & ~0x00000200);
        return this;
      }

      @java.lang.Override
      public com.google.protobuf.Descriptors.Descriptor
          getDescriptorForType() {
        return object_detection.protos.FasterRcnnOuterClass.internal_static_object_detection_protos_FasterRcnn_descriptor;
      }

      @java.lang.Override
      public object_detection.protos.FasterRcnnOuterClass.FasterRcnn getDefaultInstanceForType() {
        return object_detection.protos.FasterRcnnOuterClass.FasterRcnn.getDefaultInstance();
      }

      @java.lang.Override
      public object_detection.protos.FasterRcnnOuterClass.FasterRcnn build() {
        object_detection.protos.FasterRcnnOuterClass.FasterRcnn result = buildPartial();
        if (!result.isInitialized()) {
          throw newUninitializedMessageException(result);
        }
        return result;
      }

      @java.lang.Override
      public object_detection.protos.FasterRcnnOuterClass.FasterRcnn buildPartial() {
        object_detection.protos.FasterRcnnOuterClass.FasterRcnn result = new object_detection.protos.FasterRcnnOuterClass.FasterRcnn(this);
        int from_bitField0_ = bitField0_;
        int from_bitField1_ = bitField1_;
        int to_bitField0_ = 0;
        int to_bitField1_ = 0;
        if (((from_bitField0_ & 0x00000001) != 0)) {
          to_bitField0_ |= 0x00000001;
        }
        result.numberOfStages_ = numberOfStages_;
        if (((from_bitField0_ & 0x00000002) != 0)) {
          result.numClasses_ = numClasses_;
          to_bitField0_ |= 0x00000002;
        }
        if (((from_bitField0_ & 0x00000004) != 0)) {
          if (imageResizerBuilder_ == null) {
            result.imageResizer_ = imageResizer_;
          } else {
            result.imageResizer_ = imageResizerBuilder_.build();
          }
          to_bitField0_ |= 0x00000004;
        }
        if (((from_bitField0_ & 0x00000008) != 0)) {
          if (featureExtractorBuilder_ == null) {
            result.featureExtractor_ = featureExtractor_;
          } else {
            result.featureExtractor_ = featureExtractorBuilder_.build();
          }
          to_bitField0_ |= 0x00000008;
        }
        if (((from_bitField0_ & 0x00000010) != 0)) {
          if (firstStageAnchorGeneratorBuilder_ == null) {
            result.firstStageAnchorGenerator_ = firstStageAnchorGenerator_;
          } else {
            result.firstStageAnchorGenerator_ = firstStageAnchorGeneratorBuilder_.build();
          }
          to_bitField0_ |= 0x00000010;
        }
        if (((from_bitField0_ & 0x00000020) != 0)) {
          to_bitField0_ |= 0x00000020;
        }
        result.firstStageAtrousRate_ = firstStageAtrousRate_;
        if (((from_bitField0_ & 0x00000040) != 0)) {
          if (firstStageBoxPredictorConvHyperparamsBuilder_ == null) {
            result.firstStageBoxPredictorConvHyperparams_ = firstStageBoxPredictorConvHyperparams_;
          } else {
            result.firstStageBoxPredictorConvHyperparams_ = firstStageBoxPredictorConvHyperparamsBuilder_.build();
          }
          to_bitField0_ |= 0x00000040;
        }
        if (((from_bitField0_ & 0x00000080) != 0)) {
          to_bitField0_ |= 0x00000080;
        }
        result.firstStageBoxPredictorKernelSize_ = firstStageBoxPredictorKernelSize_;
        if (((from_bitField0_ & 0x00000100) != 0)) {
          to_bitField0_ |= 0x00000100;
        }
        result.firstStageBoxPredictorDepth_ = firstStageBoxPredictorDepth_;
        if (((from_bitField0_ & 0x00000200) != 0)) {
          to_bitField0_ |= 0x00000200;
        }
        result.firstStageMinibatchSize_ = firstStageMinibatchSize_;
        if (((from_bitField0_ & 0x00000400) != 0)) {
          to_bitField0_ |= 0x00000400;
        }
        result.firstStagePositiveBalanceFraction_ = firstStagePositiveBalanceFraction_;
        if (((from_bitField0_ & 0x00000800) != 0)) {
          result.firstStageNmsScoreThreshold_ = firstStageNmsScoreThreshold_;
          to_bitField0_ |= 0x00000800;
        }
        if (((from_bitField0_ & 0x00001000) != 0)) {
          to_bitField0_ |= 0x00001000;
        }
        result.firstStageNmsIouThreshold_ = firstStageNmsIouThreshold_;
        if (((from_bitField0_ & 0x00002000) != 0)) {
          to_bitField0_ |= 0x00002000;
        }
        result.firstStageMaxProposals_ = firstStageMaxProposals_;
        if (((from_bitField0_ & 0x00004000) != 0)) {
          to_bitField0_ |= 0x00004000;
        }
        result.firstStageLocalizationLossWeight_ = firstStageLocalizationLossWeight_;
        if (((from_bitField0_ & 0x00008000) != 0)) {
          to_bitField0_ |= 0x00008000;
        }
        result.firstStageObjectnessLossWeight_ = firstStageObjectnessLossWeight_;
        if (((from_bitField0_ & 0x00010000) != 0)) {
          result.initialCropSize_ = initialCropSize_;
          to_bitField0_ |= 0x00010000;
        }
        if (((from_bitField0_ & 0x00020000) != 0)) {
          result.maxpoolKernelSize_ = maxpoolKernelSize_;
          to_bitField0_ |= 0x00020000;
        }
        if (((from_bitField0_ & 0x00040000) != 0)) {
          result.maxpoolStride_ = maxpoolStride_;
          to_bitField0_ |= 0x00040000;
        }
        if (((from_bitField0_ & 0x00080000) != 0)) {
          if (secondStageBoxPredictorBuilder_ == null) {
            result.secondStageBoxPredictor_ = secondStageBoxPredictor_;
          } else {
            result.secondStageBoxPredictor_ = secondStageBoxPredictorBuilder_.build();
          }
          to_bitField0_ |= 0x00080000;
        }
        if (((from_bitField0_ & 0x00100000) != 0)) {
          to_bitField0_ |= 0x00100000;
        }
        result.secondStageBatchSize_ = secondStageBatchSize_;
        if (((from_bitField0_ & 0x00200000) != 0)) {
          to_bitField0_ |= 0x00200000;
        }
        result.secondStageBalanceFraction_ = secondStageBalanceFraction_;
        if (((from_bitField0_ & 0x00400000) != 0)) {
          if (secondStagePostProcessingBuilder_ == null) {
            result.secondStagePostProcessing_ = secondStagePostProcessing_;
          } else {
            result.secondStagePostProcessing_ = secondStagePostProcessingBuilder_.build();
          }
          to_bitField0_ |= 0x00400000;
        }
        if (((from_bitField0_ & 0x00800000) != 0)) {
          to_bitField0_ |= 0x00800000;
        }
        result.secondStageLocalizationLossWeight_ = secondStageLocalizationLossWeight_;
        if (((from_bitField0_ & 0x01000000) != 0)) {
          to_bitField0_ |= 0x01000000;
        }
        result.secondStageClassificationLossWeight_ = secondStageClassificationLossWeight_;
        if (((from_bitField0_ & 0x02000000) != 0)) {
          to_bitField0_ |= 0x02000000;
        }
        result.secondStageMaskPredictionLossWeight_ = secondStageMaskPredictionLossWeight_;
        if (((from_bitField0_ & 0x04000000) != 0)) {
          if (hardExampleMinerBuilder_ == null) {
            result.hardExampleMiner_ = hardExampleMiner_;
          } else {
            result.hardExampleMiner_ = hardExampleMinerBuilder_.build();
          }
          to_bitField0_ |= 0x04000000;
        }
        if (((from_bitField0_ & 0x08000000) != 0)) {
          if (secondStageClassificationLossBuilder_ == null) {
            result.secondStageClassificationLoss_ = secondStageClassificationLoss_;
          } else {
            result.secondStageClassificationLoss_ = secondStageClassificationLossBuilder_.build();
          }
          to_bitField0_ |= 0x08000000;
        }
        if (((from_bitField0_ & 0x10000000) != 0)) {
          result.inplaceBatchnormUpdate_ = inplaceBatchnormUpdate_;
          to_bitField0_ |= 0x10000000;
        }
        if (((from_bitField0_ & 0x20000000) != 0)) {
          result.useMatmulCropAndResize_ = useMatmulCropAndResize_;
          to_bitField0_ |= 0x20000000;
        }
        if (((from_bitField0_ & 0x40000000) != 0)) {
          result.clipAnchorsToImage_ = clipAnchorsToImage_;
          to_bitField0_ |= 0x40000000;
        }
        if (((from_bitField0_ & 0x80000000) != 0)) {
          result.useMatmulGatherInMatcher_ = useMatmulGatherInMatcher_;
          to_bitField0_ |= 0x80000000;
        }
        if (((from_bitField1_ & 0x00000001) != 0)) {
          result.useStaticBalancedLabelSampler_ = useStaticBalancedLabelSampler_;
          to_bitField1_ |= 0x00000001;
        }
        if (((from_bitField1_ & 0x00000002) != 0)) {
          result.useStaticShapes_ = useStaticShapes_;
          to_bitField1_ |= 0x00000002;
        }
        if (((from_bitField1_ & 0x00000004) != 0)) {
          to_bitField1_ |= 0x00000004;
        }
        result.resizeMasks_ = resizeMasks_;
        if (((from_bitField1_ & 0x00000008) != 0)) {
          result.useStaticShapesForEval_ = useStaticShapesForEval_;
          to_bitField1_ |= 0x00000008;
        }
        if (((from_bitField1_ & 0x00000010) != 0)) {
          to_bitField1_ |= 0x00000010;
        }
        result.usePartitionedNmsInFirstStage_ = usePartitionedNmsInFirstStage_;
        if (((from_bitField1_ & 0x00000020) != 0)) {
          result.returnRawDetectionsDuringPredict_ = returnRawDetectionsDuringPredict_;
          to_bitField1_ |= 0x00000020;
        }
        if (((from_bitField1_ & 0x00000040) != 0)) {
          result.useCombinedNmsInFirstStage_ = useCombinedNmsInFirstStage_;
          to_bitField1_ |= 0x00000040;
        }
        if (((from_bitField1_ & 0x00000080) != 0)) {
          result.outputFinalBoxFeatures_ = outputFinalBoxFeatures_;
          to_bitField1_ |= 0x00000080;
        }
        if (((from_bitField1_ & 0x00000100) != 0)) {
          result.outputFinalBoxRpnFeatures_ = outputFinalBoxRpnFeatures_;
          to_bitField1_ |= 0x00000100;
        }
        if (((from_bitField1_ & 0x00000200) != 0)) {
          if (contextConfigBuilder_ == null) {
            result.contextConfig_ = contextConfig_;
          } else {
            result.contextConfig_ = contextConfigBuilder_.build();
          }
          to_bitField1_ |= 0x00000200;
        }
        result.bitField0_ = to_bitField0_;
        result.bitField1_ = to_bitField1_;
        onBuilt();
        return result;
      }

      @java.lang.Override
      public Builder clone() {
        return super.clone();
      }
      @java.lang.Override
      public Builder setField(
          com.google.protobuf.Descriptors.FieldDescriptor field,
          java.lang.Object value) {
        return super.setField(field, value);
      }
      @java.lang.Override
      public Builder clearField(
          com.google.protobuf.Descriptors.FieldDescriptor field) {
        return super.clearField(field);
      }
      @java.lang.Override
      public Builder clearOneof(
          com.google.protobuf.Descriptors.OneofDescriptor oneof) {
        return super.clearOneof(oneof);
      }
      @java.lang.Override
      public Builder setRepeatedField(
          com.google.protobuf.Descriptors.FieldDescriptor field,
          int index, java.lang.Object value) {
        return super.setRepeatedField(field, index, value);
      }
      @java.lang.Override
      public Builder addRepeatedField(
          com.google.protobuf.Descriptors.FieldDescriptor field,
          java.lang.Object value) {
        return super.addRepeatedField(field, value);
      }
      @java.lang.Override
      public Builder mergeFrom(com.google.protobuf.Message other) {
        if (other instanceof object_detection.protos.FasterRcnnOuterClass.FasterRcnn) {
          return mergeFrom((object_detection.protos.FasterRcnnOuterClass.FasterRcnn)other);
        } else {
          super.mergeFrom(other);
          return this;
        }
      }

      public Builder mergeFrom(object_detection.protos.FasterRcnnOuterClass.FasterRcnn other) {
        if (other == object_detection.protos.FasterRcnnOuterClass.FasterRcnn.getDefaultInstance()) return this;
        if (other.hasNumberOfStages()) {
          setNumberOfStages(other.getNumberOfStages());
        }
        if (other.hasNumClasses()) {
          setNumClasses(other.getNumClasses());
        }
        if (other.hasImageResizer()) {
          mergeImageResizer(other.getImageResizer());
        }
        if (other.hasFeatureExtractor()) {
          mergeFeatureExtractor(other.getFeatureExtractor());
        }
        if (other.hasFirstStageAnchorGenerator()) {
          mergeFirstStageAnchorGenerator(other.getFirstStageAnchorGenerator());
        }
        if (other.hasFirstStageAtrousRate()) {
          setFirstStageAtrousRate(other.getFirstStageAtrousRate());
        }
        if (other.hasFirstStageBoxPredictorConvHyperparams()) {
          mergeFirstStageBoxPredictorConvHyperparams(other.getFirstStageBoxPredictorConvHyperparams());
        }
        if (other.hasFirstStageBoxPredictorKernelSize()) {
          setFirstStageBoxPredictorKernelSize(other.getFirstStageBoxPredictorKernelSize());
        }
        if (other.hasFirstStageBoxPredictorDepth()) {
          setFirstStageBoxPredictorDepth(other.getFirstStageBoxPredictorDepth());
        }
        if (other.hasFirstStageMinibatchSize()) {
          setFirstStageMinibatchSize(other.getFirstStageMinibatchSize());
        }
        if (other.hasFirstStagePositiveBalanceFraction()) {
          setFirstStagePositiveBalanceFraction(other.getFirstStagePositiveBalanceFraction());
        }
        if (other.hasFirstStageNmsScoreThreshold()) {
          setFirstStageNmsScoreThreshold(other.getFirstStageNmsScoreThreshold());
        }
        if (other.hasFirstStageNmsIouThreshold()) {
          setFirstStageNmsIouThreshold(other.getFirstStageNmsIouThreshold());
        }
        if (other.hasFirstStageMaxProposals()) {
          setFirstStageMaxProposals(other.getFirstStageMaxProposals());
        }
        if (other.hasFirstStageLocalizationLossWeight()) {
          setFirstStageLocalizationLossWeight(other.getFirstStageLocalizationLossWeight());
        }
        if (other.hasFirstStageObjectnessLossWeight()) {
          setFirstStageObjectnessLossWeight(other.getFirstStageObjectnessLossWeight());
        }
        if (other.hasInitialCropSize()) {
          setInitialCropSize(other.getInitialCropSize());
        }
        if (other.hasMaxpoolKernelSize()) {
          setMaxpoolKernelSize(other.getMaxpoolKernelSize());
        }
        if (other.hasMaxpoolStride()) {
          setMaxpoolStride(other.getMaxpoolStride());
        }
        if (other.hasSecondStageBoxPredictor()) {
          mergeSecondStageBoxPredictor(other.getSecondStageBoxPredictor());
        }
        if (other.hasSecondStageBatchSize()) {
          setSecondStageBatchSize(other.getSecondStageBatchSize());
        }
        if (other.hasSecondStageBalanceFraction()) {
          setSecondStageBalanceFraction(other.getSecondStageBalanceFraction());
        }
        if (other.hasSecondStagePostProcessing()) {
          mergeSecondStagePostProcessing(other.getSecondStagePostProcessing());
        }
        if (other.hasSecondStageLocalizationLossWeight()) {
          setSecondStageLocalizationLossWeight(other.getSecondStageLocalizationLossWeight());
        }
        if (other.hasSecondStageClassificationLossWeight()) {
          setSecondStageClassificationLossWeight(other.getSecondStageClassificationLossWeight());
        }
        if (other.hasSecondStageMaskPredictionLossWeight()) {
          setSecondStageMaskPredictionLossWeight(other.getSecondStageMaskPredictionLossWeight());
        }
        if (other.hasHardExampleMiner()) {
          mergeHardExampleMiner(other.getHardExampleMiner());
        }
        if (other.hasSecondStageClassificationLoss()) {
          mergeSecondStageClassificationLoss(other.getSecondStageClassificationLoss());
        }
        if (other.hasInplaceBatchnormUpdate()) {
          setInplaceBatchnormUpdate(other.getInplaceBatchnormUpdate());
        }
        if (other.hasUseMatmulCropAndResize()) {
          setUseMatmulCropAndResize(other.getUseMatmulCropAndResize());
        }
        if (other.hasClipAnchorsToImage()) {
          setClipAnchorsToImage(other.getClipAnchorsToImage());
        }
        if (other.hasUseMatmulGatherInMatcher()) {
          setUseMatmulGatherInMatcher(other.getUseMatmulGatherInMatcher());
        }
        if (other.hasUseStaticBalancedLabelSampler()) {
          setUseStaticBalancedLabelSampler(other.getUseStaticBalancedLabelSampler());
        }
        if (other.hasUseStaticShapes()) {
          setUseStaticShapes(other.getUseStaticShapes());
        }
        if (other.hasResizeMasks()) {
          setResizeMasks(other.getResizeMasks());
        }
        if (other.hasUseStaticShapesForEval()) {
          setUseStaticShapesForEval(other.getUseStaticShapesForEval());
        }
        if (other.hasUsePartitionedNmsInFirstStage()) {
          setUsePartitionedNmsInFirstStage(other.getUsePartitionedNmsInFirstStage());
        }
        if (other.hasReturnRawDetectionsDuringPredict()) {
          setReturnRawDetectionsDuringPredict(other.getReturnRawDetectionsDuringPredict());
        }
        if (other.hasUseCombinedNmsInFirstStage()) {
          setUseCombinedNmsInFirstStage(other.getUseCombinedNmsInFirstStage());
        }
        if (other.hasOutputFinalBoxFeatures()) {
          setOutputFinalBoxFeatures(other.getOutputFinalBoxFeatures());
        }
        if (other.hasOutputFinalBoxRpnFeatures()) {
          setOutputFinalBoxRpnFeatures(other.getOutputFinalBoxRpnFeatures());
        }
        if (other.hasContextConfig()) {
          mergeContextConfig(other.getContextConfig());
        }
        this.mergeUnknownFields(other.unknownFields);
        onChanged();
        return this;
      }

      @java.lang.Override
      public final boolean isInitialized() {
        return true;
      }

      @java.lang.Override
      public Builder mergeFrom(
          com.google.protobuf.CodedInputStream input,
          com.google.protobuf.ExtensionRegistryLite extensionRegistry)
          throws java.io.IOException {
        object_detection.protos.FasterRcnnOuterClass.FasterRcnn parsedMessage = null;
        try {
          parsedMessage = PARSER.parsePartialFrom(input, extensionRegistry);
        } catch (com.google.protobuf.InvalidProtocolBufferException e) {
          parsedMessage = (object_detection.protos.FasterRcnnOuterClass.FasterRcnn) e.getUnfinishedMessage();
          throw e.unwrapIOException();
        } finally {
          if (parsedMessage != null) {
            mergeFrom(parsedMessage);
          }
        }
        return this;
      }
      private int bitField0_;
      private int bitField1_;

      private int numberOfStages_ = 2;
      /**
       * <pre>
       * Whether to construct only the Region Proposal Network (RPN).
       * </pre>
       *
       * <code>optional int32 number_of_stages = 1 [default = 2];</code>
       * @return Whether the numberOfStages field is set.
       */
      @java.lang.Override
      public boolean hasNumberOfStages() {
        return ((bitField0_ & 0x00000001) != 0);
      }
      /**
       * <pre>
       * Whether to construct only the Region Proposal Network (RPN).
       * </pre>
       *
       * <code>optional int32 number_of_stages = 1 [default = 2];</code>
       * @return The numberOfStages.
       */
      @java.lang.Override
      public int getNumberOfStages() {
        return numberOfStages_;
      }
      /**
       * <pre>
       * Whether to construct only the Region Proposal Network (RPN).
       * </pre>
       *
       * <code>optional int32 number_of_stages = 1 [default = 2];</code>
       * @param value The numberOfStages to set.
       * @return This builder for chaining.
       */
      public Builder setNumberOfStages(int value) {
        bitField0_ |= 0x00000001;
        numberOfStages_ = value;
        onChanged();
        return this;
      }
      /**
       * <pre>
       * Whether to construct only the Region Proposal Network (RPN).
       * </pre>
       *
       * <code>optional int32 number_of_stages = 1 [default = 2];</code>
       * @return This builder for chaining.
       */
      public Builder clearNumberOfStages() {
        bitField0_ = (bitField0_ & ~0x00000001);
        numberOfStages_ = 2;
        onChanged();
        return this;
      }

      private int numClasses_ ;
      /**
       * <pre>
       * Number of classes to predict.
       * </pre>
       *
       * <code>optional int32 num_classes = 3;</code>
       * @return Whether the numClasses field is set.
       */
      @java.lang.Override
      public boolean hasNumClasses() {
        return ((bitField0_ & 0x00000002) != 0);
      }
      /**
       * <pre>
       * Number of classes to predict.
       * </pre>
       *
       * <code>optional int32 num_classes = 3;</code>
       * @return The numClasses.
       */
      @java.lang.Override
      public int getNumClasses() {
        return numClasses_;
      }
      /**
       * <pre>
       * Number of classes to predict.
       * </pre>
       *
       * <code>optional int32 num_classes = 3;</code>
       * @param value The numClasses to set.
       * @return This builder for chaining.
       */
      public Builder setNumClasses(int value) {
        bitField0_ |= 0x00000002;
        numClasses_ = value;
        onChanged();
        return this;
      }
      /**
       * <pre>
       * Number of classes to predict.
       * </pre>
       *
       * <code>optional int32 num_classes = 3;</code>
       * @return This builder for chaining.
       */
      public Builder clearNumClasses() {
        bitField0_ = (bitField0_ & ~0x00000002);
        numClasses_ = 0;
        onChanged();
        return this;
      }

      private object_detection.protos.ImageResizerOuterClass.ImageResizer imageResizer_;
      private com.google.protobuf.SingleFieldBuilderV3<
          object_detection.protos.ImageResizerOuterClass.ImageResizer, object_detection.protos.ImageResizerOuterClass.ImageResizer.Builder, object_detection.protos.ImageResizerOuterClass.ImageResizerOrBuilder> imageResizerBuilder_;
      /**
       * <pre>
       * Image resizer for preprocessing the input image.
       * </pre>
       *
       * <code>optional .object_detection.protos.ImageResizer image_resizer = 4;</code>
       * @return Whether the imageResizer field is set.
       */
      public boolean hasImageResizer() {
        return ((bitField0_ & 0x00000004) != 0);
      }
      /**
       * <pre>
       * Image resizer for preprocessing the input image.
       * </pre>
       *
       * <code>optional .object_detection.protos.ImageResizer image_resizer = 4;</code>
       * @return The imageResizer.
       */
      public object_detection.protos.ImageResizerOuterClass.ImageResizer getImageResizer() {
        if (imageResizerBuilder_ == null) {
          return imageResizer_ == null ? object_detection.protos.ImageResizerOuterClass.ImageResizer.getDefaultInstance() : imageResizer_;
        } else {
          return imageResizerBuilder_.getMessage();
        }
      }
      /**
       * <pre>
       * Image resizer for preprocessing the input image.
       * </pre>
       *
       * <code>optional .object_detection.protos.ImageResizer image_resizer = 4;</code>
       */
      public Builder setImageResizer(object_detection.protos.ImageResizerOuterClass.ImageResizer value) {
        if (imageResizerBuilder_ == null) {
          if (value == null) {
            throw new NullPointerException();
          }
          imageResizer_ = value;
          onChanged();
        } else {
          imageResizerBuilder_.setMessage(value);
        }
        bitField0_ |= 0x00000004;
        return this;
      }
      /**
       * <pre>
       * Image resizer for preprocessing the input image.
       * </pre>
       *
       * <code>optional .object_detection.protos.ImageResizer image_resizer = 4;</code>
       */
      public Builder setImageResizer(
          object_detection.protos.ImageResizerOuterClass.ImageResizer.Builder builderForValue) {
        if (imageResizerBuilder_ == null) {
          imageResizer_ = builderForValue.build();
          onChanged();
        } else {
          imageResizerBuilder_.setMessage(builderForValue.build());
        }
        bitField0_ |= 0x00000004;
        return this;
      }
      /**
       * <pre>
       * Image resizer for preprocessing the input image.
       * </pre>
       *
       * <code>optional .object_detection.protos.ImageResizer image_resizer = 4;</code>
       */
      public Builder mergeImageResizer(object_detection.protos.ImageResizerOuterClass.ImageResizer value) {
        if (imageResizerBuilder_ == null) {
          if (((bitField0_ & 0x00000004) != 0) &&
              imageResizer_ != null &&
              imageResizer_ != object_detection.protos.ImageResizerOuterClass.ImageResizer.getDefaultInstance()) {
            imageResizer_ =
              object_detection.protos.ImageResizerOuterClass.ImageResizer.newBuilder(imageResizer_).mergeFrom(value).buildPartial();
          } else {
            imageResizer_ = value;
          }
          onChanged();
        } else {
          imageResizerBuilder_.mergeFrom(value);
        }
        bitField0_ |= 0x00000004;
        return this;
      }
      /**
       * <pre>
       * Image resizer for preprocessing the input image.
       * </pre>
       *
       * <code>optional .object_detection.protos.ImageResizer image_resizer = 4;</code>
       */
      public Builder clearImageResizer() {
        if (imageResizerBuilder_ == null) {
          imageResizer_ = null;
          onChanged();
        } else {
          imageResizerBuilder_.clear();
        }
        bitField0_ = (bitField0_ & ~0x00000004);
        return this;
      }
      /**
       * <pre>
       * Image resizer for preprocessing the input image.
       * </pre>
       *
       * <code>optional .object_detection.protos.ImageResizer image_resizer = 4;</code>
       */
      public object_detection.protos.ImageResizerOuterClass.ImageResizer.Builder getImageResizerBuilder() {
        bitField0_ |= 0x00000004;
        onChanged();
        return getImageResizerFieldBuilder().getBuilder();
      }
      /**
       * <pre>
       * Image resizer for preprocessing the input image.
       * </pre>
       *
       * <code>optional .object_detection.protos.ImageResizer image_resizer = 4;</code>
       */
      public object_detection.protos.ImageResizerOuterClass.ImageResizerOrBuilder getImageResizerOrBuilder() {
        if (imageResizerBuilder_ != null) {
          return imageResizerBuilder_.getMessageOrBuilder();
        } else {
          return imageResizer_ == null ?
              object_detection.protos.ImageResizerOuterClass.ImageResizer.getDefaultInstance() : imageResizer_;
        }
      }
      /**
       * <pre>
       * Image resizer for preprocessing the input image.
       * </pre>
       *
       * <code>optional .object_detection.protos.ImageResizer image_resizer = 4;</code>
       */
      private com.google.protobuf.SingleFieldBuilderV3<
          object_detection.protos.ImageResizerOuterClass.ImageResizer, object_detection.protos.ImageResizerOuterClass.ImageResizer.Builder, object_detection.protos.ImageResizerOuterClass.ImageResizerOrBuilder>
          getImageResizerFieldBuilder() {
        if (imageResizerBuilder_ == null) {
          imageResizerBuilder_ = new com.google.protobuf.SingleFieldBuilderV3<
              object_detection.protos.ImageResizerOuterClass.ImageResizer, object_detection.protos.ImageResizerOuterClass.ImageResizer.Builder, object_detection.protos.ImageResizerOuterClass.ImageResizerOrBuilder>(
                  getImageResizer(),
                  getParentForChildren(),
                  isClean());
          imageResizer_ = null;
        }
        return imageResizerBuilder_;
      }

      private object_detection.protos.FasterRcnnOuterClass.FasterRcnnFeatureExtractor featureExtractor_;
      private com.google.protobuf.SingleFieldBuilderV3<
          object_detection.protos.FasterRcnnOuterClass.FasterRcnnFeatureExtractor, object_detection.protos.FasterRcnnOuterClass.FasterRcnnFeatureExtractor.Builder, object_detection.protos.FasterRcnnOuterClass.FasterRcnnFeatureExtractorOrBuilder> featureExtractorBuilder_;
      /**
       * <pre>
       * Feature extractor config.
       * </pre>
       *
       * <code>optional .object_detection.protos.FasterRcnnFeatureExtractor feature_extractor = 5;</code>
       * @return Whether the featureExtractor field is set.
       */
      public boolean hasFeatureExtractor() {
        return ((bitField0_ & 0x00000008) != 0);
      }
      /**
       * <pre>
       * Feature extractor config.
       * </pre>
       *
       * <code>optional .object_detection.protos.FasterRcnnFeatureExtractor feature_extractor = 5;</code>
       * @return The featureExtractor.
       */
      public object_detection.protos.FasterRcnnOuterClass.FasterRcnnFeatureExtractor getFeatureExtractor() {
        if (featureExtractorBuilder_ == null) {
          return featureExtractor_ == null ? object_detection.protos.FasterRcnnOuterClass.FasterRcnnFeatureExtractor.getDefaultInstance() : featureExtractor_;
        } else {
          return featureExtractorBuilder_.getMessage();
        }
      }
      /**
       * <pre>
       * Feature extractor config.
       * </pre>
       *
       * <code>optional .object_detection.protos.FasterRcnnFeatureExtractor feature_extractor = 5;</code>
       */
      public Builder setFeatureExtractor(object_detection.protos.FasterRcnnOuterClass.FasterRcnnFeatureExtractor value) {
        if (featureExtractorBuilder_ == null) {
          if (value == null) {
            throw new NullPointerException();
          }
          featureExtractor_ = value;
          onChanged();
        } else {
          featureExtractorBuilder_.setMessage(value);
        }
        bitField0_ |= 0x00000008;
        return this;
      }
      /**
       * <pre>
       * Feature extractor config.
       * </pre>
       *
       * <code>optional .object_detection.protos.FasterRcnnFeatureExtractor feature_extractor = 5;</code>
       */
      public Builder setFeatureExtractor(
          object_detection.protos.FasterRcnnOuterClass.FasterRcnnFeatureExtractor.Builder builderForValue) {
        if (featureExtractorBuilder_ == null) {
          featureExtractor_ = builderForValue.build();
          onChanged();
        } else {
          featureExtractorBuilder_.setMessage(builderForValue.build());
        }
        bitField0_ |= 0x00000008;
        return this;
      }
      /**
       * <pre>
       * Feature extractor config.
       * </pre>
       *
       * <code>optional .object_detection.protos.FasterRcnnFeatureExtractor feature_extractor = 5;</code>
       */
      public Builder mergeFeatureExtractor(object_detection.protos.FasterRcnnOuterClass.FasterRcnnFeatureExtractor value) {
        if (featureExtractorBuilder_ == null) {
          if (((bitField0_ & 0x00000008) != 0) &&
              featureExtractor_ != null &&
              featureExtractor_ != object_detection.protos.FasterRcnnOuterClass.FasterRcnnFeatureExtractor.getDefaultInstance()) {
            featureExtractor_ =
              object_detection.protos.FasterRcnnOuterClass.FasterRcnnFeatureExtractor.newBuilder(featureExtractor_).mergeFrom(value).buildPartial();
          } else {
            featureExtractor_ = value;
          }
          onChanged();
        } else {
          featureExtractorBuilder_.mergeFrom(value);
        }
        bitField0_ |= 0x00000008;
        return this;
      }
      /**
       * <pre>
       * Feature extractor config.
       * </pre>
       *
       * <code>optional .object_detection.protos.FasterRcnnFeatureExtractor feature_extractor = 5;</code>
       */
      public Builder clearFeatureExtractor() {
        if (featureExtractorBuilder_ == null) {
          featureExtractor_ = null;
          onChanged();
        } else {
          featureExtractorBuilder_.clear();
        }
        bitField0_ = (bitField0_ & ~0x00000008);
        return this;
      }
      /**
       * <pre>
       * Feature extractor config.
       * </pre>
       *
       * <code>optional .object_detection.protos.FasterRcnnFeatureExtractor feature_extractor = 5;</code>
       */
      public object_detection.protos.FasterRcnnOuterClass.FasterRcnnFeatureExtractor.Builder getFeatureExtractorBuilder() {
        bitField0_ |= 0x00000008;
        onChanged();
        return getFeatureExtractorFieldBuilder().getBuilder();
      }
      /**
       * <pre>
       * Feature extractor config.
       * </pre>
       *
       * <code>optional .object_detection.protos.FasterRcnnFeatureExtractor feature_extractor = 5;</code>
       */
      public object_detection.protos.FasterRcnnOuterClass.FasterRcnnFeatureExtractorOrBuilder getFeatureExtractorOrBuilder() {
        if (featureExtractorBuilder_ != null) {
          return featureExtractorBuilder_.getMessageOrBuilder();
        } else {
          return featureExtractor_ == null ?
              object_detection.protos.FasterRcnnOuterClass.FasterRcnnFeatureExtractor.getDefaultInstance() : featureExtractor_;
        }
      }
      /**
       * <pre>
       * Feature extractor config.
       * </pre>
       *
       * <code>optional .object_detection.protos.FasterRcnnFeatureExtractor feature_extractor = 5;</code>
       */
      private com.google.protobuf.SingleFieldBuilderV3<
          object_detection.protos.FasterRcnnOuterClass.FasterRcnnFeatureExtractor, object_detection.protos.FasterRcnnOuterClass.FasterRcnnFeatureExtractor.Builder, object_detection.protos.FasterRcnnOuterClass.FasterRcnnFeatureExtractorOrBuilder>
          getFeatureExtractorFieldBuilder() {
        if (featureExtractorBuilder_ == null) {
          featureExtractorBuilder_ = new com.google.protobuf.SingleFieldBuilderV3<
              object_detection.protos.FasterRcnnOuterClass.FasterRcnnFeatureExtractor, object_detection.protos.FasterRcnnOuterClass.FasterRcnnFeatureExtractor.Builder, object_detection.protos.FasterRcnnOuterClass.FasterRcnnFeatureExtractorOrBuilder>(
                  getFeatureExtractor(),
                  getParentForChildren(),
                  isClean());
          featureExtractor_ = null;
        }
        return featureExtractorBuilder_;
      }

      private object_detection.protos.AnchorGeneratorOuterClass.AnchorGenerator firstStageAnchorGenerator_;
      private com.google.protobuf.SingleFieldBuilderV3<
          object_detection.protos.AnchorGeneratorOuterClass.AnchorGenerator, object_detection.protos.AnchorGeneratorOuterClass.AnchorGenerator.Builder, object_detection.protos.AnchorGeneratorOuterClass.AnchorGeneratorOrBuilder> firstStageAnchorGeneratorBuilder_;
      /**
       * <pre>
       * Anchor generator to compute RPN anchors.
       * </pre>
       *
       * <code>optional .object_detection.protos.AnchorGenerator first_stage_anchor_generator = 6;</code>
       * @return Whether the firstStageAnchorGenerator field is set.
       */
      public boolean hasFirstStageAnchorGenerator() {
        return ((bitField0_ & 0x00000010) != 0);
      }
      /**
       * <pre>
       * Anchor generator to compute RPN anchors.
       * </pre>
       *
       * <code>optional .object_detection.protos.AnchorGenerator first_stage_anchor_generator = 6;</code>
       * @return The firstStageAnchorGenerator.
       */
      public object_detection.protos.AnchorGeneratorOuterClass.AnchorGenerator getFirstStageAnchorGenerator() {
        if (firstStageAnchorGeneratorBuilder_ == null) {
          return firstStageAnchorGenerator_ == null ? object_detection.protos.AnchorGeneratorOuterClass.AnchorGenerator.getDefaultInstance() : firstStageAnchorGenerator_;
        } else {
          return firstStageAnchorGeneratorBuilder_.getMessage();
        }
      }
      /**
       * <pre>
       * Anchor generator to compute RPN anchors.
       * </pre>
       *
       * <code>optional .object_detection.protos.AnchorGenerator first_stage_anchor_generator = 6;</code>
       */
      public Builder setFirstStageAnchorGenerator(object_detection.protos.AnchorGeneratorOuterClass.AnchorGenerator value) {
        if (firstStageAnchorGeneratorBuilder_ == null) {
          if (value == null) {
            throw new NullPointerException();
          }
          firstStageAnchorGenerator_ = value;
          onChanged();
        } else {
          firstStageAnchorGeneratorBuilder_.setMessage(value);
        }
        bitField0_ |= 0x00000010;
        return this;
      }
      /**
       * <pre>
       * Anchor generator to compute RPN anchors.
       * </pre>
       *
       * <code>optional .object_detection.protos.AnchorGenerator first_stage_anchor_generator = 6;</code>
       */
      public Builder setFirstStageAnchorGenerator(
          object_detection.protos.AnchorGeneratorOuterClass.AnchorGenerator.Builder builderForValue) {
        if (firstStageAnchorGeneratorBuilder_ == null) {
          firstStageAnchorGenerator_ = builderForValue.build();
          onChanged();
        } else {
          firstStageAnchorGeneratorBuilder_.setMessage(builderForValue.build());
        }
        bitField0_ |= 0x00000010;
        return this;
      }
      /**
       * <pre>
       * Anchor generator to compute RPN anchors.
       * </pre>
       *
       * <code>optional .object_detection.protos.AnchorGenerator first_stage_anchor_generator = 6;</code>
       */
      public Builder mergeFirstStageAnchorGenerator(object_detection.protos.AnchorGeneratorOuterClass.AnchorGenerator value) {
        if (firstStageAnchorGeneratorBuilder_ == null) {
          if (((bitField0_ & 0x00000010) != 0) &&
              firstStageAnchorGenerator_ != null &&
              firstStageAnchorGenerator_ != object_detection.protos.AnchorGeneratorOuterClass.AnchorGenerator.getDefaultInstance()) {
            firstStageAnchorGenerator_ =
              object_detection.protos.AnchorGeneratorOuterClass.AnchorGenerator.newBuilder(firstStageAnchorGenerator_).mergeFrom(value).buildPartial();
          } else {
            firstStageAnchorGenerator_ = value;
          }
          onChanged();
        } else {
          firstStageAnchorGeneratorBuilder_.mergeFrom(value);
        }
        bitField0_ |= 0x00000010;
        return this;
      }
      /**
       * <pre>
       * Anchor generator to compute RPN anchors.
       * </pre>
       *
       * <code>optional .object_detection.protos.AnchorGenerator first_stage_anchor_generator = 6;</code>
       */
      public Builder clearFirstStageAnchorGenerator() {
        if (firstStageAnchorGeneratorBuilder_ == null) {
          firstStageAnchorGenerator_ = null;
          onChanged();
        } else {
          firstStageAnchorGeneratorBuilder_.clear();
        }
        bitField0_ = (bitField0_ & ~0x00000010);
        return this;
      }
      /**
       * <pre>
       * Anchor generator to compute RPN anchors.
       * </pre>
       *
       * <code>optional .object_detection.protos.AnchorGenerator first_stage_anchor_generator = 6;</code>
       */
      public object_detection.protos.AnchorGeneratorOuterClass.AnchorGenerator.Builder getFirstStageAnchorGeneratorBuilder() {
        bitField0_ |= 0x00000010;
        onChanged();
        return getFirstStageAnchorGeneratorFieldBuilder().getBuilder();
      }
      /**
       * <pre>
       * Anchor generator to compute RPN anchors.
       * </pre>
       *
       * <code>optional .object_detection.protos.AnchorGenerator first_stage_anchor_generator = 6;</code>
       */
      public object_detection.protos.AnchorGeneratorOuterClass.AnchorGeneratorOrBuilder getFirstStageAnchorGeneratorOrBuilder() {
        if (firstStageAnchorGeneratorBuilder_ != null) {
          return firstStageAnchorGeneratorBuilder_.getMessageOrBuilder();
        } else {
          return firstStageAnchorGenerator_ == null ?
              object_detection.protos.AnchorGeneratorOuterClass.AnchorGenerator.getDefaultInstance() : firstStageAnchorGenerator_;
        }
      }
      /**
       * <pre>
       * Anchor generator to compute RPN anchors.
       * </pre>
       *
       * <code>optional .object_detection.protos.AnchorGenerator first_stage_anchor_generator = 6;</code>
       */
      private com.google.protobuf.SingleFieldBuilderV3<
          object_detection.protos.AnchorGeneratorOuterClass.AnchorGenerator, object_detection.protos.AnchorGeneratorOuterClass.AnchorGenerator.Builder, object_detection.protos.AnchorGeneratorOuterClass.AnchorGeneratorOrBuilder>
          getFirstStageAnchorGeneratorFieldBuilder() {
        if (firstStageAnchorGeneratorBuilder_ == null) {
          firstStageAnchorGeneratorBuilder_ = new com.google.protobuf.SingleFieldBuilderV3<
              object_detection.protos.AnchorGeneratorOuterClass.AnchorGenerator, object_detection.protos.AnchorGeneratorOuterClass.AnchorGenerator.Builder, object_detection.protos.AnchorGeneratorOuterClass.AnchorGeneratorOrBuilder>(
                  getFirstStageAnchorGenerator(),
                  getParentForChildren(),
                  isClean());
          firstStageAnchorGenerator_ = null;
        }
        return firstStageAnchorGeneratorBuilder_;
      }

      private int firstStageAtrousRate_ = 1;
      /**
       * <pre>
       * Atrous rate for the convolution op applied to the
       * `first_stage_features_to_crop` tensor to obtain box predictions.
       * </pre>
       *
       * <code>optional int32 first_stage_atrous_rate = 7 [default = 1];</code>
       * @return Whether the firstStageAtrousRate field is set.
       */
      @java.lang.Override
      public boolean hasFirstStageAtrousRate() {
        return ((bitField0_ & 0x00000020) != 0);
      }
      /**
       * <pre>
       * Atrous rate for the convolution op applied to the
       * `first_stage_features_to_crop` tensor to obtain box predictions.
       * </pre>
       *
       * <code>optional int32 first_stage_atrous_rate = 7 [default = 1];</code>
       * @return The firstStageAtrousRate.
       */
      @java.lang.Override
      public int getFirstStageAtrousRate() {
        return firstStageAtrousRate_;
      }
      /**
       * <pre>
       * Atrous rate for the convolution op applied to the
       * `first_stage_features_to_crop` tensor to obtain box predictions.
       * </pre>
       *
       * <code>optional int32 first_stage_atrous_rate = 7 [default = 1];</code>
       * @param value The firstStageAtrousRate to set.
       * @return This builder for chaining.
       */
      public Builder setFirstStageAtrousRate(int value) {
        bitField0_ |= 0x00000020;
        firstStageAtrousRate_ = value;
        onChanged();
        return this;
      }
      /**
       * <pre>
       * Atrous rate for the convolution op applied to the
       * `first_stage_features_to_crop` tensor to obtain box predictions.
       * </pre>
       *
       * <code>optional int32 first_stage_atrous_rate = 7 [default = 1];</code>
       * @return This builder for chaining.
       */
      public Builder clearFirstStageAtrousRate() {
        bitField0_ = (bitField0_ & ~0x00000020);
        firstStageAtrousRate_ = 1;
        onChanged();
        return this;
      }

      private object_detection.protos.HyperparamsOuterClass.Hyperparams firstStageBoxPredictorConvHyperparams_;
      private com.google.protobuf.SingleFieldBuilderV3<
          object_detection.protos.HyperparamsOuterClass.Hyperparams, object_detection.protos.HyperparamsOuterClass.Hyperparams.Builder, object_detection.protos.HyperparamsOuterClass.HyperparamsOrBuilder> firstStageBoxPredictorConvHyperparamsBuilder_;
      /**
       * <pre>
       * Hyperparameters for the convolutional RPN box predictor.
       * </pre>
       *
       * <code>optional .object_detection.protos.Hyperparams first_stage_box_predictor_conv_hyperparams = 8;</code>
       * @return Whether the firstStageBoxPredictorConvHyperparams field is set.
       */
      public boolean hasFirstStageBoxPredictorConvHyperparams() {
        return ((bitField0_ & 0x00000040) != 0);
      }
      /**
       * <pre>
       * Hyperparameters for the convolutional RPN box predictor.
       * </pre>
       *
       * <code>optional .object_detection.protos.Hyperparams first_stage_box_predictor_conv_hyperparams = 8;</code>
       * @return The firstStageBoxPredictorConvHyperparams.
       */
      public object_detection.protos.HyperparamsOuterClass.Hyperparams getFirstStageBoxPredictorConvHyperparams() {
        if (firstStageBoxPredictorConvHyperparamsBuilder_ == null) {
          return firstStageBoxPredictorConvHyperparams_ == null ? object_detection.protos.HyperparamsOuterClass.Hyperparams.getDefaultInstance() : firstStageBoxPredictorConvHyperparams_;
        } else {
          return firstStageBoxPredictorConvHyperparamsBuilder_.getMessage();
        }
      }
      /**
       * <pre>
       * Hyperparameters for the convolutional RPN box predictor.
       * </pre>
       *
       * <code>optional .object_detection.protos.Hyperparams first_stage_box_predictor_conv_hyperparams = 8;</code>
       */
      public Builder setFirstStageBoxPredictorConvHyperparams(object_detection.protos.HyperparamsOuterClass.Hyperparams value) {
        if (firstStageBoxPredictorConvHyperparamsBuilder_ == null) {
          if (value == null) {
            throw new NullPointerException();
          }
          firstStageBoxPredictorConvHyperparams_ = value;
          onChanged();
        } else {
          firstStageBoxPredictorConvHyperparamsBuilder_.setMessage(value);
        }
        bitField0_ |= 0x00000040;
        return this;
      }
      /**
       * <pre>
       * Hyperparameters for the convolutional RPN box predictor.
       * </pre>
       *
       * <code>optional .object_detection.protos.Hyperparams first_stage_box_predictor_conv_hyperparams = 8;</code>
       */
      public Builder setFirstStageBoxPredictorConvHyperparams(
          object_detection.protos.HyperparamsOuterClass.Hyperparams.Builder builderForValue) {
        if (firstStageBoxPredictorConvHyperparamsBuilder_ == null) {
          firstStageBoxPredictorConvHyperparams_ = builderForValue.build();
          onChanged();
        } else {
          firstStageBoxPredictorConvHyperparamsBuilder_.setMessage(builderForValue.build());
        }
        bitField0_ |= 0x00000040;
        return this;
      }
      /**
       * <pre>
       * Hyperparameters for the convolutional RPN box predictor.
       * </pre>
       *
       * <code>optional .object_detection.protos.Hyperparams first_stage_box_predictor_conv_hyperparams = 8;</code>
       */
      public Builder mergeFirstStageBoxPredictorConvHyperparams(object_detection.protos.HyperparamsOuterClass.Hyperparams value) {
        if (firstStageBoxPredictorConvHyperparamsBuilder_ == null) {
          if (((bitField0_ & 0x00000040) != 0) &&
              firstStageBoxPredictorConvHyperparams_ != null &&
              firstStageBoxPredictorConvHyperparams_ != object_detection.protos.HyperparamsOuterClass.Hyperparams.getDefaultInstance()) {
            firstStageBoxPredictorConvHyperparams_ =
              object_detection.protos.HyperparamsOuterClass.Hyperparams.newBuilder(firstStageBoxPredictorConvHyperparams_).mergeFrom(value).buildPartial();
          } else {
            firstStageBoxPredictorConvHyperparams_ = value;
          }
          onChanged();
        } else {
          firstStageBoxPredictorConvHyperparamsBuilder_.mergeFrom(value);
        }
        bitField0_ |= 0x00000040;
        return this;
      }
      /**
       * <pre>
       * Hyperparameters for the convolutional RPN box predictor.
       * </pre>
       *
       * <code>optional .object_detection.protos.Hyperparams first_stage_box_predictor_conv_hyperparams = 8;</code>
       */
      public Builder clearFirstStageBoxPredictorConvHyperparams() {
        if (firstStageBoxPredictorConvHyperparamsBuilder_ == null) {
          firstStageBoxPredictorConvHyperparams_ = null;
          onChanged();
        } else {
          firstStageBoxPredictorConvHyperparamsBuilder_.clear();
        }
        bitField0_ = (bitField0_ & ~0x00000040);
        return this;
      }
      /**
       * <pre>
       * Hyperparameters for the convolutional RPN box predictor.
       * </pre>
       *
       * <code>optional .object_detection.protos.Hyperparams first_stage_box_predictor_conv_hyperparams = 8;</code>
       */
      public object_detection.protos.HyperparamsOuterClass.Hyperparams.Builder getFirstStageBoxPredictorConvHyperparamsBuilder() {
        bitField0_ |= 0x00000040;
        onChanged();
        return getFirstStageBoxPredictorConvHyperparamsFieldBuilder().getBuilder();
      }
      /**
       * <pre>
       * Hyperparameters for the convolutional RPN box predictor.
       * </pre>
       *
       * <code>optional .object_detection.protos.Hyperparams first_stage_box_predictor_conv_hyperparams = 8;</code>
       */
      public object_detection.protos.HyperparamsOuterClass.HyperparamsOrBuilder getFirstStageBoxPredictorConvHyperparamsOrBuilder() {
        if (firstStageBoxPredictorConvHyperparamsBuilder_ != null) {
          return firstStageBoxPredictorConvHyperparamsBuilder_.getMessageOrBuilder();
        } else {
          return firstStageBoxPredictorConvHyperparams_ == null ?
              object_detection.protos.HyperparamsOuterClass.Hyperparams.getDefaultInstance() : firstStageBoxPredictorConvHyperparams_;
        }
      }
      /**
       * <pre>
       * Hyperparameters for the convolutional RPN box predictor.
       * </pre>
       *
       * <code>optional .object_detection.protos.Hyperparams first_stage_box_predictor_conv_hyperparams = 8;</code>
       */
      private com.google.protobuf.SingleFieldBuilderV3<
          object_detection.protos.HyperparamsOuterClass.Hyperparams, object_detection.protos.HyperparamsOuterClass.Hyperparams.Builder, object_detection.protos.HyperparamsOuterClass.HyperparamsOrBuilder>
          getFirstStageBoxPredictorConvHyperparamsFieldBuilder() {
        if (firstStageBoxPredictorConvHyperparamsBuilder_ == null) {
          firstStageBoxPredictorConvHyperparamsBuilder_ = new com.google.protobuf.SingleFieldBuilderV3<
              object_detection.protos.HyperparamsOuterClass.Hyperparams, object_detection.protos.HyperparamsOuterClass.Hyperparams.Builder, object_detection.protos.HyperparamsOuterClass.HyperparamsOrBuilder>(
                  getFirstStageBoxPredictorConvHyperparams(),
                  getParentForChildren(),
                  isClean());
          firstStageBoxPredictorConvHyperparams_ = null;
        }
        return firstStageBoxPredictorConvHyperparamsBuilder_;
      }

      private int firstStageBoxPredictorKernelSize_ = 3;
      /**
       * <pre>
       * Kernel size to use for the convolution op just prior to RPN box
       * predictions.
       * </pre>
       *
       * <code>optional int32 first_stage_box_predictor_kernel_size = 9 [default = 3];</code>
       * @return Whether the firstStageBoxPredictorKernelSize field is set.
       */
      @java.lang.Override
      public boolean hasFirstStageBoxPredictorKernelSize() {
        return ((bitField0_ & 0x00000080) != 0);
      }
      /**
       * <pre>
       * Kernel size to use for the convolution op just prior to RPN box
       * predictions.
       * </pre>
       *
       * <code>optional int32 first_stage_box_predictor_kernel_size = 9 [default = 3];</code>
       * @return The firstStageBoxPredictorKernelSize.
       */
      @java.lang.Override
      public int getFirstStageBoxPredictorKernelSize() {
        return firstStageBoxPredictorKernelSize_;
      }
      /**
       * <pre>
       * Kernel size to use for the convolution op just prior to RPN box
       * predictions.
       * </pre>
       *
       * <code>optional int32 first_stage_box_predictor_kernel_size = 9 [default = 3];</code>
       * @param value The firstStageBoxPredictorKernelSize to set.
       * @return This builder for chaining.
       */
      public Builder setFirstStageBoxPredictorKernelSize(int value) {
        bitField0_ |= 0x00000080;
        firstStageBoxPredictorKernelSize_ = value;
        onChanged();
        return this;
      }
      /**
       * <pre>
       * Kernel size to use for the convolution op just prior to RPN box
       * predictions.
       * </pre>
       *
       * <code>optional int32 first_stage_box_predictor_kernel_size = 9 [default = 3];</code>
       * @return This builder for chaining.
       */
      public Builder clearFirstStageBoxPredictorKernelSize() {
        bitField0_ = (bitField0_ & ~0x00000080);
        firstStageBoxPredictorKernelSize_ = 3;
        onChanged();
        return this;
      }

      private int firstStageBoxPredictorDepth_ = 512;
      /**
       * <pre>
       * Output depth for the convolution op just prior to RPN box predictions.
       * </pre>
       *
       * <code>optional int32 first_stage_box_predictor_depth = 10 [default = 512];</code>
       * @return Whether the firstStageBoxPredictorDepth field is set.
       */
      @java.lang.Override
      public boolean hasFirstStageBoxPredictorDepth() {
        return ((bitField0_ & 0x00000100) != 0);
      }
      /**
       * <pre>
       * Output depth for the convolution op just prior to RPN box predictions.
       * </pre>
       *
       * <code>optional int32 first_stage_box_predictor_depth = 10 [default = 512];</code>
       * @return The firstStageBoxPredictorDepth.
       */
      @java.lang.Override
      public int getFirstStageBoxPredictorDepth() {
        return firstStageBoxPredictorDepth_;
      }
      /**
       * <pre>
       * Output depth for the convolution op just prior to RPN box predictions.
       * </pre>
       *
       * <code>optional int32 first_stage_box_predictor_depth = 10 [default = 512];</code>
       * @param value The firstStageBoxPredictorDepth to set.
       * @return This builder for chaining.
       */
      public Builder setFirstStageBoxPredictorDepth(int value) {
        bitField0_ |= 0x00000100;
        firstStageBoxPredictorDepth_ = value;
        onChanged();
        return this;
      }
      /**
       * <pre>
       * Output depth for the convolution op just prior to RPN box predictions.
       * </pre>
       *
       * <code>optional int32 first_stage_box_predictor_depth = 10 [default = 512];</code>
       * @return This builder for chaining.
       */
      public Builder clearFirstStageBoxPredictorDepth() {
        bitField0_ = (bitField0_ & ~0x00000100);
        firstStageBoxPredictorDepth_ = 512;
        onChanged();
        return this;
      }

      private int firstStageMinibatchSize_ = 256;
      /**
       * <pre>
       * The batch size to use for computing the first stage objectness and
       * location losses.
       * </pre>
       *
       * <code>optional int32 first_stage_minibatch_size = 11 [default = 256];</code>
       * @return Whether the firstStageMinibatchSize field is set.
       */
      @java.lang.Override
      public boolean hasFirstStageMinibatchSize() {
        return ((bitField0_ & 0x00000200) != 0);
      }
      /**
       * <pre>
       * The batch size to use for computing the first stage objectness and
       * location losses.
       * </pre>
       *
       * <code>optional int32 first_stage_minibatch_size = 11 [default = 256];</code>
       * @return The firstStageMinibatchSize.
       */
      @java.lang.Override
      public int getFirstStageMinibatchSize() {
        return firstStageMinibatchSize_;
      }
      /**
       * <pre>
       * The batch size to use for computing the first stage objectness and
       * location losses.
       * </pre>
       *
       * <code>optional int32 first_stage_minibatch_size = 11 [default = 256];</code>
       * @param value The firstStageMinibatchSize to set.
       * @return This builder for chaining.
       */
      public Builder setFirstStageMinibatchSize(int value) {
        bitField0_ |= 0x00000200;
        firstStageMinibatchSize_ = value;
        onChanged();
        return this;
      }
      /**
       * <pre>
       * The batch size to use for computing the first stage objectness and
       * location losses.
       * </pre>
       *
       * <code>optional int32 first_stage_minibatch_size = 11 [default = 256];</code>
       * @return This builder for chaining.
       */
      public Builder clearFirstStageMinibatchSize() {
        bitField0_ = (bitField0_ & ~0x00000200);
        firstStageMinibatchSize_ = 256;
        onChanged();
        return this;
      }

      private float firstStagePositiveBalanceFraction_ = 0.5F;
      /**
       * <pre>
       * Fraction of positive examples per image for the RPN.
       * </pre>
       *
       * <code>optional float first_stage_positive_balance_fraction = 12 [default = 0.5];</code>
       * @return Whether the firstStagePositiveBalanceFraction field is set.
       */
      @java.lang.Override
      public boolean hasFirstStagePositiveBalanceFraction() {
        return ((bitField0_ & 0x00000400) != 0);
      }
      /**
       * <pre>
       * Fraction of positive examples per image for the RPN.
       * </pre>
       *
       * <code>optional float first_stage_positive_balance_fraction = 12 [default = 0.5];</code>
       * @return The firstStagePositiveBalanceFraction.
       */
      @java.lang.Override
      public float getFirstStagePositiveBalanceFraction() {
        return firstStagePositiveBalanceFraction_;
      }
      /**
       * <pre>
       * Fraction of positive examples per image for the RPN.
       * </pre>
       *
       * <code>optional float first_stage_positive_balance_fraction = 12 [default = 0.5];</code>
       * @param value The firstStagePositiveBalanceFraction to set.
       * @return This builder for chaining.
       */
      public Builder setFirstStagePositiveBalanceFraction(float value) {
        bitField0_ |= 0x00000400;
        firstStagePositiveBalanceFraction_ = value;
        onChanged();
        return this;
      }
      /**
       * <pre>
       * Fraction of positive examples per image for the RPN.
       * </pre>
       *
       * <code>optional float first_stage_positive_balance_fraction = 12 [default = 0.5];</code>
       * @return This builder for chaining.
       */
      public Builder clearFirstStagePositiveBalanceFraction() {
        bitField0_ = (bitField0_ & ~0x00000400);
        firstStagePositiveBalanceFraction_ = 0.5F;
        onChanged();
        return this;
      }

      private float firstStageNmsScoreThreshold_ ;
      /**
       * <pre>
       * Non max suppression score threshold applied to first stage RPN proposals.
       * </pre>
       *
       * <code>optional float first_stage_nms_score_threshold = 13 [default = 0];</code>
       * @return Whether the firstStageNmsScoreThreshold field is set.
       */
      @java.lang.Override
      public boolean hasFirstStageNmsScoreThreshold() {
        return ((bitField0_ & 0x00000800) != 0);
      }
      /**
       * <pre>
       * Non max suppression score threshold applied to first stage RPN proposals.
       * </pre>
       *
       * <code>optional float first_stage_nms_score_threshold = 13 [default = 0];</code>
       * @return The firstStageNmsScoreThreshold.
       */
      @java.lang.Override
      public float getFirstStageNmsScoreThreshold() {
        return firstStageNmsScoreThreshold_;
      }
      /**
       * <pre>
       * Non max suppression score threshold applied to first stage RPN proposals.
       * </pre>
       *
       * <code>optional float first_stage_nms_score_threshold = 13 [default = 0];</code>
       * @param value The firstStageNmsScoreThreshold to set.
       * @return This builder for chaining.
       */
      public Builder setFirstStageNmsScoreThreshold(float value) {
        bitField0_ |= 0x00000800;
        firstStageNmsScoreThreshold_ = value;
        onChanged();
        return this;
      }
      /**
       * <pre>
       * Non max suppression score threshold applied to first stage RPN proposals.
       * </pre>
       *
       * <code>optional float first_stage_nms_score_threshold = 13 [default = 0];</code>
       * @return This builder for chaining.
       */
      public Builder clearFirstStageNmsScoreThreshold() {
        bitField0_ = (bitField0_ & ~0x00000800);
        firstStageNmsScoreThreshold_ = 0F;
        onChanged();
        return this;
      }

      private float firstStageNmsIouThreshold_ = 0.7F;
      /**
       * <pre>
       * Non max suppression IOU threshold applied to first stage RPN proposals.
       * </pre>
       *
       * <code>optional float first_stage_nms_iou_threshold = 14 [default = 0.7];</code>
       * @return Whether the firstStageNmsIouThreshold field is set.
       */
      @java.lang.Override
      public boolean hasFirstStageNmsIouThreshold() {
        return ((bitField0_ & 0x00001000) != 0);
      }
      /**
       * <pre>
       * Non max suppression IOU threshold applied to first stage RPN proposals.
       * </pre>
       *
       * <code>optional float first_stage_nms_iou_threshold = 14 [default = 0.7];</code>
       * @return The firstStageNmsIouThreshold.
       */
      @java.lang.Override
      public float getFirstStageNmsIouThreshold() {
        return firstStageNmsIouThreshold_;
      }
      /**
       * <pre>
       * Non max suppression IOU threshold applied to first stage RPN proposals.
       * </pre>
       *
       * <code>optional float first_stage_nms_iou_threshold = 14 [default = 0.7];</code>
       * @param value The firstStageNmsIouThreshold to set.
       * @return This builder for chaining.
       */
      public Builder setFirstStageNmsIouThreshold(float value) {
        bitField0_ |= 0x00001000;
        firstStageNmsIouThreshold_ = value;
        onChanged();
        return this;
      }
      /**
       * <pre>
       * Non max suppression IOU threshold applied to first stage RPN proposals.
       * </pre>
       *
       * <code>optional float first_stage_nms_iou_threshold = 14 [default = 0.7];</code>
       * @return This builder for chaining.
       */
      public Builder clearFirstStageNmsIouThreshold() {
        bitField0_ = (bitField0_ & ~0x00001000);
        firstStageNmsIouThreshold_ = 0.7F;
        onChanged();
        return this;
      }

      private int firstStageMaxProposals_ = 300;
      /**
       * <pre>
       * Maximum number of RPN proposals retained after first stage postprocessing.
       * </pre>
       *
       * <code>optional int32 first_stage_max_proposals = 15 [default = 300];</code>
       * @return Whether the firstStageMaxProposals field is set.
       */
      @java.lang.Override
      public boolean hasFirstStageMaxProposals() {
        return ((bitField0_ & 0x00002000) != 0);
      }
      /**
       * <pre>
       * Maximum number of RPN proposals retained after first stage postprocessing.
       * </pre>
       *
       * <code>optional int32 first_stage_max_proposals = 15 [default = 300];</code>
       * @return The firstStageMaxProposals.
       */
      @java.lang.Override
      public int getFirstStageMaxProposals() {
        return firstStageMaxProposals_;
      }
      /**
       * <pre>
       * Maximum number of RPN proposals retained after first stage postprocessing.
       * </pre>
       *
       * <code>optional int32 first_stage_max_proposals = 15 [default = 300];</code>
       * @param value The firstStageMaxProposals to set.
       * @return This builder for chaining.
       */
      public Builder setFirstStageMaxProposals(int value) {
        bitField0_ |= 0x00002000;
        firstStageMaxProposals_ = value;
        onChanged();
        return this;
      }
      /**
       * <pre>
       * Maximum number of RPN proposals retained after first stage postprocessing.
       * </pre>
       *
       * <code>optional int32 first_stage_max_proposals = 15 [default = 300];</code>
       * @return This builder for chaining.
       */
      public Builder clearFirstStageMaxProposals() {
        bitField0_ = (bitField0_ & ~0x00002000);
        firstStageMaxProposals_ = 300;
        onChanged();
        return this;
      }

      private float firstStageLocalizationLossWeight_ = 1F;
      /**
       * <pre>
       * First stage RPN localization loss weight.
       * </pre>
       *
       * <code>optional float first_stage_localization_loss_weight = 16 [default = 1];</code>
       * @return Whether the firstStageLocalizationLossWeight field is set.
       */
      @java.lang.Override
      public boolean hasFirstStageLocalizationLossWeight() {
        return ((bitField0_ & 0x00004000) != 0);
      }
      /**
       * <pre>
       * First stage RPN localization loss weight.
       * </pre>
       *
       * <code>optional float first_stage_localization_loss_weight = 16 [default = 1];</code>
       * @return The firstStageLocalizationLossWeight.
       */
      @java.lang.Override
      public float getFirstStageLocalizationLossWeight() {
        return firstStageLocalizationLossWeight_;
      }
      /**
       * <pre>
       * First stage RPN localization loss weight.
       * </pre>
       *
       * <code>optional float first_stage_localization_loss_weight = 16 [default = 1];</code>
       * @param value The firstStageLocalizationLossWeight to set.
       * @return This builder for chaining.
       */
      public Builder setFirstStageLocalizationLossWeight(float value) {
        bitField0_ |= 0x00004000;
        firstStageLocalizationLossWeight_ = value;
        onChanged();
        return this;
      }
      /**
       * <pre>
       * First stage RPN localization loss weight.
       * </pre>
       *
       * <code>optional float first_stage_localization_loss_weight = 16 [default = 1];</code>
       * @return This builder for chaining.
       */
      public Builder clearFirstStageLocalizationLossWeight() {
        bitField0_ = (bitField0_ & ~0x00004000);
        firstStageLocalizationLossWeight_ = 1F;
        onChanged();
        return this;
      }

      private float firstStageObjectnessLossWeight_ = 1F;
      /**
       * <pre>
       * First stage RPN objectness loss weight.
       * </pre>
       *
       * <code>optional float first_stage_objectness_loss_weight = 17 [default = 1];</code>
       * @return Whether the firstStageObjectnessLossWeight field is set.
       */
      @java.lang.Override
      public boolean hasFirstStageObjectnessLossWeight() {
        return ((bitField0_ & 0x00008000) != 0);
      }
      /**
       * <pre>
       * First stage RPN objectness loss weight.
       * </pre>
       *
       * <code>optional float first_stage_objectness_loss_weight = 17 [default = 1];</code>
       * @return The firstStageObjectnessLossWeight.
       */
      @java.lang.Override
      public float getFirstStageObjectnessLossWeight() {
        return firstStageObjectnessLossWeight_;
      }
      /**
       * <pre>
       * First stage RPN objectness loss weight.
       * </pre>
       *
       * <code>optional float first_stage_objectness_loss_weight = 17 [default = 1];</code>
       * @param value The firstStageObjectnessLossWeight to set.
       * @return This builder for chaining.
       */
      public Builder setFirstStageObjectnessLossWeight(float value) {
        bitField0_ |= 0x00008000;
        firstStageObjectnessLossWeight_ = value;
        onChanged();
        return this;
      }
      /**
       * <pre>
       * First stage RPN objectness loss weight.
       * </pre>
       *
       * <code>optional float first_stage_objectness_loss_weight = 17 [default = 1];</code>
       * @return This builder for chaining.
       */
      public Builder clearFirstStageObjectnessLossWeight() {
        bitField0_ = (bitField0_ & ~0x00008000);
        firstStageObjectnessLossWeight_ = 1F;
        onChanged();
        return this;
      }

      private int initialCropSize_ ;
      /**
       * <pre>
       * Output size (width and height are set to be the same) of the initial
       * bilinear interpolation based cropping during ROI pooling.
       * </pre>
       *
       * <code>optional int32 initial_crop_size = 18;</code>
       * @return Whether the initialCropSize field is set.
       */
      @java.lang.Override
      public boolean hasInitialCropSize() {
        return ((bitField0_ & 0x00010000) != 0);
      }
      /**
       * <pre>
       * Output size (width and height are set to be the same) of the initial
       * bilinear interpolation based cropping during ROI pooling.
       * </pre>
       *
       * <code>optional int32 initial_crop_size = 18;</code>
       * @return The initialCropSize.
       */
      @java.lang.Override
      public int getInitialCropSize() {
        return initialCropSize_;
      }
      /**
       * <pre>
       * Output size (width and height are set to be the same) of the initial
       * bilinear interpolation based cropping during ROI pooling.
       * </pre>
       *
       * <code>optional int32 initial_crop_size = 18;</code>
       * @param value The initialCropSize to set.
       * @return This builder for chaining.
       */
      public Builder setInitialCropSize(int value) {
        bitField0_ |= 0x00010000;
        initialCropSize_ = value;
        onChanged();
        return this;
      }
      /**
       * <pre>
       * Output size (width and height are set to be the same) of the initial
       * bilinear interpolation based cropping during ROI pooling.
       * </pre>
       *
       * <code>optional int32 initial_crop_size = 18;</code>
       * @return This builder for chaining.
       */
      public Builder clearInitialCropSize() {
        bitField0_ = (bitField0_ & ~0x00010000);
        initialCropSize_ = 0;
        onChanged();
        return this;
      }

      private int maxpoolKernelSize_ ;
      /**
       * <pre>
       * Kernel size of the max pool op on the cropped feature map during
       * ROI pooling.
       * </pre>
       *
       * <code>optional int32 maxpool_kernel_size = 19;</code>
       * @return Whether the maxpoolKernelSize field is set.
       */
      @java.lang.Override
      public boolean hasMaxpoolKernelSize() {
        return ((bitField0_ & 0x00020000) != 0);
      }
      /**
       * <pre>
       * Kernel size of the max pool op on the cropped feature map during
       * ROI pooling.
       * </pre>
       *
       * <code>optional int32 maxpool_kernel_size = 19;</code>
       * @return The maxpoolKernelSize.
       */
      @java.lang.Override
      public int getMaxpoolKernelSize() {
        return maxpoolKernelSize_;
      }
      /**
       * <pre>
       * Kernel size of the max pool op on the cropped feature map during
       * ROI pooling.
       * </pre>
       *
       * <code>optional int32 maxpool_kernel_size = 19;</code>
       * @param value The maxpoolKernelSize to set.
       * @return This builder for chaining.
       */
      public Builder setMaxpoolKernelSize(int value) {
        bitField0_ |= 0x00020000;
        maxpoolKernelSize_ = value;
        onChanged();
        return this;
      }
      /**
       * <pre>
       * Kernel size of the max pool op on the cropped feature map during
       * ROI pooling.
       * </pre>
       *
       * <code>optional int32 maxpool_kernel_size = 19;</code>
       * @return This builder for chaining.
       */
      public Builder clearMaxpoolKernelSize() {
        bitField0_ = (bitField0_ & ~0x00020000);
        maxpoolKernelSize_ = 0;
        onChanged();
        return this;
      }

      private int maxpoolStride_ ;
      /**
       * <pre>
       * Stride of the max pool op on the cropped feature map during ROI pooling.
       * </pre>
       *
       * <code>optional int32 maxpool_stride = 20;</code>
       * @return Whether the maxpoolStride field is set.
       */
      @java.lang.Override
      public boolean hasMaxpoolStride() {
        return ((bitField0_ & 0x00040000) != 0);
      }
      /**
       * <pre>
       * Stride of the max pool op on the cropped feature map during ROI pooling.
       * </pre>
       *
       * <code>optional int32 maxpool_stride = 20;</code>
       * @return The maxpoolStride.
       */
      @java.lang.Override
      public int getMaxpoolStride() {
        return maxpoolStride_;
      }
      /**
       * <pre>
       * Stride of the max pool op on the cropped feature map during ROI pooling.
       * </pre>
       *
       * <code>optional int32 maxpool_stride = 20;</code>
       * @param value The maxpoolStride to set.
       * @return This builder for chaining.
       */
      public Builder setMaxpoolStride(int value) {
        bitField0_ |= 0x00040000;
        maxpoolStride_ = value;
        onChanged();
        return this;
      }
      /**
       * <pre>
       * Stride of the max pool op on the cropped feature map during ROI pooling.
       * </pre>
       *
       * <code>optional int32 maxpool_stride = 20;</code>
       * @return This builder for chaining.
       */
      public Builder clearMaxpoolStride() {
        bitField0_ = (bitField0_ & ~0x00040000);
        maxpoolStride_ = 0;
        onChanged();
        return this;
      }

      private object_detection.protos.BoxPredictorOuterClass.BoxPredictor secondStageBoxPredictor_;
      private com.google.protobuf.SingleFieldBuilderV3<
          object_detection.protos.BoxPredictorOuterClass.BoxPredictor, object_detection.protos.BoxPredictorOuterClass.BoxPredictor.Builder, object_detection.protos.BoxPredictorOuterClass.BoxPredictorOrBuilder> secondStageBoxPredictorBuilder_;
      /**
       * <pre>
       * Hyperparameters for the second stage box predictor. If box predictor type
       * is set to rfcn_box_predictor, a R-FCN model is constructed, otherwise a
       * Faster R-CNN model is constructed.
       * </pre>
       *
       * <code>optional .object_detection.protos.BoxPredictor second_stage_box_predictor = 21;</code>
       * @return Whether the secondStageBoxPredictor field is set.
       */
      public boolean hasSecondStageBoxPredictor() {
        return ((bitField0_ & 0x00080000) != 0);
      }
      /**
       * <pre>
       * Hyperparameters for the second stage box predictor. If box predictor type
       * is set to rfcn_box_predictor, a R-FCN model is constructed, otherwise a
       * Faster R-CNN model is constructed.
       * </pre>
       *
       * <code>optional .object_detection.protos.BoxPredictor second_stage_box_predictor = 21;</code>
       * @return The secondStageBoxPredictor.
       */
      public object_detection.protos.BoxPredictorOuterClass.BoxPredictor getSecondStageBoxPredictor() {
        if (secondStageBoxPredictorBuilder_ == null) {
          return secondStageBoxPredictor_ == null ? object_detection.protos.BoxPredictorOuterClass.BoxPredictor.getDefaultInstance() : secondStageBoxPredictor_;
        } else {
          return secondStageBoxPredictorBuilder_.getMessage();
        }
      }
      /**
       * <pre>
       * Hyperparameters for the second stage box predictor. If box predictor type
       * is set to rfcn_box_predictor, a R-FCN model is constructed, otherwise a
       * Faster R-CNN model is constructed.
       * </pre>
       *
       * <code>optional .object_detection.protos.BoxPredictor second_stage_box_predictor = 21;</code>
       */
      public Builder setSecondStageBoxPredictor(object_detection.protos.BoxPredictorOuterClass.BoxPredictor value) {
        if (secondStageBoxPredictorBuilder_ == null) {
          if (value == null) {
            throw new NullPointerException();
          }
          secondStageBoxPredictor_ = value;
          onChanged();
        } else {
          secondStageBoxPredictorBuilder_.setMessage(value);
        }
        bitField0_ |= 0x00080000;
        return this;
      }
      /**
       * <pre>
       * Hyperparameters for the second stage box predictor. If box predictor type
       * is set to rfcn_box_predictor, a R-FCN model is constructed, otherwise a
       * Faster R-CNN model is constructed.
       * </pre>
       *
       * <code>optional .object_detection.protos.BoxPredictor second_stage_box_predictor = 21;</code>
       */
      public Builder setSecondStageBoxPredictor(
          object_detection.protos.BoxPredictorOuterClass.BoxPredictor.Builder builderForValue) {
        if (secondStageBoxPredictorBuilder_ == null) {
          secondStageBoxPredictor_ = builderForValue.build();
          onChanged();
        } else {
          secondStageBoxPredictorBuilder_.setMessage(builderForValue.build());
        }
        bitField0_ |= 0x00080000;
        return this;
      }
      /**
       * <pre>
       * Hyperparameters for the second stage box predictor. If box predictor type
       * is set to rfcn_box_predictor, a R-FCN model is constructed, otherwise a
       * Faster R-CNN model is constructed.
       * </pre>
       *
       * <code>optional .object_detection.protos.BoxPredictor second_stage_box_predictor = 21;</code>
       */
      public Builder mergeSecondStageBoxPredictor(object_detection.protos.BoxPredictorOuterClass.BoxPredictor value) {
        if (secondStageBoxPredictorBuilder_ == null) {
          if (((bitField0_ & 0x00080000) != 0) &&
              secondStageBoxPredictor_ != null &&
              secondStageBoxPredictor_ != object_detection.protos.BoxPredictorOuterClass.BoxPredictor.getDefaultInstance()) {
            secondStageBoxPredictor_ =
              object_detection.protos.BoxPredictorOuterClass.BoxPredictor.newBuilder(secondStageBoxPredictor_).mergeFrom(value).buildPartial();
          } else {
            secondStageBoxPredictor_ = value;
          }
          onChanged();
        } else {
          secondStageBoxPredictorBuilder_.mergeFrom(value);
        }
        bitField0_ |= 0x00080000;
        return this;
      }
      /**
       * <pre>
       * Hyperparameters for the second stage box predictor. If box predictor type
       * is set to rfcn_box_predictor, a R-FCN model is constructed, otherwise a
       * Faster R-CNN model is constructed.
       * </pre>
       *
       * <code>optional .object_detection.protos.BoxPredictor second_stage_box_predictor = 21;</code>
       */
      public Builder clearSecondStageBoxPredictor() {
        if (secondStageBoxPredictorBuilder_ == null) {
          secondStageBoxPredictor_ = null;
          onChanged();
        } else {
          secondStageBoxPredictorBuilder_.clear();
        }
        bitField0_ = (bitField0_ & ~0x00080000);
        return this;
      }
      /**
       * <pre>
       * Hyperparameters for the second stage box predictor. If box predictor type
       * is set to rfcn_box_predictor, a R-FCN model is constructed, otherwise a
       * Faster R-CNN model is constructed.
       * </pre>
       *
       * <code>optional .object_detection.protos.BoxPredictor second_stage_box_predictor = 21;</code>
       */
      public object_detection.protos.BoxPredictorOuterClass.BoxPredictor.Builder getSecondStageBoxPredictorBuilder() {
        bitField0_ |= 0x00080000;
        onChanged();
        return getSecondStageBoxPredictorFieldBuilder().getBuilder();
      }
      /**
       * <pre>
       * Hyperparameters for the second stage box predictor. If box predictor type
       * is set to rfcn_box_predictor, a R-FCN model is constructed, otherwise a
       * Faster R-CNN model is constructed.
       * </pre>
       *
       * <code>optional .object_detection.protos.BoxPredictor second_stage_box_predictor = 21;</code>
       */
      public object_detection.protos.BoxPredictorOuterClass.BoxPredictorOrBuilder getSecondStageBoxPredictorOrBuilder() {
        if (secondStageBoxPredictorBuilder_ != null) {
          return secondStageBoxPredictorBuilder_.getMessageOrBuilder();
        } else {
          return secondStageBoxPredictor_ == null ?
              object_detection.protos.BoxPredictorOuterClass.BoxPredictor.getDefaultInstance() : secondStageBoxPredictor_;
        }
      }
      /**
       * <pre>
       * Hyperparameters for the second stage box predictor. If box predictor type
       * is set to rfcn_box_predictor, a R-FCN model is constructed, otherwise a
       * Faster R-CNN model is constructed.
       * </pre>
       *
       * <code>optional .object_detection.protos.BoxPredictor second_stage_box_predictor = 21;</code>
       */
      private com.google.protobuf.SingleFieldBuilderV3<
          object_detection.protos.BoxPredictorOuterClass.BoxPredictor, object_detection.protos.BoxPredictorOuterClass.BoxPredictor.Builder, object_detection.protos.BoxPredictorOuterClass.BoxPredictorOrBuilder>
          getSecondStageBoxPredictorFieldBuilder() {
        if (secondStageBoxPredictorBuilder_ == null) {
          secondStageBoxPredictorBuilder_ = new com.google.protobuf.SingleFieldBuilderV3<
              object_detection.protos.BoxPredictorOuterClass.BoxPredictor, object_detection.protos.BoxPredictorOuterClass.BoxPredictor.Builder, object_detection.protos.BoxPredictorOuterClass.BoxPredictorOrBuilder>(
                  getSecondStageBoxPredictor(),
                  getParentForChildren(),
                  isClean());
          secondStageBoxPredictor_ = null;
        }
        return secondStageBoxPredictorBuilder_;
      }

      private int secondStageBatchSize_ = 64;
      /**
       * <pre>
       * The batch size per image used for computing the classification and refined
       * location loss of the box classifier.
       * Note that this field is ignored if `hard_example_miner` is configured.
       * </pre>
       *
       * <code>optional int32 second_stage_batch_size = 22 [default = 64];</code>
       * @return Whether the secondStageBatchSize field is set.
       */
      @java.lang.Override
      public boolean hasSecondStageBatchSize() {
        return ((bitField0_ & 0x00100000) != 0);
      }
      /**
       * <pre>
       * The batch size per image used for computing the classification and refined
       * location loss of the box classifier.
       * Note that this field is ignored if `hard_example_miner` is configured.
       * </pre>
       *
       * <code>optional int32 second_stage_batch_size = 22 [default = 64];</code>
       * @return The secondStageBatchSize.
       */
      @java.lang.Override
      public int getSecondStageBatchSize() {
        return secondStageBatchSize_;
      }
      /**
       * <pre>
       * The batch size per image used for computing the classification and refined
       * location loss of the box classifier.
       * Note that this field is ignored if `hard_example_miner` is configured.
       * </pre>
       *
       * <code>optional int32 second_stage_batch_size = 22 [default = 64];</code>
       * @param value The secondStageBatchSize to set.
       * @return This builder for chaining.
       */
      public Builder setSecondStageBatchSize(int value) {
        bitField0_ |= 0x00100000;
        secondStageBatchSize_ = value;
        onChanged();
        return this;
      }
      /**
       * <pre>
       * The batch size per image used for computing the classification and refined
       * location loss of the box classifier.
       * Note that this field is ignored if `hard_example_miner` is configured.
       * </pre>
       *
       * <code>optional int32 second_stage_batch_size = 22 [default = 64];</code>
       * @return This builder for chaining.
       */
      public Builder clearSecondStageBatchSize() {
        bitField0_ = (bitField0_ & ~0x00100000);
        secondStageBatchSize_ = 64;
        onChanged();
        return this;
      }

      private float secondStageBalanceFraction_ = 0.25F;
      /**
       * <pre>
       * Fraction of positive examples to use per image for the box classifier.
       * </pre>
       *
       * <code>optional float second_stage_balance_fraction = 23 [default = 0.25];</code>
       * @return Whether the secondStageBalanceFraction field is set.
       */
      @java.lang.Override
      public boolean hasSecondStageBalanceFraction() {
        return ((bitField0_ & 0x00200000) != 0);
      }
      /**
       * <pre>
       * Fraction of positive examples to use per image for the box classifier.
       * </pre>
       *
       * <code>optional float second_stage_balance_fraction = 23 [default = 0.25];</code>
       * @return The secondStageBalanceFraction.
       */
      @java.lang.Override
      public float getSecondStageBalanceFraction() {
        return secondStageBalanceFraction_;
      }
      /**
       * <pre>
       * Fraction of positive examples to use per image for the box classifier.
       * </pre>
       *
       * <code>optional float second_stage_balance_fraction = 23 [default = 0.25];</code>
       * @param value The secondStageBalanceFraction to set.
       * @return This builder for chaining.
       */
      public Builder setSecondStageBalanceFraction(float value) {
        bitField0_ |= 0x00200000;
        secondStageBalanceFraction_ = value;
        onChanged();
        return this;
      }
      /**
       * <pre>
       * Fraction of positive examples to use per image for the box classifier.
       * </pre>
       *
       * <code>optional float second_stage_balance_fraction = 23 [default = 0.25];</code>
       * @return This builder for chaining.
       */
      public Builder clearSecondStageBalanceFraction() {
        bitField0_ = (bitField0_ & ~0x00200000);
        secondStageBalanceFraction_ = 0.25F;
        onChanged();
        return this;
      }

      private object_detection.protos.PostProcessingOuterClass.PostProcessing secondStagePostProcessing_;
      private com.google.protobuf.SingleFieldBuilderV3<
          object_detection.protos.PostProcessingOuterClass.PostProcessing, object_detection.protos.PostProcessingOuterClass.PostProcessing.Builder, object_detection.protos.PostProcessingOuterClass.PostProcessingOrBuilder> secondStagePostProcessingBuilder_;
      /**
       * <pre>
       * Post processing to apply on the second stage box classifier predictions.
       * Note: the `score_converter` provided to the FasterRCNNMetaArch constructor
       * is taken from this `second_stage_post_processing` proto.
       * </pre>
       *
       * <code>optional .object_detection.protos.PostProcessing second_stage_post_processing = 24;</code>
       * @return Whether the secondStagePostProcessing field is set.
       */
      public boolean hasSecondStagePostProcessing() {
        return ((bitField0_ & 0x00400000) != 0);
      }
      /**
       * <pre>
       * Post processing to apply on the second stage box classifier predictions.
       * Note: the `score_converter` provided to the FasterRCNNMetaArch constructor
       * is taken from this `second_stage_post_processing` proto.
       * </pre>
       *
       * <code>optional .object_detection.protos.PostProcessing second_stage_post_processing = 24;</code>
       * @return The secondStagePostProcessing.
       */
      public object_detection.protos.PostProcessingOuterClass.PostProcessing getSecondStagePostProcessing() {
        if (secondStagePostProcessingBuilder_ == null) {
          return secondStagePostProcessing_ == null ? object_detection.protos.PostProcessingOuterClass.PostProcessing.getDefaultInstance() : secondStagePostProcessing_;
        } else {
          return secondStagePostProcessingBuilder_.getMessage();
        }
      }
      /**
       * <pre>
       * Post processing to apply on the second stage box classifier predictions.
       * Note: the `score_converter` provided to the FasterRCNNMetaArch constructor
       * is taken from this `second_stage_post_processing` proto.
       * </pre>
       *
       * <code>optional .object_detection.protos.PostProcessing second_stage_post_processing = 24;</code>
       */
      public Builder setSecondStagePostProcessing(object_detection.protos.PostProcessingOuterClass.PostProcessing value) {
        if (secondStagePostProcessingBuilder_ == null) {
          if (value == null) {
            throw new NullPointerException();
          }
          secondStagePostProcessing_ = value;
          onChanged();
        } else {
          secondStagePostProcessingBuilder_.setMessage(value);
        }
        bitField0_ |= 0x00400000;
        return this;
      }
      /**
       * <pre>
       * Post processing to apply on the second stage box classifier predictions.
       * Note: the `score_converter` provided to the FasterRCNNMetaArch constructor
       * is taken from this `second_stage_post_processing` proto.
       * </pre>
       *
       * <code>optional .object_detection.protos.PostProcessing second_stage_post_processing = 24;</code>
       */
      public Builder setSecondStagePostProcessing(
          object_detection.protos.PostProcessingOuterClass.PostProcessing.Builder builderForValue) {
        if (secondStagePostProcessingBuilder_ == null) {
          secondStagePostProcessing_ = builderForValue.build();
          onChanged();
        } else {
          secondStagePostProcessingBuilder_.setMessage(builderForValue.build());
        }
        bitField0_ |= 0x00400000;
        return this;
      }
      /**
       * <pre>
       * Post processing to apply on the second stage box classifier predictions.
       * Note: the `score_converter` provided to the FasterRCNNMetaArch constructor
       * is taken from this `second_stage_post_processing` proto.
       * </pre>
       *
       * <code>optional .object_detection.protos.PostProcessing second_stage_post_processing = 24;</code>
       */
      public Builder mergeSecondStagePostProcessing(object_detection.protos.PostProcessingOuterClass.PostProcessing value) {
        if (secondStagePostProcessingBuilder_ == null) {
          if (((bitField0_ & 0x00400000) != 0) &&
              secondStagePostProcessing_ != null &&
              secondStagePostProcessing_ != object_detection.protos.PostProcessingOuterClass.PostProcessing.getDefaultInstance()) {
            secondStagePostProcessing_ =
              object_detection.protos.PostProcessingOuterClass.PostProcessing.newBuilder(secondStagePostProcessing_).mergeFrom(value).buildPartial();
          } else {
            secondStagePostProcessing_ = value;
          }
          onChanged();
        } else {
          secondStagePostProcessingBuilder_.mergeFrom(value);
        }
        bitField0_ |= 0x00400000;
        return this;
      }
      /**
       * <pre>
       * Post processing to apply on the second stage box classifier predictions.
       * Note: the `score_converter` provided to the FasterRCNNMetaArch constructor
       * is taken from this `second_stage_post_processing` proto.
       * </pre>
       *
       * <code>optional .object_detection.protos.PostProcessing second_stage_post_processing = 24;</code>
       */
      public Builder clearSecondStagePostProcessing() {
        if (secondStagePostProcessingBuilder_ == null) {
          secondStagePostProcessing_ = null;
          onChanged();
        } else {
          secondStagePostProcessingBuilder_.clear();
        }
        bitField0_ = (bitField0_ & ~0x00400000);
        return this;
      }
      /**
       * <pre>
       * Post processing to apply on the second stage box classifier predictions.
       * Note: the `score_converter` provided to the FasterRCNNMetaArch constructor
       * is taken from this `second_stage_post_processing` proto.
       * </pre>
       *
       * <code>optional .object_detection.protos.PostProcessing second_stage_post_processing = 24;</code>
       */
      public object_detection.protos.PostProcessingOuterClass.PostProcessing.Builder getSecondStagePostProcessingBuilder() {
        bitField0_ |= 0x00400000;
        onChanged();
        return getSecondStagePostProcessingFieldBuilder().getBuilder();
      }
      /**
       * <pre>
       * Post processing to apply on the second stage box classifier predictions.
       * Note: the `score_converter` provided to the FasterRCNNMetaArch constructor
       * is taken from this `second_stage_post_processing` proto.
       * </pre>
       *
       * <code>optional .object_detection.protos.PostProcessing second_stage_post_processing = 24;</code>
       */
      public object_detection.protos.PostProcessingOuterClass.PostProcessingOrBuilder getSecondStagePostProcessingOrBuilder() {
        if (secondStagePostProcessingBuilder_ != null) {
          return secondStagePostProcessingBuilder_.getMessageOrBuilder();
        } else {
          return secondStagePostProcessing_ == null ?
              object_detection.protos.PostProcessingOuterClass.PostProcessing.getDefaultInstance() : secondStagePostProcessing_;
        }
      }
      /**
       * <pre>
       * Post processing to apply on the second stage box classifier predictions.
       * Note: the `score_converter` provided to the FasterRCNNMetaArch constructor
       * is taken from this `second_stage_post_processing` proto.
       * </pre>
       *
       * <code>optional .object_detection.protos.PostProcessing second_stage_post_processing = 24;</code>
       */
      private com.google.protobuf.SingleFieldBuilderV3<
          object_detection.protos.PostProcessingOuterClass.PostProcessing, object_detection.protos.PostProcessingOuterClass.PostProcessing.Builder, object_detection.protos.PostProcessingOuterClass.PostProcessingOrBuilder>
          getSecondStagePostProcessingFieldBuilder() {
        if (secondStagePostProcessingBuilder_ == null) {
          secondStagePostProcessingBuilder_ = new com.google.protobuf.SingleFieldBuilderV3<
              object_detection.protos.PostProcessingOuterClass.PostProcessing, object_detection.protos.PostProcessingOuterClass.PostProcessing.Builder, object_detection.protos.PostProcessingOuterClass.PostProcessingOrBuilder>(
                  getSecondStagePostProcessing(),
                  getParentForChildren(),
                  isClean());
          secondStagePostProcessing_ = null;
        }
        return secondStagePostProcessingBuilder_;
      }

      private float secondStageLocalizationLossWeight_ = 1F;
      /**
       * <pre>
       * Second stage refined localization loss weight.
       * </pre>
       *
       * <code>optional float second_stage_localization_loss_weight = 25 [default = 1];</code>
       * @return Whether the secondStageLocalizationLossWeight field is set.
       */
      @java.lang.Override
      public boolean hasSecondStageLocalizationLossWeight() {
        return ((bitField0_ & 0x00800000) != 0);
      }
      /**
       * <pre>
       * Second stage refined localization loss weight.
       * </pre>
       *
       * <code>optional float second_stage_localization_loss_weight = 25 [default = 1];</code>
       * @return The secondStageLocalizationLossWeight.
       */
      @java.lang.Override
      public float getSecondStageLocalizationLossWeight() {
        return secondStageLocalizationLossWeight_;
      }
      /**
       * <pre>
       * Second stage refined localization loss weight.
       * </pre>
       *
       * <code>optional float second_stage_localization_loss_weight = 25 [default = 1];</code>
       * @param value The secondStageLocalizationLossWeight to set.
       * @return This builder for chaining.
       */
      public Builder setSecondStageLocalizationLossWeight(float value) {
        bitField0_ |= 0x00800000;
        secondStageLocalizationLossWeight_ = value;
        onChanged();
        return this;
      }
      /**
       * <pre>
       * Second stage refined localization loss weight.
       * </pre>
       *
       * <code>optional float second_stage_localization_loss_weight = 25 [default = 1];</code>
       * @return This builder for chaining.
       */
      public Builder clearSecondStageLocalizationLossWeight() {
        bitField0_ = (bitField0_ & ~0x00800000);
        secondStageLocalizationLossWeight_ = 1F;
        onChanged();
        return this;
      }

      private float secondStageClassificationLossWeight_ = 1F;
      /**
       * <pre>
       * Second stage classification loss weight
       * </pre>
       *
       * <code>optional float second_stage_classification_loss_weight = 26 [default = 1];</code>
       * @return Whether the secondStageClassificationLossWeight field is set.
       */
      @java.lang.Override
      public boolean hasSecondStageClassificationLossWeight() {
        return ((bitField0_ & 0x01000000) != 0);
      }
      /**
       * <pre>
       * Second stage classification loss weight
       * </pre>
       *
       * <code>optional float second_stage_classification_loss_weight = 26 [default = 1];</code>
       * @return The secondStageClassificationLossWeight.
       */
      @java.lang.Override
      public float getSecondStageClassificationLossWeight() {
        return secondStageClassificationLossWeight_;
      }
      /**
       * <pre>
       * Second stage classification loss weight
       * </pre>
       *
       * <code>optional float second_stage_classification_loss_weight = 26 [default = 1];</code>
       * @param value The secondStageClassificationLossWeight to set.
       * @return This builder for chaining.
       */
      public Builder setSecondStageClassificationLossWeight(float value) {
        bitField0_ |= 0x01000000;
        secondStageClassificationLossWeight_ = value;
        onChanged();
        return this;
      }
      /**
       * <pre>
       * Second stage classification loss weight
       * </pre>
       *
       * <code>optional float second_stage_classification_loss_weight = 26 [default = 1];</code>
       * @return This builder for chaining.
       */
      public Builder clearSecondStageClassificationLossWeight() {
        bitField0_ = (bitField0_ & ~0x01000000);
        secondStageClassificationLossWeight_ = 1F;
        onChanged();
        return this;
      }

      private float secondStageMaskPredictionLossWeight_ = 1F;
      /**
       * <pre>
       * Second stage instance mask loss weight. Note that this is only applicable
       * when `MaskRCNNBoxPredictor` is selected for second stage and configured to
       * predict instance masks.
       * </pre>
       *
       * <code>optional float second_stage_mask_prediction_loss_weight = 27 [default = 1];</code>
       * @return Whether the secondStageMaskPredictionLossWeight field is set.
       */
      @java.lang.Override
      public boolean hasSecondStageMaskPredictionLossWeight() {
        return ((bitField0_ & 0x02000000) != 0);
      }
      /**
       * <pre>
       * Second stage instance mask loss weight. Note that this is only applicable
       * when `MaskRCNNBoxPredictor` is selected for second stage and configured to
       * predict instance masks.
       * </pre>
       *
       * <code>optional float second_stage_mask_prediction_loss_weight = 27 [default = 1];</code>
       * @return The secondStageMaskPredictionLossWeight.
       */
      @java.lang.Override
      public float getSecondStageMaskPredictionLossWeight() {
        return secondStageMaskPredictionLossWeight_;
      }
      /**
       * <pre>
       * Second stage instance mask loss weight. Note that this is only applicable
       * when `MaskRCNNBoxPredictor` is selected for second stage and configured to
       * predict instance masks.
       * </pre>
       *
       * <code>optional float second_stage_mask_prediction_loss_weight = 27 [default = 1];</code>
       * @param value The secondStageMaskPredictionLossWeight to set.
       * @return This builder for chaining.
       */
      public Builder setSecondStageMaskPredictionLossWeight(float value) {
        bitField0_ |= 0x02000000;
        secondStageMaskPredictionLossWeight_ = value;
        onChanged();
        return this;
      }
      /**
       * <pre>
       * Second stage instance mask loss weight. Note that this is only applicable
       * when `MaskRCNNBoxPredictor` is selected for second stage and configured to
       * predict instance masks.
       * </pre>
       *
       * <code>optional float second_stage_mask_prediction_loss_weight = 27 [default = 1];</code>
       * @return This builder for chaining.
       */
      public Builder clearSecondStageMaskPredictionLossWeight() {
        bitField0_ = (bitField0_ & ~0x02000000);
        secondStageMaskPredictionLossWeight_ = 1F;
        onChanged();
        return this;
      }

      private object_detection.protos.Losses.HardExampleMiner hardExampleMiner_;
      private com.google.protobuf.SingleFieldBuilderV3<
          object_detection.protos.Losses.HardExampleMiner, object_detection.protos.Losses.HardExampleMiner.Builder, object_detection.protos.Losses.HardExampleMinerOrBuilder> hardExampleMinerBuilder_;
      /**
       * <pre>
       * If not left to default, applies hard example mining only to classification
       * and localization loss..
       * </pre>
       *
       * <code>optional .object_detection.protos.HardExampleMiner hard_example_miner = 28;</code>
       * @return Whether the hardExampleMiner field is set.
       */
      public boolean hasHardExampleMiner() {
        return ((bitField0_ & 0x04000000) != 0);
      }
      /**
       * <pre>
       * If not left to default, applies hard example mining only to classification
       * and localization loss..
       * </pre>
       *
       * <code>optional .object_detection.protos.HardExampleMiner hard_example_miner = 28;</code>
       * @return The hardExampleMiner.
       */
      public object_detection.protos.Losses.HardExampleMiner getHardExampleMiner() {
        if (hardExampleMinerBuilder_ == null) {
          return hardExampleMiner_ == null ? object_detection.protos.Losses.HardExampleMiner.getDefaultInstance() : hardExampleMiner_;
        } else {
          return hardExampleMinerBuilder_.getMessage();
        }
      }
      /**
       * <pre>
       * If not left to default, applies hard example mining only to classification
       * and localization loss..
       * </pre>
       *
       * <code>optional .object_detection.protos.HardExampleMiner hard_example_miner = 28;</code>
       */
      public Builder setHardExampleMiner(object_detection.protos.Losses.HardExampleMiner value) {
        if (hardExampleMinerBuilder_ == null) {
          if (value == null) {
            throw new NullPointerException();
          }
          hardExampleMiner_ = value;
          onChanged();
        } else {
          hardExampleMinerBuilder_.setMessage(value);
        }
        bitField0_ |= 0x04000000;
        return this;
      }
      /**
       * <pre>
       * If not left to default, applies hard example mining only to classification
       * and localization loss..
       * </pre>
       *
       * <code>optional .object_detection.protos.HardExampleMiner hard_example_miner = 28;</code>
       */
      public Builder setHardExampleMiner(
          object_detection.protos.Losses.HardExampleMiner.Builder builderForValue) {
        if (hardExampleMinerBuilder_ == null) {
          hardExampleMiner_ = builderForValue.build();
          onChanged();
        } else {
          hardExampleMinerBuilder_.setMessage(builderForValue.build());
        }
        bitField0_ |= 0x04000000;
        return this;
      }
      /**
       * <pre>
       * If not left to default, applies hard example mining only to classification
       * and localization loss..
       * </pre>
       *
       * <code>optional .object_detection.protos.HardExampleMiner hard_example_miner = 28;</code>
       */
      public Builder mergeHardExampleMiner(object_detection.protos.Losses.HardExampleMiner value) {
        if (hardExampleMinerBuilder_ == null) {
          if (((bitField0_ & 0x04000000) != 0) &&
              hardExampleMiner_ != null &&
              hardExampleMiner_ != object_detection.protos.Losses.HardExampleMiner.getDefaultInstance()) {
            hardExampleMiner_ =
              object_detection.protos.Losses.HardExampleMiner.newBuilder(hardExampleMiner_).mergeFrom(value).buildPartial();
          } else {
            hardExampleMiner_ = value;
          }
          onChanged();
        } else {
          hardExampleMinerBuilder_.mergeFrom(value);
        }
        bitField0_ |= 0x04000000;
        return this;
      }
      /**
       * <pre>
       * If not left to default, applies hard example mining only to classification
       * and localization loss..
       * </pre>
       *
       * <code>optional .object_detection.protos.HardExampleMiner hard_example_miner = 28;</code>
       */
      public Builder clearHardExampleMiner() {
        if (hardExampleMinerBuilder_ == null) {
          hardExampleMiner_ = null;
          onChanged();
        } else {
          hardExampleMinerBuilder_.clear();
        }
        bitField0_ = (bitField0_ & ~0x04000000);
        return this;
      }
      /**
       * <pre>
       * If not left to default, applies hard example mining only to classification
       * and localization loss..
       * </pre>
       *
       * <code>optional .object_detection.protos.HardExampleMiner hard_example_miner = 28;</code>
       */
      public object_detection.protos.Losses.HardExampleMiner.Builder getHardExampleMinerBuilder() {
        bitField0_ |= 0x04000000;
        onChanged();
        return getHardExampleMinerFieldBuilder().getBuilder();
      }
      /**
       * <pre>
       * If not left to default, applies hard example mining only to classification
       * and localization loss..
       * </pre>
       *
       * <code>optional .object_detection.protos.HardExampleMiner hard_example_miner = 28;</code>
       */
      public object_detection.protos.Losses.HardExampleMinerOrBuilder getHardExampleMinerOrBuilder() {
        if (hardExampleMinerBuilder_ != null) {
          return hardExampleMinerBuilder_.getMessageOrBuilder();
        } else {
          return hardExampleMiner_ == null ?
              object_detection.protos.Losses.HardExampleMiner.getDefaultInstance() : hardExampleMiner_;
        }
      }
      /**
       * <pre>
       * If not left to default, applies hard example mining only to classification
       * and localization loss..
       * </pre>
       *
       * <code>optional .object_detection.protos.HardExampleMiner hard_example_miner = 28;</code>
       */
      private com.google.protobuf.SingleFieldBuilderV3<
          object_detection.protos.Losses.HardExampleMiner, object_detection.protos.Losses.HardExampleMiner.Builder, object_detection.protos.Losses.HardExampleMinerOrBuilder>
          getHardExampleMinerFieldBuilder() {
        if (hardExampleMinerBuilder_ == null) {
          hardExampleMinerBuilder_ = new com.google.protobuf.SingleFieldBuilderV3<
              object_detection.protos.Losses.HardExampleMiner, object_detection.protos.Losses.HardExampleMiner.Builder, object_detection.protos.Losses.HardExampleMinerOrBuilder>(
                  getHardExampleMiner(),
                  getParentForChildren(),
                  isClean());
          hardExampleMiner_ = null;
        }
        return hardExampleMinerBuilder_;
      }

      private object_detection.protos.Losses.ClassificationLoss secondStageClassificationLoss_;
      private com.google.protobuf.SingleFieldBuilderV3<
          object_detection.protos.Losses.ClassificationLoss, object_detection.protos.Losses.ClassificationLoss.Builder, object_detection.protos.Losses.ClassificationLossOrBuilder> secondStageClassificationLossBuilder_;
      /**
       * <pre>
       * Loss for second stage box classifers, supports Softmax and Sigmoid.
       * Note that score converter must be consistent with loss type.
       * When there are multiple labels assigned to the same boxes, recommend
       * to use sigmoid loss and enable merge_multiple_label_boxes.
       * If not specified, Softmax loss is used as default.
       * </pre>
       *
       * <code>optional .object_detection.protos.ClassificationLoss second_stage_classification_loss = 29;</code>
       * @return Whether the secondStageClassificationLoss field is set.
       */
      public boolean hasSecondStageClassificationLoss() {
        return ((bitField0_ & 0x08000000) != 0);
      }
      /**
       * <pre>
       * Loss for second stage box classifers, supports Softmax and Sigmoid.
       * Note that score converter must be consistent with loss type.
       * When there are multiple labels assigned to the same boxes, recommend
       * to use sigmoid loss and enable merge_multiple_label_boxes.
       * If not specified, Softmax loss is used as default.
       * </pre>
       *
       * <code>optional .object_detection.protos.ClassificationLoss second_stage_classification_loss = 29;</code>
       * @return The secondStageClassificationLoss.
       */
      public object_detection.protos.Losses.ClassificationLoss getSecondStageClassificationLoss() {
        if (secondStageClassificationLossBuilder_ == null) {
          return secondStageClassificationLoss_ == null ? object_detection.protos.Losses.ClassificationLoss.getDefaultInstance() : secondStageClassificationLoss_;
        } else {
          return secondStageClassificationLossBuilder_.getMessage();
        }
      }
      /**
       * <pre>
       * Loss for second stage box classifers, supports Softmax and Sigmoid.
       * Note that score converter must be consistent with loss type.
       * When there are multiple labels assigned to the same boxes, recommend
       * to use sigmoid loss and enable merge_multiple_label_boxes.
       * If not specified, Softmax loss is used as default.
       * </pre>
       *
       * <code>optional .object_detection.protos.ClassificationLoss second_stage_classification_loss = 29;</code>
       */
      public Builder setSecondStageClassificationLoss(object_detection.protos.Losses.ClassificationLoss value) {
        if (secondStageClassificationLossBuilder_ == null) {
          if (value == null) {
            throw new NullPointerException();
          }
          secondStageClassificationLoss_ = value;
          onChanged();
        } else {
          secondStageClassificationLossBuilder_.setMessage(value);
        }
        bitField0_ |= 0x08000000;
        return this;
      }
      /**
       * <pre>
       * Loss for second stage box classifers, supports Softmax and Sigmoid.
       * Note that score converter must be consistent with loss type.
       * When there are multiple labels assigned to the same boxes, recommend
       * to use sigmoid loss and enable merge_multiple_label_boxes.
       * If not specified, Softmax loss is used as default.
       * </pre>
       *
       * <code>optional .object_detection.protos.ClassificationLoss second_stage_classification_loss = 29;</code>
       */
      public Builder setSecondStageClassificationLoss(
          object_detection.protos.Losses.ClassificationLoss.Builder builderForValue) {
        if (secondStageClassificationLossBuilder_ == null) {
          secondStageClassificationLoss_ = builderForValue.build();
          onChanged();
        } else {
          secondStageClassificationLossBuilder_.setMessage(builderForValue.build());
        }
        bitField0_ |= 0x08000000;
        return this;
      }
      /**
       * <pre>
       * Loss for second stage box classifers, supports Softmax and Sigmoid.
       * Note that score converter must be consistent with loss type.
       * When there are multiple labels assigned to the same boxes, recommend
       * to use sigmoid loss and enable merge_multiple_label_boxes.
       * If not specified, Softmax loss is used as default.
       * </pre>
       *
       * <code>optional .object_detection.protos.ClassificationLoss second_stage_classification_loss = 29;</code>
       */
      public Builder mergeSecondStageClassificationLoss(object_detection.protos.Losses.ClassificationLoss value) {
        if (secondStageClassificationLossBuilder_ == null) {
          if (((bitField0_ & 0x08000000) != 0) &&
              secondStageClassificationLoss_ != null &&
              secondStageClassificationLoss_ != object_detection.protos.Losses.ClassificationLoss.getDefaultInstance()) {
            secondStageClassificationLoss_ =
              object_detection.protos.Losses.ClassificationLoss.newBuilder(secondStageClassificationLoss_).mergeFrom(value).buildPartial();
          } else {
            secondStageClassificationLoss_ = value;
          }
          onChanged();
        } else {
          secondStageClassificationLossBuilder_.mergeFrom(value);
        }
        bitField0_ |= 0x08000000;
        return this;
      }
      /**
       * <pre>
       * Loss for second stage box classifers, supports Softmax and Sigmoid.
       * Note that score converter must be consistent with loss type.
       * When there are multiple labels assigned to the same boxes, recommend
       * to use sigmoid loss and enable merge_multiple_label_boxes.
       * If not specified, Softmax loss is used as default.
       * </pre>
       *
       * <code>optional .object_detection.protos.ClassificationLoss second_stage_classification_loss = 29;</code>
       */
      public Builder clearSecondStageClassificationLoss() {
        if (secondStageClassificationLossBuilder_ == null) {
          secondStageClassificationLoss_ = null;
          onChanged();
        } else {
          secondStageClassificationLossBuilder_.clear();
        }
        bitField0_ = (bitField0_ & ~0x08000000);
        return this;
      }
      /**
       * <pre>
       * Loss for second stage box classifers, supports Softmax and Sigmoid.
       * Note that score converter must be consistent with loss type.
       * When there are multiple labels assigned to the same boxes, recommend
       * to use sigmoid loss and enable merge_multiple_label_boxes.
       * If not specified, Softmax loss is used as default.
       * </pre>
       *
       * <code>optional .object_detection.protos.ClassificationLoss second_stage_classification_loss = 29;</code>
       */
      public object_detection.protos.Losses.ClassificationLoss.Builder getSecondStageClassificationLossBuilder() {
        bitField0_ |= 0x08000000;
        onChanged();
        return getSecondStageClassificationLossFieldBuilder().getBuilder();
      }
      /**
       * <pre>
       * Loss for second stage box classifers, supports Softmax and Sigmoid.
       * Note that score converter must be consistent with loss type.
       * When there are multiple labels assigned to the same boxes, recommend
       * to use sigmoid loss and enable merge_multiple_label_boxes.
       * If not specified, Softmax loss is used as default.
       * </pre>
       *
       * <code>optional .object_detection.protos.ClassificationLoss second_stage_classification_loss = 29;</code>
       */
      public object_detection.protos.Losses.ClassificationLossOrBuilder getSecondStageClassificationLossOrBuilder() {
        if (secondStageClassificationLossBuilder_ != null) {
          return secondStageClassificationLossBuilder_.getMessageOrBuilder();
        } else {
          return secondStageClassificationLoss_ == null ?
              object_detection.protos.Losses.ClassificationLoss.getDefaultInstance() : secondStageClassificationLoss_;
        }
      }
      /**
       * <pre>
       * Loss for second stage box classifers, supports Softmax and Sigmoid.
       * Note that score converter must be consistent with loss type.
       * When there are multiple labels assigned to the same boxes, recommend
       * to use sigmoid loss and enable merge_multiple_label_boxes.
       * If not specified, Softmax loss is used as default.
       * </pre>
       *
       * <code>optional .object_detection.protos.ClassificationLoss second_stage_classification_loss = 29;</code>
       */
      private com.google.protobuf.SingleFieldBuilderV3<
          object_detection.protos.Losses.ClassificationLoss, object_detection.protos.Losses.ClassificationLoss.Builder, object_detection.protos.Losses.ClassificationLossOrBuilder>
          getSecondStageClassificationLossFieldBuilder() {
        if (secondStageClassificationLossBuilder_ == null) {
          secondStageClassificationLossBuilder_ = new com.google.protobuf.SingleFieldBuilderV3<
              object_detection.protos.Losses.ClassificationLoss, object_detection.protos.Losses.ClassificationLoss.Builder, object_detection.protos.Losses.ClassificationLossOrBuilder>(
                  getSecondStageClassificationLoss(),
                  getParentForChildren(),
                  isClean());
          secondStageClassificationLoss_ = null;
        }
        return secondStageClassificationLossBuilder_;
      }

      private boolean inplaceBatchnormUpdate_ ;
      /**
       * <pre>
       * Whether to update batch_norm inplace during training. This is required
       * for batch norm to work correctly on TPUs. When this is false, user must add
       * a control dependency on tf.GraphKeys.UPDATE_OPS for train/loss op in order
       * to update the batch norm moving average parameters.
       * </pre>
       *
       * <code>optional bool inplace_batchnorm_update = 30 [default = false];</code>
       * @return Whether the inplaceBatchnormUpdate field is set.
       */
      @java.lang.Override
      public boolean hasInplaceBatchnormUpdate() {
        return ((bitField0_ & 0x10000000) != 0);
      }
      /**
       * <pre>
       * Whether to update batch_norm inplace during training. This is required
       * for batch norm to work correctly on TPUs. When this is false, user must add
       * a control dependency on tf.GraphKeys.UPDATE_OPS for train/loss op in order
       * to update the batch norm moving average parameters.
       * </pre>
       *
       * <code>optional bool inplace_batchnorm_update = 30 [default = false];</code>
       * @return The inplaceBatchnormUpdate.
       */
      @java.lang.Override
      public boolean getInplaceBatchnormUpdate() {
        return inplaceBatchnormUpdate_;
      }
      /**
       * <pre>
       * Whether to update batch_norm inplace during training. This is required
       * for batch norm to work correctly on TPUs. When this is false, user must add
       * a control dependency on tf.GraphKeys.UPDATE_OPS for train/loss op in order
       * to update the batch norm moving average parameters.
       * </pre>
       *
       * <code>optional bool inplace_batchnorm_update = 30 [default = false];</code>
       * @param value The inplaceBatchnormUpdate to set.
       * @return This builder for chaining.
       */
      public Builder setInplaceBatchnormUpdate(boolean value) {
        bitField0_ |= 0x10000000;
        inplaceBatchnormUpdate_ = value;
        onChanged();
        return this;
      }
      /**
       * <pre>
       * Whether to update batch_norm inplace during training. This is required
       * for batch norm to work correctly on TPUs. When this is false, user must add
       * a control dependency on tf.GraphKeys.UPDATE_OPS for train/loss op in order
       * to update the batch norm moving average parameters.
       * </pre>
       *
       * <code>optional bool inplace_batchnorm_update = 30 [default = false];</code>
       * @return This builder for chaining.
       */
      public Builder clearInplaceBatchnormUpdate() {
        bitField0_ = (bitField0_ & ~0x10000000);
        inplaceBatchnormUpdate_ = false;
        onChanged();
        return this;
      }

      private boolean useMatmulCropAndResize_ ;
      /**
       * <pre>
       * Force the use of matrix multiplication based crop and resize instead of
       * standard tf.image.crop_and_resize while computing second stage input
       * feature maps.
       * </pre>
       *
       * <code>optional bool use_matmul_crop_and_resize = 31 [default = false];</code>
       * @return Whether the useMatmulCropAndResize field is set.
       */
      @java.lang.Override
      public boolean hasUseMatmulCropAndResize() {
        return ((bitField0_ & 0x20000000) != 0);
      }
      /**
       * <pre>
       * Force the use of matrix multiplication based crop and resize instead of
       * standard tf.image.crop_and_resize while computing second stage input
       * feature maps.
       * </pre>
       *
       * <code>optional bool use_matmul_crop_and_resize = 31 [default = false];</code>
       * @return The useMatmulCropAndResize.
       */
      @java.lang.Override
      public boolean getUseMatmulCropAndResize() {
        return useMatmulCropAndResize_;
      }
      /**
       * <pre>
       * Force the use of matrix multiplication based crop and resize instead of
       * standard tf.image.crop_and_resize while computing second stage input
       * feature maps.
       * </pre>
       *
       * <code>optional bool use_matmul_crop_and_resize = 31 [default = false];</code>
       * @param value The useMatmulCropAndResize to set.
       * @return This builder for chaining.
       */
      public Builder setUseMatmulCropAndResize(boolean value) {
        bitField0_ |= 0x20000000;
        useMatmulCropAndResize_ = value;
        onChanged();
        return this;
      }
      /**
       * <pre>
       * Force the use of matrix multiplication based crop and resize instead of
       * standard tf.image.crop_and_resize while computing second stage input
       * feature maps.
       * </pre>
       *
       * <code>optional bool use_matmul_crop_and_resize = 31 [default = false];</code>
       * @return This builder for chaining.
       */
      public Builder clearUseMatmulCropAndResize() {
        bitField0_ = (bitField0_ & ~0x20000000);
        useMatmulCropAndResize_ = false;
        onChanged();
        return this;
      }

      private boolean clipAnchorsToImage_ ;
      /**
       * <pre>
       * Normally, anchors generated for a given image size are pruned during
       * training if they lie outside the image window. Setting this option to true,
       * clips the anchors to be within the image instead of pruning.
       * </pre>
       *
       * <code>optional bool clip_anchors_to_image = 32 [default = false];</code>
       * @return Whether the clipAnchorsToImage field is set.
       */
      @java.lang.Override
      public boolean hasClipAnchorsToImage() {
        return ((bitField0_ & 0x40000000) != 0);
      }
      /**
       * <pre>
       * Normally, anchors generated for a given image size are pruned during
       * training if they lie outside the image window. Setting this option to true,
       * clips the anchors to be within the image instead of pruning.
       * </pre>
       *
       * <code>optional bool clip_anchors_to_image = 32 [default = false];</code>
       * @return The clipAnchorsToImage.
       */
      @java.lang.Override
      public boolean getClipAnchorsToImage() {
        return clipAnchorsToImage_;
      }
      /**
       * <pre>
       * Normally, anchors generated for a given image size are pruned during
       * training if they lie outside the image window. Setting this option to true,
       * clips the anchors to be within the image instead of pruning.
       * </pre>
       *
       * <code>optional bool clip_anchors_to_image = 32 [default = false];</code>
       * @param value The clipAnchorsToImage to set.
       * @return This builder for chaining.
       */
      public Builder setClipAnchorsToImage(boolean value) {
        bitField0_ |= 0x40000000;
        clipAnchorsToImage_ = value;
        onChanged();
        return this;
      }
      /**
       * <pre>
       * Normally, anchors generated for a given image size are pruned during
       * training if they lie outside the image window. Setting this option to true,
       * clips the anchors to be within the image instead of pruning.
       * </pre>
       *
       * <code>optional bool clip_anchors_to_image = 32 [default = false];</code>
       * @return This builder for chaining.
       */
      public Builder clearClipAnchorsToImage() {
        bitField0_ = (bitField0_ & ~0x40000000);
        clipAnchorsToImage_ = false;
        onChanged();
        return this;
      }

      private boolean useMatmulGatherInMatcher_ ;
      /**
       * <pre>
       * After peforming matching between anchors and targets, in order to pull out
       * targets for training Faster R-CNN meta architecture we perform a gather
       * operation. This options specifies whether to use an alternate
       * implementation of tf.gather that is faster on TPUs.
       * </pre>
       *
       * <code>optional bool use_matmul_gather_in_matcher = 33 [default = false];</code>
       * @return Whether the useMatmulGatherInMatcher field is set.
       */
      @java.lang.Override
      public boolean hasUseMatmulGatherInMatcher() {
        return ((bitField0_ & 0x80000000) != 0);
      }
      /**
       * <pre>
       * After peforming matching between anchors and targets, in order to pull out
       * targets for training Faster R-CNN meta architecture we perform a gather
       * operation. This options specifies whether to use an alternate
       * implementation of tf.gather that is faster on TPUs.
       * </pre>
       *
       * <code>optional bool use_matmul_gather_in_matcher = 33 [default = false];</code>
       * @return The useMatmulGatherInMatcher.
       */
      @java.lang.Override
      public boolean getUseMatmulGatherInMatcher() {
        return useMatmulGatherInMatcher_;
      }
      /**
       * <pre>
       * After peforming matching between anchors and targets, in order to pull out
       * targets for training Faster R-CNN meta architecture we perform a gather
       * operation. This options specifies whether to use an alternate
       * implementation of tf.gather that is faster on TPUs.
       * </pre>
       *
       * <code>optional bool use_matmul_gather_in_matcher = 33 [default = false];</code>
       * @param value The useMatmulGatherInMatcher to set.
       * @return This builder for chaining.
       */
      public Builder setUseMatmulGatherInMatcher(boolean value) {
        bitField0_ |= 0x80000000;
        useMatmulGatherInMatcher_ = value;
        onChanged();
        return this;
      }
      /**
       * <pre>
       * After peforming matching between anchors and targets, in order to pull out
       * targets for training Faster R-CNN meta architecture we perform a gather
       * operation. This options specifies whether to use an alternate
       * implementation of tf.gather that is faster on TPUs.
       * </pre>
       *
       * <code>optional bool use_matmul_gather_in_matcher = 33 [default = false];</code>
       * @return This builder for chaining.
       */
      public Builder clearUseMatmulGatherInMatcher() {
        bitField0_ = (bitField0_ & ~0x80000000);
        useMatmulGatherInMatcher_ = false;
        onChanged();
        return this;
      }

      private boolean useStaticBalancedLabelSampler_ ;
      /**
       * <pre>
       * Whether to use the balanced positive negative sampler implementation with
       * static shape guarantees.
       * </pre>
       *
       * <code>optional bool use_static_balanced_label_sampler = 34 [default = false];</code>
       * @return Whether the useStaticBalancedLabelSampler field is set.
       */
      @java.lang.Override
      public boolean hasUseStaticBalancedLabelSampler() {
        return ((bitField1_ & 0x00000001) != 0);
      }
      /**
       * <pre>
       * Whether to use the balanced positive negative sampler implementation with
       * static shape guarantees.
       * </pre>
       *
       * <code>optional bool use_static_balanced_label_sampler = 34 [default = false];</code>
       * @return The useStaticBalancedLabelSampler.
       */
      @java.lang.Override
      public boolean getUseStaticBalancedLabelSampler() {
        return useStaticBalancedLabelSampler_;
      }
      /**
       * <pre>
       * Whether to use the balanced positive negative sampler implementation with
       * static shape guarantees.
       * </pre>
       *
       * <code>optional bool use_static_balanced_label_sampler = 34 [default = false];</code>
       * @param value The useStaticBalancedLabelSampler to set.
       * @return This builder for chaining.
       */
      public Builder setUseStaticBalancedLabelSampler(boolean value) {
        bitField1_ |= 0x00000001;
        useStaticBalancedLabelSampler_ = value;
        onChanged();
        return this;
      }
      /**
       * <pre>
       * Whether to use the balanced positive negative sampler implementation with
       * static shape guarantees.
       * </pre>
       *
       * <code>optional bool use_static_balanced_label_sampler = 34 [default = false];</code>
       * @return This builder for chaining.
       */
      public Builder clearUseStaticBalancedLabelSampler() {
        bitField1_ = (bitField1_ & ~0x00000001);
        useStaticBalancedLabelSampler_ = false;
        onChanged();
        return this;
      }

      private boolean useStaticShapes_ ;
      /**
       * <pre>
       * If True, uses implementation of ops with static shape guarantees.
       * </pre>
       *
       * <code>optional bool use_static_shapes = 35 [default = false];</code>
       * @return Whether the useStaticShapes field is set.
       */
      @java.lang.Override
      public boolean hasUseStaticShapes() {
        return ((bitField1_ & 0x00000002) != 0);
      }
      /**
       * <pre>
       * If True, uses implementation of ops with static shape guarantees.
       * </pre>
       *
       * <code>optional bool use_static_shapes = 35 [default = false];</code>
       * @return The useStaticShapes.
       */
      @java.lang.Override
      public boolean getUseStaticShapes() {
        return useStaticShapes_;
      }
      /**
       * <pre>
       * If True, uses implementation of ops with static shape guarantees.
       * </pre>
       *
       * <code>optional bool use_static_shapes = 35 [default = false];</code>
       * @param value The useStaticShapes to set.
       * @return This builder for chaining.
       */
      public Builder setUseStaticShapes(boolean value) {
        bitField1_ |= 0x00000002;
        useStaticShapes_ = value;
        onChanged();
        return this;
      }
      /**
       * <pre>
       * If True, uses implementation of ops with static shape guarantees.
       * </pre>
       *
       * <code>optional bool use_static_shapes = 35 [default = false];</code>
       * @return This builder for chaining.
       */
      public Builder clearUseStaticShapes() {
        bitField1_ = (bitField1_ & ~0x00000002);
        useStaticShapes_ = false;
        onChanged();
        return this;
      }

      private boolean resizeMasks_ = true;
      /**
       * <pre>
       * Whether the masks present in groundtruth should be resized in the model to
       * match the image size.
       * </pre>
       *
       * <code>optional bool resize_masks = 36 [default = true];</code>
       * @return Whether the resizeMasks field is set.
       */
      @java.lang.Override
      public boolean hasResizeMasks() {
        return ((bitField1_ & 0x00000004) != 0);
      }
      /**
       * <pre>
       * Whether the masks present in groundtruth should be resized in the model to
       * match the image size.
       * </pre>
       *
       * <code>optional bool resize_masks = 36 [default = true];</code>
       * @return The resizeMasks.
       */
      @java.lang.Override
      public boolean getResizeMasks() {
        return resizeMasks_;
      }
      /**
       * <pre>
       * Whether the masks present in groundtruth should be resized in the model to
       * match the image size.
       * </pre>
       *
       * <code>optional bool resize_masks = 36 [default = true];</code>
       * @param value The resizeMasks to set.
       * @return This builder for chaining.
       */
      public Builder setResizeMasks(boolean value) {
        bitField1_ |= 0x00000004;
        resizeMasks_ = value;
        onChanged();
        return this;
      }
      /**
       * <pre>
       * Whether the masks present in groundtruth should be resized in the model to
       * match the image size.
       * </pre>
       *
       * <code>optional bool resize_masks = 36 [default = true];</code>
       * @return This builder for chaining.
       */
      public Builder clearResizeMasks() {
        bitField1_ = (bitField1_ & ~0x00000004);
        resizeMasks_ = true;
        onChanged();
        return this;
      }

      private boolean useStaticShapesForEval_ ;
      /**
       * <pre>
       * If True, uses implementation of ops with static shape guarantees when
       * running evaluation (specifically not is_training if False).
       * </pre>
       *
       * <code>optional bool use_static_shapes_for_eval = 37 [default = false];</code>
       * @return Whether the useStaticShapesForEval field is set.
       */
      @java.lang.Override
      public boolean hasUseStaticShapesForEval() {
        return ((bitField1_ & 0x00000008) != 0);
      }
      /**
       * <pre>
       * If True, uses implementation of ops with static shape guarantees when
       * running evaluation (specifically not is_training if False).
       * </pre>
       *
       * <code>optional bool use_static_shapes_for_eval = 37 [default = false];</code>
       * @return The useStaticShapesForEval.
       */
      @java.lang.Override
      public boolean getUseStaticShapesForEval() {
        return useStaticShapesForEval_;
      }
      /**
       * <pre>
       * If True, uses implementation of ops with static shape guarantees when
       * running evaluation (specifically not is_training if False).
       * </pre>
       *
       * <code>optional bool use_static_shapes_for_eval = 37 [default = false];</code>
       * @param value The useStaticShapesForEval to set.
       * @return This builder for chaining.
       */
      public Builder setUseStaticShapesForEval(boolean value) {
        bitField1_ |= 0x00000008;
        useStaticShapesForEval_ = value;
        onChanged();
        return this;
      }
      /**
       * <pre>
       * If True, uses implementation of ops with static shape guarantees when
       * running evaluation (specifically not is_training if False).
       * </pre>
       *
       * <code>optional bool use_static_shapes_for_eval = 37 [default = false];</code>
       * @return This builder for chaining.
       */
      public Builder clearUseStaticShapesForEval() {
        bitField1_ = (bitField1_ & ~0x00000008);
        useStaticShapesForEval_ = false;
        onChanged();
        return this;
      }

      private boolean usePartitionedNmsInFirstStage_ = true;
      /**
       * <pre>
       * If true, uses implementation of partitioned_non_max_suppression in first
       * stage.
       * </pre>
       *
       * <code>optional bool use_partitioned_nms_in_first_stage = 38 [default = true];</code>
       * @return Whether the usePartitionedNmsInFirstStage field is set.
       */
      @java.lang.Override
      public boolean hasUsePartitionedNmsInFirstStage() {
        return ((bitField1_ & 0x00000010) != 0);
      }
      /**
       * <pre>
       * If true, uses implementation of partitioned_non_max_suppression in first
       * stage.
       * </pre>
       *
       * <code>optional bool use_partitioned_nms_in_first_stage = 38 [default = true];</code>
       * @return The usePartitionedNmsInFirstStage.
       */
      @java.lang.Override
      public boolean getUsePartitionedNmsInFirstStage() {
        return usePartitionedNmsInFirstStage_;
      }
      /**
       * <pre>
       * If true, uses implementation of partitioned_non_max_suppression in first
       * stage.
       * </pre>
       *
       * <code>optional bool use_partitioned_nms_in_first_stage = 38 [default = true];</code>
       * @param value The usePartitionedNmsInFirstStage to set.
       * @return This builder for chaining.
       */
      public Builder setUsePartitionedNmsInFirstStage(boolean value) {
        bitField1_ |= 0x00000010;
        usePartitionedNmsInFirstStage_ = value;
        onChanged();
        return this;
      }
      /**
       * <pre>
       * If true, uses implementation of partitioned_non_max_suppression in first
       * stage.
       * </pre>
       *
       * <code>optional bool use_partitioned_nms_in_first_stage = 38 [default = true];</code>
       * @return This builder for chaining.
       */
      public Builder clearUsePartitionedNmsInFirstStage() {
        bitField1_ = (bitField1_ & ~0x00000010);
        usePartitionedNmsInFirstStage_ = true;
        onChanged();
        return this;
      }

      private boolean returnRawDetectionsDuringPredict_ ;
      /**
       * <pre>
       * Whether to return raw detections (pre NMS).
       * </pre>
       *
       * <code>optional bool return_raw_detections_during_predict = 39 [default = false];</code>
       * @return Whether the returnRawDetectionsDuringPredict field is set.
       */
      @java.lang.Override
      public boolean hasReturnRawDetectionsDuringPredict() {
        return ((bitField1_ & 0x00000020) != 0);
      }
      /**
       * <pre>
       * Whether to return raw detections (pre NMS).
       * </pre>
       *
       * <code>optional bool return_raw_detections_during_predict = 39 [default = false];</code>
       * @return The returnRawDetectionsDuringPredict.
       */
      @java.lang.Override
      public boolean getReturnRawDetectionsDuringPredict() {
        return returnRawDetectionsDuringPredict_;
      }
      /**
       * <pre>
       * Whether to return raw detections (pre NMS).
       * </pre>
       *
       * <code>optional bool return_raw_detections_during_predict = 39 [default = false];</code>
       * @param value The returnRawDetectionsDuringPredict to set.
       * @return This builder for chaining.
       */
      public Builder setReturnRawDetectionsDuringPredict(boolean value) {
        bitField1_ |= 0x00000020;
        returnRawDetectionsDuringPredict_ = value;
        onChanged();
        return this;
      }
      /**
       * <pre>
       * Whether to return raw detections (pre NMS).
       * </pre>
       *
       * <code>optional bool return_raw_detections_during_predict = 39 [default = false];</code>
       * @return This builder for chaining.
       */
      public Builder clearReturnRawDetectionsDuringPredict() {
        bitField1_ = (bitField1_ & ~0x00000020);
        returnRawDetectionsDuringPredict_ = false;
        onChanged();
        return this;
      }

      private boolean useCombinedNmsInFirstStage_ ;
      /**
       * <pre>
       * Whether to use tf.image.combined_non_max_suppression.
       * </pre>
       *
       * <code>optional bool use_combined_nms_in_first_stage = 40 [default = false];</code>
       * @return Whether the useCombinedNmsInFirstStage field is set.
       */
      @java.lang.Override
      public boolean hasUseCombinedNmsInFirstStage() {
        return ((bitField1_ & 0x00000040) != 0);
      }
      /**
       * <pre>
       * Whether to use tf.image.combined_non_max_suppression.
       * </pre>
       *
       * <code>optional bool use_combined_nms_in_first_stage = 40 [default = false];</code>
       * @return The useCombinedNmsInFirstStage.
       */
      @java.lang.Override
      public boolean getUseCombinedNmsInFirstStage() {
        return useCombinedNmsInFirstStage_;
      }
      /**
       * <pre>
       * Whether to use tf.image.combined_non_max_suppression.
       * </pre>
       *
       * <code>optional bool use_combined_nms_in_first_stage = 40 [default = false];</code>
       * @param value The useCombinedNmsInFirstStage to set.
       * @return This builder for chaining.
       */
      public Builder setUseCombinedNmsInFirstStage(boolean value) {
        bitField1_ |= 0x00000040;
        useCombinedNmsInFirstStage_ = value;
        onChanged();
        return this;
      }
      /**
       * <pre>
       * Whether to use tf.image.combined_non_max_suppression.
       * </pre>
       *
       * <code>optional bool use_combined_nms_in_first_stage = 40 [default = false];</code>
       * @return This builder for chaining.
       */
      public Builder clearUseCombinedNmsInFirstStage() {
        bitField1_ = (bitField1_ & ~0x00000040);
        useCombinedNmsInFirstStage_ = false;
        onChanged();
        return this;
      }

      private boolean outputFinalBoxFeatures_ ;
      /**
       * <pre>
       * Whether to output final box feature. If true, it will crop the rpn feature
       * map based on the final prediction boxes, then pass the crops through the
       * box_classifier to compute the final features in the postprocess() method.
       * </pre>
       *
       * <code>optional bool output_final_box_features = 42 [default = false];</code>
       * @return Whether the outputFinalBoxFeatures field is set.
       */
      @java.lang.Override
      public boolean hasOutputFinalBoxFeatures() {
        return ((bitField1_ & 0x00000080) != 0);
      }
      /**
       * <pre>
       * Whether to output final box feature. If true, it will crop the rpn feature
       * map based on the final prediction boxes, then pass the crops through the
       * box_classifier to compute the final features in the postprocess() method.
       * </pre>
       *
       * <code>optional bool output_final_box_features = 42 [default = false];</code>
       * @return The outputFinalBoxFeatures.
       */
      @java.lang.Override
      public boolean getOutputFinalBoxFeatures() {
        return outputFinalBoxFeatures_;
      }
      /**
       * <pre>
       * Whether to output final box feature. If true, it will crop the rpn feature
       * map based on the final prediction boxes, then pass the crops through the
       * box_classifier to compute the final features in the postprocess() method.
       * </pre>
       *
       * <code>optional bool output_final_box_features = 42 [default = false];</code>
       * @param value The outputFinalBoxFeatures to set.
       * @return This builder for chaining.
       */
      public Builder setOutputFinalBoxFeatures(boolean value) {
        bitField1_ |= 0x00000080;
        outputFinalBoxFeatures_ = value;
        onChanged();
        return this;
      }
      /**
       * <pre>
       * Whether to output final box feature. If true, it will crop the rpn feature
       * map based on the final prediction boxes, then pass the crops through the
       * box_classifier to compute the final features in the postprocess() method.
       * </pre>
       *
       * <code>optional bool output_final_box_features = 42 [default = false];</code>
       * @return This builder for chaining.
       */
      public Builder clearOutputFinalBoxFeatures() {
        bitField1_ = (bitField1_ & ~0x00000080);
        outputFinalBoxFeatures_ = false;
        onChanged();
        return this;
      }

      private boolean outputFinalBoxRpnFeatures_ ;
      /**
       * <pre>
       * Whether to output final box rpn features. If true, it will crop the rpn
       * feature map in the postprocess() method based on the final prediction
       * boxes.
       * </pre>
       *
       * <code>optional bool output_final_box_rpn_features = 43 [default = false];</code>
       * @return Whether the outputFinalBoxRpnFeatures field is set.
       */
      @java.lang.Override
      public boolean hasOutputFinalBoxRpnFeatures() {
        return ((bitField1_ & 0x00000100) != 0);
      }
      /**
       * <pre>
       * Whether to output final box rpn features. If true, it will crop the rpn
       * feature map in the postprocess() method based on the final prediction
       * boxes.
       * </pre>
       *
       * <code>optional bool output_final_box_rpn_features = 43 [default = false];</code>
       * @return The outputFinalBoxRpnFeatures.
       */
      @java.lang.Override
      public boolean getOutputFinalBoxRpnFeatures() {
        return outputFinalBoxRpnFeatures_;
      }
      /**
       * <pre>
       * Whether to output final box rpn features. If true, it will crop the rpn
       * feature map in the postprocess() method based on the final prediction
       * boxes.
       * </pre>
       *
       * <code>optional bool output_final_box_rpn_features = 43 [default = false];</code>
       * @param value The outputFinalBoxRpnFeatures to set.
       * @return This builder for chaining.
       */
      public Builder setOutputFinalBoxRpnFeatures(boolean value) {
        bitField1_ |= 0x00000100;
        outputFinalBoxRpnFeatures_ = value;
        onChanged();
        return this;
      }
      /**
       * <pre>
       * Whether to output final box rpn features. If true, it will crop the rpn
       * feature map in the postprocess() method based on the final prediction
       * boxes.
       * </pre>
       *
       * <code>optional bool output_final_box_rpn_features = 43 [default = false];</code>
       * @return This builder for chaining.
       */
      public Builder clearOutputFinalBoxRpnFeatures() {
        bitField1_ = (bitField1_ & ~0x00000100);
        outputFinalBoxRpnFeatures_ = false;
        onChanged();
        return this;
      }

      private object_detection.protos.FasterRcnnOuterClass.Context contextConfig_;
      private com.google.protobuf.SingleFieldBuilderV3<
          object_detection.protos.FasterRcnnOuterClass.Context, object_detection.protos.FasterRcnnOuterClass.Context.Builder, object_detection.protos.FasterRcnnOuterClass.ContextOrBuilder> contextConfigBuilder_;
      /**
       * <pre>
       * Configs for context model.
       * </pre>
       *
       * <code>optional .object_detection.protos.Context context_config = 41;</code>
       * @return Whether the contextConfig field is set.
       */
      public boolean hasContextConfig() {
        return ((bitField1_ & 0x00000200) != 0);
      }
      /**
       * <pre>
       * Configs for context model.
       * </pre>
       *
       * <code>optional .object_detection.protos.Context context_config = 41;</code>
       * @return The contextConfig.
       */
      public object_detection.protos.FasterRcnnOuterClass.Context getContextConfig() {
        if (contextConfigBuilder_ == null) {
          return contextConfig_ == null ? object_detection.protos.FasterRcnnOuterClass.Context.getDefaultInstance() : contextConfig_;
        } else {
          return contextConfigBuilder_.getMessage();
        }
      }
      /**
       * <pre>
       * Configs for context model.
       * </pre>
       *
       * <code>optional .object_detection.protos.Context context_config = 41;</code>
       */
      public Builder setContextConfig(object_detection.protos.FasterRcnnOuterClass.Context value) {
        if (contextConfigBuilder_ == null) {
          if (value == null) {
            throw new NullPointerException();
          }
          contextConfig_ = value;
          onChanged();
        } else {
          contextConfigBuilder_.setMessage(value);
        }
        bitField1_ |= 0x00000200;
        return this;
      }
      /**
       * <pre>
       * Configs for context model.
       * </pre>
       *
       * <code>optional .object_detection.protos.Context context_config = 41;</code>
       */
      public Builder setContextConfig(
          object_detection.protos.FasterRcnnOuterClass.Context.Builder builderForValue) {
        if (contextConfigBuilder_ == null) {
          contextConfig_ = builderForValue.build();
          onChanged();
        } else {
          contextConfigBuilder_.setMessage(builderForValue.build());
        }
        bitField1_ |= 0x00000200;
        return this;
      }
      /**
       * <pre>
       * Configs for context model.
       * </pre>
       *
       * <code>optional .object_detection.protos.Context context_config = 41;</code>
       */
      public Builder mergeContextConfig(object_detection.protos.FasterRcnnOuterClass.Context value) {
        if (contextConfigBuilder_ == null) {
          if (((bitField1_ & 0x00000200) != 0) &&
              contextConfig_ != null &&
              contextConfig_ != object_detection.protos.FasterRcnnOuterClass.Context.getDefaultInstance()) {
            contextConfig_ =
              object_detection.protos.FasterRcnnOuterClass.Context.newBuilder(contextConfig_).mergeFrom(value).buildPartial();
          } else {
            contextConfig_ = value;
          }
          onChanged();
        } else {
          contextConfigBuilder_.mergeFrom(value);
        }
        bitField1_ |= 0x00000200;
        return this;
      }
      /**
       * <pre>
       * Configs for context model.
       * </pre>
       *
       * <code>optional .object_detection.protos.Context context_config = 41;</code>
       */
      public Builder clearContextConfig() {
        if (contextConfigBuilder_ == null) {
          contextConfig_ = null;
          onChanged();
        } else {
          contextConfigBuilder_.clear();
        }
        bitField1_ = (bitField1_ & ~0x00000200);
        return this;
      }
      /**
       * <pre>
       * Configs for context model.
       * </pre>
       *
       * <code>optional .object_detection.protos.Context context_config = 41;</code>
       */
      public object_detection.protos.FasterRcnnOuterClass.Context.Builder getContextConfigBuilder() {
        bitField1_ |= 0x00000200;
        onChanged();
        return getContextConfigFieldBuilder().getBuilder();
      }
      /**
       * <pre>
       * Configs for context model.
       * </pre>
       *
       * <code>optional .object_detection.protos.Context context_config = 41;</code>
       */
      public object_detection.protos.FasterRcnnOuterClass.ContextOrBuilder getContextConfigOrBuilder() {
        if (contextConfigBuilder_ != null) {
          return contextConfigBuilder_.getMessageOrBuilder();
        } else {
          return contextConfig_ == null ?
              object_detection.protos.FasterRcnnOuterClass.Context.getDefaultInstance() : contextConfig_;
        }
      }
      /**
       * <pre>
       * Configs for context model.
       * </pre>
       *
       * <code>optional .object_detection.protos.Context context_config = 41;</code>
       */
      private com.google.protobuf.SingleFieldBuilderV3<
          object_detection.protos.FasterRcnnOuterClass.Context, object_detection.protos.FasterRcnnOuterClass.Context.Builder, object_detection.protos.FasterRcnnOuterClass.ContextOrBuilder>
          getContextConfigFieldBuilder() {
        if (contextConfigBuilder_ == null) {
          contextConfigBuilder_ = new com.google.protobuf.SingleFieldBuilderV3<
              object_detection.protos.FasterRcnnOuterClass.Context, object_detection.protos.FasterRcnnOuterClass.Context.Builder, object_detection.protos.FasterRcnnOuterClass.ContextOrBuilder>(
                  getContextConfig(),
                  getParentForChildren(),
                  isClean());
          contextConfig_ = null;
        }
        return contextConfigBuilder_;
      }
      @java.lang.Override
      public final Builder setUnknownFields(
          final com.google.protobuf.UnknownFieldSet unknownFields) {
        return super.setUnknownFields(unknownFields);
      }

      @java.lang.Override
      public final Builder mergeUnknownFields(
          final com.google.protobuf.UnknownFieldSet unknownFields) {
        return super.mergeUnknownFields(unknownFields);
      }


      // @@protoc_insertion_point(builder_scope:object_detection.protos.FasterRcnn)
    }

    // @@protoc_insertion_point(class_scope:object_detection.protos.FasterRcnn)
    private static final object_detection.protos.FasterRcnnOuterClass.FasterRcnn DEFAULT_INSTANCE;
    static {
      DEFAULT_INSTANCE = new object_detection.protos.FasterRcnnOuterClass.FasterRcnn();
    }

    public static object_detection.protos.FasterRcnnOuterClass.FasterRcnn getDefaultInstance() {
      return DEFAULT_INSTANCE;
    }

    @java.lang.Deprecated public static final com.google.protobuf.Parser<FasterRcnn>
        PARSER = new com.google.protobuf.AbstractParser<FasterRcnn>() {
      @java.lang.Override
      public FasterRcnn parsePartialFrom(
          com.google.protobuf.CodedInputStream input,
          com.google.protobuf.ExtensionRegistryLite extensionRegistry)
          throws com.google.protobuf.InvalidProtocolBufferException {
        return new FasterRcnn(input, extensionRegistry);
      }
    };

    public static com.google.protobuf.Parser<FasterRcnn> parser() {
      return PARSER;
    }

    @java.lang.Override
    public com.google.protobuf.Parser<FasterRcnn> getParserForType() {
      return PARSER;
    }

    @java.lang.Override
    public object_detection.protos.FasterRcnnOuterClass.FasterRcnn getDefaultInstanceForType() {
      return DEFAULT_INSTANCE;
    }

  }

  public interface ContextOrBuilder extends
      // @@protoc_insertion_point(interface_extends:object_detection.protos.Context)
      com.google.protobuf.MessageOrBuilder {

    /**
     * <pre>
     * The maximum number of contextual features per-image, used for padding
     * </pre>
     *
     * <code>optional int32 max_num_context_features = 1 [default = 2000];</code>
     * @return Whether the maxNumContextFeatures field is set.
     */
    boolean hasMaxNumContextFeatures();
    /**
     * <pre>
     * The maximum number of contextual features per-image, used for padding
     * </pre>
     *
     * <code>optional int32 max_num_context_features = 1 [default = 2000];</code>
     * @return The maxNumContextFeatures.
     */
    int getMaxNumContextFeatures();

    /**
     * <pre>
     * The bottleneck feature dimension of the attention block.
     * </pre>
     *
     * <code>optional int32 attention_bottleneck_dimension = 2 [default = 2048];</code>
     * @return Whether the attentionBottleneckDimension field is set.
     */
    boolean hasAttentionBottleneckDimension();
    /**
     * <pre>
     * The bottleneck feature dimension of the attention block.
     * </pre>
     *
     * <code>optional int32 attention_bottleneck_dimension = 2 [default = 2048];</code>
     * @return The attentionBottleneckDimension.
     */
    int getAttentionBottleneckDimension();

    /**
     * <pre>
     * The attention temperature.
     * </pre>
     *
     * <code>optional float attention_temperature = 3 [default = 0.01];</code>
     * @return Whether the attentionTemperature field is set.
     */
    boolean hasAttentionTemperature();
    /**
     * <pre>
     * The attention temperature.
     * </pre>
     *
     * <code>optional float attention_temperature = 3 [default = 0.01];</code>
     * @return The attentionTemperature.
     */
    float getAttentionTemperature();

    /**
     * <pre>
     * The context feature length.
     * </pre>
     *
     * <code>optional int32 context_feature_length = 4 [default = 2057];</code>
     * @return Whether the contextFeatureLength field is set.
     */
    boolean hasContextFeatureLength();
    /**
     * <pre>
     * The context feature length.
     * </pre>
     *
     * <code>optional int32 context_feature_length = 4 [default = 2057];</code>
     * @return The contextFeatureLength.
     */
    int getContextFeatureLength();

    /**
     * <pre>
     * Whether to use self-attention from box proposals to themselves, TF1 only.
     * </pre>
     *
     * <code>optional bool use_self_attention = 6 [default = false];</code>
     * @return Whether the useSelfAttention field is set.
     */
    boolean hasUseSelfAttention();
    /**
     * <pre>
     * Whether to use self-attention from box proposals to themselves, TF1 only.
     * </pre>
     *
     * <code>optional bool use_self_attention = 6 [default = false];</code>
     * @return The useSelfAttention.
     */
    boolean getUseSelfAttention();

    /**
     * <pre>
     * Whether to use attention into context features, setting to false is only
     * implemented in TF1.
     * </pre>
     *
     * <code>optional bool use_long_term_attention = 7 [default = true];</code>
     * @return Whether the useLongTermAttention field is set.
     */
    boolean hasUseLongTermAttention();
    /**
     * <pre>
     * Whether to use attention into context features, setting to false is only
     * implemented in TF1.
     * </pre>
     *
     * <code>optional bool use_long_term_attention = 7 [default = true];</code>
     * @return The useLongTermAttention.
     */
    boolean getUseLongTermAttention();

    /**
     * <pre>
     * Whether the self-attention block and the long term attention block should
     * be in sequence or parallel, ie whether the outputs of the self-attention
     * block should be the inputs into the long term attention block (sequence)
     * or whether the self attention block and long term attention block should
     * happen in parallel, with outputs summed.
     * </pre>
     *
     * <code>optional bool self_attention_in_sequence = 8 [default = false];</code>
     * @return Whether the selfAttentionInSequence field is set.
     */
    boolean hasSelfAttentionInSequence();
    /**
     * <pre>
     * Whether the self-attention block and the long term attention block should
     * be in sequence or parallel, ie whether the outputs of the self-attention
     * block should be the inputs into the long term attention block (sequence)
     * or whether the self attention block and long term attention block should
     * happen in parallel, with outputs summed.
     * </pre>
     *
     * <code>optional bool self_attention_in_sequence = 8 [default = false];</code>
     * @return The selfAttentionInSequence.
     */
    boolean getSelfAttentionInSequence();

    /**
     * <pre>
     * Number of attention heads
     * </pre>
     *
     * <code>optional int32 num_attention_heads = 9 [default = 1];</code>
     * @return Whether the numAttentionHeads field is set.
     */
    boolean hasNumAttentionHeads();
    /**
     * <pre>
     * Number of attention heads
     * </pre>
     *
     * <code>optional int32 num_attention_heads = 9 [default = 1];</code>
     * @return The numAttentionHeads.
     */
    int getNumAttentionHeads();

    /**
     * <pre>
     * Number of attention layers
     * </pre>
     *
     * <code>optional int32 num_attention_layers = 11 [default = 1];</code>
     * @return Whether the numAttentionLayers field is set.
     */
    boolean hasNumAttentionLayers();
    /**
     * <pre>
     * Number of attention layers
     * </pre>
     *
     * <code>optional int32 num_attention_layers = 11 [default = 1];</code>
     * @return The numAttentionLayers.
     */
    int getNumAttentionLayers();

    /**
     * <pre>
     * Where the attention goes, 0 is pre-second-stage, 1 is post-second-stage
     * </pre>
     *
     * <code>optional .object_detection.protos.AttentionPosition attention_position = 10 [default = POST_BOX_CLASSIFIER];</code>
     * @return Whether the attentionPosition field is set.
     */
    boolean hasAttentionPosition();
    /**
     * <pre>
     * Where the attention goes, 0 is pre-second-stage, 1 is post-second-stage
     * </pre>
     *
     * <code>optional .object_detection.protos.AttentionPosition attention_position = 10 [default = POST_BOX_CLASSIFIER];</code>
     * @return The attentionPosition.
     */
    object_detection.protos.FasterRcnnOuterClass.AttentionPosition getAttentionPosition();
  }
  /**
   * <pre>
   * Configuration proto for Context R-CNN.
   * Next id: 12
   * </pre>
   *
   * Protobuf type {@code object_detection.protos.Context}
   */
  public static final class Context extends
      com.google.protobuf.GeneratedMessageV3 implements
      // @@protoc_insertion_point(message_implements:object_detection.protos.Context)
      ContextOrBuilder {
  private static final long serialVersionUID = 0L;
    // Use Context.newBuilder() to construct.
    private Context(com.google.protobuf.GeneratedMessageV3.Builder<?> builder) {
      super(builder);
    }
    private Context() {
      maxNumContextFeatures_ = 2000;
      attentionBottleneckDimension_ = 2048;
      attentionTemperature_ = 0.01F;
      contextFeatureLength_ = 2057;
      useLongTermAttention_ = true;
      numAttentionHeads_ = 1;
      numAttentionLayers_ = 1;
      attentionPosition_ = 1;
    }

    @java.lang.Override
    @SuppressWarnings({"unused"})
    protected java.lang.Object newInstance(
        UnusedPrivateParameter unused) {
      return new Context();
    }

    @java.lang.Override
    public final com.google.protobuf.UnknownFieldSet
    getUnknownFields() {
      return this.unknownFields;
    }
    private Context(
        com.google.protobuf.CodedInputStream input,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws com.google.protobuf.InvalidProtocolBufferException {
      this();
      if (extensionRegistry == null) {
        throw new java.lang.NullPointerException();
      }
      int mutable_bitField0_ = 0;
      com.google.protobuf.UnknownFieldSet.Builder unknownFields =
          com.google.protobuf.UnknownFieldSet.newBuilder();
      try {
        boolean done = false;
        while (!done) {
          int tag = input.readTag();
          switch (tag) {
            case 0:
              done = true;
              break;
            case 8: {
              bitField0_ |= 0x00000001;
              maxNumContextFeatures_ = input.readInt32();
              break;
            }
            case 16: {
              bitField0_ |= 0x00000002;
              attentionBottleneckDimension_ = input.readInt32();
              break;
            }
            case 29: {
              bitField0_ |= 0x00000004;
              attentionTemperature_ = input.readFloat();
              break;
            }
            case 32: {
              bitField0_ |= 0x00000008;
              contextFeatureLength_ = input.readInt32();
              break;
            }
            case 48: {
              bitField0_ |= 0x00000010;
              useSelfAttention_ = input.readBool();
              break;
            }
            case 56: {
              bitField0_ |= 0x00000020;
              useLongTermAttention_ = input.readBool();
              break;
            }
            case 64: {
              bitField0_ |= 0x00000040;
              selfAttentionInSequence_ = input.readBool();
              break;
            }
            case 72: {
              bitField0_ |= 0x00000080;
              numAttentionHeads_ = input.readInt32();
              break;
            }
            case 80: {
              int rawValue = input.readEnum();
                @SuppressWarnings("deprecation")
              object_detection.protos.FasterRcnnOuterClass.AttentionPosition value = object_detection.protos.FasterRcnnOuterClass.AttentionPosition.valueOf(rawValue);
              if (value == null) {
                unknownFields.mergeVarintField(10, rawValue);
              } else {
                bitField0_ |= 0x00000200;
                attentionPosition_ = rawValue;
              }
              break;
            }
            case 88: {
              bitField0_ |= 0x00000100;
              numAttentionLayers_ = input.readInt32();
              break;
            }
            default: {
              if (!parseUnknownField(
                  input, unknownFields, extensionRegistry, tag)) {
                done = true;
              }
              break;
            }
          }
        }
      } catch (com.google.protobuf.InvalidProtocolBufferException e) {
        throw e.setUnfinishedMessage(this);
      } catch (java.io.IOException e) {
        throw new com.google.protobuf.InvalidProtocolBufferException(
            e).setUnfinishedMessage(this);
      } finally {
        this.unknownFields = unknownFields.build();
        makeExtensionsImmutable();
      }
    }
    public static final com.google.protobuf.Descriptors.Descriptor
        getDescriptor() {
      return object_detection.protos.FasterRcnnOuterClass.internal_static_object_detection_protos_Context_descriptor;
    }

    @java.lang.Override
    protected com.google.protobuf.GeneratedMessageV3.FieldAccessorTable
        internalGetFieldAccessorTable() {
      return object_detection.protos.FasterRcnnOuterClass.internal_static_object_detection_protos_Context_fieldAccessorTable
          .ensureFieldAccessorsInitialized(
              object_detection.protos.FasterRcnnOuterClass.Context.class, object_detection.protos.FasterRcnnOuterClass.Context.Builder.class);
    }

    private int bitField0_;
    public static final int MAX_NUM_CONTEXT_FEATURES_FIELD_NUMBER = 1;
    private int maxNumContextFeatures_;
    /**
     * <pre>
     * The maximum number of contextual features per-image, used for padding
     * </pre>
     *
     * <code>optional int32 max_num_context_features = 1 [default = 2000];</code>
     * @return Whether the maxNumContextFeatures field is set.
     */
    @java.lang.Override
    public boolean hasMaxNumContextFeatures() {
      return ((bitField0_ & 0x00000001) != 0);
    }
    /**
     * <pre>
     * The maximum number of contextual features per-image, used for padding
     * </pre>
     *
     * <code>optional int32 max_num_context_features = 1 [default = 2000];</code>
     * @return The maxNumContextFeatures.
     */
    @java.lang.Override
    public int getMaxNumContextFeatures() {
      return maxNumContextFeatures_;
    }

    public static final int ATTENTION_BOTTLENECK_DIMENSION_FIELD_NUMBER = 2;
    private int attentionBottleneckDimension_;
    /**
     * <pre>
     * The bottleneck feature dimension of the attention block.
     * </pre>
     *
     * <code>optional int32 attention_bottleneck_dimension = 2 [default = 2048];</code>
     * @return Whether the attentionBottleneckDimension field is set.
     */
    @java.lang.Override
    public boolean hasAttentionBottleneckDimension() {
      return ((bitField0_ & 0x00000002) != 0);
    }
    /**
     * <pre>
     * The bottleneck feature dimension of the attention block.
     * </pre>
     *
     * <code>optional int32 attention_bottleneck_dimension = 2 [default = 2048];</code>
     * @return The attentionBottleneckDimension.
     */
    @java.lang.Override
    public int getAttentionBottleneckDimension() {
      return attentionBottleneckDimension_;
    }

    public static final int ATTENTION_TEMPERATURE_FIELD_NUMBER = 3;
    private float attentionTemperature_;
    /**
     * <pre>
     * The attention temperature.
     * </pre>
     *
     * <code>optional float attention_temperature = 3 [default = 0.01];</code>
     * @return Whether the attentionTemperature field is set.
     */
    @java.lang.Override
    public boolean hasAttentionTemperature() {
      return ((bitField0_ & 0x00000004) != 0);
    }
    /**
     * <pre>
     * The attention temperature.
     * </pre>
     *
     * <code>optional float attention_temperature = 3 [default = 0.01];</code>
     * @return The attentionTemperature.
     */
    @java.lang.Override
    public float getAttentionTemperature() {
      return attentionTemperature_;
    }

    public static final int CONTEXT_FEATURE_LENGTH_FIELD_NUMBER = 4;
    private int contextFeatureLength_;
    /**
     * <pre>
     * The context feature length.
     * </pre>
     *
     * <code>optional int32 context_feature_length = 4 [default = 2057];</code>
     * @return Whether the contextFeatureLength field is set.
     */
    @java.lang.Override
    public boolean hasContextFeatureLength() {
      return ((bitField0_ & 0x00000008) != 0);
    }
    /**
     * <pre>
     * The context feature length.
     * </pre>
     *
     * <code>optional int32 context_feature_length = 4 [default = 2057];</code>
     * @return The contextFeatureLength.
     */
    @java.lang.Override
    public int getContextFeatureLength() {
      return contextFeatureLength_;
    }

    public static final int USE_SELF_ATTENTION_FIELD_NUMBER = 6;
    private boolean useSelfAttention_;
    /**
     * <pre>
     * Whether to use self-attention from box proposals to themselves, TF1 only.
     * </pre>
     *
     * <code>optional bool use_self_attention = 6 [default = false];</code>
     * @return Whether the useSelfAttention field is set.
     */
    @java.lang.Override
    public boolean hasUseSelfAttention() {
      return ((bitField0_ & 0x00000010) != 0);
    }
    /**
     * <pre>
     * Whether to use self-attention from box proposals to themselves, TF1 only.
     * </pre>
     *
     * <code>optional bool use_self_attention = 6 [default = false];</code>
     * @return The useSelfAttention.
     */
    @java.lang.Override
    public boolean getUseSelfAttention() {
      return useSelfAttention_;
    }

    public static final int USE_LONG_TERM_ATTENTION_FIELD_NUMBER = 7;
    private boolean useLongTermAttention_;
    /**
     * <pre>
     * Whether to use attention into context features, setting to false is only
     * implemented in TF1.
     * </pre>
     *
     * <code>optional bool use_long_term_attention = 7 [default = true];</code>
     * @return Whether the useLongTermAttention field is set.
     */
    @java.lang.Override
    public boolean hasUseLongTermAttention() {
      return ((bitField0_ & 0x00000020) != 0);
    }
    /**
     * <pre>
     * Whether to use attention into context features, setting to false is only
     * implemented in TF1.
     * </pre>
     *
     * <code>optional bool use_long_term_attention = 7 [default = true];</code>
     * @return The useLongTermAttention.
     */
    @java.lang.Override
    public boolean getUseLongTermAttention() {
      return useLongTermAttention_;
    }

    public static final int SELF_ATTENTION_IN_SEQUENCE_FIELD_NUMBER = 8;
    private boolean selfAttentionInSequence_;
    /**
     * <pre>
     * Whether the self-attention block and the long term attention block should
     * be in sequence or parallel, ie whether the outputs of the self-attention
     * block should be the inputs into the long term attention block (sequence)
     * or whether the self attention block and long term attention block should
     * happen in parallel, with outputs summed.
     * </pre>
     *
     * <code>optional bool self_attention_in_sequence = 8 [default = false];</code>
     * @return Whether the selfAttentionInSequence field is set.
     */
    @java.lang.Override
    public boolean hasSelfAttentionInSequence() {
      return ((bitField0_ & 0x00000040) != 0);
    }
    /**
     * <pre>
     * Whether the self-attention block and the long term attention block should
     * be in sequence or parallel, ie whether the outputs of the self-attention
     * block should be the inputs into the long term attention block (sequence)
     * or whether the self attention block and long term attention block should
     * happen in parallel, with outputs summed.
     * </pre>
     *
     * <code>optional bool self_attention_in_sequence = 8 [default = false];</code>
     * @return The selfAttentionInSequence.
     */
    @java.lang.Override
    public boolean getSelfAttentionInSequence() {
      return selfAttentionInSequence_;
    }

    public static final int NUM_ATTENTION_HEADS_FIELD_NUMBER = 9;
    private int numAttentionHeads_;
    /**
     * <pre>
     * Number of attention heads
     * </pre>
     *
     * <code>optional int32 num_attention_heads = 9 [default = 1];</code>
     * @return Whether the numAttentionHeads field is set.
     */
    @java.lang.Override
    public boolean hasNumAttentionHeads() {
      return ((bitField0_ & 0x00000080) != 0);
    }
    /**
     * <pre>
     * Number of attention heads
     * </pre>
     *
     * <code>optional int32 num_attention_heads = 9 [default = 1];</code>
     * @return The numAttentionHeads.
     */
    @java.lang.Override
    public int getNumAttentionHeads() {
      return numAttentionHeads_;
    }

    public static final int NUM_ATTENTION_LAYERS_FIELD_NUMBER = 11;
    private int numAttentionLayers_;
    /**
     * <pre>
     * Number of attention layers
     * </pre>
     *
     * <code>optional int32 num_attention_layers = 11 [default = 1];</code>
     * @return Whether the numAttentionLayers field is set.
     */
    @java.lang.Override
    public boolean hasNumAttentionLayers() {
      return ((bitField0_ & 0x00000100) != 0);
    }
    /**
     * <pre>
     * Number of attention layers
     * </pre>
     *
     * <code>optional int32 num_attention_layers = 11 [default = 1];</code>
     * @return The numAttentionLayers.
     */
    @java.lang.Override
    public int getNumAttentionLayers() {
      return numAttentionLayers_;
    }

    public static final int ATTENTION_POSITION_FIELD_NUMBER = 10;
    private int attentionPosition_;
    /**
     * <pre>
     * Where the attention goes, 0 is pre-second-stage, 1 is post-second-stage
     * </pre>
     *
     * <code>optional .object_detection.protos.AttentionPosition attention_position = 10 [default = POST_BOX_CLASSIFIER];</code>
     * @return Whether the attentionPosition field is set.
     */
    @java.lang.Override public boolean hasAttentionPosition() {
      return ((bitField0_ & 0x00000200) != 0);
    }
    /**
     * <pre>
     * Where the attention goes, 0 is pre-second-stage, 1 is post-second-stage
     * </pre>
     *
     * <code>optional .object_detection.protos.AttentionPosition attention_position = 10 [default = POST_BOX_CLASSIFIER];</code>
     * @return The attentionPosition.
     */
    @java.lang.Override public object_detection.protos.FasterRcnnOuterClass.AttentionPosition getAttentionPosition() {
      @SuppressWarnings("deprecation")
      object_detection.protos.FasterRcnnOuterClass.AttentionPosition result = object_detection.protos.FasterRcnnOuterClass.AttentionPosition.valueOf(attentionPosition_);
      return result == null ? object_detection.protos.FasterRcnnOuterClass.AttentionPosition.POST_BOX_CLASSIFIER : result;
    }

    private byte memoizedIsInitialized = -1;
    @java.lang.Override
    public final boolean isInitialized() {
      byte isInitialized = memoizedIsInitialized;
      if (isInitialized == 1) return true;
      if (isInitialized == 0) return false;

      memoizedIsInitialized = 1;
      return true;
    }

    @java.lang.Override
    public void writeTo(com.google.protobuf.CodedOutputStream output)
                        throws java.io.IOException {
      if (((bitField0_ & 0x00000001) != 0)) {
        output.writeInt32(1, maxNumContextFeatures_);
      }
      if (((bitField0_ & 0x00000002) != 0)) {
        output.writeInt32(2, attentionBottleneckDimension_);
      }
      if (((bitField0_ & 0x00000004) != 0)) {
        output.writeFloat(3, attentionTemperature_);
      }
      if (((bitField0_ & 0x00000008) != 0)) {
        output.writeInt32(4, contextFeatureLength_);
      }
      if (((bitField0_ & 0x00000010) != 0)) {
        output.writeBool(6, useSelfAttention_);
      }
      if (((bitField0_ & 0x00000020) != 0)) {
        output.writeBool(7, useLongTermAttention_);
      }
      if (((bitField0_ & 0x00000040) != 0)) {
        output.writeBool(8, selfAttentionInSequence_);
      }
      if (((bitField0_ & 0x00000080) != 0)) {
        output.writeInt32(9, numAttentionHeads_);
      }
      if (((bitField0_ & 0x00000200) != 0)) {
        output.writeEnum(10, attentionPosition_);
      }
      if (((bitField0_ & 0x00000100) != 0)) {
        output.writeInt32(11, numAttentionLayers_);
      }
      unknownFields.writeTo(output);
    }

    @java.lang.Override
    public int getSerializedSize() {
      int size = memoizedSize;
      if (size != -1) return size;

      size = 0;
      if (((bitField0_ & 0x00000001) != 0)) {
        size += com.google.protobuf.CodedOutputStream
          .computeInt32Size(1, maxNumContextFeatures_);
      }
      if (((bitField0_ & 0x00000002) != 0)) {
        size += com.google.protobuf.CodedOutputStream
          .computeInt32Size(2, attentionBottleneckDimension_);
      }
      if (((bitField0_ & 0x00000004) != 0)) {
        size += com.google.protobuf.CodedOutputStream
          .computeFloatSize(3, attentionTemperature_);
      }
      if (((bitField0_ & 0x00000008) != 0)) {
        size += com.google.protobuf.CodedOutputStream
          .computeInt32Size(4, contextFeatureLength_);
      }
      if (((bitField0_ & 0x00000010) != 0)) {
        size += com.google.protobuf.CodedOutputStream
          .computeBoolSize(6, useSelfAttention_);
      }
      if (((bitField0_ & 0x00000020) != 0)) {
        size += com.google.protobuf.CodedOutputStream
          .computeBoolSize(7, useLongTermAttention_);
      }
      if (((bitField0_ & 0x00000040) != 0)) {
        size += com.google.protobuf.CodedOutputStream
          .computeBoolSize(8, selfAttentionInSequence_);
      }
      if (((bitField0_ & 0x00000080) != 0)) {
        size += com.google.protobuf.CodedOutputStream
          .computeInt32Size(9, numAttentionHeads_);
      }
      if (((bitField0_ & 0x00000200) != 0)) {
        size += com.google.protobuf.CodedOutputStream
          .computeEnumSize(10, attentionPosition_);
      }
      if (((bitField0_ & 0x00000100) != 0)) {
        size += com.google.protobuf.CodedOutputStream
          .computeInt32Size(11, numAttentionLayers_);
      }
      size += unknownFields.getSerializedSize();
      memoizedSize = size;
      return size;
    }

    @java.lang.Override
    public boolean equals(final java.lang.Object obj) {
      if (obj == this) {
       return true;
      }
      if (!(obj instanceof object_detection.protos.FasterRcnnOuterClass.Context)) {
        return super.equals(obj);
      }
      object_detection.protos.FasterRcnnOuterClass.Context other = (object_detection.protos.FasterRcnnOuterClass.Context) obj;

      if (hasMaxNumContextFeatures() != other.hasMaxNumContextFeatures()) return false;
      if (hasMaxNumContextFeatures()) {
        if (getMaxNumContextFeatures()
            != other.getMaxNumContextFeatures()) return false;
      }
      if (hasAttentionBottleneckDimension() != other.hasAttentionBottleneckDimension()) return false;
      if (hasAttentionBottleneckDimension()) {
        if (getAttentionBottleneckDimension()
            != other.getAttentionBottleneckDimension()) return false;
      }
      if (hasAttentionTemperature() != other.hasAttentionTemperature()) return false;
      if (hasAttentionTemperature()) {
        if (java.lang.Float.floatToIntBits(getAttentionTemperature())
            != java.lang.Float.floatToIntBits(
                other.getAttentionTemperature())) return false;
      }
      if (hasContextFeatureLength() != other.hasContextFeatureLength()) return false;
      if (hasContextFeatureLength()) {
        if (getContextFeatureLength()
            != other.getContextFeatureLength()) return false;
      }
      if (hasUseSelfAttention() != other.hasUseSelfAttention()) return false;
      if (hasUseSelfAttention()) {
        if (getUseSelfAttention()
            != other.getUseSelfAttention()) return false;
      }
      if (hasUseLongTermAttention() != other.hasUseLongTermAttention()) return false;
      if (hasUseLongTermAttention()) {
        if (getUseLongTermAttention()
            != other.getUseLongTermAttention()) return false;
      }
      if (hasSelfAttentionInSequence() != other.hasSelfAttentionInSequence()) return false;
      if (hasSelfAttentionInSequence()) {
        if (getSelfAttentionInSequence()
            != other.getSelfAttentionInSequence()) return false;
      }
      if (hasNumAttentionHeads() != other.hasNumAttentionHeads()) return false;
      if (hasNumAttentionHeads()) {
        if (getNumAttentionHeads()
            != other.getNumAttentionHeads()) return false;
      }
      if (hasNumAttentionLayers() != other.hasNumAttentionLayers()) return false;
      if (hasNumAttentionLayers()) {
        if (getNumAttentionLayers()
            != other.getNumAttentionLayers()) return false;
      }
      if (hasAttentionPosition() != other.hasAttentionPosition()) return false;
      if (hasAttentionPosition()) {
        if (attentionPosition_ != other.attentionPosition_) return false;
      }
      if (!unknownFields.equals(other.unknownFields)) return false;
      return true;
    }

    @java.lang.Override
    public int hashCode() {
      if (memoizedHashCode != 0) {
        return memoizedHashCode;
      }
      int hash = 41;
      hash = (19 * hash) + getDescriptor().hashCode();
      if (hasMaxNumContextFeatures()) {
        hash = (37 * hash) + MAX_NUM_CONTEXT_FEATURES_FIELD_NUMBER;
        hash = (53 * hash) + getMaxNumContextFeatures();
      }
      if (hasAttentionBottleneckDimension()) {
        hash = (37 * hash) + ATTENTION_BOTTLENECK_DIMENSION_FIELD_NUMBER;
        hash = (53 * hash) + getAttentionBottleneckDimension();
      }
      if (hasAttentionTemperature()) {
        hash = (37 * hash) + ATTENTION_TEMPERATURE_FIELD_NUMBER;
        hash = (53 * hash) + java.lang.Float.floatToIntBits(
            getAttentionTemperature());
      }
      if (hasContextFeatureLength()) {
        hash = (37 * hash) + CONTEXT_FEATURE_LENGTH_FIELD_NUMBER;
        hash = (53 * hash) + getContextFeatureLength();
      }
      if (hasUseSelfAttention()) {
        hash = (37 * hash) + USE_SELF_ATTENTION_FIELD_NUMBER;
        hash = (53 * hash) + com.google.protobuf.Internal.hashBoolean(
            getUseSelfAttention());
      }
      if (hasUseLongTermAttention()) {
        hash = (37 * hash) + USE_LONG_TERM_ATTENTION_FIELD_NUMBER;
        hash = (53 * hash) + com.google.protobuf.Internal.hashBoolean(
            getUseLongTermAttention());
      }
      if (hasSelfAttentionInSequence()) {
        hash = (37 * hash) + SELF_ATTENTION_IN_SEQUENCE_FIELD_NUMBER;
        hash = (53 * hash) + com.google.protobuf.Internal.hashBoolean(
            getSelfAttentionInSequence());
      }
      if (hasNumAttentionHeads()) {
        hash = (37 * hash) + NUM_ATTENTION_HEADS_FIELD_NUMBER;
        hash = (53 * hash) + getNumAttentionHeads();
      }
      if (hasNumAttentionLayers()) {
        hash = (37 * hash) + NUM_ATTENTION_LAYERS_FIELD_NUMBER;
        hash = (53 * hash) + getNumAttentionLayers();
      }
      if (hasAttentionPosition()) {
        hash = (37 * hash) + ATTENTION_POSITION_FIELD_NUMBER;
        hash = (53 * hash) + attentionPosition_;
      }
      hash = (29 * hash) + unknownFields.hashCode();
      memoizedHashCode = hash;
      return hash;
    }

    public static object_detection.protos.FasterRcnnOuterClass.Context parseFrom(
        java.nio.ByteBuffer data)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return PARSER.parseFrom(data);
    }
    public static object_detection.protos.FasterRcnnOuterClass.Context parseFrom(
        java.nio.ByteBuffer data,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return PARSER.parseFrom(data, extensionRegistry);
    }
    public static object_detection.protos.FasterRcnnOuterClass.Context parseFrom(
        com.google.protobuf.ByteString data)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return PARSER.parseFrom(data);
    }
    public static object_detection.protos.FasterRcnnOuterClass.Context parseFrom(
        com.google.protobuf.ByteString data,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return PARSER.parseFrom(data, extensionRegistry);
    }
    public static object_detection.protos.FasterRcnnOuterClass.Context parseFrom(byte[] data)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return PARSER.parseFrom(data);
    }
    public static object_detection.protos.FasterRcnnOuterClass.Context parseFrom(
        byte[] data,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return PARSER.parseFrom(data, extensionRegistry);
    }
    public static object_detection.protos.FasterRcnnOuterClass.Context parseFrom(java.io.InputStream input)
        throws java.io.IOException {
      return com.google.protobuf.GeneratedMessageV3
          .parseWithIOException(PARSER, input);
    }
    public static object_detection.protos.FasterRcnnOuterClass.Context parseFrom(
        java.io.InputStream input,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws java.io.IOException {
      return com.google.protobuf.GeneratedMessageV3
          .parseWithIOException(PARSER, input, extensionRegistry);
    }
    public static object_detection.protos.FasterRcnnOuterClass.Context parseDelimitedFrom(java.io.InputStream input)
        throws java.io.IOException {
      return com.google.protobuf.GeneratedMessageV3
          .parseDelimitedWithIOException(PARSER, input);
    }
    public static object_detection.protos.FasterRcnnOuterClass.Context parseDelimitedFrom(
        java.io.InputStream input,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws java.io.IOException {
      return com.google.protobuf.GeneratedMessageV3
          .parseDelimitedWithIOException(PARSER, input, extensionRegistry);
    }
    public static object_detection.protos.FasterRcnnOuterClass.Context parseFrom(
        com.google.protobuf.CodedInputStream input)
        throws java.io.IOException {
      return com.google.protobuf.GeneratedMessageV3
          .parseWithIOException(PARSER, input);
    }
    public static object_detection.protos.FasterRcnnOuterClass.Context parseFrom(
        com.google.protobuf.CodedInputStream input,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws java.io.IOException {
      return com.google.protobuf.GeneratedMessageV3
          .parseWithIOException(PARSER, input, extensionRegistry);
    }

    @java.lang.Override
    public Builder newBuilderForType() { return newBuilder(); }
    public static Builder newBuilder() {
      return DEFAULT_INSTANCE.toBuilder();
    }
    public static Builder newBuilder(object_detection.protos.FasterRcnnOuterClass.Context prototype) {
      return DEFAULT_INSTANCE.toBuilder().mergeFrom(prototype);
    }
    @java.lang.Override
    public Builder toBuilder() {
      return this == DEFAULT_INSTANCE
          ? new Builder() : new Builder().mergeFrom(this);
    }

    @java.lang.Override
    protected Builder newBuilderForType(
        com.google.protobuf.GeneratedMessageV3.BuilderParent parent) {
      Builder builder = new Builder(parent);
      return builder;
    }
    /**
     * <pre>
     * Configuration proto for Context R-CNN.
     * Next id: 12
     * </pre>
     *
     * Protobuf type {@code object_detection.protos.Context}
     */
    public static final class Builder extends
        com.google.protobuf.GeneratedMessageV3.Builder<Builder> implements
        // @@protoc_insertion_point(builder_implements:object_detection.protos.Context)
        object_detection.protos.FasterRcnnOuterClass.ContextOrBuilder {
      public static final com.google.protobuf.Descriptors.Descriptor
          getDescriptor() {
        return object_detection.protos.FasterRcnnOuterClass.internal_static_object_detection_protos_Context_descriptor;
      }

      @java.lang.Override
      protected com.google.protobuf.GeneratedMessageV3.FieldAccessorTable
          internalGetFieldAccessorTable() {
        return object_detection.protos.FasterRcnnOuterClass.internal_static_object_detection_protos_Context_fieldAccessorTable
            .ensureFieldAccessorsInitialized(
                object_detection.protos.FasterRcnnOuterClass.Context.class, object_detection.protos.FasterRcnnOuterClass.Context.Builder.class);
      }

      // Construct using object_detection.protos.FasterRcnnOuterClass.Context.newBuilder()
      private Builder() {
        maybeForceBuilderInitialization();
      }

      private Builder(
          com.google.protobuf.GeneratedMessageV3.BuilderParent parent) {
        super(parent);
        maybeForceBuilderInitialization();
      }
      private void maybeForceBuilderInitialization() {
        if (com.google.protobuf.GeneratedMessageV3
                .alwaysUseFieldBuilders) {
        }
      }
      @java.lang.Override
      public Builder clear() {
        super.clear();
        maxNumContextFeatures_ = 2000;
        bitField0_ = (bitField0_ & ~0x00000001);
        attentionBottleneckDimension_ = 2048;
        bitField0_ = (bitField0_ & ~0x00000002);
        attentionTemperature_ = 0.01F;
        bitField0_ = (bitField0_ & ~0x00000004);
        contextFeatureLength_ = 2057;
        bitField0_ = (bitField0_ & ~0x00000008);
        useSelfAttention_ = false;
        bitField0_ = (bitField0_ & ~0x00000010);
        useLongTermAttention_ = true;
        bitField0_ = (bitField0_ & ~0x00000020);
        selfAttentionInSequence_ = false;
        bitField0_ = (bitField0_ & ~0x00000040);
        numAttentionHeads_ = 1;
        bitField0_ = (bitField0_ & ~0x00000080);
        numAttentionLayers_ = 1;
        bitField0_ = (bitField0_ & ~0x00000100);
        attentionPosition_ = 1;
        bitField0_ = (bitField0_ & ~0x00000200);
        return this;
      }

      @java.lang.Override
      public com.google.protobuf.Descriptors.Descriptor
          getDescriptorForType() {
        return object_detection.protos.FasterRcnnOuterClass.internal_static_object_detection_protos_Context_descriptor;
      }

      @java.lang.Override
      public object_detection.protos.FasterRcnnOuterClass.Context getDefaultInstanceForType() {
        return object_detection.protos.FasterRcnnOuterClass.Context.getDefaultInstance();
      }

      @java.lang.Override
      public object_detection.protos.FasterRcnnOuterClass.Context build() {
        object_detection.protos.FasterRcnnOuterClass.Context result = buildPartial();
        if (!result.isInitialized()) {
          throw newUninitializedMessageException(result);
        }
        return result;
      }

      @java.lang.Override
      public object_detection.protos.FasterRcnnOuterClass.Context buildPartial() {
        object_detection.protos.FasterRcnnOuterClass.Context result = new object_detection.protos.FasterRcnnOuterClass.Context(this);
        int from_bitField0_ = bitField0_;
        int to_bitField0_ = 0;
        if (((from_bitField0_ & 0x00000001) != 0)) {
          to_bitField0_ |= 0x00000001;
        }
        result.maxNumContextFeatures_ = maxNumContextFeatures_;
        if (((from_bitField0_ & 0x00000002) != 0)) {
          to_bitField0_ |= 0x00000002;
        }
        result.attentionBottleneckDimension_ = attentionBottleneckDimension_;
        if (((from_bitField0_ & 0x00000004) != 0)) {
          to_bitField0_ |= 0x00000004;
        }
        result.attentionTemperature_ = attentionTemperature_;
        if (((from_bitField0_ & 0x00000008) != 0)) {
          to_bitField0_ |= 0x00000008;
        }
        result.contextFeatureLength_ = contextFeatureLength_;
        if (((from_bitField0_ & 0x00000010) != 0)) {
          result.useSelfAttention_ = useSelfAttention_;
          to_bitField0_ |= 0x00000010;
        }
        if (((from_bitField0_ & 0x00000020) != 0)) {
          to_bitField0_ |= 0x00000020;
        }
        result.useLongTermAttention_ = useLongTermAttention_;
        if (((from_bitField0_ & 0x00000040) != 0)) {
          result.selfAttentionInSequence_ = selfAttentionInSequence_;
          to_bitField0_ |= 0x00000040;
        }
        if (((from_bitField0_ & 0x00000080) != 0)) {
          to_bitField0_ |= 0x00000080;
        }
        result.numAttentionHeads_ = numAttentionHeads_;
        if (((from_bitField0_ & 0x00000100) != 0)) {
          to_bitField0_ |= 0x00000100;
        }
        result.numAttentionLayers_ = numAttentionLayers_;
        if (((from_bitField0_ & 0x00000200) != 0)) {
          to_bitField0_ |= 0x00000200;
        }
        result.attentionPosition_ = attentionPosition_;
        result.bitField0_ = to_bitField0_;
        onBuilt();
        return result;
      }

      @java.lang.Override
      public Builder clone() {
        return super.clone();
      }
      @java.lang.Override
      public Builder setField(
          com.google.protobuf.Descriptors.FieldDescriptor field,
          java.lang.Object value) {
        return super.setField(field, value);
      }
      @java.lang.Override
      public Builder clearField(
          com.google.protobuf.Descriptors.FieldDescriptor field) {
        return super.clearField(field);
      }
      @java.lang.Override
      public Builder clearOneof(
          com.google.protobuf.Descriptors.OneofDescriptor oneof) {
        return super.clearOneof(oneof);
      }
      @java.lang.Override
      public Builder setRepeatedField(
          com.google.protobuf.Descriptors.FieldDescriptor field,
          int index, java.lang.Object value) {
        return super.setRepeatedField(field, index, value);
      }
      @java.lang.Override
      public Builder addRepeatedField(
          com.google.protobuf.Descriptors.FieldDescriptor field,
          java.lang.Object value) {
        return super.addRepeatedField(field, value);
      }
      @java.lang.Override
      public Builder mergeFrom(com.google.protobuf.Message other) {
        if (other instanceof object_detection.protos.FasterRcnnOuterClass.Context) {
          return mergeFrom((object_detection.protos.FasterRcnnOuterClass.Context)other);
        } else {
          super.mergeFrom(other);
          return this;
        }
      }

      public Builder mergeFrom(object_detection.protos.FasterRcnnOuterClass.Context other) {
        if (other == object_detection.protos.FasterRcnnOuterClass.Context.getDefaultInstance()) return this;
        if (other.hasMaxNumContextFeatures()) {
          setMaxNumContextFeatures(other.getMaxNumContextFeatures());
        }
        if (other.hasAttentionBottleneckDimension()) {
          setAttentionBottleneckDimension(other.getAttentionBottleneckDimension());
        }
        if (other.hasAttentionTemperature()) {
          setAttentionTemperature(other.getAttentionTemperature());
        }
        if (other.hasContextFeatureLength()) {
          setContextFeatureLength(other.getContextFeatureLength());
        }
        if (other.hasUseSelfAttention()) {
          setUseSelfAttention(other.getUseSelfAttention());
        }
        if (other.hasUseLongTermAttention()) {
          setUseLongTermAttention(other.getUseLongTermAttention());
        }
        if (other.hasSelfAttentionInSequence()) {
          setSelfAttentionInSequence(other.getSelfAttentionInSequence());
        }
        if (other.hasNumAttentionHeads()) {
          setNumAttentionHeads(other.getNumAttentionHeads());
        }
        if (other.hasNumAttentionLayers()) {
          setNumAttentionLayers(other.getNumAttentionLayers());
        }
        if (other.hasAttentionPosition()) {
          setAttentionPosition(other.getAttentionPosition());
        }
        this.mergeUnknownFields(other.unknownFields);
        onChanged();
        return this;
      }

      @java.lang.Override
      public final boolean isInitialized() {
        return true;
      }

      @java.lang.Override
      public Builder mergeFrom(
          com.google.protobuf.CodedInputStream input,
          com.google.protobuf.ExtensionRegistryLite extensionRegistry)
          throws java.io.IOException {
        object_detection.protos.FasterRcnnOuterClass.Context parsedMessage = null;
        try {
          parsedMessage = PARSER.parsePartialFrom(input, extensionRegistry);
        } catch (com.google.protobuf.InvalidProtocolBufferException e) {
          parsedMessage = (object_detection.protos.FasterRcnnOuterClass.Context) e.getUnfinishedMessage();
          throw e.unwrapIOException();
        } finally {
          if (parsedMessage != null) {
            mergeFrom(parsedMessage);
          }
        }
        return this;
      }
      private int bitField0_;

      private int maxNumContextFeatures_ = 2000;
      /**
       * <pre>
       * The maximum number of contextual features per-image, used for padding
       * </pre>
       *
       * <code>optional int32 max_num_context_features = 1 [default = 2000];</code>
       * @return Whether the maxNumContextFeatures field is set.
       */
      @java.lang.Override
      public boolean hasMaxNumContextFeatures() {
        return ((bitField0_ & 0x00000001) != 0);
      }
      /**
       * <pre>
       * The maximum number of contextual features per-image, used for padding
       * </pre>
       *
       * <code>optional int32 max_num_context_features = 1 [default = 2000];</code>
       * @return The maxNumContextFeatures.
       */
      @java.lang.Override
      public int getMaxNumContextFeatures() {
        return maxNumContextFeatures_;
      }
      /**
       * <pre>
       * The maximum number of contextual features per-image, used for padding
       * </pre>
       *
       * <code>optional int32 max_num_context_features = 1 [default = 2000];</code>
       * @param value The maxNumContextFeatures to set.
       * @return This builder for chaining.
       */
      public Builder setMaxNumContextFeatures(int value) {
        bitField0_ |= 0x00000001;
        maxNumContextFeatures_ = value;
        onChanged();
        return this;
      }
      /**
       * <pre>
       * The maximum number of contextual features per-image, used for padding
       * </pre>
       *
       * <code>optional int32 max_num_context_features = 1 [default = 2000];</code>
       * @return This builder for chaining.
       */
      public Builder clearMaxNumContextFeatures() {
        bitField0_ = (bitField0_ & ~0x00000001);
        maxNumContextFeatures_ = 2000;
        onChanged();
        return this;
      }

      private int attentionBottleneckDimension_ = 2048;
      /**
       * <pre>
       * The bottleneck feature dimension of the attention block.
       * </pre>
       *
       * <code>optional int32 attention_bottleneck_dimension = 2 [default = 2048];</code>
       * @return Whether the attentionBottleneckDimension field is set.
       */
      @java.lang.Override
      public boolean hasAttentionBottleneckDimension() {
        return ((bitField0_ & 0x00000002) != 0);
      }
      /**
       * <pre>
       * The bottleneck feature dimension of the attention block.
       * </pre>
       *
       * <code>optional int32 attention_bottleneck_dimension = 2 [default = 2048];</code>
       * @return The attentionBottleneckDimension.
       */
      @java.lang.Override
      public int getAttentionBottleneckDimension() {
        return attentionBottleneckDimension_;
      }
      /**
       * <pre>
       * The bottleneck feature dimension of the attention block.
       * </pre>
       *
       * <code>optional int32 attention_bottleneck_dimension = 2 [default = 2048];</code>
       * @param value The attentionBottleneckDimension to set.
       * @return This builder for chaining.
       */
      public Builder setAttentionBottleneckDimension(int value) {
        bitField0_ |= 0x00000002;
        attentionBottleneckDimension_ = value;
        onChanged();
        return this;
      }
      /**
       * <pre>
       * The bottleneck feature dimension of the attention block.
       * </pre>
       *
       * <code>optional int32 attention_bottleneck_dimension = 2 [default = 2048];</code>
       * @return This builder for chaining.
       */
      public Builder clearAttentionBottleneckDimension() {
        bitField0_ = (bitField0_ & ~0x00000002);
        attentionBottleneckDimension_ = 2048;
        onChanged();
        return this;
      }

      private float attentionTemperature_ = 0.01F;
      /**
       * <pre>
       * The attention temperature.
       * </pre>
       *
       * <code>optional float attention_temperature = 3 [default = 0.01];</code>
       * @return Whether the attentionTemperature field is set.
       */
      @java.lang.Override
      public boolean hasAttentionTemperature() {
        return ((bitField0_ & 0x00000004) != 0);
      }
      /**
       * <pre>
       * The attention temperature.
       * </pre>
       *
       * <code>optional float attention_temperature = 3 [default = 0.01];</code>
       * @return The attentionTemperature.
       */
      @java.lang.Override
      public float getAttentionTemperature() {
        return attentionTemperature_;
      }
      /**
       * <pre>
       * The attention temperature.
       * </pre>
       *
       * <code>optional float attention_temperature = 3 [default = 0.01];</code>
       * @param value The attentionTemperature to set.
       * @return This builder for chaining.
       */
      public Builder setAttentionTemperature(float value) {
        bitField0_ |= 0x00000004;
        attentionTemperature_ = value;
        onChanged();
        return this;
      }
      /**
       * <pre>
       * The attention temperature.
       * </pre>
       *
       * <code>optional float attention_temperature = 3 [default = 0.01];</code>
       * @return This builder for chaining.
       */
      public Builder clearAttentionTemperature() {
        bitField0_ = (bitField0_ & ~0x00000004);
        attentionTemperature_ = 0.01F;
        onChanged();
        return this;
      }

      private int contextFeatureLength_ = 2057;
      /**
       * <pre>
       * The context feature length.
       * </pre>
       *
       * <code>optional int32 context_feature_length = 4 [default = 2057];</code>
       * @return Whether the contextFeatureLength field is set.
       */
      @java.lang.Override
      public boolean hasContextFeatureLength() {
        return ((bitField0_ & 0x00000008) != 0);
      }
      /**
       * <pre>
       * The context feature length.
       * </pre>
       *
       * <code>optional int32 context_feature_length = 4 [default = 2057];</code>
       * @return The contextFeatureLength.
       */
      @java.lang.Override
      public int getContextFeatureLength() {
        return contextFeatureLength_;
      }
      /**
       * <pre>
       * The context feature length.
       * </pre>
       *
       * <code>optional int32 context_feature_length = 4 [default = 2057];</code>
       * @param value The contextFeatureLength to set.
       * @return This builder for chaining.
       */
      public Builder setContextFeatureLength(int value) {
        bitField0_ |= 0x00000008;
        contextFeatureLength_ = value;
        onChanged();
        return this;
      }
      /**
       * <pre>
       * The context feature length.
       * </pre>
       *
       * <code>optional int32 context_feature_length = 4 [default = 2057];</code>
       * @return This builder for chaining.
       */
      public Builder clearContextFeatureLength() {
        bitField0_ = (bitField0_ & ~0x00000008);
        contextFeatureLength_ = 2057;
        onChanged();
        return this;
      }

      private boolean useSelfAttention_ ;
      /**
       * <pre>
       * Whether to use self-attention from box proposals to themselves, TF1 only.
       * </pre>
       *
       * <code>optional bool use_self_attention = 6 [default = false];</code>
       * @return Whether the useSelfAttention field is set.
       */
      @java.lang.Override
      public boolean hasUseSelfAttention() {
        return ((bitField0_ & 0x00000010) != 0);
      }
      /**
       * <pre>
       * Whether to use self-attention from box proposals to themselves, TF1 only.
       * </pre>
       *
       * <code>optional bool use_self_attention = 6 [default = false];</code>
       * @return The useSelfAttention.
       */
      @java.lang.Override
      public boolean getUseSelfAttention() {
        return useSelfAttention_;
      }
      /**
       * <pre>
       * Whether to use self-attention from box proposals to themselves, TF1 only.
       * </pre>
       *
       * <code>optional bool use_self_attention = 6 [default = false];</code>
       * @param value The useSelfAttention to set.
       * @return This builder for chaining.
       */
      public Builder setUseSelfAttention(boolean value) {
        bitField0_ |= 0x00000010;
        useSelfAttention_ = value;
        onChanged();
        return this;
      }
      /**
       * <pre>
       * Whether to use self-attention from box proposals to themselves, TF1 only.
       * </pre>
       *
       * <code>optional bool use_self_attention = 6 [default = false];</code>
       * @return This builder for chaining.
       */
      public Builder clearUseSelfAttention() {
        bitField0_ = (bitField0_ & ~0x00000010);
        useSelfAttention_ = false;
        onChanged();
        return this;
      }

      private boolean useLongTermAttention_ = true;
      /**
       * <pre>
       * Whether to use attention into context features, setting to false is only
       * implemented in TF1.
       * </pre>
       *
       * <code>optional bool use_long_term_attention = 7 [default = true];</code>
       * @return Whether the useLongTermAttention field is set.
       */
      @java.lang.Override
      public boolean hasUseLongTermAttention() {
        return ((bitField0_ & 0x00000020) != 0);
      }
      /**
       * <pre>
       * Whether to use attention into context features, setting to false is only
       * implemented in TF1.
       * </pre>
       *
       * <code>optional bool use_long_term_attention = 7 [default = true];</code>
       * @return The useLongTermAttention.
       */
      @java.lang.Override
      public boolean getUseLongTermAttention() {
        return useLongTermAttention_;
      }
      /**
       * <pre>
       * Whether to use attention into context features, setting to false is only
       * implemented in TF1.
       * </pre>
       *
       * <code>optional bool use_long_term_attention = 7 [default = true];</code>
       * @param value The useLongTermAttention to set.
       * @return This builder for chaining.
       */
      public Builder setUseLongTermAttention(boolean value) {
        bitField0_ |= 0x00000020;
        useLongTermAttention_ = value;
        onChanged();
        return this;
      }
      /**
       * <pre>
       * Whether to use attention into context features, setting to false is only
       * implemented in TF1.
       * </pre>
       *
       * <code>optional bool use_long_term_attention = 7 [default = true];</code>
       * @return This builder for chaining.
       */
      public Builder clearUseLongTermAttention() {
        bitField0_ = (bitField0_ & ~0x00000020);
        useLongTermAttention_ = true;
        onChanged();
        return this;
      }

      private boolean selfAttentionInSequence_ ;
      /**
       * <pre>
       * Whether the self-attention block and the long term attention block should
       * be in sequence or parallel, ie whether the outputs of the self-attention
       * block should be the inputs into the long term attention block (sequence)
       * or whether the self attention block and long term attention block should
       * happen in parallel, with outputs summed.
       * </pre>
       *
       * <code>optional bool self_attention_in_sequence = 8 [default = false];</code>
       * @return Whether the selfAttentionInSequence field is set.
       */
      @java.lang.Override
      public boolean hasSelfAttentionInSequence() {
        return ((bitField0_ & 0x00000040) != 0);
      }
      /**
       * <pre>
       * Whether the self-attention block and the long term attention block should
       * be in sequence or parallel, ie whether the outputs of the self-attention
       * block should be the inputs into the long term attention block (sequence)
       * or whether the self attention block and long term attention block should
       * happen in parallel, with outputs summed.
       * </pre>
       *
       * <code>optional bool self_attention_in_sequence = 8 [default = false];</code>
       * @return The selfAttentionInSequence.
       */
      @java.lang.Override
      public boolean getSelfAttentionInSequence() {
        return selfAttentionInSequence_;
      }
      /**
       * <pre>
       * Whether the self-attention block and the long term attention block should
       * be in sequence or parallel, ie whether the outputs of the self-attention
       * block should be the inputs into the long term attention block (sequence)
       * or whether the self attention block and long term attention block should
       * happen in parallel, with outputs summed.
       * </pre>
       *
       * <code>optional bool self_attention_in_sequence = 8 [default = false];</code>
       * @param value The selfAttentionInSequence to set.
       * @return This builder for chaining.
       */
      public Builder setSelfAttentionInSequence(boolean value) {
        bitField0_ |= 0x00000040;
        selfAttentionInSequence_ = value;
        onChanged();
        return this;
      }
      /**
       * <pre>
       * Whether the self-attention block and the long term attention block should
       * be in sequence or parallel, ie whether the outputs of the self-attention
       * block should be the inputs into the long term attention block (sequence)
       * or whether the self attention block and long term attention block should
       * happen in parallel, with outputs summed.
       * </pre>
       *
       * <code>optional bool self_attention_in_sequence = 8 [default = false];</code>
       * @return This builder for chaining.
       */
      public Builder clearSelfAttentionInSequence() {
        bitField0_ = (bitField0_ & ~0x00000040);
        selfAttentionInSequence_ = false;
        onChanged();
        return this;
      }

      private int numAttentionHeads_ = 1;
      /**
       * <pre>
       * Number of attention heads
       * </pre>
       *
       * <code>optional int32 num_attention_heads = 9 [default = 1];</code>
       * @return Whether the numAttentionHeads field is set.
       */
      @java.lang.Override
      public boolean hasNumAttentionHeads() {
        return ((bitField0_ & 0x00000080) != 0);
      }
      /**
       * <pre>
       * Number of attention heads
       * </pre>
       *
       * <code>optional int32 num_attention_heads = 9 [default = 1];</code>
       * @return The numAttentionHeads.
       */
      @java.lang.Override
      public int getNumAttentionHeads() {
        return numAttentionHeads_;
      }
      /**
       * <pre>
       * Number of attention heads
       * </pre>
       *
       * <code>optional int32 num_attention_heads = 9 [default = 1];</code>
       * @param value The numAttentionHeads to set.
       * @return This builder for chaining.
       */
      public Builder setNumAttentionHeads(int value) {
        bitField0_ |= 0x00000080;
        numAttentionHeads_ = value;
        onChanged();
        return this;
      }
      /**
       * <pre>
       * Number of attention heads
       * </pre>
       *
       * <code>optional int32 num_attention_heads = 9 [default = 1];</code>
       * @return This builder for chaining.
       */
      public Builder clearNumAttentionHeads() {
        bitField0_ = (bitField0_ & ~0x00000080);
        numAttentionHeads_ = 1;
        onChanged();
        return this;
      }

      private int numAttentionLayers_ = 1;
      /**
       * <pre>
       * Number of attention layers
       * </pre>
       *
       * <code>optional int32 num_attention_layers = 11 [default = 1];</code>
       * @return Whether the numAttentionLayers field is set.
       */
      @java.lang.Override
      public boolean hasNumAttentionLayers() {
        return ((bitField0_ & 0x00000100) != 0);
      }
      /**
       * <pre>
       * Number of attention layers
       * </pre>
       *
       * <code>optional int32 num_attention_layers = 11 [default = 1];</code>
       * @return The numAttentionLayers.
       */
      @java.lang.Override
      public int getNumAttentionLayers() {
        return numAttentionLayers_;
      }
      /**
       * <pre>
       * Number of attention layers
       * </pre>
       *
       * <code>optional int32 num_attention_layers = 11 [default = 1];</code>
       * @param value The numAttentionLayers to set.
       * @return This builder for chaining.
       */
      public Builder setNumAttentionLayers(int value) {
        bitField0_ |= 0x00000100;
        numAttentionLayers_ = value;
        onChanged();
        return this;
      }
      /**
       * <pre>
       * Number of attention layers
       * </pre>
       *
       * <code>optional int32 num_attention_layers = 11 [default = 1];</code>
       * @return This builder for chaining.
       */
      public Builder clearNumAttentionLayers() {
        bitField0_ = (bitField0_ & ~0x00000100);
        numAttentionLayers_ = 1;
        onChanged();
        return this;
      }

      private int attentionPosition_ = 1;
      /**
       * <pre>
       * Where the attention goes, 0 is pre-second-stage, 1 is post-second-stage
       * </pre>
       *
       * <code>optional .object_detection.protos.AttentionPosition attention_position = 10 [default = POST_BOX_CLASSIFIER];</code>
       * @return Whether the attentionPosition field is set.
       */
      @java.lang.Override public boolean hasAttentionPosition() {
        return ((bitField0_ & 0x00000200) != 0);
      }
      /**
       * <pre>
       * Where the attention goes, 0 is pre-second-stage, 1 is post-second-stage
       * </pre>
       *
       * <code>optional .object_detection.protos.AttentionPosition attention_position = 10 [default = POST_BOX_CLASSIFIER];</code>
       * @return The attentionPosition.
       */
      @java.lang.Override
      public object_detection.protos.FasterRcnnOuterClass.AttentionPosition getAttentionPosition() {
        @SuppressWarnings("deprecation")
        object_detection.protos.FasterRcnnOuterClass.AttentionPosition result = object_detection.protos.FasterRcnnOuterClass.AttentionPosition.valueOf(attentionPosition_);
        return result == null ? object_detection.protos.FasterRcnnOuterClass.AttentionPosition.POST_BOX_CLASSIFIER : result;
      }
      /**
       * <pre>
       * Where the attention goes, 0 is pre-second-stage, 1 is post-second-stage
       * </pre>
       *
       * <code>optional .object_detection.protos.AttentionPosition attention_position = 10 [default = POST_BOX_CLASSIFIER];</code>
       * @param value The attentionPosition to set.
       * @return This builder for chaining.
       */
      public Builder setAttentionPosition(object_detection.protos.FasterRcnnOuterClass.AttentionPosition value) {
        if (value == null) {
          throw new NullPointerException();
        }
        bitField0_ |= 0x00000200;
        attentionPosition_ = value.getNumber();
        onChanged();
        return this;
      }
      /**
       * <pre>
       * Where the attention goes, 0 is pre-second-stage, 1 is post-second-stage
       * </pre>
       *
       * <code>optional .object_detection.protos.AttentionPosition attention_position = 10 [default = POST_BOX_CLASSIFIER];</code>
       * @return This builder for chaining.
       */
      public Builder clearAttentionPosition() {
        bitField0_ = (bitField0_ & ~0x00000200);
        attentionPosition_ = 1;
        onChanged();
        return this;
      }
      @java.lang.Override
      public final Builder setUnknownFields(
          final com.google.protobuf.UnknownFieldSet unknownFields) {
        return super.setUnknownFields(unknownFields);
      }

      @java.lang.Override
      public final Builder mergeUnknownFields(
          final com.google.protobuf.UnknownFieldSet unknownFields) {
        return super.mergeUnknownFields(unknownFields);
      }


      // @@protoc_insertion_point(builder_scope:object_detection.protos.Context)
    }

    // @@protoc_insertion_point(class_scope:object_detection.protos.Context)
    private static final object_detection.protos.FasterRcnnOuterClass.Context DEFAULT_INSTANCE;
    static {
      DEFAULT_INSTANCE = new object_detection.protos.FasterRcnnOuterClass.Context();
    }

    public static object_detection.protos.FasterRcnnOuterClass.Context getDefaultInstance() {
      return DEFAULT_INSTANCE;
    }

    @java.lang.Deprecated public static final com.google.protobuf.Parser<Context>
        PARSER = new com.google.protobuf.AbstractParser<Context>() {
      @java.lang.Override
      public Context parsePartialFrom(
          com.google.protobuf.CodedInputStream input,
          com.google.protobuf.ExtensionRegistryLite extensionRegistry)
          throws com.google.protobuf.InvalidProtocolBufferException {
        return new Context(input, extensionRegistry);
      }
    };

    public static com.google.protobuf.Parser<Context> parser() {
      return PARSER;
    }

    @java.lang.Override
    public com.google.protobuf.Parser<Context> getParserForType() {
      return PARSER;
    }

    @java.lang.Override
    public object_detection.protos.FasterRcnnOuterClass.Context getDefaultInstanceForType() {
      return DEFAULT_INSTANCE;
    }

  }

  public interface FasterRcnnFeatureExtractorOrBuilder extends
      // @@protoc_insertion_point(interface_extends:object_detection.protos.FasterRcnnFeatureExtractor)
      com.google.protobuf.MessageOrBuilder {

    /**
     * <pre>
     * Type of Faster R-CNN model (e.g., 'faster_rcnn_resnet101';
     * See builders/model_builder.py for expected types).
     * </pre>
     *
     * <code>optional string type = 1;</code>
     * @return Whether the type field is set.
     */
    boolean hasType();
    /**
     * <pre>
     * Type of Faster R-CNN model (e.g., 'faster_rcnn_resnet101';
     * See builders/model_builder.py for expected types).
     * </pre>
     *
     * <code>optional string type = 1;</code>
     * @return The type.
     */
    java.lang.String getType();
    /**
     * <pre>
     * Type of Faster R-CNN model (e.g., 'faster_rcnn_resnet101';
     * See builders/model_builder.py for expected types).
     * </pre>
     *
     * <code>optional string type = 1;</code>
     * @return The bytes for type.
     */
    com.google.protobuf.ByteString
        getTypeBytes();

    /**
     * <pre>
     * Output stride of extracted RPN feature map.
     * </pre>
     *
     * <code>optional int32 first_stage_features_stride = 2 [default = 16];</code>
     * @return Whether the firstStageFeaturesStride field is set.
     */
    boolean hasFirstStageFeaturesStride();
    /**
     * <pre>
     * Output stride of extracted RPN feature map.
     * </pre>
     *
     * <code>optional int32 first_stage_features_stride = 2 [default = 16];</code>
     * @return The firstStageFeaturesStride.
     */
    int getFirstStageFeaturesStride();

    /**
     * <pre>
     * Whether to update batch norm parameters during training or not.
     * When training with a relative large batch size (e.g. 8), it could be
     * desirable to enable batch norm update.
     * </pre>
     *
     * <code>optional bool batch_norm_trainable = 3 [default = false];</code>
     * @return Whether the batchNormTrainable field is set.
     */
    boolean hasBatchNormTrainable();
    /**
     * <pre>
     * Whether to update batch norm parameters during training or not.
     * When training with a relative large batch size (e.g. 8), it could be
     * desirable to enable batch norm update.
     * </pre>
     *
     * <code>optional bool batch_norm_trainable = 3 [default = false];</code>
     * @return The batchNormTrainable.
     */
    boolean getBatchNormTrainable();

    /**
     * <pre>
     * Hyperparameters that affect the layers of feature extractor added on top
     * of the base feature extractor.
     * </pre>
     *
     * <code>optional .object_detection.protos.Hyperparams conv_hyperparams = 4;</code>
     * @return Whether the convHyperparams field is set.
     */
    boolean hasConvHyperparams();
    /**
     * <pre>
     * Hyperparameters that affect the layers of feature extractor added on top
     * of the base feature extractor.
     * </pre>
     *
     * <code>optional .object_detection.protos.Hyperparams conv_hyperparams = 4;</code>
     * @return The convHyperparams.
     */
    object_detection.protos.HyperparamsOuterClass.Hyperparams getConvHyperparams();
    /**
     * <pre>
     * Hyperparameters that affect the layers of feature extractor added on top
     * of the base feature extractor.
     * </pre>
     *
     * <code>optional .object_detection.protos.Hyperparams conv_hyperparams = 4;</code>
     */
    object_detection.protos.HyperparamsOuterClass.HyperparamsOrBuilder getConvHyperparamsOrBuilder();

    /**
     * <pre>
     * if the value is set to true, the base feature extractor's hyperparams will
     * be overridden with the `conv_hyperparams`.
     * </pre>
     *
     * <code>optional bool override_base_feature_extractor_hyperparams = 5 [default = false];</code>
     * @return Whether the overrideBaseFeatureExtractorHyperparams field is set.
     */
    boolean hasOverrideBaseFeatureExtractorHyperparams();
    /**
     * <pre>
     * if the value is set to true, the base feature extractor's hyperparams will
     * be overridden with the `conv_hyperparams`.
     * </pre>
     *
     * <code>optional bool override_base_feature_extractor_hyperparams = 5 [default = false];</code>
     * @return The overrideBaseFeatureExtractorHyperparams.
     */
    boolean getOverrideBaseFeatureExtractorHyperparams();

    /**
     * <pre>
     * The nearest multiple to zero-pad the input height and width dimensions to.
     * For example, if pad_to_multiple = 2, input dimensions are zero-padded
     * until the resulting dimensions are even.
     * </pre>
     *
     * <code>optional int32 pad_to_multiple = 6 [default = 32];</code>
     * @return Whether the padToMultiple field is set.
     */
    boolean hasPadToMultiple();
    /**
     * <pre>
     * The nearest multiple to zero-pad the input height and width dimensions to.
     * For example, if pad_to_multiple = 2, input dimensions are zero-padded
     * until the resulting dimensions are even.
     * </pre>
     *
     * <code>optional int32 pad_to_multiple = 6 [default = 32];</code>
     * @return The padToMultiple.
     */
    int getPadToMultiple();

    /**
     * <pre>
     * Feature Pyramid Networks config.
     * </pre>
     *
     * <code>optional .object_detection.protos.FeaturePyramidNetworks fpn = 7;</code>
     * @return Whether the fpn field is set.
     */
    boolean hasFpn();
    /**
     * <pre>
     * Feature Pyramid Networks config.
     * </pre>
     *
     * <code>optional .object_detection.protos.FeaturePyramidNetworks fpn = 7;</code>
     * @return The fpn.
     */
    object_detection.protos.Fpn.FeaturePyramidNetworks getFpn();
    /**
     * <pre>
     * Feature Pyramid Networks config.
     * </pre>
     *
     * <code>optional .object_detection.protos.FeaturePyramidNetworks fpn = 7;</code>
     */
    object_detection.protos.Fpn.FeaturePyramidNetworksOrBuilder getFpnOrBuilder();
  }
  /**
   * Protobuf type {@code object_detection.protos.FasterRcnnFeatureExtractor}
   */
  public static final class FasterRcnnFeatureExtractor extends
      com.google.protobuf.GeneratedMessageV3 implements
      // @@protoc_insertion_point(message_implements:object_detection.protos.FasterRcnnFeatureExtractor)
      FasterRcnnFeatureExtractorOrBuilder {
  private static final long serialVersionUID = 0L;
    // Use FasterRcnnFeatureExtractor.newBuilder() to construct.
    private FasterRcnnFeatureExtractor(com.google.protobuf.GeneratedMessageV3.Builder<?> builder) {
      super(builder);
    }
    private FasterRcnnFeatureExtractor() {
      type_ = "";
      firstStageFeaturesStride_ = 16;
      padToMultiple_ = 32;
    }

    @java.lang.Override
    @SuppressWarnings({"unused"})
    protected java.lang.Object newInstance(
        UnusedPrivateParameter unused) {
      return new FasterRcnnFeatureExtractor();
    }

    @java.lang.Override
    public final com.google.protobuf.UnknownFieldSet
    getUnknownFields() {
      return this.unknownFields;
    }
    private FasterRcnnFeatureExtractor(
        com.google.protobuf.CodedInputStream input,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws com.google.protobuf.InvalidProtocolBufferException {
      this();
      if (extensionRegistry == null) {
        throw new java.lang.NullPointerException();
      }
      int mutable_bitField0_ = 0;
      com.google.protobuf.UnknownFieldSet.Builder unknownFields =
          com.google.protobuf.UnknownFieldSet.newBuilder();
      try {
        boolean done = false;
        while (!done) {
          int tag = input.readTag();
          switch (tag) {
            case 0:
              done = true;
              break;
            case 10: {
              com.google.protobuf.ByteString bs = input.readBytes();
              bitField0_ |= 0x00000001;
              type_ = bs;
              break;
            }
            case 16: {
              bitField0_ |= 0x00000002;
              firstStageFeaturesStride_ = input.readInt32();
              break;
            }
            case 24: {
              bitField0_ |= 0x00000004;
              batchNormTrainable_ = input.readBool();
              break;
            }
            case 34: {
              object_detection.protos.HyperparamsOuterClass.Hyperparams.Builder subBuilder = null;
              if (((bitField0_ & 0x00000008) != 0)) {
                subBuilder = convHyperparams_.toBuilder();
              }
              convHyperparams_ = input.readMessage(object_detection.protos.HyperparamsOuterClass.Hyperparams.PARSER, extensionRegistry);
              if (subBuilder != null) {
                subBuilder.mergeFrom(convHyperparams_);
                convHyperparams_ = subBuilder.buildPartial();
              }
              bitField0_ |= 0x00000008;
              break;
            }
            case 40: {
              bitField0_ |= 0x00000010;
              overrideBaseFeatureExtractorHyperparams_ = input.readBool();
              break;
            }
            case 48: {
              bitField0_ |= 0x00000020;
              padToMultiple_ = input.readInt32();
              break;
            }
            case 58: {
              object_detection.protos.Fpn.FeaturePyramidNetworks.Builder subBuilder = null;
              if (((bitField0_ & 0x00000040) != 0)) {
                subBuilder = fpn_.toBuilder();
              }
              fpn_ = input.readMessage(object_detection.protos.Fpn.FeaturePyramidNetworks.PARSER, extensionRegistry);
              if (subBuilder != null) {
                subBuilder.mergeFrom(fpn_);
                fpn_ = subBuilder.buildPartial();
              }
              bitField0_ |= 0x00000040;
              break;
            }
            default: {
              if (!parseUnknownField(
                  input, unknownFields, extensionRegistry, tag)) {
                done = true;
              }
              break;
            }
          }
        }
      } catch (com.google.protobuf.InvalidProtocolBufferException e) {
        throw e.setUnfinishedMessage(this);
      } catch (java.io.IOException e) {
        throw new com.google.protobuf.InvalidProtocolBufferException(
            e).setUnfinishedMessage(this);
      } finally {
        this.unknownFields = unknownFields.build();
        makeExtensionsImmutable();
      }
    }
    public static final com.google.protobuf.Descriptors.Descriptor
        getDescriptor() {
      return object_detection.protos.FasterRcnnOuterClass.internal_static_object_detection_protos_FasterRcnnFeatureExtractor_descriptor;
    }

    @java.lang.Override
    protected com.google.protobuf.GeneratedMessageV3.FieldAccessorTable
        internalGetFieldAccessorTable() {
      return object_detection.protos.FasterRcnnOuterClass.internal_static_object_detection_protos_FasterRcnnFeatureExtractor_fieldAccessorTable
          .ensureFieldAccessorsInitialized(
              object_detection.protos.FasterRcnnOuterClass.FasterRcnnFeatureExtractor.class, object_detection.protos.FasterRcnnOuterClass.FasterRcnnFeatureExtractor.Builder.class);
    }

    private int bitField0_;
    public static final int TYPE_FIELD_NUMBER = 1;
    private volatile java.lang.Object type_;
    /**
     * <pre>
     * Type of Faster R-CNN model (e.g., 'faster_rcnn_resnet101';
     * See builders/model_builder.py for expected types).
     * </pre>
     *
     * <code>optional string type = 1;</code>
     * @return Whether the type field is set.
     */
    @java.lang.Override
    public boolean hasType() {
      return ((bitField0_ & 0x00000001) != 0);
    }
    /**
     * <pre>
     * Type of Faster R-CNN model (e.g., 'faster_rcnn_resnet101';
     * See builders/model_builder.py for expected types).
     * </pre>
     *
     * <code>optional string type = 1;</code>
     * @return The type.
     */
    @java.lang.Override
    public java.lang.String getType() {
      java.lang.Object ref = type_;
      if (ref instanceof java.lang.String) {
        return (java.lang.String) ref;
      } else {
        com.google.protobuf.ByteString bs =
            (com.google.protobuf.ByteString) ref;
        java.lang.String s = bs.toStringUtf8();
        if (bs.isValidUtf8()) {
          type_ = s;
        }
        return s;
      }
    }
    /**
     * <pre>
     * Type of Faster R-CNN model (e.g., 'faster_rcnn_resnet101';
     * See builders/model_builder.py for expected types).
     * </pre>
     *
     * <code>optional string type = 1;</code>
     * @return The bytes for type.
     */
    @java.lang.Override
    public com.google.protobuf.ByteString
        getTypeBytes() {
      java.lang.Object ref = type_;
      if (ref instanceof java.lang.String) {
        com.google.protobuf.ByteString b =
            com.google.protobuf.ByteString.copyFromUtf8(
                (java.lang.String) ref);
        type_ = b;
        return b;
      } else {
        return (com.google.protobuf.ByteString) ref;
      }
    }

    public static final int FIRST_STAGE_FEATURES_STRIDE_FIELD_NUMBER = 2;
    private int firstStageFeaturesStride_;
    /**
     * <pre>
     * Output stride of extracted RPN feature map.
     * </pre>
     *
     * <code>optional int32 first_stage_features_stride = 2 [default = 16];</code>
     * @return Whether the firstStageFeaturesStride field is set.
     */
    @java.lang.Override
    public boolean hasFirstStageFeaturesStride() {
      return ((bitField0_ & 0x00000002) != 0);
    }
    /**
     * <pre>
     * Output stride of extracted RPN feature map.
     * </pre>
     *
     * <code>optional int32 first_stage_features_stride = 2 [default = 16];</code>
     * @return The firstStageFeaturesStride.
     */
    @java.lang.Override
    public int getFirstStageFeaturesStride() {
      return firstStageFeaturesStride_;
    }

    public static final int BATCH_NORM_TRAINABLE_FIELD_NUMBER = 3;
    private boolean batchNormTrainable_;
    /**
     * <pre>
     * Whether to update batch norm parameters during training or not.
     * When training with a relative large batch size (e.g. 8), it could be
     * desirable to enable batch norm update.
     * </pre>
     *
     * <code>optional bool batch_norm_trainable = 3 [default = false];</code>
     * @return Whether the batchNormTrainable field is set.
     */
    @java.lang.Override
    public boolean hasBatchNormTrainable() {
      return ((bitField0_ & 0x00000004) != 0);
    }
    /**
     * <pre>
     * Whether to update batch norm parameters during training or not.
     * When training with a relative large batch size (e.g. 8), it could be
     * desirable to enable batch norm update.
     * </pre>
     *
     * <code>optional bool batch_norm_trainable = 3 [default = false];</code>
     * @return The batchNormTrainable.
     */
    @java.lang.Override
    public boolean getBatchNormTrainable() {
      return batchNormTrainable_;
    }

    public static final int CONV_HYPERPARAMS_FIELD_NUMBER = 4;
    private object_detection.protos.HyperparamsOuterClass.Hyperparams convHyperparams_;
    /**
     * <pre>
     * Hyperparameters that affect the layers of feature extractor added on top
     * of the base feature extractor.
     * </pre>
     *
     * <code>optional .object_detection.protos.Hyperparams conv_hyperparams = 4;</code>
     * @return Whether the convHyperparams field is set.
     */
    @java.lang.Override
    public boolean hasConvHyperparams() {
      return ((bitField0_ & 0x00000008) != 0);
    }
    /**
     * <pre>
     * Hyperparameters that affect the layers of feature extractor added on top
     * of the base feature extractor.
     * </pre>
     *
     * <code>optional .object_detection.protos.Hyperparams conv_hyperparams = 4;</code>
     * @return The convHyperparams.
     */
    @java.lang.Override
    public object_detection.protos.HyperparamsOuterClass.Hyperparams getConvHyperparams() {
      return convHyperparams_ == null ? object_detection.protos.HyperparamsOuterClass.Hyperparams.getDefaultInstance() : convHyperparams_;
    }
    /**
     * <pre>
     * Hyperparameters that affect the layers of feature extractor added on top
     * of the base feature extractor.
     * </pre>
     *
     * <code>optional .object_detection.protos.Hyperparams conv_hyperparams = 4;</code>
     */
    @java.lang.Override
    public object_detection.protos.HyperparamsOuterClass.HyperparamsOrBuilder getConvHyperparamsOrBuilder() {
      return convHyperparams_ == null ? object_detection.protos.HyperparamsOuterClass.Hyperparams.getDefaultInstance() : convHyperparams_;
    }

    public static final int OVERRIDE_BASE_FEATURE_EXTRACTOR_HYPERPARAMS_FIELD_NUMBER = 5;
    private boolean overrideBaseFeatureExtractorHyperparams_;
    /**
     * <pre>
     * if the value is set to true, the base feature extractor's hyperparams will
     * be overridden with the `conv_hyperparams`.
     * </pre>
     *
     * <code>optional bool override_base_feature_extractor_hyperparams = 5 [default = false];</code>
     * @return Whether the overrideBaseFeatureExtractorHyperparams field is set.
     */
    @java.lang.Override
    public boolean hasOverrideBaseFeatureExtractorHyperparams() {
      return ((bitField0_ & 0x00000010) != 0);
    }
    /**
     * <pre>
     * if the value is set to true, the base feature extractor's hyperparams will
     * be overridden with the `conv_hyperparams`.
     * </pre>
     *
     * <code>optional bool override_base_feature_extractor_hyperparams = 5 [default = false];</code>
     * @return The overrideBaseFeatureExtractorHyperparams.
     */
    @java.lang.Override
    public boolean getOverrideBaseFeatureExtractorHyperparams() {
      return overrideBaseFeatureExtractorHyperparams_;
    }

    public static final int PAD_TO_MULTIPLE_FIELD_NUMBER = 6;
    private int padToMultiple_;
    /**
     * <pre>
     * The nearest multiple to zero-pad the input height and width dimensions to.
     * For example, if pad_to_multiple = 2, input dimensions are zero-padded
     * until the resulting dimensions are even.
     * </pre>
     *
     * <code>optional int32 pad_to_multiple = 6 [default = 32];</code>
     * @return Whether the padToMultiple field is set.
     */
    @java.lang.Override
    public boolean hasPadToMultiple() {
      return ((bitField0_ & 0x00000020) != 0);
    }
    /**
     * <pre>
     * The nearest multiple to zero-pad the input height and width dimensions to.
     * For example, if pad_to_multiple = 2, input dimensions are zero-padded
     * until the resulting dimensions are even.
     * </pre>
     *
     * <code>optional int32 pad_to_multiple = 6 [default = 32];</code>
     * @return The padToMultiple.
     */
    @java.lang.Override
    public int getPadToMultiple() {
      return padToMultiple_;
    }

    public static final int FPN_FIELD_NUMBER = 7;
    private object_detection.protos.Fpn.FeaturePyramidNetworks fpn_;
    /**
     * <pre>
     * Feature Pyramid Networks config.
     * </pre>
     *
     * <code>optional .object_detection.protos.FeaturePyramidNetworks fpn = 7;</code>
     * @return Whether the fpn field is set.
     */
    @java.lang.Override
    public boolean hasFpn() {
      return ((bitField0_ & 0x00000040) != 0);
    }
    /**
     * <pre>
     * Feature Pyramid Networks config.
     * </pre>
     *
     * <code>optional .object_detection.protos.FeaturePyramidNetworks fpn = 7;</code>
     * @return The fpn.
     */
    @java.lang.Override
    public object_detection.protos.Fpn.FeaturePyramidNetworks getFpn() {
      return fpn_ == null ? object_detection.protos.Fpn.FeaturePyramidNetworks.getDefaultInstance() : fpn_;
    }
    /**
     * <pre>
     * Feature Pyramid Networks config.
     * </pre>
     *
     * <code>optional .object_detection.protos.FeaturePyramidNetworks fpn = 7;</code>
     */
    @java.lang.Override
    public object_detection.protos.Fpn.FeaturePyramidNetworksOrBuilder getFpnOrBuilder() {
      return fpn_ == null ? object_detection.protos.Fpn.FeaturePyramidNetworks.getDefaultInstance() : fpn_;
    }

    private byte memoizedIsInitialized = -1;
    @java.lang.Override
    public final boolean isInitialized() {
      byte isInitialized = memoizedIsInitialized;
      if (isInitialized == 1) return true;
      if (isInitialized == 0) return false;

      memoizedIsInitialized = 1;
      return true;
    }

    @java.lang.Override
    public void writeTo(com.google.protobuf.CodedOutputStream output)
                        throws java.io.IOException {
      if (((bitField0_ & 0x00000001) != 0)) {
        com.google.protobuf.GeneratedMessageV3.writeString(output, 1, type_);
      }
      if (((bitField0_ & 0x00000002) != 0)) {
        output.writeInt32(2, firstStageFeaturesStride_);
      }
      if (((bitField0_ & 0x00000004) != 0)) {
        output.writeBool(3, batchNormTrainable_);
      }
      if (((bitField0_ & 0x00000008) != 0)) {
        output.writeMessage(4, getConvHyperparams());
      }
      if (((bitField0_ & 0x00000010) != 0)) {
        output.writeBool(5, overrideBaseFeatureExtractorHyperparams_);
      }
      if (((bitField0_ & 0x00000020) != 0)) {
        output.writeInt32(6, padToMultiple_);
      }
      if (((bitField0_ & 0x00000040) != 0)) {
        output.writeMessage(7, getFpn());
      }
      unknownFields.writeTo(output);
    }

    @java.lang.Override
    public int getSerializedSize() {
      int size = memoizedSize;
      if (size != -1) return size;

      size = 0;
      if (((bitField0_ & 0x00000001) != 0)) {
        size += com.google.protobuf.GeneratedMessageV3.computeStringSize(1, type_);
      }
      if (((bitField0_ & 0x00000002) != 0)) {
        size += com.google.protobuf.CodedOutputStream
          .computeInt32Size(2, firstStageFeaturesStride_);
      }
      if (((bitField0_ & 0x00000004) != 0)) {
        size += com.google.protobuf.CodedOutputStream
          .computeBoolSize(3, batchNormTrainable_);
      }
      if (((bitField0_ & 0x00000008) != 0)) {
        size += com.google.protobuf.CodedOutputStream
          .computeMessageSize(4, getConvHyperparams());
      }
      if (((bitField0_ & 0x00000010) != 0)) {
        size += com.google.protobuf.CodedOutputStream
          .computeBoolSize(5, overrideBaseFeatureExtractorHyperparams_);
      }
      if (((bitField0_ & 0x00000020) != 0)) {
        size += com.google.protobuf.CodedOutputStream
          .computeInt32Size(6, padToMultiple_);
      }
      if (((bitField0_ & 0x00000040) != 0)) {
        size += com.google.protobuf.CodedOutputStream
          .computeMessageSize(7, getFpn());
      }
      size += unknownFields.getSerializedSize();
      memoizedSize = size;
      return size;
    }

    @java.lang.Override
    public boolean equals(final java.lang.Object obj) {
      if (obj == this) {
       return true;
      }
      if (!(obj instanceof object_detection.protos.FasterRcnnOuterClass.FasterRcnnFeatureExtractor)) {
        return super.equals(obj);
      }
      object_detection.protos.FasterRcnnOuterClass.FasterRcnnFeatureExtractor other = (object_detection.protos.FasterRcnnOuterClass.FasterRcnnFeatureExtractor) obj;

      if (hasType() != other.hasType()) return false;
      if (hasType()) {
        if (!getType()
            .equals(other.getType())) return false;
      }
      if (hasFirstStageFeaturesStride() != other.hasFirstStageFeaturesStride()) return false;
      if (hasFirstStageFeaturesStride()) {
        if (getFirstStageFeaturesStride()
            != other.getFirstStageFeaturesStride()) return false;
      }
      if (hasBatchNormTrainable() != other.hasBatchNormTrainable()) return false;
      if (hasBatchNormTrainable()) {
        if (getBatchNormTrainable()
            != other.getBatchNormTrainable()) return false;
      }
      if (hasConvHyperparams() != other.hasConvHyperparams()) return false;
      if (hasConvHyperparams()) {
        if (!getConvHyperparams()
            .equals(other.getConvHyperparams())) return false;
      }
      if (hasOverrideBaseFeatureExtractorHyperparams() != other.hasOverrideBaseFeatureExtractorHyperparams()) return false;
      if (hasOverrideBaseFeatureExtractorHyperparams()) {
        if (getOverrideBaseFeatureExtractorHyperparams()
            != other.getOverrideBaseFeatureExtractorHyperparams()) return false;
      }
      if (hasPadToMultiple() != other.hasPadToMultiple()) return false;
      if (hasPadToMultiple()) {
        if (getPadToMultiple()
            != other.getPadToMultiple()) return false;
      }
      if (hasFpn() != other.hasFpn()) return false;
      if (hasFpn()) {
        if (!getFpn()
            .equals(other.getFpn())) return false;
      }
      if (!unknownFields.equals(other.unknownFields)) return false;
      return true;
    }

    @java.lang.Override
    public int hashCode() {
      if (memoizedHashCode != 0) {
        return memoizedHashCode;
      }
      int hash = 41;
      hash = (19 * hash) + getDescriptor().hashCode();
      if (hasType()) {
        hash = (37 * hash) + TYPE_FIELD_NUMBER;
        hash = (53 * hash) + getType().hashCode();
      }
      if (hasFirstStageFeaturesStride()) {
        hash = (37 * hash) + FIRST_STAGE_FEATURES_STRIDE_FIELD_NUMBER;
        hash = (53 * hash) + getFirstStageFeaturesStride();
      }
      if (hasBatchNormTrainable()) {
        hash = (37 * hash) + BATCH_NORM_TRAINABLE_FIELD_NUMBER;
        hash = (53 * hash) + com.google.protobuf.Internal.hashBoolean(
            getBatchNormTrainable());
      }
      if (hasConvHyperparams()) {
        hash = (37 * hash) + CONV_HYPERPARAMS_FIELD_NUMBER;
        hash = (53 * hash) + getConvHyperparams().hashCode();
      }
      if (hasOverrideBaseFeatureExtractorHyperparams()) {
        hash = (37 * hash) + OVERRIDE_BASE_FEATURE_EXTRACTOR_HYPERPARAMS_FIELD_NUMBER;
        hash = (53 * hash) + com.google.protobuf.Internal.hashBoolean(
            getOverrideBaseFeatureExtractorHyperparams());
      }
      if (hasPadToMultiple()) {
        hash = (37 * hash) + PAD_TO_MULTIPLE_FIELD_NUMBER;
        hash = (53 * hash) + getPadToMultiple();
      }
      if (hasFpn()) {
        hash = (37 * hash) + FPN_FIELD_NUMBER;
        hash = (53 * hash) + getFpn().hashCode();
      }
      hash = (29 * hash) + unknownFields.hashCode();
      memoizedHashCode = hash;
      return hash;
    }

    public static object_detection.protos.FasterRcnnOuterClass.FasterRcnnFeatureExtractor parseFrom(
        java.nio.ByteBuffer data)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return PARSER.parseFrom(data);
    }
    public static object_detection.protos.FasterRcnnOuterClass.FasterRcnnFeatureExtractor parseFrom(
        java.nio.ByteBuffer data,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return PARSER.parseFrom(data, extensionRegistry);
    }
    public static object_detection.protos.FasterRcnnOuterClass.FasterRcnnFeatureExtractor parseFrom(
        com.google.protobuf.ByteString data)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return PARSER.parseFrom(data);
    }
    public static object_detection.protos.FasterRcnnOuterClass.FasterRcnnFeatureExtractor parseFrom(
        com.google.protobuf.ByteString data,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return PARSER.parseFrom(data, extensionRegistry);
    }
    public static object_detection.protos.FasterRcnnOuterClass.FasterRcnnFeatureExtractor parseFrom(byte[] data)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return PARSER.parseFrom(data);
    }
    public static object_detection.protos.FasterRcnnOuterClass.FasterRcnnFeatureExtractor parseFrom(
        byte[] data,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return PARSER.parseFrom(data, extensionRegistry);
    }
    public static object_detection.protos.FasterRcnnOuterClass.FasterRcnnFeatureExtractor parseFrom(java.io.InputStream input)
        throws java.io.IOException {
      return com.google.protobuf.GeneratedMessageV3
          .parseWithIOException(PARSER, input);
    }
    public static object_detection.protos.FasterRcnnOuterClass.FasterRcnnFeatureExtractor parseFrom(
        java.io.InputStream input,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws java.io.IOException {
      return com.google.protobuf.GeneratedMessageV3
          .parseWithIOException(PARSER, input, extensionRegistry);
    }
    public static object_detection.protos.FasterRcnnOuterClass.FasterRcnnFeatureExtractor parseDelimitedFrom(java.io.InputStream input)
        throws java.io.IOException {
      return com.google.protobuf.GeneratedMessageV3
          .parseDelimitedWithIOException(PARSER, input);
    }
    public static object_detection.protos.FasterRcnnOuterClass.FasterRcnnFeatureExtractor parseDelimitedFrom(
        java.io.InputStream input,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws java.io.IOException {
      return com.google.protobuf.GeneratedMessageV3
          .parseDelimitedWithIOException(PARSER, input, extensionRegistry);
    }
    public static object_detection.protos.FasterRcnnOuterClass.FasterRcnnFeatureExtractor parseFrom(
        com.google.protobuf.CodedInputStream input)
        throws java.io.IOException {
      return com.google.protobuf.GeneratedMessageV3
          .parseWithIOException(PARSER, input);
    }
    public static object_detection.protos.FasterRcnnOuterClass.FasterRcnnFeatureExtractor parseFrom(
        com.google.protobuf.CodedInputStream input,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws java.io.IOException {
      return com.google.protobuf.GeneratedMessageV3
          .parseWithIOException(PARSER, input, extensionRegistry);
    }

    @java.lang.Override
    public Builder newBuilderForType() { return newBuilder(); }
    public static Builder newBuilder() {
      return DEFAULT_INSTANCE.toBuilder();
    }
    public static Builder newBuilder(object_detection.protos.FasterRcnnOuterClass.FasterRcnnFeatureExtractor prototype) {
      return DEFAULT_INSTANCE.toBuilder().mergeFrom(prototype);
    }
    @java.lang.Override
    public Builder toBuilder() {
      return this == DEFAULT_INSTANCE
          ? new Builder() : new Builder().mergeFrom(this);
    }

    @java.lang.Override
    protected Builder newBuilderForType(
        com.google.protobuf.GeneratedMessageV3.BuilderParent parent) {
      Builder builder = new Builder(parent);
      return builder;
    }
    /**
     * Protobuf type {@code object_detection.protos.FasterRcnnFeatureExtractor}
     */
    public static final class Builder extends
        com.google.protobuf.GeneratedMessageV3.Builder<Builder> implements
        // @@protoc_insertion_point(builder_implements:object_detection.protos.FasterRcnnFeatureExtractor)
        object_detection.protos.FasterRcnnOuterClass.FasterRcnnFeatureExtractorOrBuilder {
      public static final com.google.protobuf.Descriptors.Descriptor
          getDescriptor() {
        return object_detection.protos.FasterRcnnOuterClass.internal_static_object_detection_protos_FasterRcnnFeatureExtractor_descriptor;
      }

      @java.lang.Override
      protected com.google.protobuf.GeneratedMessageV3.FieldAccessorTable
          internalGetFieldAccessorTable() {
        return object_detection.protos.FasterRcnnOuterClass.internal_static_object_detection_protos_FasterRcnnFeatureExtractor_fieldAccessorTable
            .ensureFieldAccessorsInitialized(
                object_detection.protos.FasterRcnnOuterClass.FasterRcnnFeatureExtractor.class, object_detection.protos.FasterRcnnOuterClass.FasterRcnnFeatureExtractor.Builder.class);
      }

      // Construct using object_detection.protos.FasterRcnnOuterClass.FasterRcnnFeatureExtractor.newBuilder()
      private Builder() {
        maybeForceBuilderInitialization();
      }

      private Builder(
          com.google.protobuf.GeneratedMessageV3.BuilderParent parent) {
        super(parent);
        maybeForceBuilderInitialization();
      }
      private void maybeForceBuilderInitialization() {
        if (com.google.protobuf.GeneratedMessageV3
                .alwaysUseFieldBuilders) {
          getConvHyperparamsFieldBuilder();
          getFpnFieldBuilder();
        }
      }
      @java.lang.Override
      public Builder clear() {
        super.clear();
        type_ = "";
        bitField0_ = (bitField0_ & ~0x00000001);
        firstStageFeaturesStride_ = 16;
        bitField0_ = (bitField0_ & ~0x00000002);
        batchNormTrainable_ = false;
        bitField0_ = (bitField0_ & ~0x00000004);
        if (convHyperparamsBuilder_ == null) {
          convHyperparams_ = null;
        } else {
          convHyperparamsBuilder_.clear();
        }
        bitField0_ = (bitField0_ & ~0x00000008);
        overrideBaseFeatureExtractorHyperparams_ = false;
        bitField0_ = (bitField0_ & ~0x00000010);
        padToMultiple_ = 32;
        bitField0_ = (bitField0_ & ~0x00000020);
        if (fpnBuilder_ == null) {
          fpn_ = null;
        } else {
          fpnBuilder_.clear();
        }
        bitField0_ = (bitField0_ & ~0x00000040);
        return this;
      }

      @java.lang.Override
      public com.google.protobuf.Descriptors.Descriptor
          getDescriptorForType() {
        return object_detection.protos.FasterRcnnOuterClass.internal_static_object_detection_protos_FasterRcnnFeatureExtractor_descriptor;
      }

      @java.lang.Override
      public object_detection.protos.FasterRcnnOuterClass.FasterRcnnFeatureExtractor getDefaultInstanceForType() {
        return object_detection.protos.FasterRcnnOuterClass.FasterRcnnFeatureExtractor.getDefaultInstance();
      }

      @java.lang.Override
      public object_detection.protos.FasterRcnnOuterClass.FasterRcnnFeatureExtractor build() {
        object_detection.protos.FasterRcnnOuterClass.FasterRcnnFeatureExtractor result = buildPartial();
        if (!result.isInitialized()) {
          throw newUninitializedMessageException(result);
        }
        return result;
      }

      @java.lang.Override
      public object_detection.protos.FasterRcnnOuterClass.FasterRcnnFeatureExtractor buildPartial() {
        object_detection.protos.FasterRcnnOuterClass.FasterRcnnFeatureExtractor result = new object_detection.protos.FasterRcnnOuterClass.FasterRcnnFeatureExtractor(this);
        int from_bitField0_ = bitField0_;
        int to_bitField0_ = 0;
        if (((from_bitField0_ & 0x00000001) != 0)) {
          to_bitField0_ |= 0x00000001;
        }
        result.type_ = type_;
        if (((from_bitField0_ & 0x00000002) != 0)) {
          to_bitField0_ |= 0x00000002;
        }
        result.firstStageFeaturesStride_ = firstStageFeaturesStride_;
        if (((from_bitField0_ & 0x00000004) != 0)) {
          result.batchNormTrainable_ = batchNormTrainable_;
          to_bitField0_ |= 0x00000004;
        }
        if (((from_bitField0_ & 0x00000008) != 0)) {
          if (convHyperparamsBuilder_ == null) {
            result.convHyperparams_ = convHyperparams_;
          } else {
            result.convHyperparams_ = convHyperparamsBuilder_.build();
          }
          to_bitField0_ |= 0x00000008;
        }
        if (((from_bitField0_ & 0x00000010) != 0)) {
          result.overrideBaseFeatureExtractorHyperparams_ = overrideBaseFeatureExtractorHyperparams_;
          to_bitField0_ |= 0x00000010;
        }
        if (((from_bitField0_ & 0x00000020) != 0)) {
          to_bitField0_ |= 0x00000020;
        }
        result.padToMultiple_ = padToMultiple_;
        if (((from_bitField0_ & 0x00000040) != 0)) {
          if (fpnBuilder_ == null) {
            result.fpn_ = fpn_;
          } else {
            result.fpn_ = fpnBuilder_.build();
          }
          to_bitField0_ |= 0x00000040;
        }
        result.bitField0_ = to_bitField0_;
        onBuilt();
        return result;
      }

      @java.lang.Override
      public Builder clone() {
        return super.clone();
      }
      @java.lang.Override
      public Builder setField(
          com.google.protobuf.Descriptors.FieldDescriptor field,
          java.lang.Object value) {
        return super.setField(field, value);
      }
      @java.lang.Override
      public Builder clearField(
          com.google.protobuf.Descriptors.FieldDescriptor field) {
        return super.clearField(field);
      }
      @java.lang.Override
      public Builder clearOneof(
          com.google.protobuf.Descriptors.OneofDescriptor oneof) {
        return super.clearOneof(oneof);
      }
      @java.lang.Override
      public Builder setRepeatedField(
          com.google.protobuf.Descriptors.FieldDescriptor field,
          int index, java.lang.Object value) {
        return super.setRepeatedField(field, index, value);
      }
      @java.lang.Override
      public Builder addRepeatedField(
          com.google.protobuf.Descriptors.FieldDescriptor field,
          java.lang.Object value) {
        return super.addRepeatedField(field, value);
      }
      @java.lang.Override
      public Builder mergeFrom(com.google.protobuf.Message other) {
        if (other instanceof object_detection.protos.FasterRcnnOuterClass.FasterRcnnFeatureExtractor) {
          return mergeFrom((object_detection.protos.FasterRcnnOuterClass.FasterRcnnFeatureExtractor)other);
        } else {
          super.mergeFrom(other);
          return this;
        }
      }

      public Builder mergeFrom(object_detection.protos.FasterRcnnOuterClass.FasterRcnnFeatureExtractor other) {
        if (other == object_detection.protos.FasterRcnnOuterClass.FasterRcnnFeatureExtractor.getDefaultInstance()) return this;
        if (other.hasType()) {
          bitField0_ |= 0x00000001;
          type_ = other.type_;
          onChanged();
        }
        if (other.hasFirstStageFeaturesStride()) {
          setFirstStageFeaturesStride(other.getFirstStageFeaturesStride());
        }
        if (other.hasBatchNormTrainable()) {
          setBatchNormTrainable(other.getBatchNormTrainable());
        }
        if (other.hasConvHyperparams()) {
          mergeConvHyperparams(other.getConvHyperparams());
        }
        if (other.hasOverrideBaseFeatureExtractorHyperparams()) {
          setOverrideBaseFeatureExtractorHyperparams(other.getOverrideBaseFeatureExtractorHyperparams());
        }
        if (other.hasPadToMultiple()) {
          setPadToMultiple(other.getPadToMultiple());
        }
        if (other.hasFpn()) {
          mergeFpn(other.getFpn());
        }
        this.mergeUnknownFields(other.unknownFields);
        onChanged();
        return this;
      }

      @java.lang.Override
      public final boolean isInitialized() {
        return true;
      }

      @java.lang.Override
      public Builder mergeFrom(
          com.google.protobuf.CodedInputStream input,
          com.google.protobuf.ExtensionRegistryLite extensionRegistry)
          throws java.io.IOException {
        object_detection.protos.FasterRcnnOuterClass.FasterRcnnFeatureExtractor parsedMessage = null;
        try {
          parsedMessage = PARSER.parsePartialFrom(input, extensionRegistry);
        } catch (com.google.protobuf.InvalidProtocolBufferException e) {
          parsedMessage = (object_detection.protos.FasterRcnnOuterClass.FasterRcnnFeatureExtractor) e.getUnfinishedMessage();
          throw e.unwrapIOException();
        } finally {
          if (parsedMessage != null) {
            mergeFrom(parsedMessage);
          }
        }
        return this;
      }
      private int bitField0_;

      private java.lang.Object type_ = "";
      /**
       * <pre>
       * Type of Faster R-CNN model (e.g., 'faster_rcnn_resnet101';
       * See builders/model_builder.py for expected types).
       * </pre>
       *
       * <code>optional string type = 1;</code>
       * @return Whether the type field is set.
       */
      public boolean hasType() {
        return ((bitField0_ & 0x00000001) != 0);
      }
      /**
       * <pre>
       * Type of Faster R-CNN model (e.g., 'faster_rcnn_resnet101';
       * See builders/model_builder.py for expected types).
       * </pre>
       *
       * <code>optional string type = 1;</code>
       * @return The type.
       */
      public java.lang.String getType() {
        java.lang.Object ref = type_;
        if (!(ref instanceof java.lang.String)) {
          com.google.protobuf.ByteString bs =
              (com.google.protobuf.ByteString) ref;
          java.lang.String s = bs.toStringUtf8();
          if (bs.isValidUtf8()) {
            type_ = s;
          }
          return s;
        } else {
          return (java.lang.String) ref;
        }
      }
      /**
       * <pre>
       * Type of Faster R-CNN model (e.g., 'faster_rcnn_resnet101';
       * See builders/model_builder.py for expected types).
       * </pre>
       *
       * <code>optional string type = 1;</code>
       * @return The bytes for type.
       */
      public com.google.protobuf.ByteString
          getTypeBytes() {
        java.lang.Object ref = type_;
        if (ref instanceof String) {
          com.google.protobuf.ByteString b =
              com.google.protobuf.ByteString.copyFromUtf8(
                  (java.lang.String) ref);
          type_ = b;
          return b;
        } else {
          return (com.google.protobuf.ByteString) ref;
        }
      }
      /**
       * <pre>
       * Type of Faster R-CNN model (e.g., 'faster_rcnn_resnet101';
       * See builders/model_builder.py for expected types).
       * </pre>
       *
       * <code>optional string type = 1;</code>
       * @param value The type to set.
       * @return This builder for chaining.
       */
      public Builder setType(
          java.lang.String value) {
        if (value == null) {
    throw new NullPointerException();
  }
  bitField0_ |= 0x00000001;
        type_ = value;
        onChanged();
        return this;
      }
      /**
       * <pre>
       * Type of Faster R-CNN model (e.g., 'faster_rcnn_resnet101';
       * See builders/model_builder.py for expected types).
       * </pre>
       *
       * <code>optional string type = 1;</code>
       * @return This builder for chaining.
       */
      public Builder clearType() {
        bitField0_ = (bitField0_ & ~0x00000001);
        type_ = getDefaultInstance().getType();
        onChanged();
        return this;
      }
      /**
       * <pre>
       * Type of Faster R-CNN model (e.g., 'faster_rcnn_resnet101';
       * See builders/model_builder.py for expected types).
       * </pre>
       *
       * <code>optional string type = 1;</code>
       * @param value The bytes for type to set.
       * @return This builder for chaining.
       */
      public Builder setTypeBytes(
          com.google.protobuf.ByteString value) {
        if (value == null) {
    throw new NullPointerException();
  }
  bitField0_ |= 0x00000001;
        type_ = value;
        onChanged();
        return this;
      }

      private int firstStageFeaturesStride_ = 16;
      /**
       * <pre>
       * Output stride of extracted RPN feature map.
       * </pre>
       *
       * <code>optional int32 first_stage_features_stride = 2 [default = 16];</code>
       * @return Whether the firstStageFeaturesStride field is set.
       */
      @java.lang.Override
      public boolean hasFirstStageFeaturesStride() {
        return ((bitField0_ & 0x00000002) != 0);
      }
      /**
       * <pre>
       * Output stride of extracted RPN feature map.
       * </pre>
       *
       * <code>optional int32 first_stage_features_stride = 2 [default = 16];</code>
       * @return The firstStageFeaturesStride.
       */
      @java.lang.Override
      public int getFirstStageFeaturesStride() {
        return firstStageFeaturesStride_;
      }
      /**
       * <pre>
       * Output stride of extracted RPN feature map.
       * </pre>
       *
       * <code>optional int32 first_stage_features_stride = 2 [default = 16];</code>
       * @param value The firstStageFeaturesStride to set.
       * @return This builder for chaining.
       */
      public Builder setFirstStageFeaturesStride(int value) {
        bitField0_ |= 0x00000002;
        firstStageFeaturesStride_ = value;
        onChanged();
        return this;
      }
      /**
       * <pre>
       * Output stride of extracted RPN feature map.
       * </pre>
       *
       * <code>optional int32 first_stage_features_stride = 2 [default = 16];</code>
       * @return This builder for chaining.
       */
      public Builder clearFirstStageFeaturesStride() {
        bitField0_ = (bitField0_ & ~0x00000002);
        firstStageFeaturesStride_ = 16;
        onChanged();
        return this;
      }

      private boolean batchNormTrainable_ ;
      /**
       * <pre>
       * Whether to update batch norm parameters during training or not.
       * When training with a relative large batch size (e.g. 8), it could be
       * desirable to enable batch norm update.
       * </pre>
       *
       * <code>optional bool batch_norm_trainable = 3 [default = false];</code>
       * @return Whether the batchNormTrainable field is set.
       */
      @java.lang.Override
      public boolean hasBatchNormTrainable() {
        return ((bitField0_ & 0x00000004) != 0);
      }
      /**
       * <pre>
       * Whether to update batch norm parameters during training or not.
       * When training with a relative large batch size (e.g. 8), it could be
       * desirable to enable batch norm update.
       * </pre>
       *
       * <code>optional bool batch_norm_trainable = 3 [default = false];</code>
       * @return The batchNormTrainable.
       */
      @java.lang.Override
      public boolean getBatchNormTrainable() {
        return batchNormTrainable_;
      }
      /**
       * <pre>
       * Whether to update batch norm parameters during training or not.
       * When training with a relative large batch size (e.g. 8), it could be
       * desirable to enable batch norm update.
       * </pre>
       *
       * <code>optional bool batch_norm_trainable = 3 [default = false];</code>
       * @param value The batchNormTrainable to set.
       * @return This builder for chaining.
       */
      public Builder setBatchNormTrainable(boolean value) {
        bitField0_ |= 0x00000004;
        batchNormTrainable_ = value;
        onChanged();
        return this;
      }
      /**
       * <pre>
       * Whether to update batch norm parameters during training or not.
       * When training with a relative large batch size (e.g. 8), it could be
       * desirable to enable batch norm update.
       * </pre>
       *
       * <code>optional bool batch_norm_trainable = 3 [default = false];</code>
       * @return This builder for chaining.
       */
      public Builder clearBatchNormTrainable() {
        bitField0_ = (bitField0_ & ~0x00000004);
        batchNormTrainable_ = false;
        onChanged();
        return this;
      }

      private object_detection.protos.HyperparamsOuterClass.Hyperparams convHyperparams_;
      private com.google.protobuf.SingleFieldBuilderV3<
          object_detection.protos.HyperparamsOuterClass.Hyperparams, object_detection.protos.HyperparamsOuterClass.Hyperparams.Builder, object_detection.protos.HyperparamsOuterClass.HyperparamsOrBuilder> convHyperparamsBuilder_;
      /**
       * <pre>
       * Hyperparameters that affect the layers of feature extractor added on top
       * of the base feature extractor.
       * </pre>
       *
       * <code>optional .object_detection.protos.Hyperparams conv_hyperparams = 4;</code>
       * @return Whether the convHyperparams field is set.
       */
      public boolean hasConvHyperparams() {
        return ((bitField0_ & 0x00000008) != 0);
      }
      /**
       * <pre>
       * Hyperparameters that affect the layers of feature extractor added on top
       * of the base feature extractor.
       * </pre>
       *
       * <code>optional .object_detection.protos.Hyperparams conv_hyperparams = 4;</code>
       * @return The convHyperparams.
       */
      public object_detection.protos.HyperparamsOuterClass.Hyperparams getConvHyperparams() {
        if (convHyperparamsBuilder_ == null) {
          return convHyperparams_ == null ? object_detection.protos.HyperparamsOuterClass.Hyperparams.getDefaultInstance() : convHyperparams_;
        } else {
          return convHyperparamsBuilder_.getMessage();
        }
      }
      /**
       * <pre>
       * Hyperparameters that affect the layers of feature extractor added on top
       * of the base feature extractor.
       * </pre>
       *
       * <code>optional .object_detection.protos.Hyperparams conv_hyperparams = 4;</code>
       */
      public Builder setConvHyperparams(object_detection.protos.HyperparamsOuterClass.Hyperparams value) {
        if (convHyperparamsBuilder_ == null) {
          if (value == null) {
            throw new NullPointerException();
          }
          convHyperparams_ = value;
          onChanged();
        } else {
          convHyperparamsBuilder_.setMessage(value);
        }
        bitField0_ |= 0x00000008;
        return this;
      }
      /**
       * <pre>
       * Hyperparameters that affect the layers of feature extractor added on top
       * of the base feature extractor.
       * </pre>
       *
       * <code>optional .object_detection.protos.Hyperparams conv_hyperparams = 4;</code>
       */
      public Builder setConvHyperparams(
          object_detection.protos.HyperparamsOuterClass.Hyperparams.Builder builderForValue) {
        if (convHyperparamsBuilder_ == null) {
          convHyperparams_ = builderForValue.build();
          onChanged();
        } else {
          convHyperparamsBuilder_.setMessage(builderForValue.build());
        }
        bitField0_ |= 0x00000008;
        return this;
      }
      /**
       * <pre>
       * Hyperparameters that affect the layers of feature extractor added on top
       * of the base feature extractor.
       * </pre>
       *
       * <code>optional .object_detection.protos.Hyperparams conv_hyperparams = 4;</code>
       */
      public Builder mergeConvHyperparams(object_detection.protos.HyperparamsOuterClass.Hyperparams value) {
        if (convHyperparamsBuilder_ == null) {
          if (((bitField0_ & 0x00000008) != 0) &&
              convHyperparams_ != null &&
              convHyperparams_ != object_detection.protos.HyperparamsOuterClass.Hyperparams.getDefaultInstance()) {
            convHyperparams_ =
              object_detection.protos.HyperparamsOuterClass.Hyperparams.newBuilder(convHyperparams_).mergeFrom(value).buildPartial();
          } else {
            convHyperparams_ = value;
          }
          onChanged();
        } else {
          convHyperparamsBuilder_.mergeFrom(value);
        }
        bitField0_ |= 0x00000008;
        return this;
      }
      /**
       * <pre>
       * Hyperparameters that affect the layers of feature extractor added on top
       * of the base feature extractor.
       * </pre>
       *
       * <code>optional .object_detection.protos.Hyperparams conv_hyperparams = 4;</code>
       */
      public Builder clearConvHyperparams() {
        if (convHyperparamsBuilder_ == null) {
          convHyperparams_ = null;
          onChanged();
        } else {
          convHyperparamsBuilder_.clear();
        }
        bitField0_ = (bitField0_ & ~0x00000008);
        return this;
      }
      /**
       * <pre>
       * Hyperparameters that affect the layers of feature extractor added on top
       * of the base feature extractor.
       * </pre>
       *
       * <code>optional .object_detection.protos.Hyperparams conv_hyperparams = 4;</code>
       */
      public object_detection.protos.HyperparamsOuterClass.Hyperparams.Builder getConvHyperparamsBuilder() {
        bitField0_ |= 0x00000008;
        onChanged();
        return getConvHyperparamsFieldBuilder().getBuilder();
      }
      /**
       * <pre>
       * Hyperparameters that affect the layers of feature extractor added on top
       * of the base feature extractor.
       * </pre>
       *
       * <code>optional .object_detection.protos.Hyperparams conv_hyperparams = 4;</code>
       */
      public object_detection.protos.HyperparamsOuterClass.HyperparamsOrBuilder getConvHyperparamsOrBuilder() {
        if (convHyperparamsBuilder_ != null) {
          return convHyperparamsBuilder_.getMessageOrBuilder();
        } else {
          return convHyperparams_ == null ?
              object_detection.protos.HyperparamsOuterClass.Hyperparams.getDefaultInstance() : convHyperparams_;
        }
      }
      /**
       * <pre>
       * Hyperparameters that affect the layers of feature extractor added on top
       * of the base feature extractor.
       * </pre>
       *
       * <code>optional .object_detection.protos.Hyperparams conv_hyperparams = 4;</code>
       */
      private com.google.protobuf.SingleFieldBuilderV3<
          object_detection.protos.HyperparamsOuterClass.Hyperparams, object_detection.protos.HyperparamsOuterClass.Hyperparams.Builder, object_detection.protos.HyperparamsOuterClass.HyperparamsOrBuilder>
          getConvHyperparamsFieldBuilder() {
        if (convHyperparamsBuilder_ == null) {
          convHyperparamsBuilder_ = new com.google.protobuf.SingleFieldBuilderV3<
              object_detection.protos.HyperparamsOuterClass.Hyperparams, object_detection.protos.HyperparamsOuterClass.Hyperparams.Builder, object_detection.protos.HyperparamsOuterClass.HyperparamsOrBuilder>(
                  getConvHyperparams(),
                  getParentForChildren(),
                  isClean());
          convHyperparams_ = null;
        }
        return convHyperparamsBuilder_;
      }

      private boolean overrideBaseFeatureExtractorHyperparams_ ;
      /**
       * <pre>
       * if the value is set to true, the base feature extractor's hyperparams will
       * be overridden with the `conv_hyperparams`.
       * </pre>
       *
       * <code>optional bool override_base_feature_extractor_hyperparams = 5 [default = false];</code>
       * @return Whether the overrideBaseFeatureExtractorHyperparams field is set.
       */
      @java.lang.Override
      public boolean hasOverrideBaseFeatureExtractorHyperparams() {
        return ((bitField0_ & 0x00000010) != 0);
      }
      /**
       * <pre>
       * if the value is set to true, the base feature extractor's hyperparams will
       * be overridden with the `conv_hyperparams`.
       * </pre>
       *
       * <code>optional bool override_base_feature_extractor_hyperparams = 5 [default = false];</code>
       * @return The overrideBaseFeatureExtractorHyperparams.
       */
      @java.lang.Override
      public boolean getOverrideBaseFeatureExtractorHyperparams() {
        return overrideBaseFeatureExtractorHyperparams_;
      }
      /**
       * <pre>
       * if the value is set to true, the base feature extractor's hyperparams will
       * be overridden with the `conv_hyperparams`.
       * </pre>
       *
       * <code>optional bool override_base_feature_extractor_hyperparams = 5 [default = false];</code>
       * @param value The overrideBaseFeatureExtractorHyperparams to set.
       * @return This builder for chaining.
       */
      public Builder setOverrideBaseFeatureExtractorHyperparams(boolean value) {
        bitField0_ |= 0x00000010;
        overrideBaseFeatureExtractorHyperparams_ = value;
        onChanged();
        return this;
      }
      /**
       * <pre>
       * if the value is set to true, the base feature extractor's hyperparams will
       * be overridden with the `conv_hyperparams`.
       * </pre>
       *
       * <code>optional bool override_base_feature_extractor_hyperparams = 5 [default = false];</code>
       * @return This builder for chaining.
       */
      public Builder clearOverrideBaseFeatureExtractorHyperparams() {
        bitField0_ = (bitField0_ & ~0x00000010);
        overrideBaseFeatureExtractorHyperparams_ = false;
        onChanged();
        return this;
      }

      private int padToMultiple_ = 32;
      /**
       * <pre>
       * The nearest multiple to zero-pad the input height and width dimensions to.
       * For example, if pad_to_multiple = 2, input dimensions are zero-padded
       * until the resulting dimensions are even.
       * </pre>
       *
       * <code>optional int32 pad_to_multiple = 6 [default = 32];</code>
       * @return Whether the padToMultiple field is set.
       */
      @java.lang.Override
      public boolean hasPadToMultiple() {
        return ((bitField0_ & 0x00000020) != 0);
      }
      /**
       * <pre>
       * The nearest multiple to zero-pad the input height and width dimensions to.
       * For example, if pad_to_multiple = 2, input dimensions are zero-padded
       * until the resulting dimensions are even.
       * </pre>
       *
       * <code>optional int32 pad_to_multiple = 6 [default = 32];</code>
       * @return The padToMultiple.
       */
      @java.lang.Override
      public int getPadToMultiple() {
        return padToMultiple_;
      }
      /**
       * <pre>
       * The nearest multiple to zero-pad the input height and width dimensions to.
       * For example, if pad_to_multiple = 2, input dimensions are zero-padded
       * until the resulting dimensions are even.
       * </pre>
       *
       * <code>optional int32 pad_to_multiple = 6 [default = 32];</code>
       * @param value The padToMultiple to set.
       * @return This builder for chaining.
       */
      public Builder setPadToMultiple(int value) {
        bitField0_ |= 0x00000020;
        padToMultiple_ = value;
        onChanged();
        return this;
      }
      /**
       * <pre>
       * The nearest multiple to zero-pad the input height and width dimensions to.
       * For example, if pad_to_multiple = 2, input dimensions are zero-padded
       * until the resulting dimensions are even.
       * </pre>
       *
       * <code>optional int32 pad_to_multiple = 6 [default = 32];</code>
       * @return This builder for chaining.
       */
      public Builder clearPadToMultiple() {
        bitField0_ = (bitField0_ & ~0x00000020);
        padToMultiple_ = 32;
        onChanged();
        return this;
      }

      private object_detection.protos.Fpn.FeaturePyramidNetworks fpn_;
      private com.google.protobuf.SingleFieldBuilderV3<
          object_detection.protos.Fpn.FeaturePyramidNetworks, object_detection.protos.Fpn.FeaturePyramidNetworks.Builder, object_detection.protos.Fpn.FeaturePyramidNetworksOrBuilder> fpnBuilder_;
      /**
       * <pre>
       * Feature Pyramid Networks config.
       * </pre>
       *
       * <code>optional .object_detection.protos.FeaturePyramidNetworks fpn = 7;</code>
       * @return Whether the fpn field is set.
       */
      public boolean hasFpn() {
        return ((bitField0_ & 0x00000040) != 0);
      }
      /**
       * <pre>
       * Feature Pyramid Networks config.
       * </pre>
       *
       * <code>optional .object_detection.protos.FeaturePyramidNetworks fpn = 7;</code>
       * @return The fpn.
       */
      public object_detection.protos.Fpn.FeaturePyramidNetworks getFpn() {
        if (fpnBuilder_ == null) {
          return fpn_ == null ? object_detection.protos.Fpn.FeaturePyramidNetworks.getDefaultInstance() : fpn_;
        } else {
          return fpnBuilder_.getMessage();
        }
      }
      /**
       * <pre>
       * Feature Pyramid Networks config.
       * </pre>
       *
       * <code>optional .object_detection.protos.FeaturePyramidNetworks fpn = 7;</code>
       */
      public Builder setFpn(object_detection.protos.Fpn.FeaturePyramidNetworks value) {
        if (fpnBuilder_ == null) {
          if (value == null) {
            throw new NullPointerException();
          }
          fpn_ = value;
          onChanged();
        } else {
          fpnBuilder_.setMessage(value);
        }
        bitField0_ |= 0x00000040;
        return this;
      }
      /**
       * <pre>
       * Feature Pyramid Networks config.
       * </pre>
       *
       * <code>optional .object_detection.protos.FeaturePyramidNetworks fpn = 7;</code>
       */
      public Builder setFpn(
          object_detection.protos.Fpn.FeaturePyramidNetworks.Builder builderForValue) {
        if (fpnBuilder_ == null) {
          fpn_ = builderForValue.build();
          onChanged();
        } else {
          fpnBuilder_.setMessage(builderForValue.build());
        }
        bitField0_ |= 0x00000040;
        return this;
      }
      /**
       * <pre>
       * Feature Pyramid Networks config.
       * </pre>
       *
       * <code>optional .object_detection.protos.FeaturePyramidNetworks fpn = 7;</code>
       */
      public Builder mergeFpn(object_detection.protos.Fpn.FeaturePyramidNetworks value) {
        if (fpnBuilder_ == null) {
          if (((bitField0_ & 0x00000040) != 0) &&
              fpn_ != null &&
              fpn_ != object_detection.protos.Fpn.FeaturePyramidNetworks.getDefaultInstance()) {
            fpn_ =
              object_detection.protos.Fpn.FeaturePyramidNetworks.newBuilder(fpn_).mergeFrom(value).buildPartial();
          } else {
            fpn_ = value;
          }
          onChanged();
        } else {
          fpnBuilder_.mergeFrom(value);
        }
        bitField0_ |= 0x00000040;
        return this;
      }
      /**
       * <pre>
       * Feature Pyramid Networks config.
       * </pre>
       *
       * <code>optional .object_detection.protos.FeaturePyramidNetworks fpn = 7;</code>
       */
      public Builder clearFpn() {
        if (fpnBuilder_ == null) {
          fpn_ = null;
          onChanged();
        } else {
          fpnBuilder_.clear();
        }
        bitField0_ = (bitField0_ & ~0x00000040);
        return this;
      }
      /**
       * <pre>
       * Feature Pyramid Networks config.
       * </pre>
       *
       * <code>optional .object_detection.protos.FeaturePyramidNetworks fpn = 7;</code>
       */
      public object_detection.protos.Fpn.FeaturePyramidNetworks.Builder getFpnBuilder() {
        bitField0_ |= 0x00000040;
        onChanged();
        return getFpnFieldBuilder().getBuilder();
      }
      /**
       * <pre>
       * Feature Pyramid Networks config.
       * </pre>
       *
       * <code>optional .object_detection.protos.FeaturePyramidNetworks fpn = 7;</code>
       */
      public object_detection.protos.Fpn.FeaturePyramidNetworksOrBuilder getFpnOrBuilder() {
        if (fpnBuilder_ != null) {
          return fpnBuilder_.getMessageOrBuilder();
        } else {
          return fpn_ == null ?
              object_detection.protos.Fpn.FeaturePyramidNetworks.getDefaultInstance() : fpn_;
        }
      }
      /**
       * <pre>
       * Feature Pyramid Networks config.
       * </pre>
       *
       * <code>optional .object_detection.protos.FeaturePyramidNetworks fpn = 7;</code>
       */
      private com.google.protobuf.SingleFieldBuilderV3<
          object_detection.protos.Fpn.FeaturePyramidNetworks, object_detection.protos.Fpn.FeaturePyramidNetworks.Builder, object_detection.protos.Fpn.FeaturePyramidNetworksOrBuilder>
          getFpnFieldBuilder() {
        if (fpnBuilder_ == null) {
          fpnBuilder_ = new com.google.protobuf.SingleFieldBuilderV3<
              object_detection.protos.Fpn.FeaturePyramidNetworks, object_detection.protos.Fpn.FeaturePyramidNetworks.Builder, object_detection.protos.Fpn.FeaturePyramidNetworksOrBuilder>(
                  getFpn(),
                  getParentForChildren(),
                  isClean());
          fpn_ = null;
        }
        return fpnBuilder_;
      }
      @java.lang.Override
      public final Builder setUnknownFields(
          final com.google.protobuf.UnknownFieldSet unknownFields) {
        return super.setUnknownFields(unknownFields);
      }

      @java.lang.Override
      public final Builder mergeUnknownFields(
          final com.google.protobuf.UnknownFieldSet unknownFields) {
        return super.mergeUnknownFields(unknownFields);
      }


      // @@protoc_insertion_point(builder_scope:object_detection.protos.FasterRcnnFeatureExtractor)
    }

    // @@protoc_insertion_point(class_scope:object_detection.protos.FasterRcnnFeatureExtractor)
    private static final object_detection.protos.FasterRcnnOuterClass.FasterRcnnFeatureExtractor DEFAULT_INSTANCE;
    static {
      DEFAULT_INSTANCE = new object_detection.protos.FasterRcnnOuterClass.FasterRcnnFeatureExtractor();
    }

    public static object_detection.protos.FasterRcnnOuterClass.FasterRcnnFeatureExtractor getDefaultInstance() {
      return DEFAULT_INSTANCE;
    }

    @java.lang.Deprecated public static final com.google.protobuf.Parser<FasterRcnnFeatureExtractor>
        PARSER = new com.google.protobuf.AbstractParser<FasterRcnnFeatureExtractor>() {
      @java.lang.Override
      public FasterRcnnFeatureExtractor parsePartialFrom(
          com.google.protobuf.CodedInputStream input,
          com.google.protobuf.ExtensionRegistryLite extensionRegistry)
          throws com.google.protobuf.InvalidProtocolBufferException {
        return new FasterRcnnFeatureExtractor(input, extensionRegistry);
      }
    };

    public static com.google.protobuf.Parser<FasterRcnnFeatureExtractor> parser() {
      return PARSER;
    }

    @java.lang.Override
    public com.google.protobuf.Parser<FasterRcnnFeatureExtractor> getParserForType() {
      return PARSER;
    }

    @java.lang.Override
    public object_detection.protos.FasterRcnnOuterClass.FasterRcnnFeatureExtractor getDefaultInstanceForType() {
      return DEFAULT_INSTANCE;
    }

  }

  private static final com.google.protobuf.Descriptors.Descriptor
    internal_static_object_detection_protos_FasterRcnn_descriptor;
  private static final
    com.google.protobuf.GeneratedMessageV3.FieldAccessorTable
      internal_static_object_detection_protos_FasterRcnn_fieldAccessorTable;
  private static final com.google.protobuf.Descriptors.Descriptor
    internal_static_object_detection_protos_Context_descriptor;
  private static final
    com.google.protobuf.GeneratedMessageV3.FieldAccessorTable
      internal_static_object_detection_protos_Context_fieldAccessorTable;
  private static final com.google.protobuf.Descriptors.Descriptor
    internal_static_object_detection_protos_FasterRcnnFeatureExtractor_descriptor;
  private static final
    com.google.protobuf.GeneratedMessageV3.FieldAccessorTable
      internal_static_object_detection_protos_FasterRcnnFeatureExtractor_fieldAccessorTable;

  public static com.google.protobuf.Descriptors.FileDescriptor
      getDescriptor() {
    return descriptor;
  }
  private static  com.google.protobuf.Descriptors.FileDescriptor
      descriptor;
  static {
    java.lang.String[] descriptorData = {
      "\n)object_detection/protos/faster_rcnn.pr" +
      "oto\022\027object_detection.protos\032.object_det" +
      "ection/protos/anchor_generator.proto\032+ob" +
      "ject_detection/protos/box_predictor.prot" +
      "o\032)object_detection/protos/hyperparams.p" +
      "roto\032+object_detection/protos/image_resi" +
      "zer.proto\032$object_detection/protos/losse" +
      "s.proto\032-object_detection/protos/post_pr" +
      "ocessing.proto\032!object_detection/protos/" +
      "fpn.proto\"\227\020\n\nFasterRcnn\022\033\n\020number_of_st" +
      "ages\030\001 \001(\005:\0012\022\023\n\013num_classes\030\003 \001(\005\022<\n\rim" +
      "age_resizer\030\004 \001(\0132%.object_detection.pro" +
      "tos.ImageResizer\022N\n\021feature_extractor\030\005 " +
      "\001(\01323.object_detection.protos.FasterRcnn" +
      "FeatureExtractor\022N\n\034first_stage_anchor_g" +
      "enerator\030\006 \001(\0132(.object_detection.protos" +
      ".AnchorGenerator\022\"\n\027first_stage_atrous_r" +
      "ate\030\007 \001(\005:\0011\022X\n*first_stage_box_predicto" +
      "r_conv_hyperparams\030\010 \001(\0132$.object_detect" +
      "ion.protos.Hyperparams\0220\n%first_stage_bo" +
      "x_predictor_kernel_size\030\t \001(\005:\0013\022,\n\037firs" +
      "t_stage_box_predictor_depth\030\n \001(\005:\003512\022\'" +
      "\n\032first_stage_minibatch_size\030\013 \001(\005:\003256\022" +
      "2\n%first_stage_positive_balance_fraction" +
      "\030\014 \001(\002:\0030.5\022*\n\037first_stage_nms_score_thr" +
      "eshold\030\r \001(\002:\0010\022*\n\035first_stage_nms_iou_t" +
      "hreshold\030\016 \001(\002:\0030.7\022&\n\031first_stage_max_p" +
      "roposals\030\017 \001(\005:\003300\022/\n$first_stage_local" +
      "ization_loss_weight\030\020 \001(\002:\0011\022-\n\"first_st" +
      "age_objectness_loss_weight\030\021 \001(\002:\0011\022\031\n\021i" +
      "nitial_crop_size\030\022 \001(\005\022\033\n\023maxpool_kernel" +
      "_size\030\023 \001(\005\022\026\n\016maxpool_stride\030\024 \001(\005\022I\n\032s" +
      "econd_stage_box_predictor\030\025 \001(\0132%.object" +
      "_detection.protos.BoxPredictor\022#\n\027second" +
      "_stage_batch_size\030\026 \001(\005:\00264\022+\n\035second_st" +
      "age_balance_fraction\030\027 \001(\002:\0040.25\022M\n\034seco" +
      "nd_stage_post_processing\030\030 \001(\0132\'.object_" +
      "detection.protos.PostProcessing\0220\n%secon" +
      "d_stage_localization_loss_weight\030\031 \001(\002:\001" +
      "1\0222\n\'second_stage_classification_loss_we" +
      "ight\030\032 \001(\002:\0011\0223\n(second_stage_mask_predi" +
      "ction_loss_weight\030\033 \001(\002:\0011\022E\n\022hard_examp" +
      "le_miner\030\034 \001(\0132).object_detection.protos" +
      ".HardExampleMiner\022U\n second_stage_classi" +
      "fication_loss\030\035 \001(\0132+.object_detection.p" +
      "rotos.ClassificationLoss\022\'\n\030inplace_batc" +
      "hnorm_update\030\036 \001(\010:\005false\022)\n\032use_matmul_" +
      "crop_and_resize\030\037 \001(\010:\005false\022$\n\025clip_anc" +
      "hors_to_image\030  \001(\010:\005false\022+\n\034use_matmul" +
      "_gather_in_matcher\030! \001(\010:\005false\0220\n!use_s" +
      "tatic_balanced_label_sampler\030\" \001(\010:\005fals" +
      "e\022 \n\021use_static_shapes\030# \001(\010:\005false\022\032\n\014r" +
      "esize_masks\030$ \001(\010:\004true\022)\n\032use_static_sh" +
      "apes_for_eval\030% \001(\010:\005false\0220\n\"use_partit" +
      "ioned_nms_in_first_stage\030& \001(\010:\004true\0223\n$" +
      "return_raw_detections_during_predict\030\' \001" +
      "(\010:\005false\022.\n\037use_combined_nms_in_first_s" +
      "tage\030( \001(\010:\005false\022(\n\031output_final_box_fe" +
      "atures\030* \001(\010:\005false\022,\n\035output_final_box_" +
      "rpn_features\030+ \001(\010:\005false\0228\n\016context_con" +
      "fig\030) \001(\0132 .object_detection.protos.Cont" +
      "ext\"\275\003\n\007Context\022&\n\030max_num_context_featu" +
      "res\030\001 \001(\005:\0042000\022,\n\036attention_bottleneck_" +
      "dimension\030\002 \001(\005:\0042048\022#\n\025attention_tempe" +
      "rature\030\003 \001(\002:\0040.01\022$\n\026context_feature_le" +
      "ngth\030\004 \001(\005:\0042057\022!\n\022use_self_attention\030\006" +
      " \001(\010:\005false\022%\n\027use_long_term_attention\030\007" +
      " \001(\010:\004true\022)\n\032self_attention_in_sequence" +
      "\030\010 \001(\010:\005false\022\036\n\023num_attention_heads\030\t \001" +
      "(\005:\0011\022\037\n\024num_attention_layers\030\013 \001(\005:\0011\022[" +
      "\n\022attention_position\030\n \001(\0162*.object_dete" +
      "ction.protos.AttentionPosition:\023POST_BOX" +
      "_CLASSIFIER\"\317\002\n\032FasterRcnnFeatureExtract" +
      "or\022\014\n\004type\030\001 \001(\t\022\'\n\033first_stage_features" +
      "_stride\030\002 \001(\005:\00216\022#\n\024batch_norm_trainabl" +
      "e\030\003 \001(\010:\005false\022>\n\020conv_hyperparams\030\004 \001(\013" +
      "2$.object_detection.protos.Hyperparams\022:" +
      "\n+override_base_feature_extractor_hyperp" +
      "arams\030\005 \001(\010:\005false\022\033\n\017pad_to_multiple\030\006 " +
      "\001(\005:\00232\022<\n\003fpn\030\007 \001(\0132/.object_detection." +
      "protos.FeaturePyramidNetworks*Q\n\021Attenti" +
      "onPosition\022\025\n\021ATTENTION_DEFAULT\020\000\022\027\n\023POS" +
      "T_BOX_CLASSIFIER\020\001\022\014\n\010POST_RPN\020\002"
    };
    descriptor = com.google.protobuf.Descriptors.FileDescriptor
      .internalBuildGeneratedFileFrom(descriptorData,
        new com.google.protobuf.Descriptors.FileDescriptor[] {
          object_detection.protos.AnchorGeneratorOuterClass.getDescriptor(),
          object_detection.protos.BoxPredictorOuterClass.getDescriptor(),
          object_detection.protos.HyperparamsOuterClass.getDescriptor(),
          object_detection.protos.ImageResizerOuterClass.getDescriptor(),
          object_detection.protos.Losses.getDescriptor(),
          object_detection.protos.PostProcessingOuterClass.getDescriptor(),
          object_detection.protos.Fpn.getDescriptor(),
        });
    internal_static_object_detection_protos_FasterRcnn_descriptor =
      getDescriptor().getMessageTypes().get(0);
    internal_static_object_detection_protos_FasterRcnn_fieldAccessorTable = new
      com.google.protobuf.GeneratedMessageV3.FieldAccessorTable(
        internal_static_object_detection_protos_FasterRcnn_descriptor,
        new java.lang.String[] { "NumberOfStages", "NumClasses", "ImageResizer", "FeatureExtractor", "FirstStageAnchorGenerator", "FirstStageAtrousRate", "FirstStageBoxPredictorConvHyperparams", "FirstStageBoxPredictorKernelSize", "FirstStageBoxPredictorDepth", "FirstStageMinibatchSize", "FirstStagePositiveBalanceFraction", "FirstStageNmsScoreThreshold", "FirstStageNmsIouThreshold", "FirstStageMaxProposals", "FirstStageLocalizationLossWeight", "FirstStageObjectnessLossWeight", "InitialCropSize", "MaxpoolKernelSize", "MaxpoolStride", "SecondStageBoxPredictor", "SecondStageBatchSize", "SecondStageBalanceFraction", "SecondStagePostProcessing", "SecondStageLocalizationLossWeight", "SecondStageClassificationLossWeight", "SecondStageMaskPredictionLossWeight", "HardExampleMiner", "SecondStageClassificationLoss", "InplaceBatchnormUpdate", "UseMatmulCropAndResize", "ClipAnchorsToImage", "UseMatmulGatherInMatcher", "UseStaticBalancedLabelSampler", "UseStaticShapes", "ResizeMasks", "UseStaticShapesForEval", "UsePartitionedNmsInFirstStage", "ReturnRawDetectionsDuringPredict", "UseCombinedNmsInFirstStage", "OutputFinalBoxFeatures", "OutputFinalBoxRpnFeatures", "ContextConfig", });
    internal_static_object_detection_protos_Context_descriptor =
      getDescriptor().getMessageTypes().get(1);
    internal_static_object_detection_protos_Context_fieldAccessorTable = new
      com.google.protobuf.GeneratedMessageV3.FieldAccessorTable(
        internal_static_object_detection_protos_Context_descriptor,
        new java.lang.String[] { "MaxNumContextFeatures", "AttentionBottleneckDimension", "AttentionTemperature", "ContextFeatureLength", "UseSelfAttention", "UseLongTermAttention", "SelfAttentionInSequence", "NumAttentionHeads", "NumAttentionLayers", "AttentionPosition", });
    internal_static_object_detection_protos_FasterRcnnFeatureExtractor_descriptor =
      getDescriptor().getMessageTypes().get(2);
    internal_static_object_detection_protos_FasterRcnnFeatureExtractor_fieldAccessorTable = new
      com.google.protobuf.GeneratedMessageV3.FieldAccessorTable(
        internal_static_object_detection_protos_FasterRcnnFeatureExtractor_descriptor,
        new java.lang.String[] { "Type", "FirstStageFeaturesStride", "BatchNormTrainable", "ConvHyperparams", "OverrideBaseFeatureExtractorHyperparams", "PadToMultiple", "Fpn", });
    object_detection.protos.AnchorGeneratorOuterClass.getDescriptor();
    object_detection.protos.BoxPredictorOuterClass.getDescriptor();
    object_detection.protos.HyperparamsOuterClass.getDescriptor();
    object_detection.protos.ImageResizerOuterClass.getDescriptor();
    object_detection.protos.Losses.getDescriptor();
    object_detection.protos.PostProcessingOuterClass.getDescriptor();
    object_detection.protos.Fpn.getDescriptor();
  }

  // @@protoc_insertion_point(outer_class_scope)
}
